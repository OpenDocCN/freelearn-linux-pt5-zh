- en: Chapter 10. Handling SELinux-aware Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章：处理 SELinux 感知应用程序
- en: 'In this chapter, we will cover handling of SELinux-aware applications through
    the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过以下几种方案介绍如何处理 SELinux 感知应用程序：
- en: Controlling D-Bus message flows
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制 D-Bus 消息流
- en: Restricting service ownership
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制服务的所有权
- en: Understanding udev's SELinux integration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 udev 的 SELinux 集成
- en: Using cron with SELinux
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 cron 和 SELinux
- en: Checking the SELinux state programmatically
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以编程方式检查 SELinux 状态
- en: Querying SELinux userland configuration in C
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C 中查询 SELinux 用户空间配置
- en: Interrogating the SELinux subsystem code-wise
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过代码方式查询 SELinux 子系统
- en: Running new processes in a new context
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新上下文中运行新进程
- en: Reading the context of a resource
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取资源的上下文
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: For most applications, the SELinux subsystem in the Linux kernel is capable
    of enforcing security controls without further interaction with other applications
    and components. However, there are actions that cannot be handled by the SELinux
    subsystem autonomously. Some applications execute commands for specific users,
    but the target domain cannot be deduced from the path of the application that
    is itself being executed, making type transitions based on the label impossible.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用程序，Linux 内核中的 SELinux 子系统能够在不与其他应用程序和组件进一步交互的情况下执行安全控制。然而，存在一些无法由 SELinux
    子系统自动处理的操作。一些应用程序为特定用户执行命令，但目标域无法从正在执行的应用程序的路径中推断出来，因此无法基于标签进行类型转换。
- en: One solution for this problem is to make the application SELinux-aware, having
    the application interrogate the SELinux subsystem as to what should be the context
    of the newly executed application. Once the context is obtained, the application
    can then instruct the SELinux subsystem that this context can be assigned to the
    process that will be launched next.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个方法是使应用程序成为 SELinux 感知的，让应用程序查询 SELinux 子系统，以确定新执行的应用程序应该使用什么上下文。一旦获得上下文，应用程序就可以指示
    SELinux 子系统将该上下文分配给接下来将启动的进程。
- en: Of course, it isn't only about deciding what context a process should be in.
    Applications can also check the SELinux policy and act on the policy themselves,
    rather than having the policies enforced through the Linux kernel. If applications
    use SELinux to get more information about a session and set contexts based on
    this information, then we call these applications SELinux-aware.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，问题不仅仅是决定进程应该处于哪个上下文。应用程序也可以检查 SELinux 策略，并根据策略进行操作，而不是通过 Linux 内核强制执行策略。如果应用程序使用
    SELinux 获取更多有关会话的信息，并根据这些信息设置上下文，那么我们称这些应用程序为 SELinux 感知的。
- en: 'The easiest method to see whether an application is SELinux-aware is to check
    the documentation, or to check whether it is linked with the `libselinux.so` library:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查看应用程序是否为 SELinux 感知的最简单方法是检查文档，或者检查它是否与 `libselinux.so` 库链接：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Some SELinux-aware applications not only query information, but also enforce
    decisions on objects that the SELinux subsystem in the Linux kernel cannot control.
    Examples of such objects are the database objects in the **Security Enhanced PostgreSQL**
    (**SEPostgreSQL**) application or the D-Bus services. Although represented in
    the SELinux policy, they are not part of the regular Linux operating system but
    are instead owned by the application itself. Such SELinux-aware applications are
    called **user space object managers**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 SELinux 感知应用程序不仅查询信息，还对 SELinux 子系统无法控制的对象执行决策。这些对象的例子包括 **安全增强型 PostgreSQL**
    (**SEPostgreSQL**) 应用程序中的数据库对象或 D-Bus 服务。尽管它们在 SELinux 策略中有所表示，但它们并不是常规 Linux
    操作系统的一部分，而是由应用程序本身拥有的。这些 SELinux 感知应用程序被称为 **用户空间对象管理器**。
- en: Regardless of how an application handles its SELinux-specific code, whenever
    such applications are used on a system, it is important to know how the SELinux
    code in the application works, as the standard approach (look at AVC denials and
    see whether a context needs to be changed or the policy tuned) might not work
    at all in these cases.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 无论应用程序如何处理其 SELinux 特定代码，在系统上使用这些应用程序时，了解应用程序中 SELinux 代码的工作方式非常重要，因为标准方法（查看
    AVC 拒绝记录，看看是否需要更改上下文或调整策略）在这些情况下可能根本不起作用。
- en: Controlling D-Bus message flows
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制 D-Bus 消息流
- en: D-Bus implementation on Linux is an example of an SELinux-aware application,
    acting as a user space object manager. Applications can register themselves on
    a bus and can send messages between applications through D-Bus. These messages
    can be controlled through the SELinux policy as well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: D-Bus 在 Linux 上的实现是一个 SELinux 感知的应用程序示例，充当用户空间对象管理器。应用程序可以在总线上注册自己，并且可以通过 D-Bus
    在应用程序之间发送消息。这些消息也可以通过 SELinux 策略进行控制。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before looking at the SELinux access controls related to message flows, it is
    important to focus on a D-Bus service and see how its authentication is done (and
    how messages are relayed in D-Bus) as this is reflected in the SELinux integration.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看与消息流相关的 SELinux 访问控制之前，重要的是先关注一个 D-Bus 服务，查看它的认证方式（以及消息如何在 D-Bus 中传递），因为这会反映在
    SELinux 集成中。
- en: 'Go to `/etc/dbus-1/system.d/` (which hosts the configuration files for D-Bus
    services) and take a look at a configuration file. For instance, the service configuration
    file for `dnsmasq` looks like the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 转到 `/etc/dbus-1/system.d/`（该目录存放 D-Bus 服务的配置文件），查看其中的配置文件。例如，`dnsmasq` 的服务配置文件如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This configuration tells D-Bus that only the root Linux user is allowed to have
    a service *own* the `uk.org.thekelleys.dnsmasq` service and send messages to this
    service. Others (as managed through the default policy) are denied these operations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置告诉 D-Bus，只有 root Linux 用户被允许拥有 `uk.org.thekelleys.dnsmasq` 服务，并向该服务发送消息。其他用户（根据默认策略进行管理）被拒绝执行这些操作。
- en: On a system with SELinux enabled, having root as the finest granularity doesn't
    cut it. So, let's look at how the SELinux policy can offer a fine-grained access
    control in D-Bus.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用 SELinux 的系统中，单纯使用 root 作为最小粒度的权限是不够的。因此，我们需要了解 SELinux 策略如何在 D-Bus 中提供细粒度的访问控制。
- en: How to do it…
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'To control D-Bus message flows with SELinux, perform the following steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 SELinux 控制 D-Bus 消息流，请执行以下步骤：
- en: 'Identify the domain of the application that will (or does) own the D-Bus service
    we are interested in. For the `dnsmasq` application, this would be `dnsmasq_t`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定我们感兴趣的 D-Bus 服务所属应用的域。对于 `dnsmasq` 应用来说，这将是 `dnsmasq_t`：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Identify the domain of the application that wants to send messages to the service.
    For instance, this could be the `sysadm_t` user domain.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定希望向服务发送消息的应用的域。例如，这可以是 `sysadm_t` 用户域。
- en: 'Allow the two domains to interact with each other through D-Bus messages as
    follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许这两个域通过 D-Bus 消息相互交互，方法如下：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: When an application connects to D-Bus, the SELinux label of its connection is
    used as the label to check when sending messages. As there is no transition for
    such connections, the label of the connection is the context of the process itself
    (the domain); hence the selection of `dnsmasq_t` in the example.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个应用连接到 D-Bus 时，其连接的 SELinux 标签会作为发送消息时检查的标签。由于这种连接没有过渡，因此连接的标签就是进程本身的上下文（域）；因此在示例中选择了
    `dnsmasq_t`。
- en: When D-Bus receives a request to send a message to a service, D-Bus will check
    the SELinux policy for the `send_msg` permission. It does so by passing on the
    information about the session (source and target context and the permission that
    is requested) to the SELinux subsystem, which computes whether access should be
    allowed or not. The access control itself, however, is not enforced by SELinux
    (it only gives feedback), but by D-Bus itself as governing the message flows is
    solely D-Bus' responsibility.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当 D-Bus 接收到发送消息到服务的请求时，D-Bus 会检查 SELinux 策略中的 `send_msg` 权限。它通过将会话的信息（源和目标上下文以及请求的权限）传递给
    SELinux 子系统，来计算是否应允许访问。然而，访问控制本身并不由 SELinux 强制执行（它只是提供反馈），而是由 D-Bus 自身执行，因为管理消息流是
    D-Bus 的责任。
- en: This is also why, when developing D-Bus-related policies, both the class and
    permission need to be explicitly mentioned in the policy module. Without this,
    the development environment might error out, claiming that `dbus` is not a valid
    class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么在开发 D-Bus 相关策略时，需要在策略模块中显式提及类和权限。没有这一点，开发环境可能会报错，声称 `dbus` 不是有效的类。
- en: D-Bus checks the context of the client that is sending a message as well as
    the context of the connection of the service (which are both domain labels) and
    see if there is a `send_msg` permission allowed. As most communication is two-fold
    (sending a message and then receiving a reply), the permission is checked in both
    directions. After all, sending a reply is just sending a message (policy-wise)
    in the reverse direction.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: D-Bus 检查发送消息的客户端的上下文以及服务的连接上下文（这两个都是域标签），并查看是否允许`send_msg`权限。由于大多数通信是双向的（发送消息然后接收回复），因此权限在两个方向上都会被检查。毕竟，发送回复本质上就是在相反方向上发送消息（从策略角度来看）。
- en: 'It is possible to verify this behavior with `dbus-send` if the rule is on a
    user domain. For instance, to look at the objects provided by the service, the
    D-Bus introspection can be invoked against the service:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果规则位于用户域中，可以使用`dbus-send`验证此行为。例如，要查看服务提供的对象，可以对该服务调用 D-Bus introspection：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When SELinux does not have the proper `send_msg` allow rules in place, the
    following error will be logged by D-Bus in its service logs (but no AVC denial
    will show up as it isn''t the SELinux subsystem that denies the access):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SELinux 没有正确的`send_msg`允许规则时，D-Bus 会在其服务日志中记录以下错误（但不会出现 AVC 拒绝，因为不是 SELinux
    子系统拒绝了访问）：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When the policy does allow the `send_msg` permission, the introspection returns
    an XML output showing the provided methods and interfaces for this service.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当策略允许`send_msg`权限时， introspection 会返回一个 XML 输出，显示该服务提供的方法和接口。
- en: There's more...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The current D-Bus implementation is a pure user space implementation. Because
    more applications become dependent on D-Bus, work is being done to create a kernel-based
    D-Bus implementation called **kdbus**. The exact implementation details of this
    project are not finished yet, so it is unknown whether the SELinux access controls
    that are currently applicable to D-Bus will still be valid on kdbus.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的 D-Bus 实现是纯用户空间实现。随着越来越多的应用程序依赖于 D-Bus，正在进行创建基于内核的 D-Bus 实现，即 **kdbus**。该项目的具体实现细节尚未完成，因此尚不清楚目前适用于
    D-Bus 的 SELinux 访问控制是否仍然适用于 kdbus。
- en: Restricting service ownership
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制服务所有权
- en: Applications that register themselves on the bus own a service name. The `uk.org.thekelleys.dnsmasq`
    service name is an example of this. The D-Bus policy, declared in the `busconfig`
    XML file at `/etc/dbus-1/system.d/` (or `session.d/` if the service is for the
    session bus instead of system bus) provides information for D-Bus to decide when
    taking ownership of a particular service is allowed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在总线注册的应用程序拥有服务名称。`uk.org.thekelleys.dnsmasq` 服务名称就是其中一个例子。D-Bus 策略在 `/etc/dbus-1/system.d/`（如果服务用于会话总线而不是系统总线，则为`session.d/`）中的
    `busconfig` XML 文件中声明，为 D-Bus 提供信息以决定何时允许获取特定服务的所有权。
- en: Thanks to D-Bus' SELinux integration, additional constraints can be added to
    ensure that only authorized applications can take ownership of a particular service.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 D-Bus 的 SELinux 集成，可以添加额外的约束，确保只有授权的应用程序才能拥有特定服务。
- en: How to do it…
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行…
- en: 'To restrict service ownership through the SELinux policy, follow the ensuing
    set of steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 SELinux 策略限制服务所有权，请按照以下步骤操作：
- en: 'Inside the D-Bus configuration file of the service, make sure that the `own`
    permission is properly protected. For instance, make sure only the `root` Linux
    user can own the service:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务的 D-Bus 配置文件中，确保`own`权限得到了适当保护。例如，确保只有`root` Linux 用户可以拥有该服务：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the runtime service account can differ, it is possible to declare a `group=`
    parameter instead of a `user=` parameter as well.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果运行时服务帐户可能不同，则也可以声明`group=`参数，而不是`user=`参数。
- en: 'Next, declare which label to associate to the service:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明与服务关联的标签：
- en: '[PRE7]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the SELinux policy, declare which domain(s) are allowed to acquire this
    service:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 SELinux 策略中，声明哪些域可以获取该服务：
- en: '[PRE8]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The D-Bus configuration allows administrators to define when service ownership
    for a particular service can be taken. Most services define the user (or group)
    that is allowed to own a service, as shown in the example. But for system services,
    only declaring that the Linux root user can own a particular service is definitely
    not sufficiently fine-grained.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: D-Bus 配置允许管理员定义何时可以获取特定服务的所有权。大多数服务会定义允许拥有服务的用户（或组），如示例所示。但对于系统服务，仅声明 Linux
    根用户可以拥有特定服务显然不够精细。
- en: Enter SELinux. With the association definition in the `busconfig` XML file,
    D-Bus is told that any application domain that tries to own that particular service
    must have the `acquire_svc` privilege (in the `dbus` class) against the mentioned
    context.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 SELinux。通过在 `busconfig` XML 文件中的关联定义，D-Bus 会告知任何尝试拥有该特定服务的应用程序域必须具备在所述上下文中对
    `dbus` 类的 `acquire_svc` 权限。
- en: With this approach, administrators can ensure that other domains, even though
    they run as the Linux root user, are not allowed to own the service.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，管理员可以确保即使其他域以 Linux root 用户身份运行，也不允许拥有该服务。
- en: 'Although the usual approach, for the target label, is to require the context
    of the application itself, it is also possible to use a different context. For
    instance, a new type can be declared such as `dnsmasq_dbus_t` and then the SELinux
    policy is set to the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常方法是为目标标签要求应用程序本身的上下文，但也可以使用不同的上下文。例如，可以声明一个新的类型，如 `dnsmasq_dbus_t`，然后将 SELinux
    策略设置为如下：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There's more...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: The D-Bus application has a configuration file inside `/etc/selinux/mcs/contexts/`,
    which follows the same structure, called `dbus_contexts`. This is a default context
    definition for D-Bus ownership (what context should be used by default if it cannot
    be deduced by other means). By default, no SELinux-specific settings are provided
    anymore as D-Bus is now fully aware of the contexts to use, and it is not recommended
    to modify this file anymore.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: D-Bus 应用程序在 `/etc/selinux/mcs/contexts/` 目录下有一个配置文件，文件结构相同，名为 `dbus_contexts`。这是
    D-Bus 所有权的默认上下文定义（如果无法通过其他方式推断，则应使用哪个上下文）。默认情况下，D-Bus 已经完全意识到需要使用哪些上下文，因此不再提供任何
    SELinux 特定的设置，并且不建议再修改此文件。
- en: 'However, it is useful to know that the file exists and is used, especially
    when D-Bus would be executed in a container, chroot, or other environment as D-Bus
    will complain if the file is missing:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，了解该文件的存在及其使用仍然很有用，特别是当 D-Bus 在容器、chroot 或其他环境中执行时，因为如果该文件缺失，D-Bus 会抱怨：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If the SELinux support in D-Bus needs to be disabled (but without rebuilding
    D-Bus), then edit `/etc/dbus-1/system.conf` and `session.conf` and remove the
    following line:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要禁用 D-Bus 中的 SELinux 支持（但不重新构建 D-Bus），则编辑 `/etc/dbus-1/system.conf` 和 `session.conf`
    文件，并删除以下行：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Understanding udev's SELinux integration
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 udev 的 SELinux 集成
- en: 'The udev device manager is responsible for handling device files inside the
    `/dev/` structure whenever changes occur. As many device files have different
    contexts, without any SELinux awareness, the udev policy would need to be enhanced
    with many, many named file transitions. Such a named file transition, for a device
    `/dev/mydevice` towards the `mydevice_t` type, would look like the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: udev 设备管理器负责在 `/dev/` 结构内处理设备文件的变动。由于许多设备文件具有不同的上下文，如果没有 SELinux 感知，udev 策略就需要通过许多命名文件转换来增强。例如，对于设备
    `/dev/mydevice` 转换为 `mydevice_t` 类型的命名文件转换如下所示：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, when `/dev/mydevice1`, `/dev/mydevice2`, and so on need to be labeled
    as well, then each possible name would need to be iterated in the policy (named
    file transitions do not support regular expressions). Luckily, udev is SELinux-aware,
    making it unnecessary to create policy enhancements for every device file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当需要为 `/dev/mydevice1`、`/dev/mydevice2` 等设备文件打上标签时，每个可能的名称都需要在策略中迭代（命名文件转换不支持正则表达式）。幸运的是，udev
    具有 SELinux 感知能力，因此无需为每个设备文件创建策略增强。
- en: This recipe shows us when additional policy enhancements are needed and when
    not.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法向我们展示了何时需要额外的策略增强，何时不需要。
- en: How to do it…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'To understand how udev''s SELinux integration works, the following decision
    criteria can be followed:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 udev 的 SELinux 集成如何工作，可以遵循以下决策标准：
- en: Whenever a device file is created by udev inside a directory with the `device_t`
    label, then udev will automatically label the device file with the label known
    to the SELinux subsystem through its `file_contexts` definitions if the target
    type is assigned the `device_node` attribute.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当 udev 在具有 `device_t` 标签的目录中创建设备文件时，如果目标类型被赋予 `device_node` 属性，则 udev 会根据 SELinux
    子系统通过 `file_contexts` 定义的标签自动为设备文件打上标签。
- en: If the parent directory does not use the `device_t` type, then make sure that
    udev holds manage rights on that target type.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果父目录未使用 `device_t` 类型，则确保 udev 对该目标类型具有管理权限。
- en: If the target file context is not associated with the `device_node` attribute,
    grant udev the proper `relabelto` privileges.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果目标文件上下文没有与 `device_node` 属性相关联，则授予 udev 适当的 `relabelto` 权限。
- en: If udev's rules are configured to create symbolic links, then assert that the
    label of the links remains the generic `device_t` type.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 udev 的规则配置为创建符号链接，则需要确保链接的标签保持为通用的 `device_t` 类型。
- en: How it works…
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The udev application is a standard SELinux-aware application that interacts
    with the SELinux user space by querying the context definitions and either creating
    the new device files with the queried context or by relabeling the device files
    afterwards.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: udev 应用程序是一个标准的 SELinux 感知应用程序，它通过查询上下文定义与 SELinux 用户空间交互，或者通过查询的上下文创建新的设备文件，或在之后重新标记设备文件。
- en: 'By querying the context definitions (instead of relying on the SELinux policy),
    administrators can easily modify the rules for different device names or include
    support for new device types, without the need to enhance the `udev_t` related
    policies. All that an administrator has to do is to configure the proper file
    context definition:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查询上下文定义（而不是依赖 SELinux 策略），管理员可以轻松修改不同设备名称的规则，或者为新设备类型提供支持，而无需增强与 `udev_t`
    相关的策略。管理员只需要配置适当的文件上下文定义：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: However, if the target device type (`mydevice_t`) is not associated with the
    `device_node` attribute, then `udev_t` will not have the privileges to relabel
    this device type. This attribute is vital for the support of `udev_t`, as it has
    relabel (and manage) rights on all device nodes through this attribute.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果目标设备类型（`mydevice_t`）没有与 `device_node` 属性关联，那么 `udev_t` 将无法重新标记该设备类型。这个属性对于
    `udev_t` 的支持至关重要，因为它通过该属性对所有设备节点具有重新标记（和管理）权限。
- en: If a udev rule would request the creation of a device file that is not associated
    with the `device_node` attribute (or a different file—the requested file does
    not need to be a device), then an update on the SELinux policy is needed if the
    default context association (that is, through inheritance of the type through
    the parent directory) is not sufficient.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 udev 规则要求创建一个未与 `device_node` 属性关联的设备文件（或者是其他文件——请求的文件不一定是设备文件），那么如果默认的上下文关联（即通过父目录的类型继承）不足以满足要求，则需要更新
    SELinux 策略。
- en: For the same reason, it is necessary to have symbolic links remain as `device_t`
    as the SELinux policy does not handle different types for symbolic links.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 出于同样的原因，符号链接必须保持为 `device_t`，因为 SELinux 策略不处理符号链接的不同类型。
- en: Of course, this SELinux support inside udev also has its consequences when device
    files are created outside of udev's handling. If that is the case, then the administrator
    has to make sure that the label of the files is corrected, as wrong device types
    can result in a system malfunction.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，udev 中的 SELinux 支持也有其影响，尤其是在设备文件在 udev 管理之外创建时。如果是这种情况，管理员必须确保文件的标签被正确修正，因为错误的设备类型可能导致系统故障。
- en: 'A popular approach for that is to relabel the entire `/dev/` structure (which
    is often done by a distribution `init` script to counter the default device file
    creation—and its default `device_t` type—from within the initial RAM filesystem
    or the `devtmpfs` mount):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的方法是重新标记整个 `/dev/` 结构（这通常是通过分发版的 `init` 脚本在初始 RAM 文件系统或 `devtmpfs` 挂载中对默认设备文件创建及其默认的
    `device_t` 类型进行处理）：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using cron with SELinux
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 cron 与 SELinux
- en: Another example of an SELinux-aware application is cron. Well, actually a set
    of cron implementations, as there is not a single cron application. Examples of
    cron implementations are vixie-cron, cronie, and fcron.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 SELinux 感知应用程序的例子是 cron。实际上是多个 cron 实现，因为并不存在单一的 cron 应用程序。常见的 cron 实现包括
    vixie-cron、cronie 和 fcron。
- en: 'The cron implementations invoke commands for (and as) a particular Linux user.
    As these commands are not set in stone (the main purpose of cron is to allow any
    command to be run for a particular user or even for the system itself), it is
    not possible to easily create a policy that is sufficiently fine-grained to accommodate
    all features provided by cron. After all, for SELinux itself, there is no difference
    between cron calling a command for one user or another: all that is involved is
    the cron domain (`crond_t`) and the target type of the command (such as `bin_t`).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: cron 实现调用命令时，会以特定的 Linux 用户身份执行这些命令。由于这些命令并不是一成不变的（cron 的主要目的就是允许为特定用户甚至系统本身执行任何命令），因此无法轻易创建出足够细粒度的策略来支持
    cron 提供的所有功能。毕竟，对于 SELinux 本身来说，cron 为某个用户或另一个用户调用命令并没有区别：涉及的只是 cron 域（`crond_t`）和命令的目标类型（例如
    `bin_t`）。
- en: For this reason, many cron implementations are made SELinux-aware, allowing
    the cron implementation to select the proper target context.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，许多 cron 实现都已支持 SELinux，使得 cron 实现能够选择正确的目标上下文。
- en: How to do it…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To properly interact with an SELinux-aware cron, the following steps need to
    be followed:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确与支持 SELinux 的 cron 交互，必须按照以下步骤操作：
- en: 'Make sure that the crontab files are properly labeled: `user_cron_spool_t`
    for the user crontabs, and `system_cron_spool_t` for the system crontab.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 crontab 文件正确标记：用户 crontab 使用 `user_cron_spool_t`，系统 crontab 使用 `system_cron_spool_t`。
- en: Check `/etc/selinux/mcs/contexts/default_contexts` or `/etc/selinux/mcs/contexts/users/*`
    for the target context of the `system_r:crond_t` domain.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `/etc/selinux/mcs/contexts/default_contexts` 或 `/etc/selinux/mcs/contexts/users/*`
    以获取 `system_r:crond_t` 域的目标上下文。
- en: Have the crontab file context be an entrypoint for the target domain. For instance,
    if the target domain for a user is its own user domain (such as `user_t`), then
    `user_cron_spool_t` has to be known as an entrypoint for `user_t`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让 crontab 文件上下文作为目标域的入口点。例如，如果用户的目标域是其自身的用户域（如 `user_t`），则 `user_cron_spool_t`
    必须作为 `user_t` 的入口点。
- en: Set the `cron_userdomain_transition` Boolean to `on` if the target domain for
    user jobs is the user domain, or `off` if the target domain should be the `cronjob_t`
    domain.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户作业的目标域是用户域，则将 `cron_userdomain_transition` 布尔值设置为 `on`；如果目标域应为 `cronjob_t`
    域，则将其设置为 `off`。
- en: How it works…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'When cron is SELinux-aware, it is vital that it is running in the `crond_t`
    domain. Its internal SELinux code will query the SELinux policy to see what the
    target domain is for a user through the application, and if cron isn''t running
    in the `crond_t` domain, then this query will not result in the correct set of
    domains:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当 cron 支持 SELinux 时，确保它运行在 `crond_t` 域内至关重要。它的内部 SELinux 代码将查询 SELinux 策略，以查看通过应用程序的用户的目标域是什么，如果
    cron 没有在 `crond_t` 域中运行，则此查询将无法返回正确的域集：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Before launching user jobs from cron, the cron application will check the file
    context of the user crontab file. This file context is then used to see whether
    the target domain for the user jobs has the user crontab file context as an entrypoint.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在从 cron 启动用户作业之前，cron 应用程序会检查用户 crontab 文件的文件上下文。然后使用这个文件上下文来查看用户作业的目标域是否将用户
    crontab 文件上下文作为入口点。
- en: 'To know what the current target domain will be, we can use the `getseuser`
    helper application:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解当前的目标域是什么，我们可以使用 `getseuser` 辅助应用程序：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this case, the target domain is `cronjob_t`. This should be confirmed by
    the `default_contexts` (or user-specific context) file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，目标域是 `cronjob_t`。可以通过 `default_contexts`（或用户特定上下文）文件来确认这一点：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If the target domain should be the user domain, then we need to toggle the
    right Boolean and adjust the context file accordingly:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标域应为用户域，则需要切换正确的布尔值并相应地调整上下文文件：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the target domain known, the last thing that is needed is that the user
    cronjob file context is known as an entrypoint for the domain, which most cron
    implementations will check as a sort-of access control:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 知道目标域后，最后需要的就是确保用户 cron 作业文件上下文作为该域的入口点，这通常是大多数 cron 实现会检查的一种访问控制：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There's more…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Not all cron implementations are SELinux-aware. If the implementation is not
    SELinux-aware, then the cron jobs will all run inside a single cron job container
    (`cronjob_t` for user cron jobs and `system_cronjob_t` for system cron jobs) with
    the `system_u` SELinux user and the `system_r` SELinux role.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的 cron 实现都支持 SELinux。如果实现不支持 SELinux，则所有 cron 作业将都在一个单一的 cron 作业容器中运行（用户
    cron 作业使用 `cronjob_t`，系统 cron 作业使用 `system_cronjob_t`），并且使用 `system_u` SELinux
    用户和 `system_r` SELinux 角色。
- en: Checking the SELinux state programmatically
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过编程方式检查 SELinux 状态
- en: If the need arises to make an SELinux-aware application, then several languages
    can be used. The `libselinux` package usually provides bindings for multiple programming
    and scripting languages. In the next set of recipes, the C programming language
    will be used as an example implementation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要创建一个支持 SELinux 的应用程序，可以使用多种编程语言。`libselinux` 包通常提供多个编程和脚本语言的绑定。在接下来的示例中，将使用
    C 编程语言作为示例实现。
- en: The first step to support SELinux in an application is to check the SELinux
    state. In this recipe, we will show how to create an application that links with
    the `libselinux` library and checks the state of SELinux.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 SELinux 的第一步是检查 SELinux 的状态。在这个示例中，我们将展示如何创建一个与 `libselinux` 库链接并检查 SELinux
    状态的应用程序。
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As we are going to update a C application, this set of recipes will assume basic
    knowledge of C programming. An example C application that uses all the input from
    this (and other) recipes can be found in the download pack of this book.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们要更新一个C应用程序，这一系列步骤假定你具有基本的C编程知识。本书下载包中可以找到一个示例C应用程序，使用了此（以及其他）食谱中的所有输入。
- en: How to do it…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In order to link with `libselinux` and to check the current SELinux state,
    the following set of steps can be used:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了链接`libselinux`并检查当前的SELinux状态，可以使用以下步骤：
- en: 'Create a C application code file and refer to the SELinux header files through
    a compiler directive:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个C应用程序代码文件，并通过编译器指令引用SELinux头文件：
- en: '[PRE20]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the application, have the SELinux-related function call return `success`
    if SELinux support should not be built-in (that is, when the compiler directive
    isn''t set):'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序中，如果不需要内建SELinux支持（即编译器指令未设置时），则相关的SELinux函数调用应返回`success`：
- en: '[PRE21]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Inside the SELinux function, check whether SELinux is enabled using the `is_selinux_enabled()`
    function call:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在SELinux函数内部，使用`is_selinux_enabled()`函数调用检查SELinux是否启用：
- en: '[PRE22]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add a check to see whether SELinux is in permissive or enforcing mode. Of course,
    this check is only needed if SELinux is enabled:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个检查，看看SELinux是处于宽容模式还是强制模式。当然，只有在启用SELinux时，才需要进行此检查：
- en: '[PRE23]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Build the application while linking with `libselinux`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`libselinux`链接时构建应用程序：
- en: '[PRE24]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `libselinux` library provides all needed functions for applications to
    query SELinux and interact with the SELinux subsystem. Of course, when developing
    applications, it remains important that SELinux support is a compile-time optional
    choice: not all Linux systems have SELinux enabled, so if the application is by
    default linked with `libselinux`, then all target systems would need to install
    the necessary dependencies.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`libselinux`库提供了所有必要的功能，以便应用程序查询SELinux并与SELinux子系统进行交互。当然，在开发应用程序时，仍然需要确保SELinux支持是一个编译时的可选项：并非所有Linux系统都启用了SELinux，因此，如果应用程序默认与`libselinux`链接，那么所有目标系统都需要安装必要的依赖项。'
- en: But even applications that are linked with `libselinux` must be able to support
    systems where SELinux has been disabled; hence, the need to check the state of
    SELinux using `is_selinux_enabled()`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但即便是与`libselinux`链接的应用程序，也必须能够支持SELinux已禁用的系统；因此，需要使用`is_selinux_enabled()`来检查SELinux状态。
- en: However, this `is_selinux_enabled()` function does not return any other information
    (such as which policy is loaded). To check if SELinux is running in permissive
    mode, the call to `security_getenforce()` can be used.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个`is_selinux_enabled()`函数并不会返回其他信息（例如，加载了哪个策略）。要检查SELinux是否在宽容模式下运行，可以使用`security_getenforce()`进行调用。
- en: 'A well-defined application should use this state as well to adjust its behavior:
    if the application is running in permissive mode, then it should try not to enforce
    SELinux policy-related decisions in its application logic.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个定义良好的应用程序应当使用此状态来调整其行为：如果应用程序运行在宽容模式下，则应尽量避免在应用逻辑中强制执行SELinux策略相关的决策。
- en: 'To refer to the cron example from an earlier recipe: if the crontab file context
    is not known as an entrypoint for the selected domain, then the application should
    log that this is not the case, but still continue working (as the mode is set
    in permissive mode). Sadly, most SELinux-aware applications do not change their
    behavior based on the permissive state of SELinux and can still fail (or follow
    a different logic) as if SELinux is in the enforcing state.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 参考之前食谱中的cron示例：如果crontab文件的上下文未知，无法作为所选域的入口点，则应用程序应该记录这一点，但仍继续工作（因为模式设置为宽容模式）。遗憾的是，大多数支持SELinux的应用程序并未根据SELinux的宽容状态改变其行为，仍可能像在强制模式下运行一样失败（或执行不同的逻辑）。
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There are other similar methods available that can be used to query the SELinux
    state.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类似的方法可以用来查询SELinux状态。
- en: The `is_selinux_mls_enabled()` method, for instance, returns a value indicating
    whether SELinux is running with MLS or not. This is useful as some context-related
    methods require level information if MLS is enabled, so querying the state and
    changing the method calls depending on the MLS state might be necessary.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`is_selinux_mls_enabled()`方法返回一个值，指示SELinux是否在MLS模式下运行。这很有用，因为某些与上下文相关的方法在启用MLS时需要级别信息，因此可能需要查询状态并根据MLS状态更改方法调用。
- en: A similar function to `security_getenforce()` is `security_setenforce()`. As
    can be deduced from the name, this allows applications to toggle the enforcing
    mode of SELinux. Of course, this is only possible if the domain in which the application
    runs has the proper SELinux permissions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与`security_getenforce()`类似的函数是`security_setenforce()`。从名称可以推测，这允许应用程序切换SELinux的强制模式。当然，只有当应用程序所在的域具备适当的SELinux权限时，这才是可能的。
- en: Querying SELinux userland configuration in C
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C中查询SELinux用户空间配置
- en: In this recipe, we will be querying the SELinux userland to obtain the default
    context for a given user based on the context of the current process. The process
    is responsible for gathering the Linux username of the user upfront.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将查询SELinux用户空间，以根据当前进程的上下文为给定用户获取默认上下文。进程负责事先收集该用户的Linux用户名。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Query the SELinux configuration as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式查询SELinux配置：
- en: 'Get the current context of the process:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取进程的当前上下文：
- en: '[PRE25]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Take the Linux username (assumed to be in the `name` variable) and get the
    SELinux user:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取Linux用户名（假设存储在`name`变量中），并获取SELinux用户：
- en: '[PRE26]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, get the default context based on the obtained SELinux user (`sename`)
    and current context (which is handled by the method itself through the `NULL`
    variable):'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，根据获取到的SELinux用户（`sename`）和当前上下文（该方法通过`NULL`变量自身处理）获取默认上下文：
- en: '[PRE27]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works…
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理…
- en: In the first block, the current process context is obtained using the `getcon()`
    method. For the end result of this recipe, getting the current context explicitly
    isn't necessary—the `get_default_context()` method that is invoked later will
    base its decision on the current context anyway (through the second parameter,
    which is `NULL` in this recipe). However, having the current context known is
    important for logging purposes as well as to query the SELinux policy itself (as
    we will do in the next recipe).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个代码块中，通过`getcon()`方法获取当前进程的上下文。对于这个示例的最终结果，显式地获取当前上下文并非必须——稍后调用的`get_default_context()`方法会根据当前上下文做出决定（通过第二个参数，这在本示例中是`NULL`）。然而，知道当前上下文对于日志记录以及查询SELinux策略本身来说是非常重要的（就像我们将在下一个示例中所做的那样）。
- en: The next step is to obtain the SELinux user given a Linux user. The `sename`
    (SELinux user) and `selevel` (SELinux sensitivity) variables are filled in by
    the `getseuserbyname()` method, given the Linux username (which is a regular `char
    *` variable).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是根据给定的Linux用户获取SELinux用户。`sename`（SELinux用户）和`selevel`（SELinux敏感度）变量由`getseuserbyname()`方法填充，传入Linux用户名（它是一个常规的`char
    *`变量）。
- en: 'Finally, with the SELinux user now available, `get_default_context()` is invoked
    to get the default context stored into the third parameter (`newcon`). If we would
    need to get the default context from a different context than the current one,
    then instead of `NULL`, the second parameter should be the context to query for:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当SELinux用户可用时，调用`get_default_context()`获取默认上下文，并将其存储到第三个参数（`newcon`）中。如果需要从与当前上下文不同的上下文中获取默认上下文，那么第二个参数就不应是`NULL`，而应该是要查询的上下文：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There's more...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Some other methods might be interesting to use in SELinux-aware applications.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在SELinux感知的应用程序中，其他一些方法可能也很有趣。
- en: The `getprevcon()` method, for instance, returns the previous context rather
    than the current context of the process. This previous context is usually the
    context of the parent process, although with applications that can perform dynamic
    transitions, this can be the previous context of the current process as well.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，`getprevcon()`方法返回的是进程的先前上下文，而不是当前上下文。这个先前的上下文通常是父进程的上下文，虽然对于可以执行动态转换的应用程序来说，这也可能是当前进程的先前上下文。
- en: 'This information can also be obtained from the `/proc/` filesystem, in the
    process''s `attr/` subdirectory in which the `current` and `prev` files can be
    checked:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息也可以从`/proc/`文件系统中获取，在进程的`attr/`子目录下可以查看`current`和`prev`文件：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As can be seen, after running `newrole` to switch roles, the last domain that
    the process was in was the `newrole_t` domain (which then performed a domain and
    role transition to the current context).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，运行`newrole`切换角色后，进程所在的最后一个域是`newrole_t`域（然后执行域和角色的转换，切换到当前的上下文）。
- en: Applications that are allowed to perform dynamic transitions (that is, without
    launching new commands) can use the `setcon()` method to switch from the current
    context to a new context.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 允许执行动态转换（即不需要启动新命令）的应用程序，可以使用`setcon()`方法从当前上下文切换到新上下文。
- en: The `get_default_context()` method is also part of a larger family of methods.
    For instance, when the user has multiple roles assigned, there can be multiple
    contexts allowed for a particular transition. The `get_ordered_context_list()`
    method returns the list of contexts that are supported (whereas the `get_default_context()`
    method only returns the first). One can filter out specific contexts by providing
    the role with the `get_ordered_context_list_with_role()` method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_default_context()`方法也是一组更大方法家族的一部分。例如，当用户分配了多个角色时，特定转换可能允许多个上下文。`get_ordered_context_list()`方法返回支持的上下文列表（而`get_default_context()`方法只返回第一个）。通过使用`get_ordered_context_list_with_role()`方法，可以通过角色过滤出特定上下文。'
- en: On MLS-enabled systems, `get_default_context_with_level()` or `get_default_context_with_rolelevel()`
    will apply a specified level to the resulting context as well.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用MLS的系统上，`get_default_context_with_level()`或`get_default_context_with_rolelevel()`将对结果上下文应用指定的级别。
- en: Another method that is available is the `get_default_type()` method, which returns
    the default type for a given role. As with the other methods, this results in
    the SELinux code to query configuration files inside `/etc/selinux/`; in this
    particular case, the `default_type` file inside `/etc/selinux/mcs/contexts/`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可用的方法是`get_default_type()`方法，它返回给定角色的默认类型。与其他方法一样，这会导致SELinux代码查询位于`/etc/selinux/`中的配置文件；在此特定情况下，是位于`/etc/selinux/mcs/contexts/`中的`default_type`文件。
- en: Interrogating the SELinux subsystem code-wise
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从代码角度审查SELinux子系统
- en: In order to query the SELinux policy, we have seen the use of the `sesearch`
    command and other SELinux utilities. Code-wise, SELinux policies can be queried
    using the `security_compute_av_flags` method.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查询SELinux策略，我们已经看到了如何使用`sesearch`命令和其他SELinux工具。从代码角度来看，SELinux策略可以通过`security_compute_av_flags`方法查询。
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `curcon` and `newcon` variables can be filled in through methods such as
    `getcon()` (for the current context) or `get_default_context()` as we have seen
    in the previous recipe.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`curcon`和`newcon`变量可以通过诸如`getcon()`（获取当前上下文）或`get_default_context()`（如我们在前面的示例中所见）等方法填充。'
- en: How to do it…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'As an example, we want to query the transition permission between two process
    domains. To accomplish this, the following method is used:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们希望查询两个进程域之间的转换权限。为此，使用以下方法：
- en: 'First of all, call the `security_compute_av_flags()` method:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，调用`security_compute_av_flags()`方法：
- en: '[PRE30]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now read the response:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在阅读响应：
- en: '[PRE31]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Check whether the current context is a permissive domain or not:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查当前上下文是否为宽容域：
- en: '[PRE32]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works…
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `security_compute_av_flags()` method is the C method equivalent of `sesearch`
    (roughly speaking). It takes the source and target context, class, and permission
    and stores the result of the query in a specific structure (`struct av_decision`).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`security_compute_av_flags()`方法是C语言中与`sesearch`（粗略来说）等效的方法。它接受源和目标上下文、类别和权限，并将查询结果存储在一个特定的结构体中（`struct
    av_decision`）。'
- en: The class and permission entries can be obtained from the `flask.h` (for the
    class declarations) and the `av_permissions.h` (for the permission declarations)
    header files that are located inside `/usr/include/selinux/`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 类别和权限条目可以从`flask.h`（类别声明）和`av_permissions.h`（权限声明）头文件中获取，这些头文件位于`/usr/include/selinux/`目录下。
- en: The result of the query is obtained by checking whether the permission is in
    the decision result.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 查询结果是通过检查权限是否出现在决策结果中来获得的。
- en: Next to the permission query, an important aspect to validate (and which is
    often forgotten by SELinux-aware applications) is to check whether the domain
    itself is marked as permissive. After all, even on an SELinux-enabled system,
    where SELinux is in enforcing mode, some domains can still be marked as permissive.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 除了权限查询，另一个需要验证的重要方面（而这一点通常会被SELinux意识到的应用忽略）是检查域本身是否标记为宽容模式。毕竟，即使在启用了SELinux并且SELinux处于强制模式的系统上，某些域仍然可以标记为宽容模式。
- en: The `SELINUX_AVD_FLAGS_PERMISSIVE` flag is a flag added to the query response
    (`struct av_decision`), which allows developers to query the permissive state
    of domains. With this information at hand, the SELinux-aware application can still
    decide to continue even if the policy denies a certain activity, just as the user
    has requested.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELINUX_AVD_FLAGS_PERMISSIVE`标志是添加到查询响应中的标志（`struct av_decision`），它允许开发人员查询域的宽容状态。掌握这些信息后，SELinux-aware应用程序仍然可以决定继续进行，即使策略拒绝某些活动，就像用户请求的那样。'
- en: There's more...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There are other methods available as well to query the SELinux policy that might
    be used by SELinux-aware applications.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可以查询SELinux策略，这些方法可能会被支持SELinux的应用程序使用。
- en: With `selinux_check_access()`, for instance, applications can query the SELinux
    policy to see if a given source context has the access permission for a given
    class and permission on the target context. This is not the same as `security_compute_av_flags()`,
    as this method uses strings for the class and permission, and also has a different
    return based on the enforcing state of SELinux or the permissive nature of a particular
    domain.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用`selinux_check_access()`，应用程序可以查询SELinux策略，查看给定的源上下文是否对目标上下文的特定类和权限具有访问权限。这与`security_compute_av_flags()`不同，因为该方法使用类和权限的字符串，并且根据SELinux的强制执行状态或特定域的宽容性返回不同的结果。
- en: Running new processes in a new context
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在新上下文中运行新进程
- en: Sometimes, it isn't possible to force a particular domain upon invocation of
    a new task or process. The default transition rules that can be enabled through
    the SELinux policy are only applicable if the source domain and file context (of
    the application or task to execute) are unambiguously decisive for the target
    context.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在调用新任务或进程时，无法强制指定特定的域。只有在源域和文件上下文（应用程序或任务执行的上下文）对目标上下文的决定性非常明确时，才能通过SELinux策略启用默认的过渡规则。
- en: In applications that can run the same command (or execute commands with the
    same context) for different target domains, SELinux-awareness is a must.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在可以为不同目标域运行相同命令（或以相同上下文执行命令）的应用程序中，支持SELinux至关重要。
- en: This recipe will show how to force a particular domain for a new process.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将展示如何强制为新进程指定特定域。
- en: Getting ready
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The `newcon` variable that is used in this recipe can be filled in through methods
    such as `get_default_context()` as we have seen in a previous recipe.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中使用的`newcon`变量可以通过像`get_default_context()`这样的方式来填充，正如我们在之前的示例中看到的那样。
- en: How to do it…
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何做的…
- en: 'To launch a process in a specific context, go through the following steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要在特定上下文中启动进程，请执行以下步骤：
- en: 'Tell SELinux what the new context should be:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉SELinux新上下文应该是什么：
- en: '[PRE33]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Fork and execute the command. For instance, to execute `id -Z`, the following
    code is used:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分叉并执行命令。例如，要执行`id -Z`，可以使用以下代码：
- en: '[PRE34]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works…
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Applications that want newly executed tasks to run in a particular context need
    to tell the SELinux subsystem that the next `execve`, `execl`, or other `exec*`
    method should result in the child process running in the new domain.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 希望新执行任务在特定上下文中运行的应用程序，需要告知SELinux子系统，下一个`execve`、`execl`或其他`exec*`方法应该导致子进程在新域中运行。
- en: 'Of course, the SELinux policy must still allow the transition policy-wise,
    even though there is no more need for an automatic domain transition in the policy
    (as this would require an unambiguous decision, which is exactly what isn''t possible
    if the source domain and file context are the same for different target contexts):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，尽管政策中不再需要自动域过渡（因为这需要明确的决定，而如果源域和文件上下文对不同目标上下文相同时，这是不可能的），但SELinux策略仍然必须允许过渡策略。
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `setexec` permission allows the source domain to explicitly tell the SELinux
    subsystem what context the task should run in. Without this permission, the call
    to `setexeccon()` would fail.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`setexec`权限允许源域明确告诉SELinux子系统任务应该在哪个上下文中运行。没有此权限，`setexeccon()`调用将失败。'
- en: There's more...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The `setexeccon()` method has a sibling method called `getexeccon()`. This method
    returns the context that would be assigned when executing a new process (which
    would provide a validation of the last `setexeccon()` call).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`setexeccon()`方法有一个类似的方法叫做`getexeccon()`。该方法返回执行新进程时将被分配的上下文（这将验证上一次`setexeccon()`调用的结果）。'
- en: 'Another similar method is the `setexecfilecon()` method. This method allows
    SELinux-aware applications to take the SELinux policy decisions into account in
    case of file-based transition information. So, if there is a domain transition
    known when executing a particular file, then this domain transition is honored.
    If not, the fallback type provided through the `setexecfilecon()` method is used:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类似的方法是`setexecfilecon()`方法。该方法允许支持SELinux的应用程序在处理基于文件的过渡信息时，考虑SELinux策略的决策。因此，如果执行特定文件时已知的域过渡存在，则会遵循该域过渡。如果没有，则使用`setexecfilecon()`方法提供的回退类型：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, if the context of the `probe_process` file is used in the SELinux
    policy to create an automatic domain transition upon invocation by the current
    application, then that target domain is used for the application execution. However,
    if the context of the `probe_process` file is the one that does not trigger any
    automatic domain transition, then the `fallbackcon` context is used for the next
    application execution.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，如果`probe_process`文件的上下文在SELinux策略中被用来在当前应用程序调用时创建自动域转换，则该目标域将用于应用程序执行。然而，如果`probe_process`文件的上下文是不会触发任何自动域转换的，那么`fallbackcon`上下文将用于下一个应用程序执行。
- en: Reading the context of a resource
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取资源的上下文
- en: It is, of course, also important to obtain the context of a resource if the
    application is SELinux-aware. This could be for logging purposes or to decide
    which domain to transition to (based on the resource context, current context,
    username, and so on).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果应用程序是SELinux感知的，获取资源的上下文也很重要。这可能是为了日志记录，或决定要转换到哪个域（基于资源上下文、当前上下文、用户名等）。
- en: How to do it…
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'To read the context of a resource, the following methods are available:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取资源的上下文，可以使用以下方法：
- en: 'Given a file path, the following call to `getfilecon()` will provide the context
    of the file:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个文件路径，以下调用`getfilecon()`将提供文件的上下文：
- en: '[PRE37]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To get the context of a process, assuming the `pid` variable (of the `pid_t`
    type) has the proper process ID in it, the following code is used:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取一个进程的上下文，假设`pid`变量（类型为`pid_t`）已经包含正确的进程ID，使用以下代码：
- en: '[PRE38]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works…
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The SELinux library has various methods for obtaining the contexts of resources.
    File and process types are shown in the recipe, but other methods exist as well.
    For instance, with the `fgetfilecon()` method, the context of a file descriptor
    can be obtained. All these methods provide the context in a standard string (`char
    *`) format.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux库提供了多种方法来获取资源的上下文。文件和进程类型在示例中有展示，但也有其他方法。例如，使用`fgetfilecon()`方法，可以获取文件描述符的上下文。所有这些方法都会以标准字符串（`char
    *`）格式返回上下文。
- en: After getting the context of a resource, it is important to free the context
    when it is no longer used. Otherwise, a memory leak will occur in the application
    as there are no other methods that will clean up the contexts.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取资源的上下文后，当不再使用该上下文时，释放它非常重要。否则，应用程序将发生内存泄漏，因为没有其他方法清理上下文。
- en: There's more...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When labeled networking is used (for instance, with CIPSO/NetLabel support or
    labeled IPSec), then the `getpeercon()` method can be used to obtain the context
    of the peer that participates in the communication session.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用标记化网络（例如，支持CIPSO/NetLabel或标记化IPSec）时，可以使用`getpeercon()`方法获取参与通信会话的对等方的上下文。
- en: Alongside querying the context, it is also possible to tell the SELinux subsystem
    that file creation should result in that file being created immediately with a
    particular context. For this, the `setfscreatecon()` method can be used—this is
    also the method that recent udev versions use when creating new device files in
    `/dev/`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询上下文的同时，也可以告诉SELinux子系统文件创建应该立即使用特定上下文创建该文件。为此，可以使用`setfscreatecon()`方法——这是近期udev版本在`/dev/`中创建新设备文件时使用的方法。
