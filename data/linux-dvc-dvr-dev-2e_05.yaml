- en: '*Chapter 4*: Writing Character Device Drivers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：编写字符设备驱动程序'
- en: Unix-based systems expose hardware to user space by means of special files,
    all created in the `/dev` directory upon device registration with the system.
    Programs willing to access a given device must locate its corresponding device
    file in `/dev` and perform the appropriate system call on it, which will be redirected
    to the driver of the underlying device associated with that special file. Though
    system calls redirection is done by an operating system, what system calls are
    supported depends on the type of device and the driver implementation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Unix的系统通过特殊文件将硬件暴露给用户空间，这些文件在设备注册到系统后会在`/dev`目录下创建。愿意访问某个设备的程序必须在`/dev`中找到相应的设备文件，并在其上执行适当的系统调用，该系统调用将被重定向到与该特殊文件相关联的底层设备的驱动程序。尽管系统调用的重定向是由操作系统完成的，但支持哪些系统调用取决于设备类型和驱动程序的实现。
- en: On the topic of types of devices, there are many of them from a hardware point
    of view, which are, however, grouped into two families of special device files
    in `/dev` – these are **block devices** and **character devices**. They are differentiated
    by the way they are accessed, their speed, and the way data is transferred between
    them and the system. Typically, character devices are slow and transfer data to
    or from user applications sequentially byte by byte (one character after another
    – hence their name). Such devices include serial ports and input devices (keyboards,
    mouses, touchpads, video devices, and so on). On the other hand, block devices
    are fast, since they are accessed quite frequently and transfer data in blocks.
    Such devices are essentially storage devices (hard drives, CD-ROMs, solid-state
    drives, and so on).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设备类型，硬件角度上有很多种，但它们被归为`/dev`目录下的两类特殊设备文件——**块设备**和**字符设备**。它们通过访问方式、速度以及数据在它们与系统之间传输的方式来区分。通常，字符设备比较慢，数据传输是按字节顺序从用户应用程序中逐个字节传输的（一个字符接一个字符——因此得名）。这样的设备包括串行端口和输入设备（键盘、鼠标、触控板、视频设备等）。另一方面，块设备比较快，因为它们的访问频繁且数据以块为单位传输。这类设备本质上是存储设备（硬盘、光盘驱动器、固态硬盘等）。
- en: In this chapter, we will focus on character devices and their drivers, their
    APIs, and their common data structures. We will introduce most of their concepts
    and write our first character device driver.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点讨论字符设备及其驱动程序、它们的API以及它们的常见数据结构。我们将介绍大部分概念并编写我们的第一个字符设备驱动程序。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The concept of major and minor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主设备号和次设备号的概念
- en: Character device data structure introduction
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符设备数据结构介绍
- en: Creating a device node
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建设备节点
- en: Implementing file operations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现文件操作
- en: The concept of major and minor
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主设备号和次设备号的概念
- en: 'Linux has always enforced device file identification by a unique identifier,
    composed of two parts, a `/dev`, character or block device files are recognizable
    by their types, which can be seen using the `ls -l` command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Linux一直通过一个唯一的标识符来强制执行设备文件的识别，该标识符由两部分组成，`/dev`，字符或块设备文件通过其类型来识别，可以通过`ls -l`命令查看：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From the preceding excerpt, in the first column, `c` identifies character device
    files and `b` identifies block device files. In the fifth and sixth columns, we
    can see, respectively, major and minor numbers. The major number either identifies
    the type of device or can be bound to a driver. The minor number either identifies
    a device locally to the driver or devices of the same type. This explains the
    fact that some device files have the same major number in the preceding output.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的摘录中，第一列中，`c`标识字符设备文件，`b`标识块设备文件。在第五列和第六列中，我们可以看到主设备号和次设备号。主设备号要么标识设备类型，要么与驱动程序绑定。次设备号要么在驱动程序中本地标识设备，要么标识同类型的设备。这就解释了为什么前面的输出中有些设备文件具有相同的主设备号。
- en: Now that we are done with the basic concepts of character devices in a Linux
    system, we can start exploring the kernel code, starting from introducing the
    main data structures.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了Linux系统中字符设备的基本概念，我们可以开始探索内核代码，从介绍主要数据结构开始。
- en: Character device data structure introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符设备数据结构介绍
- en: 'A character device driver represents the most basic device driver in the kernel
    sources. Character devices are represented in the kernel as instances of `struct
    cdev`, declared in `include/linux/cdev.h`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 字符设备驱动程序是内核源代码中最基本的设备驱动程序。字符设备在内核中以`struct cdev`实例的形式表示，该结构在`include/linux/cdev.h`中声明：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding excerpt has listed elements of our interest only. The following
    shows the meaning of these elements in this data structure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的摘录仅列出了我们感兴趣的元素。以下显示了这些元素在此数据结构中的含义：
- en: '`kobj`: This is the underlying kernel object for this character device object,
    used to enforce the Linux device model. We will discuss this in [*Chapter 14*](B17934_14_Epub.xhtml#_idTextAnchor203),
    *Introduction to the Linux Device Model*.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kobj`: 这是该字符设备对象的基础内核对象，用于实施 Linux 设备模型。我们将在[*第14章*](B17934_14_Epub.xhtml#_idTextAnchor203)，*Linux
    设备模型介绍*中讨论这一点。'
- en: '`owner`: This should be set with the `THIS_MODULE` macro.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`owner`: 应该使用`THIS_MODULE`宏进行设置。'
- en: '`ops`: This is the set of file operations associated with this character device.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ops`: 这是与此字符设备关联的文件操作集合。'
- en: '`dev`: This is the character device identifier.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`: 这是字符设备标识符。'
- en: With this data structure introduced, the next logical one for discussion is
    the one exposing file operations that system calls will rely on. Let's then introduce
    the data structure that allows interaction between user space and kernel space
    through the character device.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了这个数据结构后，接下来讨论的逻辑下一个数据结构是暴露给系统调用依赖的文件操作。然后让我们介绍允许用户空间与内核空间通过字符设备进行交互的数据结构。
- en: An introduction to device file operations
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备文件操作简介
- en: 'The `cdev->ops` element points to the file operations supported by a given
    device. Each of these operations is the target of a particular system call, in
    a manner that, when the system call is invoked by a program in user space on the
    character device, this system call is redirected in the kernel to its file operation
    counterpart in `cdev->ops`. `struct file_operations` is the data structure that
    holds these operations. It looks like the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdev->ops`元素指向给定设备支持的文件操作。每个这些操作都是特定系统调用的目标，当用户空间程序在字符设备上调用系统调用时，内核将此系统调用重定向到其在`cdev->ops`中的文件操作对应项。`struct
    file_operations`是保存这些操作的数据结构。它看起来像这样：'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding excerpt lists only the important methods of the structure, especially
    the ones that are relevant to the needs of this book. The full code is in `include/linux/fs.h`
    in kernel sources. Each of these callbacks is the backend of a system call, and
    none of them are mandatory. The following explains the meanings of elements in
    the structure:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的摘录仅列出了结构的重要方法，特别是与本书需求相关的方法。完整代码在内核源码的`include/linux/fs.h`中。每个这些回调函数是系统调用的后端，并且它们都不是强制性的。以下解释了结构中元素的含义：
- en: '`struct module *owner`: This is a mandatory field that should point to the
    module owning this structure. It is used for proper reference counting. Most of
    the time, it is set to `THIS_MODULE`, a macro defined in `<linux/module.h>`.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct module *owner`: 这是一个必填字段，应指向拥有此结构的模块。它用于正确的引用计数。大多数情况下，它设置为`THIS_MODULE`，这是在`<linux/module.h>`中定义的宏。'
- en: '`loff_t (*llseek) (struct file *, loff_t, int);`: This method is used to move
    the current cursor position in the file given as the first parameter. On a successful
    move, the function must return the new position, or else a negative value must
    be returned. If this method is not implemented, then every seek performed on this
    file will succeed by modifying the position counter in the `file` structure (`file->f_pos`),
    except the seek relative to end-of-file, which will fail.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loff_t (*llseek) (struct file *, loff_t, int);`: 此方法用于移动文件中当前光标位置，第一个参数是文件。成功移动后，函数必须返回新位置，否则必须返回负值。如果未实现此方法，则在该文件上执行的每个查找都将通过修改文件结构（`file->f_pos`）中的位置计数器成功执行，除了相对于文件末尾的查找将失败。'
- en: '`ssize_t (*read) (struct file *, char *, size_t, loff_t *);`: The role of this
    function is to retrieve data from the device. Since the return value is a "signed
    size" type, this function must return either the number (positive) of bytes successfully
    read, or else return an appropriate negative code on error. If this function is
    not implemented, then any `read()` system call on the device file will fail, returning
    with `-EINVAL` (an "invalid argument").'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssize_t (*read) (struct file *, char *, size_t, loff_t *);`: 此函数的作用是从设备中检索数据。由于返回值是"有符号大小"类型，因此此函数必须返回成功读取的字节数（正数），否则在错误时返回适当的负代码。如果未实现此函数，则对设备文件的任何`read()`系统调用都将失败，并返回`-EINVAL`（"无效参数"）。'
- en: '`ssize_t (*write) (struct file *, const char *, size_t, loff_t *);`: The role
    of this function is to send data to the device. Like the `read()` function, it
    must return a positive number, which, in this case, represents the number of bytes
    that have been written successfully, or else return an appropriately negative
    code on error. In the same way, if it is not implemented in the driver, then the
    `write()` system call attempt will fail with `-EINVAL`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssize_t (*write) (struct file *, const char *, size_t, loff_t *);`：此函数的作用是向设备发送数据。像`read()`函数一样，它必须返回一个正数，表示已成功写入的字节数，否则返回适当的负值代码以指示错误。同样，如果驱动程序中未实现此功能，则尝试执行`write()`系统调用时将失败，并返回`-EINVAL`。'
- en: '`int (*flush) (struct file *, fl_owner_t id);`: This operation is invoked when
    the file structure is being released. Like `open`, `release` can be `NULL`.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int (*flush) (struct file *, fl_owner_t id);`：当文件结构被释放时，将调用此操作。与`open`类似，`release`可以是`NULL`。'
- en: '`unsigned int (*poll) (struct file *, struct poll_table_struct *);`: This file
    operation must return a bitmask describing the status of the device. It is the
    kernel backend for both `poll()` and `select()` system calls, both used to query
    whether the device is writable, readable, or in some special state. Any caller
    of this method will block until the device enters the requested state. If this
    file operation is not implemented, then the device is always assumed to be readable,
    writable, and in no special state.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned int (*poll) (struct file *, struct poll_table_struct *);`：此文件操作必须返回一个位掩码，描述设备的状态。它是`poll()`和`select()`系统调用的内核后端，二者用于查询设备是否可写、可读，或是否处于某些特殊状态。调用此方法的任何程序都会阻塞，直到设备进入请求的状态。如果此文件操作未实现，则设备始终被假定为可读、可写且不处于特殊状态。'
- en: '`int (*mmap) (struct file *, struct vm_area_struct *);`: This is used to request
    part or all of the device memory to be mapped to a process address space. If this
    file operation is not implemented, then any attempt to invoke the `mmap()` system
    call on the device file will fail, returning `-ENODEV`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int (*mmap) (struct file *, struct vm_area_struct *);`：此操作用于请求将设备内存的部分或全部映射到进程的地址空间。如果此文件操作未实现，则对设备文件调用`mmap()`系统调用时会失败，并返回`-ENODEV`。'
- en: '`int (*open) (struct inode *, struct file *);` This file operation is the backend
    of the `open()` system call, which, if not implemented (if `NULL`), will result
    in the success of any attempt to open the device and the driver won''t be notified
    of the operation.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int (*open) (struct inode *, struct file *);`：此文件操作是`open()`系统调用的后端。如果未实现（即`NULL`），则任何尝试打开设备的操作都会成功，并且驱动程序不会收到此操作的通知。'
- en: '`int (*release) (struct inode *, struct file *);`: This is invoked when the
    file is being released, in response to the `close()` system call. Like `open`,
    `release` is not mandatory and can be `NULL`.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int (*release) (struct inode *, struct file *);`：当文件被释放时，响应`close()`系统调用时调用此操作。像`open`一样，`release`不是强制性的，可以是`NULL`。'
- en: '`int (*fsync) (struct file *, loff_t, loff_t, int datasync);`: This operation
    is the backend of the `fsync()` system call, whose purpose is to flush any pending
    data. If it is not implemented, any call to `fsync()` on the device file will
    fail, returning `-EINVAL`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int (*fsync) (struct file *, loff_t, loff_t, int datasync);`：此操作是`fsync()`系统调用的后端，旨在刷新任何待处理的数据。如果未实现，对设备文件的任何`fsync()`调用都会失败，并返回`-EINVAL`。'
- en: '`long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);`: This
    is the backend of the `ioctl` system call, whose purpose is to extend the commands
    that can be sent to the device (such as formatting a track of a floppy disk, which
    is neither reading nor writing). The commands defined by this function will extend
    a set of predefined commands that are already recognized by the kernel without
    referring to this file operation. Thus, for any command that is not defined (either
    because this function is not implemented or because it does not support the specified
    command), the system call will return `-ENOTTY`, to say *"No such ioctl for device"*.
    Any non-negative value returned by this function is passed back to the calling
    program to indicate successful completion.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);`：这是`ioctl`系统调用的后端，其目的是扩展可以发送到设备的命令（例如格式化软盘的某个磁道，这既不是读取也不是写入）。由此函数定义的命令将扩展一组已经被内核识别的预定义命令，而无需参考此文件操作。因此，对于任何未定义的命令（无论是因为此函数未实现，还是因为它不支持指定的命令），系统调用将返回`-ENOTTY`，表示*“设备没有此类ioctl”*。此函数返回的任何非负值都将传回调用程序，以表示成功完成。'
- en: Now that we are familiar with the file operation callbacks, let's delve into
    the kernel insights and learn how files are handled for a better understanding
    of the mechanisms behind character devices.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了文件操作回调，让我们深入了解内核的机制，学习文件如何处理，从而更好地理解字符设备背后的机制。
- en: File representation in the kernel
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核中的文件表示
- en: Looking at the file operation table, at least one of the parameters of each
    operation is either the `struct inode` or `struct file` type. `struct inode` refers
    to a file on the disk. However, to refer an open file (associated with a file
    descriptor within a process), the `struct file` structure is used.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 查看文件操作表时，每个操作的至少一个参数要么是`struct inode`类型，要么是`struct file`类型。`struct inode`表示磁盘上的一个文件。但是，要引用一个打开的文件（与进程中的文件描述符相关联），则使用`struct
    file`结构。
- en: 'The following is the declaration of an `inode` structure:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`inode`结构的声明：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The most important field in the structure is the `union`, especially the `i_cdev`
    element, which is set when the underlying file is a character device. This makes
    it possible to switch back and forth between `struct inode` and `struct cdev`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构体中最重要的字段是`union`，特别是`i_cdev`元素，当底层文件是字符设备时会设置此元素。这使得在`struct inode`和`struct
    cdev`之间来回切换成为可能。
- en: 'On the other hand, `struct file` is a filesystem data structure holding information
    about a file (its type, character, block, pipe, and so on), most of which is only
    relevant to the OS. The `struct file` structure (defined in `include/linux/fs.h`)
    has the following definition:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`struct file`是一个文件系统数据结构，保存有关文件的信息（如文件类型、字符、块、管道等），其中大多数信息仅与操作系统相关。`struct
    file`结构（定义在`include/linux/fs.h`中）具有以下定义：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding data structure, `f_path` represents the actual path of the
    file in the filesystem, and `f_inode` is the underlying `inode` that points to
    this opened file. This makes it possible to switch back and forth between `struct
    file` and the underlying `cdev`, through the `f_inode` element. `f_op` represents
    the file operation table. Because `struct file` represents an open file descriptor,
    it tracks the current read/write position within its opened instance. This is
    done through the `f_pos` element, and `f_pos` is the current read/write position.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述数据结构中，`f_path`表示文件在文件系统中的实际路径，`f_inode`是指向此打开文件的底层`inode`。这使得通过`f_inode`元素在`struct
    file`和底层`cdev`之间来回切换成为可能。`f_op`表示文件操作表。由于`struct file`表示一个打开的文件描述符，它追踪其打开实例中的当前读写位置。这是通过`f_pos`元素完成的，`f_pos`是当前的读写位置。
- en: Creating a device node
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建设备节点
- en: The creation of a device node makes it visible to users and allows users to
    interact with the underlying device. Linux requires intermediate steps before
    the device node is created and the following section discusses these steps.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 设备节点的创建使其对用户可见，并允许用户与底层设备进行交互。Linux在创建设备节点之前需要经过一些中间步骤，接下来的部分将讨论这些步骤。
- en: Device identification
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备标识
- en: To precisely identify devices, their identifiers must be unique. Although identifiers
    can be dynamically allocated, most drivers still use static identifiers for compatibility
    reasons. Whatever the allocation method, the Linux kernel stores file device numbers
    in elements of `dev_t` type, which is a 32-bit unsigned integer in which the major
    is represented by the first `12` bits, and the minor is coded on the `20` remaining
    bits.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了精确标识设备，它们的标识符必须是唯一的。虽然标识符可以动态分配，但大多数驱动程序仍然使用静态标识符以兼容为主。不论分配方式如何，Linux内核会将文件设备号存储在`dev_t`类型的元素中，它是一个32位无符号整数，其中前`12`位表示主设备号，剩余的`20`位表示次设备号。
- en: 'All of this is stated in `include/linux/kdev_t.h`, which contains several macros,
    including those that, given a `dev_t` type variable, can return either a minor
    or a major number:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些内容都在`include/linux/kdev_t.h`中声明，该文件包含了多个宏，其中一些宏可以根据给定的`dev_t`类型变量，返回设备的次设备号或主设备号：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The last macro accepts a minor and a major number and returns a `dev_t` type
    identifier, which the kernel uses to keep identifiers. The preceding excerpt also
    describes how the `character device` identifier is built using a bit shift. At
    this point, we can get deep into the code, using the APIs that the kernel provides
    for code allocation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的宏接受一个次设备号和主设备号，返回一个`dev_t`类型的标识符，内核使用这个标识符来存储设备标识符。前面的摘录也描述了如何通过位移构建`字符设备`标识符。到此为止，我们可以深入到代码中，使用内核提供的API来进行代码分配。
- en: Registration and deregistration of character device numbers
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符设备号的注册与注销
- en: 'There are two ways to deal with device numbers – **registration** (the static
    method) and **allocation** (the dynamic method). Registration, also called **static
    allocation**, is only useful if you know in advance which major number you want
    to start with, after making sure it does not clash with another driver using the
    same major (though this is not always predictable). Registration is a brute-force
    method in which you let the kernel know what device numbers you want by providing
    the starting major/minor pair and the number of minors, and it either grants them
    to you or not (depending on availability). The function to use for device number
    registration is the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 处理设备号的方式有两种——**注册**（静态方法）和**分配**（动态方法）。注册，也叫**静态分配**，只有在你提前知道想要开始使用的主设备号时才有用，前提是确保它不会与另一个驱动程序使用相同的主设备号（虽然这并不总是可预测的）。注册是一种暴力方法，你通过提供起始的主设备号/次设备号对和次设备号的数量，让内核知道你想要哪些设备号，内核会根据可用性来分配它们或不分配。用于设备号注册的函数如下：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method returns `0` on success, or a negative error code when it fails.
    The `first` parameter is the identifier you must have built using the major number
    and the first minor of the desired range. You can use the `MKDEV(maj, min)` macro
    to achieve that. `count` is the number of consecutive device minors required,
    and `name` should be the name of the associated device or driver.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在成功时返回`0`，失败时返回负错误代码。`first`参数是你必须使用主设备号和所需范围的第一个次设备号构建的标识符。你可以使用`MKDEV(maj,
    min)`宏来实现。`count`是所需连续设备次设备号的数量，`name`应该是关联的设备或驱动程序的名称。
- en: 'However, note that `register_chrdev_region()` works well if you know exactly
    which device numbers you want, and of course, those numbers must be available
    on your running system. Because this can be a source of conflict with other device
    drivers, it is considered preferable to use dynamic allocation, with which the
    kernel happily allocates a major number for you on the fly. `alloc_chrdev_region()`
    is the API you must use for dynamic allocation. The following is its prototype:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，`register_chrdev_region()`如果你确切知道想要的设备号，它会表现得很好，当然，这些号必须在你运行的系统中可用。由于这可能与其他设备驱动程序发生冲突，因此建议使用动态分配方式，内核可以自动为你分配一个主设备号。你必须使用`alloc_chrdev_region()`来进行动态分配。以下是它的原型：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method returns `0` on success, or a negative error code on failure. `dev`
    is the only output parameter. It represents the first number (built using the
    allocated major and the first minor requested) that the kernel assigned. `firstminor`
    is the first of the requested range of minor numbers, `count` is the number of
    consecutive minors you need, and `name` should be the name of the associated device
    or driver.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在成功时返回`0`，失败时返回负错误代码。`dev`是唯一的输出参数。它表示内核分配的第一个号（使用分配的主设备号和请求的第一个次设备号构建）。`firstminor`是请求的次设备号范围中的第一个，`count`是你需要的连续次设备号的数量，`name`应该是关联的设备或驱动程序的名称。
- en: The difference between static allocation and dynamic allocation is that, with
    the former, you should know in advance which device number is needed. When it
    comes to loading the driver on another machine, there is no guarantee that the
    chosen number is free on that machine, and this can lead to conflict and trouble.
    New drivers are encouraged to use dynamic allocation to obtain a major device
    number, rather than choosing a number randomly from the ones that are currently
    free, which will probably lead to a clash. In other words, your drivers are better
    using `alloc_chrdev_region()` rather than `register_chrdev_region()`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分配和动态分配的区别在于，前者需要你提前知道所需的设备号。将驱动程序加载到另一台机器上时，无法保证所选设备号在该机器上是空闲的，这可能导致冲突和问题。新驱动程序建议使用动态分配来获取主设备号，而不是从当前空闲的设备号中随机选择，这样可能会导致冲突。换句话说，你的驱动程序最好使用`alloc_chrdev_region()`，而不是`register_chrdev_region()`。
- en: Initializing and registering a character device on the system
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在系统上初始化并注册字符设备
- en: 'The registration of a character device is made by specifying a device identifier
    (of `dev_t` type). In this chapter, we will be using dynamic allocation, using
    `alloc_chrdev_region()`. After the identifier has been allocated, you must initialize
    the character device and add it to the system using `cdev_init()` and `cdev_add(),`
    respectively. The following are their prototypes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 字符设备的注册是通过指定设备标识符（`dev_t`类型）来进行的。在本章中，我们将使用动态分配，使用`alloc_chrdev_region()`。标识符分配后，必须使用`cdev_init()`和`cdev_add()`分别初始化字符设备并将其添加到系统中。以下是它们的原型：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In `cdev_init()`, `cdev` is the structure to initialize, and `fops` the `file_operations`
    instance for this device, making it ready to add to the system. In `cdev_add()`,
    `p` is the `cdev` structure for the device, `dev` is the first device number for
    which this device is responsible (obtained dynamically), and `count` is the number
    of consecutive minor numbers corresponding to this device. When it succeeds, `cdev_add()`
    returns `0`, or else it returns a negative error code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cdev_init()`中，`cdev`是要初始化的结构体，`fops`是该设备的`file_operations`实例，使其准备好添加到系统中。在`cdev_add()`中，`p`是设备的`cdev`结构体，`dev`是该设备负责的第一个设备号（动态获取），`count`是与该设备对应的连续次设备号的数量。成功时，`cdev_add()`返回`0`，否则返回负错误代码。
- en: 'The respective reverse operation of `cdev_add()` is `cdev_del()`, which removes
    the character device from the system and has the following prototype:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdev_add()`的相应反向操作是`cdev_del()`，它将字符设备从系统中移除，具有以下原型：'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At this step, the device is part of the system but not physically present.
    In other words, it is not visible in `/dev` yet. For the node to be created, you
    must use `device_create()`, which has the following prototype:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，设备已成为系统的一部分，但尚未物理存在。换句话说，它尚未在`/dev`中可见。为了创建节点，必须使用`device_create()`，它具有以下原型：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method creates a device and registers it with Sysfs. In its argument, `class`
    is a pointer to `struct class` that this device should be registered to, `parent`
    is a pointer to the `struct device` parent of this new device if there is any,
    `devt` is the device number for the char device to be added, and `drvdata` is
    the data to be added to the device for callbacks.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法创建一个设备并将其注册到Sysfs中。在其参数中，`class`是指向`struct class`的指针，表示该设备应注册到的类，`parent`是指向该新设备父设备`struct
    device`的指针（如果有的话），`devt`是要添加的字符设备的设备号，`drvdata`是要添加到设备的回调数据。
- en: Important Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'In case of multiple minors, the `device_create()` and `device_destroy()` APIs
    can be put in a `for` loop, and the `<device name format>` string can be appended
    with the loop counter, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个次设备，`device_create()`和`device_destroy()` API可以放入一个`for`循环中，并且`<device name
    format>`字符串可以与循环计数器一起拼接，如下所示：
- en: '`device_create(class, NULL, MKDEV(MAJOR(first_devt), MINOR(first_devt) + i),
    NULL, "mynull%d", i);`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`device_create(class, NULL, MKDEV(MAJOR(first_devt), MINOR(first_devt) + i),
    NULL, "mynull%d", i);`'
- en: 'Because a device needs an existing class before being created, you must either
    create a class or use an existing one. For now, we will create a class, and to
    do that, we need to use the `class_create()` function, declared as the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因为设备在创建之前需要一个现有的类，你必须创建一个类或者使用一个已存在的类。现在，我们将创建一个类，为此，我们需要使用`class_create()`函数，声明如下：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After then, the class will be visible in `/sys/class`, and we can create the
    device using that class. The following is a rough example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，该类将在`/sys/class`中可见，我们可以使用该类创建设备。以下是一个粗略的示例：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, `device_create()` will create a node for each device,
    – `/dev/eep-mem0`, `dev/eep-mem1`, and so on, with our class represented by `eep_class`.
    Additionally, devices can also be viewed under `/sys/class/eep-class`. In the
    meantime, the reverse operation is the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`device_create()`将为每个设备创建一个节点——`/dev/eep-mem0`、`/dev/eep-mem1`，依此类推，我们的类由`eep_class`表示。此外，设备还可以在`/sys/class/eep-class`下查看。与此同时，反向操作如下所示：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, `device_destroy()` will remove a device node from `/dev`,
    `cdev_del()` will make the system forget about this character device, `class_unregister()`
    and `class_destroy()` will deregister and remove the class from the system, and
    finally, `unregister_chrdev_region()` will release our device number.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`device_destroy()`将从`/dev`中删除设备节点，`cdev_del()`将使系统忘记这个字符设备，`class_unregister()`和`class_destroy()`将注销并从系统中移除类，最后，`unregister_chrdev_region()`将释放我们的设备号。
- en: Now that we are familiar with all the prerequisites about character devices,
    we can start implementing a file operation, which allows users to interact with
    the underlying device.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了关于字符设备的所有前提知识，接下来可以开始实现一个文件操作，让用户能够与底层设备交互。
- en: Implementing file operations
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现文件操作
- en: After introducing file operations in the previous section, it is time to implement
    those to enhance the driver capabilities and expose the device's methods to user
    space (by means of system calls, of course). Each of these methods has its particularities,
    which we will highlight in this section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节介绍了文件操作之后，是时候实现这些操作来增强驱动程序功能，并通过系统调用将设备的方法暴露给用户空间。每个方法都有其特定的特点，我们将在本节中重点介绍。
- en: Exchanging data between the kernel space and user space
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在内核空间和用户空间之间交换数据
- en: As we have seen while introducing the file operation table, the `read` and `write`
    methods are used to exchange data with the underlying device. Both being system
    calls means that data will originate from or be in destination to user space.
    While looking at the `read` and `write` method prototypes, the first point that
    catches our attention is the use of `__user`. This is a cookie used by **Sparse**
    (a semantic checker used by the kernel to find possible coding faults) to let
    the developer know they are about to use an untrusted pointer (or a pointer that
    may be invalid in the current virtual address mapping) improperly, which they
    should not dereference but, instead, use dedicated kernel functions to access
    the memory to which this pointer points.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍文件操作表时所看到的，`read`和`write`方法用于与底层设备交换数据。它们都是系统调用，这意味着数据将从用户空间传输到内核空间，或从内核空间传输到用户空间。在查看`read`和`write`方法原型时，第一个引起我们注意的是`__user`的使用。它是**Sparse**（一个用于帮助内核检查潜在编码错误的语义检查工具）用来提醒开发者他们即将不正确地使用一个不可信的指针（或者在当前虚拟地址映射中可能无效的指针），开发者不应解引用该指针，而应该使用专门的内核函数来访问指针指向的内存。
- en: 'This leads us to two principal functions that allow us to exchange data between
    a kernel and user space, `copy_from_user()` and `copy_to_user()`, which copy a
    buffer from user space to kernel space and vice versa, respectively:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了两个主要函数，它们允许我们在内核空间和用户空间之间交换数据：`copy_from_user()`和`copy_to_user()`，分别用于将缓冲区从用户空间复制到内核空间，以及从内核空间复制到用户空间：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In both cases, pointers prefixed with `__user` point to the user space (untrusted)
    memory. `n` represents the number of bytes to copy, either to or from user space.
    `from` represents the source address, and `to` is the destination address. Each
    of these returns the number of bytes that could not be copied, if any, while they
    return `0` on success. Note that these routines may sleep as they run in a user
    context and do not need to be invoked in an atomic context.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，前缀为`__user`的指针指向用户空间（不可信）内存。`n`表示要复制的字节数，既可以是从用户空间到内核空间，也可以是从内核空间到用户空间。`from`表示源地址，`to`是目标地址。每个操作都会返回无法复制的字节数（如果有的话），如果成功则返回`0`。需要注意的是，这些例程可能会休眠，因为它们在用户上下文中运行，不需要在原子上下文中调用。
- en: Implementing the open file operation
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现打开文件操作
- en: 'The `open` file operation is the backend of the open system call. One usually
    uses this method to perform device and data structure initializations, after which
    it should return `0` on success, or a negative error code if something went wrong.
    The prototype of the `open` file operation is defined as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`open`文件操作是`open`系统调用的后端。通常使用此方法进行设备和数据结构初始化，初始化后如果成功应返回`0`，如果发生错误则返回一个负的错误码。`open`文件操作的原型定义如下：'
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If it is not implemented, device opening will always succeed, but the driver
    won't be aware, which is not necessarily a problem if the device needs no special
    initialization.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有实现，设备打开将始终成功，但驱动程序不会意识到这一点。如果设备不需要特殊的初始化，这通常不会成为问题。
- en: Per-device data
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每个设备的数据
- en: As we have seen in file operation prototypes, there is almost always a `struct
    file` argument. `struct file` has an element free of use, that is `private_data`.
    `file->private_data`, if set, will be available to other system calls invoked
    on the same file descriptor. You can use this field during the lifetime of the
    file descriptor. It is good practice to set this field in the `open` method as
    it is always the first system call on any file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在文件操作原型中看到的，几乎总是有一个`struct file`参数。`struct file`有一个空闲使用的元素，即`private_data`。如果设置了`file->private_data`，它将在对相同文件描述符调用的其他系统调用中可用。你可以在文件描述符的生命周期内使用这个字段。在`open`方法中设置这个字段是一个好习惯，因为它总是任何文件上的第一个系统调用。
- en: 'The following is our data structure:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的数据结构：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Given this data structure, the `open` method would look like the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此数据结构，`open` 方法将如下所示：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Most of the time, the `open` operation does some initialization and requests
    resources that will be used while a user keeps an open instance of the device
    node. Everything that has to be done in this operation must be undone and released
    when the device is closed, as we'll see in the next operation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，`open` 操作进行一些初始化并请求在用户保持设备节点的打开实例期间使用的资源。在设备关闭时，必须撤销和释放此操作中所做的所有工作，正如我们将在下一操作中看到的那样。
- en: Implementing the release file operation
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现释放文件操作
- en: The `release` method is called when the device gets closed, the reverse of the
    `open` method. You must then undo everything you have done in the `open` operation.
    It could be literally, freeing any private memory allocated and shutting down
    the device (if supported), and discarding every buffer on the last closing (if
    the device supports multi-opening, or if the driver can handle more than one device
    at a time).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`release` 方法在设备关闭时调用，是 `open` 方法的反向操作。你必须撤销在 `open` 操作中所做的一切。这可能包括释放分配的私有内存、关闭设备（如果支持），并在最后一次关闭时丢弃所有缓冲区（如果设备支持多次打开，或者驱动程序可以处理多个设备）。'
- en: 'The following is an excerpt of a `release` function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `release` 函数的摘录：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code releases all the resources acquired when the device node
    has been open. This is literally all that needs to be done in this file operation.
    If the device node is backed by a hardware device, this operation can also put
    this device in the appropriate state.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码释放了设备节点打开时获得的所有资源。这实际上是此文件操作中需要做的所有事情。如果设备节点由硬件设备支持，此操作还可以将设备置于适当的状态。
- en: At this point, we are able to implement the entry (`open`) and exit (`release)`
    points for the character device. All that remains now is to implement each possible
    operation that can be done in between.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们能够实现字符设备的入口点（`open`）和出口点（`release`）。现在剩下的就是实现每个可能的操作。
- en: Implementing the write file operation
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现写文件操作
- en: 'The `write` method is used to send data to the device; whenever a user calls
    the `write()` system call on the device''s file, the kernel implementation that
    is called ends up being invoked. Its prototype is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`write` 方法用于向设备发送数据；每当用户在设备的文件上调用 `write()` 系统调用时，内核实现的相应方法会被调用。其原型如下：'
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This file operation must return the number of bytes (size) written, and the
    following are the definitions of its arguments:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件操作必须返回已写入的字节数（大小），以下是其参数的定义：
- en: '`*buf` represents the data buffer coming from the user space.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*buf` 表示来自用户空间的数据缓冲区。'
- en: '`count` is the size of the requested transfer.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count` 是请求传输的大小。'
- en: '`*pos` indicates the start position from which data should be written in the
    file (or in the corresponding memory region if the character device file is memory-backed).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*pos` 表示从文件中的哪个位置开始写入数据（如果字符设备文件由内存支持，则表示相应内存区域的位置）。'
- en: 'Generally, in this file operation, the first thing to do is to check for bad
    or invalid requests coming from the user space (for example, check for size limitations
    in case of a memory-backed device and size overflow). The following is an example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在执行此文件操作时，首先需要检查来自用户空间的无效请求或错误请求（例如，检查内存支持设备的大小限制以及大小溢出）。以下是一个示例：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After the checks, it is common to make some adjustments, especially with `count,`
    to not go beyond the file size. This step is not mandatory either:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 检查完成后，通常需要进行一些调整，尤其是对于 `count`，以确保不超过文件大小。此步骤也不是强制性的：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The next step is to find the location from which you will start to write. This
    step is relevant only if the device is backed by physical memory in which the
    `write()` method is supposed to store given data:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是找到开始写入的位置。只有在设备由物理内存支持的情况下，这一步才相关，在这种情况下，`write()` 方法应当存储给定的数据：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, you can copy data from user space into kernel memory, after which
    you can perform the `write` operation on the backing device and adjust `*pos`,
    as in the following excerpt:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以将数据从用户空间复制到内核内存，然后在支持设备上执行 `write` 操作，并调整 `*pos`，如下所示：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following is an example of the `write` method, which summarizes the steps
    described so far:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `write` 方法的示例，概述了目前为止描述的步骤：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After the data has been read and processed, it might be necessary to write the
    processing output back. Since we have started with writing, the next operation
    we may think of is `read`, as we will see in the next section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据被读取并处理后，可能需要将处理结果写回文件。由于我们从写操作开始，接下来我们可能想到的是`read`操作，如下节所示。
- en: Implementing the read file operation
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现读取文件操作
- en: 'The `read` method has the following prototype:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`方法具有以下原型：'
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This operation is the backend of the `read()` system call. Its arguments are
    described as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作是`read()`系统调用的后端。它的参数如下所示：
- en: '`*buf` is the buffer we receive from user space.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*buf`是我们从用户空间接收的缓冲区。'
- en: '`count` is the size of the requested transfer (the size of the user buffer).'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`是请求的传输大小（用户缓冲区的大小）。'
- en: '`*pos` indicates the start position from which data should be read in the file.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*pos`表示数据应从文件中读取的起始位置。'
- en: It must return the size of the data that has been successfully read. This size
    can be less than `count` though (for example, when reaching the end of the file
    before reaching the `count` requested by the user).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须返回成功读取的数据大小。尽管这个大小可能小于`count`（例如，在到达文件末尾之前，未达到用户请求的`count`）。
- en: 'Implementing the read operation looks like the write one, since some sanity
    checks need to be performed. First, you can prevent reading beyond the file size
    and return an end-of-file response:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实现读取操作看起来与写操作类似，因为需要执行一些健全性检查。首先，您可以防止读取超出文件大小，并返回文件结束响应：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, you should make sure the number of bytes read can''t go beyond the file
    size and you can adjust `count` appropriately:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您应该确保读取的字节数不能超过文件大小，并可以适当调整`count`：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, you can find the location from which you will start the read, after which
    you can copy the data into the user space buffer and return an error on failure,
    and then advance the file''s current position according to the number of bytes
    read and return the number of bytes copied:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以找到开始读取的位置，然后将数据复制到用户空间的缓冲区中，并在失败时返回错误，然后根据读取的字节数更新文件的当前位置信息，并返回复制的字节数：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is an example of a driver `read()` file operation, intended to
    give an overview of what can be done here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个驱动程序`read()`文件操作的示例，旨在概述这里可以做的事情：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Though reading and writing data moves the cursor position, there is an operation
    whose main purpose is to move the cursor position without touching data at all.
    Such an operation helps to start writing or reading data from anywhere by moving
    the cursor to the desired position.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管读取和写入数据会移动光标位置，但有一种操作的主要目的是在不接触数据的情况下仅移动光标位置。此操作有助于通过将光标移到所需位置，从任何地方开始读写数据。
- en: Implementing the llseek file operation
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现`llseek`文件操作
- en: 'The `llseek` file operation is the kernel backend for the `lseek()` system
    call, used to move the cursor position within a file. Its prototype looks as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`llseek`文件操作是`lseek()`系统调用的内核后端，用于在文件中移动光标位置。它的原型如下所示：'
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This callback must return the new position in the file. The following are the
    definitions of its parameters:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此回调必须返回文件中的新位置。以下是其参数的定义：
- en: '`loff_t` is an offset, relative to the current file position, which defines
    how much of it will be changed.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loff_t`是一个偏移量，相对于当前文件位置，定义了要更改的位置。'
- en: '`whence` defines where to seek from. The possible values are as follows:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`whence`定义了从哪里开始定位。可能的值如下：'
- en: '`SEEK_SET`: To put the cursor to a position relative from the beginning of
    the file'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEEK_SET`：将光标定位到相对于文件开头的位置'
- en: '`SEEK_CUR`: To put the cursor to a position relative to the current file position'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEEK_CUR`：将光标定位到相对于当前文件位置的位置'
- en: '`SEEK_END`: To adjust the cursor to a position relative to the end of the file'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEEK_END`：将光标定位到相对于文件末尾的位置'
- en: 'When implementing this operation, it is a good practice to use the `switch`
    statement to check every possible `whence` case, since they are limited, and adjust
    the new position accordingly:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现此操作时，使用`switch`语句检查每个可能的`whence`情况是一种良好的实践，因为它们是有限的，并相应地调整新位置：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After the preceding kernel backend excerpt, the following is an example of
    a user program that will successively read and seek into a file. The underlying
    driver will then execute the `llseek()` file operation entry:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的内核后端摘录之后，以下是一个用户程序的示例，该程序将依次读取并定位到文件中。底层驱动程序随后将执行`llseek()`文件操作入口：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The code produces the following output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码产生以下输出：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this section, we have explained the concept of seeking with an example, showing
    how relative and absolute seeking works. Now that we are done with operations
    moving data around, we can switch to the next operation, sensing the readability
    or writability of data in a character device.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过示例解释了寻址的概念，展示了相对寻址和绝对寻址是如何工作的。现在我们已经完成了数据操作的部分，可以转到下一个操作，感知字符设备中数据的可读性或可写性。
- en: The poll method
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`poll`方法'
- en: 'The `poll` method is the backend of both the `poll()` and `select()` system
    calls. These system calls are used to passively (by sleeping, without wasting
    CPU cycles) sense the readability/writability in a file. To support these system
    calls, the driver must implement `poll`, which has the following prototype:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`poll`方法是`poll()`和`select()`系统调用的后端。这些系统调用用于被动地（通过休眠，避免浪费CPU周期）感知文件的可读性/可写性。为了支持这些系统调用，驱动程序必须实现`poll`，其原型如下：'
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The kernel function at the heart of this method implementation is `poll_wait()`,
    defined in `<linux/poll.h>`, which is the header you must include in the driver
    code. It has the following declaration:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法实现的核心函数是`poll_wait()`，定义在`<linux/poll.h>`中，这是你必须在驱动程序代码中包含的头文件。它的声明如下：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`poll_wait()` adds the device associated with a `struct file` structure (given
    as the first parameter) to a list of those that can wake up processes (put to
    sleep in the `struct wait_queue_head_t` structure given as the second parameter),
    according to events registered in the `struct poll_table` structure given as the
    third parameter. A user process can call the `poll()`, `select()`, or `epoll()`
    system calls to add a set of files to a list on which it needs to wait, in order
    to be aware of the associated (if any) device''s readiness. The kernel will then
    call the `poll` entry of the driver associated with each device file. The `poll`
    method of each driver should then call `poll_wait()` in order to register events
    for which the process needs to be notified with the kernel, put that process to
    sleep until one of these events occurs, and register the driver as one of those
    that can wake the process up. The usual way is to use a wait queue per event type
    (one for readability, another one for writability, and eventually one for an exception
    if needed), according to events supported by the `select()` (or `poll()`) system
    call.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`poll_wait()`将与`struct file`结构相关联的设备（作为第一个参数传递）添加到可以唤醒进程的设备列表中（根据在第三个参数`struct
    poll_table`结构中注册的事件），并将进程置于由第二个参数`struct wait_queue_head_t`结构表示的等待队列中。用户进程可以调用`poll()`、`select()`或`epoll()`系统调用，将一组文件添加到等待列表中，以便了解相关设备的就绪情况。然后，内核会调用与每个设备文件关联的驱动程序的`poll`方法。每个驱动程序的`poll`方法应该调用`poll_wait()`，以便注册需要通知的事件，并将该进程休眠，直到其中一个事件发生，并将该驱动程序注册为能够唤醒该进程的设备。通常的做法是根据`select()`（或`poll()`）系统调用支持的事件类型为每个事件类型使用一个等待队列（一个用于可读性，另一个用于可写性，必要时还可以为异常使用一个）。'
- en: The return value of the (`*poll`) file operation must have `POLLIN | POLLRDNORM`
    set if there is data to read, `POLLOUT | POLLWRNORM` if the device is writable,
    and `0` if there is no new data and the device is not yet writable. In the following
    example, we assume the device supports both blocking read and write. Of course,
    you can implement only one of these. If the driver does not define this method,
    the device will be considered as always readable and writable, and `poll()` or
    `select()` system calls return immediately.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有数据可读，则（`*poll`）文件操作的返回值必须设置`POLLIN | POLLRDNORM`；如果设备是可写的，则设置`POLLOUT | POLLWRNORM`；如果没有新数据且设备尚不可写，则返回`0`。在以下示例中，我们假设设备支持阻塞的读写。当然，你也可以只实现其中一个。如果驱动程序没有定义此方法，设备将被视为始终可读和可写，`poll()`或`select()`系统调用将立即返回。
- en: 'Implementing the poll operation may require adapting the read or write file
    operations in a way that, on write, readers are notified of the readability, and
    on read, writers are notified of the writability:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`poll`操作可能需要调整读写文件操作方式，在写入时通知读者数据可读，在读取时通知写者数据可写：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding snippet, we have implemented the `poll` operation, which can
    put processes to sleep if a device is not writable or readable. However, there
    is no notification mechanism when any of those states change. Therefore, a `write`
    operation (or any operation making data available, such as an IRQ) must notify
    processes sleeping in the readability wait queue; the same applies to the `read`
    operation (or any operation making the device ready to be writable), which must
    notify processes sleeping in the writability wait queue. The following is an example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们实现了`poll`操作，当设备不可写或不可读时，进程会被挂起。然而，当这些状态发生变化时，没有通知机制。因此，`write`操作（或任何使数据可用的操作，如IRQ）必须通知在可读等待队列中挂起的进程；同样，`read`操作（或任何使设备准备好可写的操作）必须通知在可写等待队列中挂起的进程。以下是一个示例：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: More precisely, you can notify a readable event either from within the driver's
    `write()` method, meaning that the written data can be read back, or from within
    an IRQ handler, meaning that an external device sent some data that can be read
    back. On the other hand, you can notify a writable event either from within the
    driver's `read()` method, meaning that the buffer is empty and can be filled again,
    or from within an IRQ handler, meaning that the device has completed a data-send
    operation and is ready to accept data again. Do not forget to set flags back to
    `false` when the state changes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，你可以通过驱动程序的`write()`方法通知可读事件，这意味着写入的数据可以被读取，或者通过IRQ处理程序通知可读事件，这意味着外部设备发送了一些可以读取的数据。另一方面，你可以通过驱动程序的`read()`方法通知可写事件，这意味着缓冲区为空并且可以重新填充，或者通过IRQ处理程序通知可写事件，这意味着设备已完成数据发送操作并准备再次接受数据。不要忘记在状态改变时将标志重置为`false`。
- en: 'The following is an excerpt of code that uses `select()` on a given character
    device in order to sense data availability:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`select()`在给定字符设备上检测数据可用性的代码片段：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code sample, we used `select()` without timeout, in a way that
    means we will be notified of "read" events only. From that line, the process is
    put to sleep until it is notified of the event for which it registered itself.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们使用了不带超时的`select()`，这种方式意味着我们将只在“读取”事件发生时得到通知。从那一行开始，进程会被挂起，直到它收到注册的事件通知。
- en: The ioctl method
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ioctl方法
- en: 'A typical Linux system contains around 350 `-ENOTTY` error to any `ioctl()`
    system call. The following is its prototype:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的Linux系统包含大约350个`-ENOTTY`错误，这些错误会发生在任何`ioctl()`系统调用中。以下是其原型：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the preceding prototype, `f` is the pointer to the file descriptor representing
    an opened instance of the device, `cmd` is the ioctl command, and `arg` is a user
    parameter, which can be the address of any user memory on which the driver can
    call `copy_to_user()` or `copy_from_user()`. To be concise, and for obvious reasons,
    an IOCTL command needs to be identified by a number, which should be unique to
    the system. The unicity of IOCTL numbers across the system will prevent us from
    sending the right command to the wrong device, or passing the wrong argument to
    the right command (with a duplicated IOCTL number). Linux provides four helper
    macros to create an IOCTL identifier, depending on whether there is data transfer
    or not and the direction of the transfer. Their respective prototypes are as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的原型中，`f`是指向文件描述符的指针，表示已打开的设备实例，`cmd`是ioctl命令，`arg`是一个用户参数，可以是任何用户内存的地址，驱动程序可以在其上调用`copy_to_user()`或`copy_from_user()`。为了简洁起见，并出于显而易见的原因，IOCTL命令需要由一个唯一的编号来标识，这个编号应该在系统中唯一。IOCTL编号的唯一性可以防止我们将正确的命令发送到错误的设备，或者将错误的参数传递给正确的命令（因为IOCTL编号重复）。Linux提供了四个辅助宏来创建IOCTL标识符，具体取决于是否有数据传输以及传输的方向。它们各自的原型如下：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Their descriptions are as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的描述如下：
- en: '`_IO`: The IOCTL command does not need data transfer.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_IO`：IOCTL命令不需要数据传输。'
- en: '`_IOR`: This means that we''re creating an IOCTL command number for passing
    information from the kernel to user space (which is reading data). The driver
    will be allowed to return the `sizeof(TYPE)` bytes to the user without this return
    value being considered as an error.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_IOR`：这意味着我们正在创建一个IOCTL命令编号，用于将信息从内核传递到用户空间（即读取数据）。驱动程序将允许返回`sizeof(TYPE)`字节给用户，而不会将这个返回值视为错误。'
- en: '`_IOW`: This is the same as `_IOR`, but the user sends data to the driver this
    time.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_IOW`：这与`_IOR`相同，但这次是用户向驱动程序发送数据。'
- en: '`_IOWR`: The IOCTL command needs both write and read parameters.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_IOWR`：IOCTL命令需要同时提供写入和读取参数。'
- en: 'What their parameters mean (in the order they are passed) is described here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的参数含义（按传递顺序）在此处进行了描述：
- en: A number coded on 8 bits (`0` to `255`), called the **magic number**.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个由 8 位编码的数字（`0` 到 `255`），称为**魔术数字**。
- en: A sequence number or command ID, also on 8 bits.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个序列号或命令 ID，大小也是 8 位。
- en: A data type, if any, that will inform the kernel about the size to be copied.
    This could be the name of a structure or a data type.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数据类型（如果有的话），它将告诉内核要复制的大小。这可以是一个结构体或数据类型的名称。
- en: This is well documented in `Documentation/ioctl/ioctl-decoding.txt` in the kernel
    sources, and existing IOCTL commands are listed in `Documentation/ioctl/ioctl-number.txt`,
    a good place to start when you need to create your own IOCTL commands.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这在内核源代码的`Documentation/ioctl/ioctl-decoding.txt`中有很好的文档记录，现有的 IOCTL 命令列在`Documentation/ioctl/ioctl-number.txt`中，这是创建你自己
    IOCTL 命令时的一个好起点。
- en: Generating an IOCTL number (a command)
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成一个 IOCTL 数字（一个命令）
- en: 'It is recommended to generate your own IOCTL numbers in a dedicated header
    file, since this header should be available in user space as well. In other words,
    you should handle the duplication (by means of symbolic links, for example) of
    the IOCTL header file so that there is one in the kernel and one in user space,
    which can be included in user apps. Let''s now generate some IOCTL numbers in
    a real example, and let''s call this header `eep_ioctl.h`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在专用的头文件中生成你自己的 IOCTL 数字，因为这个头文件也应该在用户空间中可用。换句话说，你应该处理 IOCTL 头文件的重复（例如通过符号链接），确保内核中有一个，用户空间中也有一个，这样用户应用程序可以包含它。现在让我们在一个实际示例中生成一些
    IOCTL 数字，并称这个头文件为`eep_ioctl.h`：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After the commands have been defined, the header needs to be included in the
    final code. Moreover, because they are all unique and limited, it is a good practice
    to use a `switch ... case` statement to handle each command and return a `-ENOTTY`
    error code when an undefined `ioctl` command is called. The following is an example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义命令之后，头文件需要包含在最终代码中。此外，由于它们都是唯一且有限的，使用`switch ... case`语句处理每个命令，并在调用未定义的`ioctl`命令时返回`-ENOTTY`错误代码是一个好习惯。以下是一个示例：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Both the kernel and user space must include the header files that contain the
    IOCTL commands. Therefore, in the first line of the preceding excerpt, we have
    included `eep_ioctl.h`, which is the header file where our IOCTL commands are
    defined.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 内核和用户空间都必须包含包含 IOCTL 命令的头文件。因此，在前面摘录的第一行中，我们包含了`eep_ioctl.h`，这是定义我们 IOCTL 命令的头文件。
- en: If you think your IOCTL command will need more than one argument, you should
    gather those arguments in a structure and just pass a pointer to the structure
    to `ioctl`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为你的 IOCTL 命令需要多个参数，你应该将这些参数收集到一个结构体中，并只需将结构体的指针传递给`ioctl`。
- en: 'Now, from the user space, you must use the same `ioctl` header as in the driver''s
    code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从用户空间，你必须使用与驱动代码中相同的`ioctl`头文件：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code, we have demonstrated the use of kernel IOCTL commands
    from user space. That said, all throughout this section, we have learned how to
    implement the character device's `ioctl` callback and how to exchange data between
    the kernel and user space.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们展示了如何从用户空间使用内核的 IOCTL 命令。也就是说，在本节中，我们学习了如何实现字符设备的`ioctl`回调，以及如何在内核和用户空间之间交换数据。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have demystified character devices, and we have seen how
    to let users interact with our driver through device files. We learned how to
    expose file operations to user space and control their behavior from within the
    kernel. We went so far that you are even able to implement multi-device support.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经解开了字符设备的神秘面纱，并且我们已经看到如何通过设备文件让用户与我们的驱动程序进行交互。我们学会了如何将文件操作暴露给用户空间，并在内核中控制它们的行为。我们甚至走得更远，现在你甚至能够实现多设备支持。
- en: The next chapter is a bit more hardware-oriented, as it deals with the device
    tree, a mechanism that allows hardware devices present on the system to be declared
    to the kernel. See you in the next chapter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将更侧重于硬件，因为它涉及设备树，这是一种机制，允许系统中的硬件设备向内核声明。下章见。
