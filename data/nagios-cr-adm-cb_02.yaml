- en: Chapter 2. Working with Commands and Plugins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章：使用命令和插件
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Finding a plugin
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找插件
- en: Installing a plugin
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装插件
- en: Removing a plugin
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除插件
- en: Customizing an existing command
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义现有命令
- en: Using an alternative check command for a host
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用替代的主机检查命令
- en: Writing a new plugin from scratch
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从零开始编写新插件
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Nagios Core is perhaps best thought of less as a monitoring tool, and more as
    a monitoring framework. Its modular design can use any kind of program which returns
    appropriate values based on some kind of check, such as a `check_command` plugin
    for a host or service. This is where the concepts of commands and plugins come
    into play.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Nagios Core 也许最好被视为一个监控框架，而不仅仅是一个监控工具。它的模块化设计可以使用任何能够根据某种检查返回适当值的程序，例如用于主机或服务的
    `check_command` 插件。这就是命令和插件概念发挥作用的地方。
- en: For Nagios Core, a **plugin** is any program that can be used to gather information
    about a host or service. To ensure that a host was responding to PING requests,
    we'd use a plugin, such as `check_ping`, which when run against a hostname or
    address—whether by Nagios Core or not—would return a status code to whatever called
    it, based on whether a response was received to the PING request within a certain
    period of time. This status code and any accompanying message is what Nagios Core
    uses to establish what state a host or service is in.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Nagios Core，**插件**是任何可以用来收集有关主机或服务信息的程序。为了确保主机响应 PING 请求，我们可以使用一个插件，如 `check_ping`，当该插件针对主机名或地址运行时，无论是否由
    Nagios Core 执行，都会返回一个状态码，指示是否在一定时间内收到了 PING 请求的响应。这个状态码和任何附带的消息就是 Nagios Core
    用来确定主机或服务状态的依据。
- en: Plugins are generally just like any other program on a Unix-like system; they
    can be run from the command line, are subject to permissions and owner restrictions,
    can be written in any programming language, and can take parameters and options
    to modify how they work. Most importantly, they are entirely separate from Nagios
    Core itself (even if programmed by the same people), and the way that they're
    used by the application can be changed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 插件通常就像 Unix 类系统上的任何其他程序；它们可以从命令行运行，受限于权限和所有者的限制，可以用任何编程语言编写，并且可以接受参数和选项来修改其工作方式。最重要的是，它们与
    Nagios Core 本身完全独立（即使是由同一个团队编写的），并且它们在应用程序中的使用方式是可以更改的。
- en: To allow for additional flexibility in how plugins are used, Nagios Core uses
    these programs according to the terms of a command definition. A command for a
    specific plugin defines the way in which that plugin is used, including its location
    in the filesystem, any parameters it should be passed, and any other options.
    In particular, parameters and options often include thresholds for `WARNING` and
    `CRITICAL` states.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许插件在使用时具有更大的灵活性，Nagios Core 根据命令定义的条款使用这些程序。特定插件的命令定义了该插件的使用方式，包括它在文件系统中的位置、应该传递的任何参数以及其他选项。特别是，参数和选项通常包括
    `WARNING` 和 `CRITICAL` 状态的阈值。
- en: Nagios Core is usually downloaded and installed along a set of plugins called
    **Nagios Plugins**, available at [http://www.nagiosplugins.org/](http://www.nagiosplugins.org/),
    which this book assumes you have installed. These plugins were chosen because,
    as a set, they cover the most common needs for a monitoring infrastructure quite
    well, including checks for common services, such as web, mail services, and DNS
    services, as well as more generic checks, such as whether a TCP or UDP port is
    accessible and open on a server. It's likely that for most of our monitoring needs,
    we won't need any other plugins; but if we do, Nagios Core makes it possible to
    use existing plugins in novel ways using custom command definitions, adding third-party
    plugins written by contributors on the Nagios Exchange website, or even writing
    custom plugins ourselves from scratch in some special cases.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Nagios Core 通常与一组插件一起下载和安装，这些插件称为**Nagios 插件**，可以在[http://www.nagiosplugins.org/](http://www.nagiosplugins.org/)上找到，本书假设你已经安装了这些插件。这些插件之所以被选择，是因为作为一个整体，它们能够很好地覆盖监控基础设施中最常见的需求，包括对常见服务的检查，如
    web、邮件服务和 DNS 服务，以及更通用的检查，如检查服务器上 TCP 或 UDP 端口是否可访问并且开放。对于大多数监控需求，我们可能不需要其他插件；但如果需要，Nagios
    Core 使得通过自定义命令定义、在 Nagios Exchange 网站上添加由贡献者编写的第三方插件，或者在一些特殊情况下从零开始编写自定义插件成为可能。
- en: Finding a plugin
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找插件
- en: In this recipe, we'll follow a good procedure for finding a plugin appropriate
    to a specific monitoring task. We'll start by checking to see if an existing plugin
    is already available to do just what we need. If we can't find one, we'll check
    to see if we can use another more generic plugin to solve the problem. If we still
    find that nothing suits, we'll visit Nagios Exchange and search for an appropriate
    plugin there.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将遵循一个良好的流程，找到适合特定监控任务的插件。我们将首先检查是否已经有现有的插件可以完全满足我们的需求。如果找不到，我们将检查是否可以使用其他更通用的插件来解决问题。如果仍然没有合适的插件，我们将访问Nagios
    Exchange并在那里搜索合适的插件。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have a Nagios Core 3.0 or newer server running with a few hosts and
    services configured already, and you'll need to have a particular service on one
    of those hosts, which you're not sure how to monitor.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经运行了一个Nagios Core 3.0或更新版本的服务器，并且已经配置了一些主机和服务，你需要在其中一台主机上配置一个特定的服务，而你不确定如何监控它。
- en: We'll use a simple problem as an example; we have a server named `troy.naginet`
    that runs an `rsync` process that listens on port `873`. We're already monitoring
    the host's network connectivity via `PING`, but we'd like to have Nagios Core
    check whether the `rsync` server is available and listening at all times, in case
    it crashes while running or doesn't start up when the system is rebooted.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一个简单的问题作为示例；我们有一台名为`troy.naginet`的服务器，运行一个`rsync`进程，该进程在端口`873`上监听。我们已经通过`PING`监控了主机的网络连接，但我们希望Nagios
    Core检查`rsync`服务器是否始终可用并监听，以防它在运行时崩溃或在系统重启时未能启动。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We can find a new plugin appropriate to any monitoring task as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤找到适合任何监控任务的新插件：
- en: 'Firstly, since we have the Nagios Core Plugins set installed, we''ll check
    to see if any of the plugins available in it apply directly to our problem. We''ll
    start by visiting `/usr/local/nagios/libexec` on our Nagios Core server, and getting
    a directory listing:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，由于我们已经安装了Nagios Core Plugins集，我们将检查其中的任何插件是否可以直接应用于我们的问题。我们将从访问Nagios Core服务器上的`/usr/local/nagios/libexec`目录开始，并获取目录列表：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There's a long list of plugins there, but none of them look like `check_rsync`
    or `check_backup`, so it doesn't quite seem like there's a plugin in the core
    to do exactly what we need.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里有一长串插件，但没有一个像`check_rsync`或`check_backup`，所以看起来核心中似乎没有一个插件能完全满足我们的需求。
- en: 'However, there is a plugin called `check_tcp`. A web search for its name pulls
    up its manual page on the Nagios Plugins website as the first result, and a description
    of what it does:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，有一个名为`check_tcp`的插件。搜索其名称时，Nagios Plugins网站的手册页面作为第一个结果出现，描述了它的功能：
- en: '*"This plugin tests TCP connections with the specified host (or unix socket)."*'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*“这个插件测试与指定主机（或Unix套接字）的TCP连接。”*'
- en: We need to do more than just check the port, so this doesn't quite suit us either.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不仅仅需要检查端口，所以这也不太适合我们。
- en: A web search for `check_rsync`, which would be an appropriate name for the plugin,
    turns up a page on the Nagios Exchange website with a plugin named exactly that.
    We've found an appropriate plugin now:![How to do it...](img/5566_02_01.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索`check_rsync`，这是插件的合适名称，搜索结果中出现了Nagios Exchange网站的一页，正好有一个名为`check_rsync`的插件。我们现在找到了一个合适的插件：![How
    to do it...](img/5566_02_01.jpg)
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If all we needed to do was check that `rsync` was listening on port `873`, and
    we didn't really need to monitor any of its actual function, then the `check_tcp`
    plugin might actually suffice. However, in our case, we might need to find a way
    to not only check that a port is open, but also check that a specific directory
    or `rsync` module is accessible.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要检查`rsync`是否在端口`873`上监听，而不需要真正监控其实际功能，那么`check_tcp`插件可能足够了。然而，在我们的案例中，我们可能需要找到一种方法，不仅检查端口是否开放，还需要检查特定目录或`rsync`模块是否可访问。
- en: Reading the description for `check_rsync`, it looks like it has the exact functionality
    we need, checking that a certain `rsync` module is available on the server. At
    this point, we could download the plugin and follow its installation instructions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读`check_rsync`的描述，它看起来正好具备我们需要的功能——检查服务器上是否有某个`rsync`模块。在这一点上，我们可以下载插件并按照其安装说明进行安装。
- en: There's more...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe is intended to highlight that in addition to having a capable set
    of plugins as a part of the Nagios Core Plugins set, the documentation available
    online on the Nagios Core Plugins website at [http://nagiosplugins.org/](http://nagiosplugins.org/)
    and the other plugins available on Nagios Exchange at [http://exchange.nagios.org/](http://exchange.nagios.org/)
    make it relatively straightforward to find an appropriate plugin for the particular
    monitoring problem we need to solve.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本操作指南旨在强调，除了将一组功能强大的插件作为Nagios Core插件集的一部分外，Nagios Core插件网站上提供的在线文档 [http://nagiosplugins.org/](http://nagiosplugins.org/)
    以及Nagios Exchange上提供的其他插件 [http://exchange.nagios.org/](http://exchange.nagios.org/)
    使得找到适合特定监控问题的插件相对简单。
- en: Note that when we download third-party plugins, it's important to check that
    we trust the plugin to do what we need it to. **Nagios Exchange** is a moderated
    community with a coding standard, but the plugins are provided at our own risk;
    if we don't understand what a plugin does, we should be wary of installing it
    or using it without reading its code, its documentation, and its reviews.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们下载第三方插件时，重要的是要检查是否信任该插件以确保它能执行我们需要的操作。**Nagios Exchange**是一个有管理的社区，遵循一定的编码标准，但插件的使用风险自负；如果我们不理解某个插件的功能，应该谨慎安装或使用它，且需阅读其代码、文档及评论。
- en: See also
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The *Installing a plugin*, *Removing a plugin*, and *Writing a new plugin from
    scratch* recipes in this chapter
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*安装插件*、*移除插件*和*从零开始编写插件*的操作指南
- en: Installing a plugin
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装插件
- en: In this recipe, we'll install a custom plugin that we retrieved from Nagios
    Exchange onto a Nagios Core server, so that we can use it as a Nagios Core command
    and hence check a service with it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本操作指南中，我们将把从Nagios Exchange下载的自定义插件安装到Nagios Core服务器上，以便将其用作Nagios Core命令，从而检查服务。
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have a Nagios Core 3.0 or newer server running with a few hosts and
    services configured already, and have found an appropriate plugin to install,
    to solve some particular monitoring need. Your Nagios Core server should have
    internet connectivity to allow you to download the plugin directly from the website.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经有一个Nagios Core 3.0或更新版本的服务器，并且已经配置了一些主机和服务，同时找到一个合适的插件来解决某个特定的监控需求。你的Nagios
    Core服务器应该具有互联网连接，能够直接从网站下载插件。
- en: In this example we'll use `check_rsync`, which is available on the Web at [http://exchange.nagios.org/directory/Plugins/Network-Protocols/Rsync/check_rsync/details](http://exchange.nagios.org/directory/Plugins/Network-Protocols/Rsync/check_rsync/details).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`check_rsync`插件，它可以在网上找到，网址是 [http://exchange.nagios.org/directory/Plugins/Network-Protocols/Rsync/check_rsync/details](http://exchange.nagios.org/directory/Plugins/Network-Protocols/Rsync/check_rsync/details)。
- en: This particular plugin is quite simple, consisting of a single Perl script with
    very basic dependencies. If you want to install this script as an example, then
    the server will also need to have a Perl interpreter installed; it's installed
    in `/usr/bin/perl` on many systems.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件非常简单，由一个Perl脚本和一些基本的依赖项组成。如果你希望安装此脚本作为示例，那么服务器还需要安装Perl解释器；在许多系统中，它安装在`/usr/bin/perl`路径下。
- en: This example will also include directly testing a server running an `rsync`
    daemon called `troy.naginet`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例还将直接测试运行`rsync`守护进程的服务器，主机名为`troy.naginet`。
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We can download and install a new plugin as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式下载并安装新插件：
- en: Copy the URL for the download link for the most recent version of the `check_rsync`
    plugin:![How to do it...](img/5566_02_02.jpg)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`check_rsync`插件的最新版本下载链接：![How to do it...](img/5566_02_02.jpg)
- en: 'Navigate to the plugins directory for the Nagios Core server. The default location
    is `/usr/local/nagios/libexec`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到Nagios Core服务器的插件目录。默认位置是`/usr/local/nagios/libexec`：
- en: '[PRE1]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Download the plugin using `wget` into a file called `check_rsync`. It''s important
    to surround the URL in quotes:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`wget`命令将插件下载到名为`check_rsync`的文件中。请确保将URL用引号括起来：
- en: '[PRE2]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Make the plugin executable using `chmod` and `chown`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`chmod`和`chown`命令使插件可执行：
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the plugin directly with no arguments to check that it runs, and to get
    usage instructions. It''s a good idea to test it as the `nagios` user using `su`
    or `sudo`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接运行插件，且不带任何参数，以检查它是否能够运行并获取使用说明。建议使用`nagios`用户通过`su`或`sudo`来测试：
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Try running the plugin directly against a host running `rsync`, to see if it
    works and reports a status:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试直接对运行`rsync`的主机运行插件，查看它是否能正常工作并报告状态：
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If all of this works, then the plugin is now installed and working correctly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切正常，那么插件现在已经安装并且可以正常工作。
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Because Nagios Core plugins are programs in themselves, installing a plugin
    amounts to saving a program or script into an appropriate directory; in this case,
    `/usr/local/nagios/libexec`, where all the other plugins live. It's then available
    to be used the same way as any other plugin.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Nagios Core插件本身就是程序，所以安装插件就相当于将一个程序或脚本保存到合适的目录；在这个案例中是`/usr/local/nagios/libexec`，在那里存放着所有其他插件。它接下来可以像任何其他插件一样使用。
- en: The next step once the plugin is working is defining a command in the Nagios
    Core configuration for it, so that it can be used to monitor hosts and/or services.
    This can be done with the *Creating a new command* recipe in this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 插件一旦正常工作，下一步就是在Nagios Core配置中定义一个命令，以便它可以用于监控主机和/或服务。这可以通过本章中的*创建新命令*部分来完成。
- en: There's more...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If we inspect the Perl script, we can see a little bit of how it works. It works
    like any other Perl script, except for the fact that its return values are defined
    in a hash table called `%ERRORS`, and the return values it chooses depend on what
    happens when it tries to check the `rsync` process. This is the most important
    part of implementing a plugin for Nagios Core.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查Perl脚本，我们可以看到它的工作原理。它像其他Perl脚本一样工作，不同之处在于它的返回值定义在一个名为`%ERRORS`的哈希表中，选择的返回值取决于它尝试检查`rsync`进程时发生的情况。这是为Nagios
    Core实现插件的最关键部分。
- en: 'Installation procedures for different plugins vary. In particular, many plugins
    are written in languages such as C, and hence need be compiled. One such plugin
    is the popular `check_nrpe`. Rather than simply being saved into a directory and
    made executable, these sorts of plugins often follow the usual pattern of configuration,
    compilation, and installation:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 不同插件的安装过程各不相同。特别是许多插件是用像C这样的语言编写的，因此需要编译。一个这样的插件是流行的`check_nrpe`。这些插件通常不仅仅是保存到一个目录并使其可执行，它们往往遵循配置、编译和安装的常规模式：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For many plugins that are built in this style, the last step in that process
    will often install the compiled plugin into the appropriate directory for us.
    In general, if instructions are included with the plugin, then it pays to read
    them so that we can ensure we install it correctly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多以这种方式构建的插件，通常该过程的最后一步会将编译好的插件安装到合适的目录。一般来说，如果插件附带了说明文档，最好阅读它们，以确保我们正确安装插件。
- en: See also
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Finding a plugin*, *Removing a plugin*, and *Creating a new command* recipes
    in this chapter
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*查找插件*、*删除插件*和*创建新命令*部分
- en: Removing a plugin
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除插件
- en: In this recipe, we'll remove a plugin that we no longer need as part of our
    Nagios Core installation. Perhaps it's not working correctly, the service it monitors
    is no longer available, or there are security or licensing concerns with its usage.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中，我们将删除一个我们不再需要的插件，作为我们Nagios Core安装的一部分。可能是它无法正常工作，或者它监控的服务不再可用，或者使用它存在安全或许可问题。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have a Nagios Core 3.0 or newer server running with a few hosts and
    services configured already, and have a plugin that you would like to remove from
    the server. In this instance, we'll remove the now unneeded `check_rsync` plugin
    from our Nagios Core server.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经运行了一个Nagios Core 3.0或更高版本的服务器，并且已经配置了几个主机和服务，同时有一个你想从服务器中删除的插件。在本例中，我们将从Nagios
    Core服务器中删除现在不再需要的`check_rsync`插件。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法...
- en: 'We can remove a plugin from our Nagios Core instance as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下步骤从Nagios Core实例中删除插件：
- en: 'Remove any part of the configuration that uses the plugin, including hosts
    or services that use it for `check_command`, and command definitions that refer
    to the program. As an example, the following definition for a command would no
    longer work after we removed the `check_rsync` plugin:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除任何使用该插件的配置部分，包括使用它的主机或服务的`check_command`，以及引用该程序的命令定义。举个例子，以下定义的命令在我们删除`check_rsync`插件后将不再有效：
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using a tool such as `grep` can be a good way to find mentions of the command
    and plugin:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`grep`等工具是查找命令和插件引用的一个好方法：
- en: '[PRE8]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Change directory on the Nagios Core server to wherever the plugins are kept.
    The default location is `/usr/local/nagios/libexec`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Nagios Core服务器上切换到保存插件的目录。默认位置是`/usr/local/nagios/libexec`：
- en: '[PRE9]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Delete the plugin with the `rm` command:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`rm`命令删除插件：
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Validate the configuration and restart the Nagios Core server:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证配置并重启Nagios Core服务器：
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Nagios Core plugins are simply external programs that the server uses to perform
    checks of hosts and services. If a plugin is no longer wanted, all that needs
    to be done is to remove references to it in our configuration, if any, and then
    delete the plugin program from `/usr/local/nagios/libexec`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Nagios Core插件仅仅是服务器用来执行主机和服务检查的外部程序。如果不再需要插件，只需从我们的配置中删除对它的引用（如果有），然后从`/usr/local/nagios/libexec`目录中删除插件程序即可。
- en: There's more...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Usually there's not any harm in leaving the plugin's program on the server even
    if Nagios Core isn't using it. It doesn't slow anything down or cause any other
    problems, and it may be needed later. Nagios Core plugins are generally quite
    small programs, and should not really cause disk space concerns on a modern server.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，即使Nagios Core没有使用插件程序，将其保留在服务器上也不会有什么害处。它不会导致任何性能问题或其他麻烦，而且以后可能会需要。Nagios
    Core的插件通常是非常小的程序，不会在现代服务器上占用太多磁盘空间。
- en: See also
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Finding a plugin*, *Installing a plugin*, and *Creating a new command*
    recipes in this chapter
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*查找插件*，*安装插件*和*创建新命令*方法
- en: Creating a new command
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新命令
- en: In this recipe, we'll create a new command for a plugin that was just installed
    into the `/usr/local/nagios/libexec` directory on the Nagios Core server. This
    will define the way in which Nagios Core should use the plugin, and thereby allow
    it to be used as part of a service definition.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将为刚刚安装到Nagios Core服务器上`/usr/local/nagios/libexec`目录中的插件创建一个新命令。这将定义Nagios
    Core如何使用该插件，从而允许它作为服务定义的一部分被使用。
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have a Nagios Core 3.0 or newer server running with a few hosts and
    services configured already, and have a plugin installed for which you'd like
    to define a new command. This will allow you to use it as part of a service definition.
    In this instance, we'll define a command for an installed `check_rsync` plugin.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经运行了Nagios Core 3.0或更新版本的服务器，并且已经配置了一些主机和服务，并安装了你希望为其定义新命令的插件。这将允许你将它作为服务定义的一部分使用。在这个例子中，我们将为已安装的`check_rsync`插件定义一个命令。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We can define a new command in our configuration as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式在配置中定义一个新命令：
- en: 'Change to the directory containing the objects configuration for Nagios Core.
    The default location is `/usr/local/nagios/etc/objects`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到包含Nagios Core对象配置的目录。默认位置是`/usr/local/nagios/etc/objects`：
- en: '[PRE12]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Edit the `commands.cfg` file:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`commands.cfg`文件：
- en: '[PRE13]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At the bottom of the file, add the following command definition:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件底部，添加以下命令定义：
- en: '[PRE14]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Validate the configuration and restart the Nagios Core server:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证配置并重启Nagios Core服务器：
- en: '[PRE15]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the validation passes and the server restarts successfully, we should be
    able to use the `check_rsync` command in a service definition.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果验证通过并且服务器成功重启，我们应该能够在服务定义中使用`check_rsync`命令。
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The configuration we added to the `commands.cfg` file defines a new command
    called `check_rsync`, which defines a method for using the plugin of the same
    name to monitor a service. This enables us to use `check_rsync` as a value for
    the `check_command` directive in a service declaration, which might look similar
    to the following code snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到`commands.cfg`文件中的配置定义了一个名为`check_rsync`的新命令，定义了使用同名插件监控服务的方法。这使我们能够在服务声明中使用`check_rsync`作为`check_command`指令的值，类似于以下代码片段：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Only two directives are required for command definitions, and we''ve defined
    both:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 命令定义只需要两个指令，我们已经定义了这两个指令：
- en: '`command_name`: This defines the unique name with which we can reference the
    command when we use it in host or service definitions.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command_name`：这定义了我们可以在主机或服务定义中引用该命令时使用的唯一名称。'
- en: '`command_line`: This defines the command line that should be executed by Nagios
    Core to make the appropriate check.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command_line`：这定义了Nagios Core应该执行的命令行，以进行适当的检查。'
- en: 'This particular command line also uses two macros:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的命令行还使用了两个宏：
- en: '`$USER1$`: This expands to `/usr/local/nagios/libexec`, the location of the
    plugin binaries, including `check_rsync`. It is defined in the sample configuration
    in the file `/usr/local/nagios/etc/resource.cfg`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$USER1$`：它展开为`/usr/local/nagios/libexec`，这是插件二进制文件的存放位置，包括`check_rsync`。它在文件`/usr/local/nagios/etc/resource.cfg`的示例配置中定义。'
- en: '`$HOSTADDRESS$`: This expands to the address of any host for which this command
    is used as a host or service definition.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$HOSTADDRESS$`：它展开为任何主机的地址，且该命令用于该主机或服务定义。'
- en: 'So if we used the command in a service checking the `rsync` server on `troy.naginet`,
    then the completed command might look similar to the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们在检查`troy.naginet`上的`rsync`服务器时使用了这个命令，那么完成的命令可能会像下面这样：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We could run this straight from the command line ourselves as the nagios user
    to see what kind of results it returns:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接以nagios用户身份从命令行运行它，看看它返回什么样的结果：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There's more...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'A plugin can be used for more than one command. If we had a particular `rsync`
    module to check with the configured name of `backup`, we could write another command
    called `check_rsync_backup` , as follows, to check this module is available:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个插件可以用于多个命令。如果我们有一个特定的`rsync`模块，配置名称为`backup`，我们可以编写另一个命令`check_rsync_backup`，如下所示，检查此模块是否可用：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Or if one or more of our `rsync` servers was running on an alternate port,
    say port `5873`, then we could define a separate command, `check_rsync_altport`,
    for that:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们的一个或多个`rsync`服务器运行在另一个端口上，比如端口`5873`，那么我们可以为此定义一个单独的命令`check_rsync_altport`：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Commands can thus be defined as precisely as we need them to be. We explore
    this in more detail in the *Customizing an existing command* recipe in this chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，命令可以根据我们的需求定义得非常精确。在本章的*自定义现有命令*配方中，我们将详细探讨这一点。
- en: See also
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Installing a plugin* and *Customizing an existing command* recipes in this
    chapter
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*安装插件*和*自定义现有命令*配方
- en: Customizing an existing command
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义现有命令
- en: In this recipe, we'll customize an existing command definition. There are a
    number of reasons why you might want to do this, but a common one is if a check
    is "overzealous", sending notifications for `WARNING` or `CRITICAL` states, which
    aren't actually terribly worrisome. It can also be useful if a check is too "forgiving"
    and doesn't detect actual problems with hosts or services.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将自定义一个现有的命令定义。你可能会出于多种原因想这么做，其中一个常见的原因是检查过于“积极”，在`WARNING`或`CRITICAL`状态时发送通知，尽管这些状态实际上并不严重。它还可以有用，如果一个检查过于“宽容”，没有检测到主机或服务的实际问题。
- en: Another reason is to account for peculiarities in your own network. For example,
    if you run HTTP daemons on a large number of hosts on the alternative port `8080`
    that you need to check, it would be convenient to have a `check_http_altport`
    command available. We can do this by copying and altering the definition for the
    vanilla `check_http` command.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是考虑到你自己网络的特殊情况。例如，如果你在大量主机上运行HTTP守护进程，并且这些守护进程都使用备用端口`8080`，那么需要检查它们，最好有一个`check_http_altport`命令可用。我们可以通过复制并修改原始`check_http`命令的定义来实现这一点。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have a Nagios Core 3.0 or newer server running with a few hosts and
    services configured already. You should also already be familiar with the relationship
    between services, commands, and plugins.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经运行了Nagios Core 3.0或更新版本的服务器，并且已经配置了一些主机和服务。你还应该已经熟悉服务、命令和插件之间的关系。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We can customize an existing command definition as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照如下方式自定义现有的命令定义：
- en: 'Change to the directory containing the objects configuration for Nagios Core.
    The default location is `/usr/local/nagios/etc/objects`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到包含Nagios Core对象配置的目录。默认位置是`/usr/local/nagios/etc/objects`：
- en: '[PRE21]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Edit the `commands.cfg` file, or any file which is at an appropriate location
    for the `check_http` command:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`commands.cfg`文件，或者编辑位于适当位置的其他文件，以适应`check_http`命令：
- en: '[PRE22]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Find the definition for the `check_http` command. In a default Nagios Core
    configuration, it should look similar to the following:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找`check_http`命令的定义。在默认的Nagios Core配置中，它应该类似于以下内容：
- en: '[PRE23]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Copy this definition into a new definition directly below it and alter it to
    look similar to the following code snippet, renaming the command and adding a
    new option to its command line:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此定义复制到新定义中，并将其更改为类似于以下代码片段，重命名命令并向命令行添加一个新选项：
- en: '[PRE24]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Validate the configuration and restart the Nagios Core server:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证配置并重启Nagios Core服务器：
- en: '[PRE25]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the validation passed and the server restarted successfully, we should now
    be able to use the `check_http_altport` command, which is based on the original
    `check_http` command, in a service definition.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果验证通过且服务器成功重启，我们现在应该能够在服务定义中使用基于原始`check_http`命令的`check_http_altport`命令。
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The configuration we added to the `commands.cfg` file reproduces the command
    definition for `check_http`, but changes it in two ways:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到`commands.cfg`文件中的配置重新定义了`check_http`命令，但在两个方面做了更改：
- en: It renames the command from `check_http` to `check_http_alt`, which is necessary
    to distinguish the commands from one another. Command names in Nagios Core, just
    like host names, must be unique.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将命令从`check_http`重命名为`check_http_alt`，这是为了区分这些命令。Nagios Core中的命令名称，就像主机名一样，必须是唯一的。
- en: It adds the option `-p 8080` to the command-line call, specifying the time when
    the call to `check_http` is made. The check will be made using TCP port `8080`,
    rather than the default value for TCP port `80`.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在命令行调用中添加了选项`-p 8080`，指定了何时调用`check_http`。检查将使用TCP端口`8080`，而不是默认的TCP端口`80`。
- en: 'The `check_http_alt` command can now be used as a check command in the same
    way as a `check_http` command. For example, a service definition that checks whether
    the `sparta.naginet` host is running an HTTP daemon on port `8080` might look
    similar to the following code snippet:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`check_http_alt`命令现在可以像`check_http`命令一样作为检查命令使用。例如，检查`sparta.naginet`主机是否在`8080`端口上运行HTTP守护进程的服务定义可能类似于以下代码片段：'
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There's more...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe's title implies that we should customize the existing commands by
    editing them in place, and indeed, this works fine if we really do want to do
    things this way. Instead of copying the command definition, we could just add
    the `-p 8080` or another customization to the command line and change the original
    command.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这道配方的标题暗示我们应该通过直接编辑现有命令来进行自定义，实际上，如果我们确实希望以这种方式操作，这种方法是有效的。我们可以在命令行中直接添加`-p
    8080`或其他自定义选项，而不是复制命令定义，并修改原始命令。
- en: However, this is bad practice in most cases, mostly because it could break the
    existing monitoring and be potentially confusing to other administrators of the
    Nagios Core server. If we have a special case for monitoring—in this case, checking
    a non-standard port for HTTP—then it's wise to create a whole new command based
    on the existing one with the customizations we need.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数情况下，这种做法是不可取的，主要是因为它可能会破坏现有的监控，并且可能会让其他Nagios Core服务器的管理员感到困惑。如果我们有一个特殊的监控案例——在这种情况下，检查非标准端口的HTTP——那么明智的做法是基于现有命令创建一个全新的命令，并进行必要的自定义。
- en: 'There is no limit to the number of commands you can define, so you can be very
    liberal in defining as many alternative commands as you need. It''s a good idea
    to give them instructive names that say something about what they do, as well
    as to add explanatory comments to the configuration file. You can add a comment
    to the file by prefixing it with a `#` character:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义任意数量的命令，因此在定义所需的替代命令时可以非常自由。建议给它们起一些具有指导意义的名字，描述它们的功能，并在配置文件中添加解释性注释。你可以通过在文件前加`#`字符来添加注释：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: See also
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The *Creating a new command* recipe in this chapter
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*创建新命令*配方
- en: The *Creating a new service* recipe in [Chapter 1](ch01.html "Chapter 1. Understanding
    Hosts, Services, and Contacts"), *Understanding Hosts, Services, and Contacts*
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. 理解主机、服务和联系人")中的*创建新服务*配方，*理解主机、服务和联系人*'
- en: Using an alternative check command for hosts
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用备用检查命令检查主机
- en: In this recipe, we'll learn how to deal with a slightly tricky case in network
    monitoring—monitoring a server that doesn't respond to PING, but still provides
    some network service that requires checking.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何处理网络监控中的一个稍微棘手的情况——监控一个不响应PING的服务器，但仍然提供需要检查的某些网络服务。
- en: It's good practice to allow PING where you can, as it's one of the stipulations
    in **RFC 1122** and a very useful diagnostic tool not just for monitoring, but
    also for troubleshooting. However, sometimes servers that are accessed only by
    a few people might be configured not to respond to these messages, perhaps for
    reasons of secrecy. It's quite common for domestic routers to be configured this
    way.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，允许PING是一个良好的实践，因为它是**RFC 1122**中的一项规定，并且是一个非常有用的诊断工具，不仅用于监控，也用于故障排除。然而，有时只被少数人访问的服务器可能被配置为不响应这些消息，可能是出于保密的原因。家庭路由器通常会这样配置。
- en: Another very common reason for this problem, and the example we'll address here,
    is checking servers that are behind an **IPv4 NAT** firewall. It's not possible
    to address the host directly via an **RFC1918** address, such as `192.168.1.20`,
    from the public Internet. Pinging the public interface of the router therefore
    doesn't tell us whether the host for which it is translating addresses is actually
    working.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的另一个非常常见的原因，也是我们在这里处理的示例，是检查位于**IPv4 NAT**防火墙后面的服务器。我们无法通过**RFC1918**地址（如`192.168.1.20`）直接访问主机，因为它不能从公共互联网进行访问。因此，单纯地对路由器的公共接口进行
    ping 测试并不能告诉我们，路由器正在转换地址的主机是否正常工作。
- en: However, port `22` for SSH is forwarded from the outside to this server, and
    it's this service that we need to check for availability.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，SSH 的端口`22`从外部转发到该服务器，正是我们需要检查其可用性的服务。
- en: '![Using an alternative check command for hosts](img/5566_02_03.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![使用替代的检查命令检查主机](img/5566_02_03.jpg)'
- en: We'll do this by checking whether the host is up through an SSH check, since
    we can't PING it from the outside as we normally would.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 SSH 检查主机是否正常，因为我们无法像通常那样从外部 ping 它。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have a Nagios Core 3.0 or newer server running with a few hosts and
    services configured already. You should also already be familiar with the relationship
    between services, commands, and plugins.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经运行了 Nagios Core 3.0 或更新版本的服务器，并且已经配置了一些主机和服务。您也应该已经熟悉服务、命令和插件之间的关系。
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We can specify an alternative check method for a host as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式为主机指定替代的检查方法：
- en: 'Change to the directory containing the objects configuration for Nagios Core.
    The default location is `/usr/local/nagios/etc/objects`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到包含 Nagios Core 对象配置的目录。默认位置是`/usr/local/nagios/etc/objects`：
- en: '[PRE28]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Find the file that contains the host definition for the host that won''t respond
    to PING, and edit it. In this example, our `crete.naginet` host is the one we
    want to edit:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到包含无法响应 PING 的主机定义的文件，并进行编辑。在本例中，我们要编辑的是`crete.naginet`主机：
- en: '[PRE29]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Change or define the `check_command` parameter of the host to the command that
    we want to use for the check instead of the usual `check-host-alive` or `check_ping`
    plugin. In this case, we want to use `check_ssh`. The resulting host definition
    might look similar to the following code snippet:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改或定义主机的`check_command`参数，使用我们想要用于检查的命令，而不是通常的`check-host-alive`或`check_ping`插件。在这种情况下，我们希望使用`check_ssh`。最终的主机定义可能类似于以下代码片段：
- en: '[PRE30]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that defining `check_command` still works even if we''re using a host
    template, such as `generic-host` or `linux-server`. It''s a good idea to check
    that the host will actually respond to our check as we expect it to:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，即使我们使用的是主机模板，如`generic-host`或`linux-server`，定义`check_command`依然有效。最好检查主机是否会按预期响应我们的检查：
- en: '[PRE31]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Validate the configuration and restart the Nagios Core server:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证配置并重启 Nagios Core 服务器：
- en: '[PRE32]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With this done, the next scheduled host check for the `crete.naginet` server
    should show the host as `UP`, because it was checked with the `check_ssh` command
    and not the usual `check-host-alive` command.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，接下来的对`crete.naginet`服务器的计划检查应该会显示该主机为`UP`，因为它是通过`check_ssh`命令而非通常的`check-host-alive`命令进行检查的。
- en: How it works
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The configuration we added for the `crete.naginet` host uses `check_ssh` to
    check whether the host is `UP`, rather than a check that uses PING. This is appropriate
    because the only public service accessible from `crete.naginet` is its SSH service.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`crete.naginet`主机添加的配置使用`check_ssh`来检查主机是否`UP`，而不是使用 PING 的检查。这是合适的，因为从`crete.naginet`访问的唯一公共服务是其
    SSH 服务。
- en: '![How it works](img/5566_02_04.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的](img/5566_02_04.jpg)'
- en: The `check_ssh` command is normally used to check whether a service is available,
    rather than a host. However, Nagios Core allows us to use it as a host check command
    as well. Most service commands work this way; you could check a web server behind
    NAT in the same way with `check_http`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`check_ssh`命令通常用于检查服务的可用性，而不是主机。然而，Nagios Core 允许我们将其作为主机检查命令使用。大多数服务命令都是这样工作的；您也可以通过`check_http`检查位于
    NAT 后面的 Web 服务器。'
- en: There's more...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Note that for completeness' sake, it would also be appropriate to monitor the
    NAT router via PING, or some other check appropriate to its public address. That
    way, if the host check for the SSH server fails, we can check to see if the NAT
    router in front of it is still available, which assists in troubleshooting whether
    the problem is with the server or with the NAT router in front of it. You can
    make this setup even more useful by making the NAT router a parent host for the
    SSH server behind it, explained in the *Creating a network host hierarchy* recipe
    in [Chapter 8](ch08.html "Chapter 8. Managing Network Layout"), *Understanding
    the Network Layout*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了完整性，适当地通过 PING 或其他适合其公共地址的检查监控 NAT 路由器也是合适的。这样，如果 SSH 服务器的主机检查失败，我们可以检查位于前面的
    NAT 路由器是否仍然可用，这有助于排查问题是否出在服务器本身还是前面的 NAT 路由器上。你还可以通过将 NAT 路由器设置为 SSH 服务器的父主机，来使这个设置更有用，这一点可以在
    [第 8 章](ch08.html "第 8 章。管理网络布局")中的 *创建网络主机层次结构* 方案，*理解网络布局* 中找到。
- en: See also
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Monitoring SSH for any host* and *Checking an alternative SSH port* recipes
    in [Chapter 5](ch05.html "Chapter 5. Monitoring Methods"), *Monitoring Methods*
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 5 章](ch05.html "第 5 章。监控方法")中的 *监控 SSH 以检查任何主机* 和 *检查替代 SSH 端口* 方案，*监控方法*'
- en: The *Monitoring local services on a remote machine with NRPE* recipe in [Chapter
    6](ch06.html "Chapter 6. Enabling Remote Execution"), *Enabling Remote Execution*
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 6 章](ch06.html "第 6 章。启用远程执行")中的 *使用 NRPE 监控远程主机上的本地服务* 方案，*启用远程执行*'
- en: The *Creating a network host hierarchy* and *Establishing a host dependency*
    recipes in [Chapter 8](ch08.html "Chapter 8. Managing Network Layout"), *Understanding
    the Network Layout*
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 8 章](ch08.html "第 8 章。管理网络布局")中的 *创建网络主机层次结构* 和 *建立主机依赖关系* 方案，*理解网络布局*'
- en: Writing a new plugin from scratch
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从零开始编写一个新的插件
- en: Even given the very useful standard plugins in the Nagios Plugins set, and the
    large number of custom plugins available on Nagios Exchange, occasionally as our
    monitoring setup grows more refined, we may find that there is some service or
    property of a host that we would like to check, but for which there doesn't seem
    to be any suitable plugin available. Every network is different, and sometimes
    the plugins that others have generously donated their time to make for the community
    don't quite cover all your bases. Generally, the more specific your monitoring
    requirements get, the less likely it is that there's a plugin available that does
    exactly what you need.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 即便有 Nagios 插件集中非常有用的标准插件，以及 Nagios Exchange 上大量可用的自定义插件，随着我们的监控设置变得更加精细，我们有时也会发现，某些服务或主机的某个属性我们希望进行检查，但似乎没有合适的插件可用。每个网络都是不同的，有时候其他人慷慨为社区制作的插件并不能完全覆盖你的需求。通常，监控需求越具体，可用的插件就越少，甚至没有一个插件能够完全满足你的要求。
- en: 'In this example, we''ll deal with a very particular problem that we''ll assume
    can''t be dealt with effectively by any known Nagios Core plugins, and we''ll
    write one ourselves using Perl. Here''s the example problem:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将处理一个非常具体的问题，我们假设这个问题无法通过任何已知的 Nagios Core 插件有效解决，因此我们将使用 Perl 编写一个插件来解决。下面是示例问题：
- en: Our Linux security team wants to be able to automatically check whether any
    of our servers are running kernels that have known exploits. However, they're
    not worried about every vulnerable kernel, only specific versions. They have provided
    us with the version numbers of three kernels having small vulnerabilities that
    they're not particularly worried about but that do need patching, and one they're
    extremely worried about.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Linux 安全团队希望能够自动检查我们的服务器是否运行着有已知漏洞的内核。然而，他们并不担心所有存在漏洞的内核，而是关注特定的版本。他们已经提供了三个内核的版本号，这些内核有一些小漏洞，虽然他们并不特别担心，但确实需要打补丁，还有一个内核是他们非常担心的。
- en: Let's say the minor vulnerabilities are in the kernels with version numbers
    `2.6.19`, `2.6.24`, and `3.0.1`. The serious vulnerability is in the kernel with
    version number `2.6.39`. Note that the version numbers in this case are arbitrary
    and don't necessarily reflect any real kernel vulnerabilities!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 假设小漏洞存在于版本号为 `2.6.19`、`2.6.24` 和 `3.0.1` 的内核中，而严重漏洞存在于版本号为 `2.6.39` 的内核中。请注意，这些版本号是任意的，并不一定反映任何真实的内核漏洞！
- en: The team could log in to all of the servers individually to check them, but
    the servers are of varying ages and access methods, and managed by different people.
    They would also have to check manually more than once, because it's possible that
    a naive administrator could upgrade to a kernel that's known to be vulnerable
    in an older release, and they also might want to add other vulnerable kernel numbers
    for checking later on.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 团队可以单独登录到所有服务器进行检查，但这些服务器的年龄和访问方式各不相同，由不同的人管理。他们还需要多次手动检查，因为有可能某个未经经验的管理员会升级到一个在旧版中已知存在漏洞的内核版本，而且他们可能还想以后添加其他受影响的内核版本进行检查。
- en: 'So, the team have asked us to solve the problem with Nagios Core monitoring,
    and we''ve decided the best way to do it is to write our own plugin, `check_vuln_kernel`,
    which checks the output of `uname` for a kernel version string, and then does
    the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，团队要求我们通过 Nagios Core 监控来解决问题，我们决定最好的解决方式是编写自己的插件 `check_vuln_kernel`，该插件检查
    `uname` 的输出中的内核版本字符串，然后执行以下操作：
- en: If it's one of the slightly vulnerable kernels, then it will return a `WARNING`
    state, so that we can let the security team know that they should address it when
    they're next able to.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是略微有漏洞的内核版本，它将返回一个 `WARNING` 状态，提醒我们安全团队在下次有时间时应当处理此问题。
- en: If it's the highly vulnerable kernel version, then it will return a `CRITICAL`
    state, so that the security team knows a patched kernel needs to be installed
    immediately.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是高度易受攻击的内核版本，它将返回一个 `CRITICAL` 状态，安全团队知道必须立即安装修补后的内核。
- en: If `uname` gives an error or output we don't understand, then it will return
    an `UNKNOWN` state, alerting the team to a bug in the plugin or possibly more
    serious problems with the server.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `uname` 给出了错误或我们无法理解的输出，它将返回一个 `UNKNOWN` 状态，提醒团队插件中可能存在错误或服务器可能存在更严重的问题。
- en: Otherwise, it returns an `OK` state, confirming that the kernel is not known
    to be a vulnerable one.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，它将返回一个 `OK` 状态，确认该内核版本没有已知漏洞。
- en: Finally, they want to be able to see at a glance in the Nagios Core monitoring
    what the kernel version is, and whether it's vulnerable or not.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，他们希望能够一目了然地在 Nagios Core 监控中看到内核版本，并判断它是否存在漏洞。
- en: For the purposes of this example, we'll only monitor the Nagios Core server
    itself, but via NRPE we'd be able to install this plugin on the other servers
    that require this monitoring, where they'll work just as well. You should see
    the *Monitoring local services on a remote machine with NRPE* recipe in [Chapter
    6](ch06.html "Chapter 6. Enabling Remote Execution"), *Enabling Remote Execution*
    to learn how to do this.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个示例的目的，我们只监控 Nagios Core 服务器本身，但通过 NRPE，我们可以在其他需要监控的服务器上安装这个插件，它们也能正常工作。你可以在[第6章](ch06.html
    "第6章：启用远程执行")的 *使用 NRPE 监控远程机器的本地服务* 中学习如何操作。
- en: 'While this problem is very specific, we''ll approach it in a very general way,
    which you''ll be able to adapt to any solution where it''s required for a Nagios
    plugin to:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个问题非常具体，我们将以一种非常通用的方式来处理它，你可以将这种方式适应到任何需要 Nagios 插件的解决方案中：
- en: Run a command and pull its output into a variable.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行命令并将其输出存储到变量中。
- en: Check the output for the presence or absence of certain patterns.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查输出中是否存在或不存在某些模式。
- en: Return an appropriate status based on those tests.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据这些测试返回适当的状态。
- en: All that means is that if you're able to do this, you'll be able to effectively
    monitor anything on a server from Nagios Core!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你能做到这一点，你将能够通过 Nagios Core 有效地监控服务器上的任何东西！
- en: Getting ready
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have a Nagios Core 3.0 or newer server running with a few hosts and
    services configured already. You should also already be familiar with the relationship
    between services, commands, and plugins. You should also have Perl installed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经有一个运行着的 Nagios Core 3.0 或更新版本的服务器，并且已经配置了一些主机和服务。你还应该熟悉服务、命令和插件之间的关系。你还需要安装
    Perl。
- en: 'This will be a rather long recipe that ties in a lot of Nagios Core concepts.
    You should be familiar with all the following concepts:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个相当长的教程，涵盖了许多 Nagios Core 的概念。你应该熟悉以下所有概念：
- en: Defining new hosts and services, and how they relate to one another
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义新主机和服务，以及它们之间的关系。
- en: Defining new commands, and how they relate to the plugins they call
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义新命令，以及它们如何与调用的插件相关联。
- en: Installing, testing, and using Nagios Core plugins
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装、测试和使用 Nagios Core 插件。
- en: Some familiarity with Perl would also be helpful, but is not required. We'll
    include comments to explain what each block of code is doing in the plugin.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Perl的基础知识也会有所帮助，但不是必需的。我们会在插件中包含注释，解释每一段代码的作用。
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We can write, test, and implement our example plugin as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式编写、测试并实现我们的示例插件：
- en: 'Change to the directory containing the plugin binaries for Nagios Core. The
    default location is `/usr/local/nagios/libexec`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到包含Nagios Core插件二进制文件的目录。默认位置是`/usr/local/nagios/libexec`：
- en: '[PRE33]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Start editing a new file called `check_vuln_kernel`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始编辑一个新的文件，名为`check_vuln_kernel`：
- en: '[PRE34]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Include the following code in it; take note of the comments, which explain
    what each block of code is doing:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中包含以下代码；请注意注释，它们解释了每一段代码的作用：
- en: '[PRE35]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Make the plugin owned by the `nagios` user and executable with `chmod`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使插件归`nagios`用户所有，并使用`chmod`命令使其可执行：
- en: '[PRE36]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We should now be able to use the plugin in a command, and hence in a service
    check, just like any other command. Note that the code for this plugin is included
    in the code bundle of this book for your convenience.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够像使用任何其他命令一样，在命令中使用该插件，从而在服务检查中使用它。请注意，本书的代码包中包含了该插件的代码，方便您参考。
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The code we added in the new plugin file `check_vuln_kernel` is actually quite
    simple:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在新插件文件`check_vuln_kernel`中添加的代码其实非常简单：
- en: It runs `uname -r` to get the version number of the kernel.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它运行`uname -r`来获取内核的版本号。
- en: If that didn't work, it exits with a status of `UNKNOWN`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这不起作用，它会以`UNKNOWN`状态退出。
- en: If the version number matches anything in a pattern containing critical version
    numbers, it exits with a status of `CRITICAL`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果版本号与包含关键版本号的模式匹配，它会以`CRITICAL`状态退出。
- en: If the version number matches anything in a pattern containing warning version
    numbers, it exits with a status of `WARNING`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果版本号与包含警告版本号的模式匹配，它会以`WARNING`状态退出。
- en: Otherwise, it exits with a status of `OK`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，它会以`OK`状态退出。
- en: It also prints the status as a string, along with the kernel version number,
    if it was able to retrieve one.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会打印状态作为字符串，并附带内核版本号，如果它能够成功获取的话。
- en: 'We might set up a command definition for this plugin as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会按如下方式为此插件设置命令定义：
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In turn, we might set up a service definition for that command as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，我们可能会按如下方式为该命令设置服务定义：
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If the kernel was not vulnerable, the service''s appearance in the web interface
    might look similar to the following screenshot:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内核没有漏洞，服务在Web界面中的显示可能类似于以下截图：
- en: '![How it works...](img/5566_02_05.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5566_02_05.jpg)'
- en: 'However, if the monitoring server itself happened to be running a vulnerable
    kernel, then it might look more similar to the following screenshot (and send
    consequent notifications, if configured to do so):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果监控服务器本身运行的是一个有漏洞的内核，那么它的显示可能更接近以下截图（并且如果配置了通知，它会发送后续通知）：
- en: '![How it works...](img/5566_02_06.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5566_02_06.jpg)'
- en: There's more...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This may be a simple plugin, but its structure can be generalized to all sorts
    of monitoring tasks. If we can figure out the correct logic to return the status
    we want in an appropriate programming language, then we can write a plugin to
    do basically anything.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个简单的插件，但它的结构可以泛化为各种监控任务。如果我们能找出正确的逻辑，在合适的编程语言中返回我们想要的状态，那么我们就可以编写一个插件，几乎做任何事情。
- en: A plugin like this could just as effectively be written in C for improved performance,
    but we'll assume for simplicity's sake that high performance for the plugin is
    not required. Instead, we can use a language that's better suited for quick ad
    hoc scripts like this one; in this case, we use Perl. The file `utils.sh`, also
    in `/usr/local/nagios/libexec`, allows us to write in shell script if we'd prefer
    that.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个插件同样可以用C语言编写，以提高性能，但为了简便起见，我们假设插件不需要高性能。相反，我们可以使用更适合快速临时脚本的语言；在这种情况下，我们使用Perl。文件`utils.sh`，也在`/usr/local/nagios/libexec`中，如果我们更喜欢，也允许我们使用Shell脚本编写。
- en: If you write a plugin that you think could be generally useful for the Nagios
    community at large, then please consider putting it under a free software license
    and submitting it to the Nagios Exchange, so that others can benefit from your
    work. Community contribution and support is what has made Nagios Core such a great
    monitoring platform in such wide use.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编写了一个插件，认为它对Nagios社区有普遍的使用价值，请考虑将其置于自由软件许可证下，并提交到Nagios Exchange，以便其他人也能从您的工作中受益。社区的贡献和支持使Nagios
    Core成为一个如此出色的监控平台，并在广泛使用中。
- en: Any plugin you publish in this way should conform to the Nagios Plugin Development
    Guidelines. At the time of writing, these are available at [http://nagiosplug.sourceforge.net/developer-guidelines.html](http://nagiosplug.sourceforge.net/developer-guidelines.html).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式发布的任何插件应该符合Nagios插件开发指南。在撰写本文时，这些指南可在[http://nagiosplug.sourceforge.net/developer-guidelines.html](http://nagiosplug.sourceforge.net/developer-guidelines.html)找到。
- en: Finally, you should note that the method of including `utils.pm`, used in this
    example, may be deprecated in future versions of Nagios Core. It is used here
    for simplicity's sake. The new method of including it in Perl is done with a CPAN
    module called `Nagios::Plugin`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您应该注意，示例中使用的`utils.pm`方法可能在未来版本的Nagios Core中被弃用。为了简便起见，这里使用了这种方法。新的包含方式是通过一个名为`Nagios::Plugin`的CPAN模块来实现的。
- en: See also
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Creating a new command* and *Customizing an existing command* recipes in
    this chapter
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*创建新命令*和*定制现有命令*食谱
- en: The *Creating a new service recipe* in [Chapter 1](ch01.html "Chapter 1. Understanding
    Hosts, Services, and Contacts"), *Understanding Hosts, Services, a**nd Contacts*
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*创建新服务食谱*，见[第1章](ch01.html "第1章. 理解主机、服务和联系人")，*理解主机、服务和联系人*
- en: The *Monitoring local services on a remote machine with NRPE* recipe in [Chapter
    6](ch06.html "Chapter 6. Enabling Remote Execution"), *Enabling Remote Execution*
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用NRPE监控远程机器上的本地服务*食谱，见[第6章](ch06.html "第6章. 启用远程执行")，*启用远程执行*
