- en: Chapter 8. Debugging SELinux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 SELinux 调试
- en: 'In this chapter, we will look at SELinux debugging through the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过以下方法来查看 SELinux 调试：
- en: Identifying whether SELinux is to blame
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定是否是 SELinux 导致的问题
- en: Analyzing SELINUX_ERR messages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析 SELINUX_ERR 消息
- en: Logging positive policy decisions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录积极的策略决策
- en: Looking through SELinux constraints
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 SELinux 限制
- en: Ensuring an SELinux rule is never allowed
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保 SELinux 规则永远不被允许
- en: Using strace to clarify permission issues
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 strace 来澄清权限问题
- en: Using strace against daemons
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对守护进程使用 strace
- en: Auditing system behavior
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计系统行为
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: On an SELinux-enabled system, the SELinux policy defines how applications should
    behave. Any change in behavior might trigger SELinux denials for certain actions
    of that application. As a result, end users can notice unexpected permission issues
    or erratic application behavior.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用 SELinux 的系统上，SELinux 策略定义了应用程序应如何行为。任何行为的改变可能会导致 SELinux 拒绝某些应用程序的操作。因此，最终用户可能会注意到意外的权限问题或异常的应用程序行为。
- en: 'Troubleshooting such situations is usually done through analysis of the AVC
    events. Many resources already cover AVC events in great detail. The basic premise
    is that an AVC event uses a set of key-value pairs, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此类问题通常通过分析 AVC 事件来完成。许多资源已经详细讨论了 AVC 事件。基本前提是，AVC 事件使用一组键值对，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, we can deduce the following from the AVC event:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以从 AVC 事件中推断出以下内容：
- en: 'The event is a denial (`avc: denied`)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '该事件是拒绝（`avc: denied`）'
- en: The operation that was denied is appending to a file (`{ append } … tclass=file`)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被拒绝的操作是追加到文件中（`{ append } … tclass=file`）
- en: The process that tried to append to the file has PID `1787` and name `syslog-ng`
    (`pid=1787 comm="syslog-ng"`)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试追加到文件的进程的 PID 为 `1787`，名称为 `syslog-ng`（`pid=1787 comm="syslog-ng"`）
- en: The process' context is `syslogd_t` (`scontext=system_u:system_r:syslogd_t:s0`)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程的上下文是 `syslogd_t`（`scontext=system_u:system_r:syslogd_t:s0`）
- en: The target file is called `oracle_audit.log` and has an inode number `65` on
    the filesystem, stored on the `/dev/dm-18` metadevice (`name="oracle_audit.log"
    dev=dm-18 ino=65`)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标文件名为 `oracle_audit.log`，并且在文件系统中的 inode 号为 `65`，存储在 `/dev/dm-18` 逻辑设备中（`name="oracle_audit.log"
    dev=dm-18 ino=65`）
- en: The file's context is `usr_t` (`tcontext=system_u:object_r:usr_t:s0`)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的上下文是 `usr_t`（`tcontext=system_u:object_r:usr_t:s0`）
- en: However, sometimes it isn't sufficient to find out where the problem is. Luckily,
    there are many more options available to debug the problem.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时仅仅找到问题的所在是不够的。幸运的是，调试问题还有许多其他选项。
- en: Identifying whether SELinux is to blame
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定是否是 SELinux 导致的问题
- en: Before blaming the SELinux subsystem and policies for a problem, it is important
    to verify whether SELinux is to blame at all. Too often, hours of troubleshooting
    are put in analyzing the SELinux policies and subsystem only to find out that
    the problem also persists when SELinux is not enabled.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在将问题归咎于 SELinux 子系统和策略之前，重要的是先验证 SELinux 是否真的导致了问题。过多时候，人们花费数小时分析 SELinux 策略和子系统，却最终发现当
    SELinux 未启用时，问题依然存在。
- en: How to do it…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In order to be confident that SELinux is (or isn''t) to blame, the following
    set of steps can be taken:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保 SELinux 是否（或不）是问题的根源，可以采取以下步骤：
- en: 'Is it possible to get more information through the application''s internal
    debugging system? Consider the following instance:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可以通过应用程序的内部调试系统获取更多信息？考虑以下示例：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Is an AVC denial related to the problem shown in the audit logs? If not, try
    disabling the `dontaudit` rules and try again:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AVC 拒绝是否与审计日志中显示的问题有关？如果没有，尝试禁用 `dontaudit` 规则并重新尝试：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Is the application that gives problems SELinux-aware? Most SELinux-aware applications
    are linked with the `libselinux.so` library, so we can verify whether this is
    the case using `ldd` or `scanelf`:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引发问题的应用程序是否支持 SELinux？大多数支持 SELinux 的应用程序会链接 `libselinux.so` 库，因此我们可以使用 `ldd`
    或 `scanelf` 来验证这是否为事实：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Is the issue login related? If so, an application might not be SELinux-aware
    but still behave differently, as it uses PAM under the hood, which calls the `pam_selinux.so`
    library.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题是否与登录相关？如果是，某些应用程序可能不支持 SELinux，但仍然会有所不同，因为它使用 PAM 底层库，该库调用 `pam_selinux.so`
    库。
- en: 'Does the problem still persist if the application domain is put in permissive
    mode? To check this, issue the following command:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果将应用程序域设置为宽容模式，问题是否仍然存在？要检查这一点，可以执行以下命令：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If the application domain is unknown, try putting the entire system in permissive
    mode (if allowed) to see whether the problem is still showing up. If it is, then
    SELinux might not be the cause after all:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用程序域名未知，可以尝试将整个系统置于宽容模式（如果允许的话），看看问题是否仍然存在。如果仍然存在，那么 SELinux 可能并不是问题的根源：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理……
- en: Ensuring that SELinux is the cause of a problem is the first step to enlightenment.
    Numerous hours of SELinux investigations to resolve issues are spent only to find
    out that the problem was not with SELinux to begin with.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 SELinux 是问题根源的第一步是领悟真相。许多用于调查 SELinux 问题的小时数，最终都发现问题根本就不在 SELinux 上。
- en: Getting more information from the application (or applications) involved is
    the first step to troubleshooting issues. Many applications have command-line
    flags that increase logging verbosity, and many daemons can be configured to log
    more of their inner workings. The resulting debug information (or even trace information,
    if the application supports it) will provide a massive help to the administrator
    to troubleshoot a problem.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 获取更多来自相关应用程序的信息是故障排除的第一步。许多应用程序都有命令行标志，可以增加日志的详细程度，许多守护进程也可以配置为记录更多的内部工作信息。由此产生的调试信息（或者如果应用程序支持，还可以是跟踪信息）将为管理员排查问题提供极大的帮助。
- en: If additional logging does not help, then it is important to verify whether
    there are AVC denials in the audit logs. As some AVC denials can be hidden during
    regular operations, disabling the `dontaudit` rules temporarily might be necessary.
    Don't stare blindly at AVC denials though, and take a broader look at logfiles
    and audit events. For instance, in the next recipe (*Analyzing SELINUX_ERR messages*),
    a more in-depth analysis of a particular audit event type is discussed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果额外的日志信息没有帮助，那么需要检查审计日志中是否有 AVC 拒绝信息。由于一些 AVC 拒绝信息在常规操作中可能会被隐藏，因此可能需要临时禁用 `dontaudit`
    规则。不过，不要盯着 AVC 拒绝信息不放，而是要广泛地查看日志文件和审计事件。例如，在下一章节（*分析 SELINUX_ERR 信息*）中，将讨论特定审计事件类型的更深入分析。
- en: Look through the various logs on the system as well. The output of `dmesg` is
    important if the problem is kernel, hardware, or core-system related. The `messages`
    logfile (in `/var/log/`) usually contains pointers when issues come up with system
    daemons.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，检查系统上的各种日志文件也很重要。如果问题与内核、硬件或核心系统相关，`dmesg` 的输出非常关键。`messages` 日志文件（位于 `/var/log/`
    中）通常会包含系统守护进程出现问题时的线索。
- en: When no denials are shown and there is no specific logging that can assist with
    the troubleshooting of an application, the next step is to assure ourselves that
    the application is not SELinux-aware.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有拒绝信息显示，并且没有可以协助故障排除的特定日志时，下一步是确保我们所使用的应用程序不是 SELinux 感知的。
- en: SELinux-aware applications (applications that know they run on an SELinux-enabled
    system and interact with the SELinux subsystem) can act differently based on the
    SELinux policy that is loaded, without actually triggering any SELinux decision
    in the SELinux subsystem. On account of their awareness, the in-kernel SELinux
    subsystem access controls might not be called, so no logging will be shown even
    though the problem is somewhat SELinux-related.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 感知的应用程序（知道它们运行在启用 SELinux 的系统上，并与 SELinux 子系统交互的应用程序）可以根据加载的 SELinux
    策略表现得不同，而无需实际触发 SELinux 子系统中的任何 SELinux 决策。由于它们的感知，内核中的 SELinux 子系统访问控制可能不会被调用，因此即使问题与
    SELinux 有关，也不会显示任何日志。
- en: 'Although there is not any 100 percent certain method to check whether an application
    is SELinux-aware, the two most common approaches are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有 100% 确定的方法来检查应用程序是否是 SELinux 感知的，但最常用的两种方法如下：
- en: Checking whether the application binary is linked with the `libselinux.so` library
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查应用程序的二进制文件是否与 `libselinux.so` 库链接
- en: Checking whether the application uses PAM
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查应用程序是否使用 PAM
- en: An application that is linked with the `libselinux.so` library is SELinux-aware
    and will be able to query SELinux policies, possibly acting differently when SELinux
    is enabled and often regardless of SELinux being in the enforcing or permissive
    mode.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序链接了`libselinux.so`库，那么它就是 SELinux 感知的，并且能够查询 SELinux 策略，可能会在 SELinux
    启用时表现不同，并且通常不管 SELinux 是否处于强制模式或宽容模式。
- en: 'Besides the `ldd` command, it is also possible to use the `scanelf` application
    as provided by the `pax-utils` package. This application does not need execute
    privileges against the binary (which `ldd` requires) but has the downside that
    it only shows the requirements for the binary, while `ldd` also includes the libraries
    linked by the libraries themselves:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `ldd` 命令，还可以使用 `pax-utils` 包提供的 `scanelf` 应用程序。该应用程序不需要对二进制文件具有执行权限（而 `ldd`
    命令需要），但缺点是它只显示二进制文件的需求，而 `ldd` 还会显示库本身所链接的库：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Applications that use PAM can also be influenced by SELinux, since their PAM
    configuration might call the `pam_selinux.so` library (or not call it, which can
    be equally damaging for the functionality of the application as no transition
    will occur then, having the user session still run with the context of the daemon).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PAM 的应用程序也可能受到 SELinux 的影响，因为它们的 PAM 配置可能调用 `pam_selinux.so` 库（或者不调用它，这同样会对应用程序功能产生影响，因为这样就不会发生转换，导致用户会话仍然以守护进程的上下文运行）。
- en: If the application does not interact with the SELinux subsystem to query the
    SELinux policy, and it also doesn't handle SELinux labels directly (that is, it
    has no knowledge of SELinux labels and does not actively work with them code-wise),
    then running the application in the permissive mode should show us whether SELinux
    is to blame. In the permissive mode, the SELinux subsystem access controls do
    not prevent any action. If a problem still persists in the permissive mode, chances
    are that SELinux is not to blame at all.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序没有与 SELinux 子系统交互以查询 SELinux 策略，并且它也没有直接处理 SELinux 标签（即它不知道 SELinux 标签并且没有在代码中主动与之交互），那么在宽容模式下运行应用程序应该能显示
    SELinux 是否是罪魁祸首。在宽容模式下，SELinux 子系统的访问控制不会阻止任何操作。如果问题在宽容模式下仍然存在，那么很可能不是 SELinux
    的问题。
- en: See also
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: More information about SELinux-aware applications and how to write one is covered
    in [Chapter 10](ch10.html "Chapter 10. Handling SELinux-aware Applications"),
    *Handling SELinux-aware Applications*
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 SELinux 兼容应用程序的信息以及如何编写此类应用程序，详见 [第10章](ch10.html "第10章 处理 SELinux 兼容应用程序")，*处理
    SELinux 兼容应用程序*
- en: Analyzing SELINUX_ERR messages
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析 SELINUX_ERR 消息
- en: When the SELinux subsystem is asked to perform an invalid SELinux-specific operation,
    it will log this through the audit subsystem using the `SELINUX_ERR` message type.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SELinux 子系统被要求执行一个无效的 SELinux 特定操作时，它会通过审计子系统记录此操作，使用 `SELINUX_ERR` 消息类型。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Make sure that the audit subsystem is up and running as we will be using the
    `ausearch` application to (re)view audit events:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 确保审计子系统已经启动并运行，因为我们将使用 `ausearch` 应用程序来（重新）查看审计事件：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How to do it…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Analyzing `SELINUX_ERR` messages is done by viewing the entry in the audit
    logs and understanding the individual fields; this is done by completing the following
    steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 分析 `SELINUX_ERR` 消息是通过查看审计日志中的条目并理解各个字段来完成的；可以按照以下步骤进行：
- en: 'Note the current date/time, or reload the SELinux policy, to have a clear point
    in the audit logs from where to look:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录当前的日期/时间，或者重新加载 SELinux 策略，以便在审计日志中清楚地标明从哪里开始查看：
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Trigger the behavior in the application.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序中触发该行为。
- en: 'Ask the audit subsystem to show the last events of the `SELINUX_ERR` and `MAC_POLICY_LOAD`
    types:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求审计子系统显示最后的 `SELINUX_ERR` 和 `MAC_POLICY_LOAD` 类型的事件：
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Look at the beginning of the message to find out what problematic situation
    SELinux is informing us about.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看消息的开头，了解 SELinux 通知我们什么问题。
- en: How it works…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The SELinux subsystem will log any incorrect request. If it is application behavior,
    it is usually logged through the AVC type; but when the request is SELinux-specific
    and incorrect, an `SELINUX_ERR` message type is displayed. In the example, we
    also looked for the `MAC_POLICY_LOAD` type, so we know at which stage the SELinux
    policy was reloaded, giving us a good starting point for the investigation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 子系统会记录任何不正确的请求。如果是应用程序行为，通常会通过 AVC 类型记录；但当请求是 SELinux 特有且不正确时，会显示 `SELINUX_ERR`
    消息类型。在此示例中，我们还查找了 `MAC_POLICY_LOAD` 类型，因此我们知道 SELinux 策略在何时重新加载，从而为调查提供了一个良好的起点。
- en: 'Some examples of the `SELINUX_ERR` messages are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 `SELINUX_ERR` 消息的示例：
- en: '`security_compute_sid`: Invalid context'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`security_compute_sid`: 无效的上下文'
- en: '`security_validate_transition`: Denied'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`security_validate_transition`: 拒绝'
- en: '`security_bounded_transition`: Denied'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`security_bounded_transition`: 拒绝'
- en: Some other messages exist as well, although these are mostly for SELinux-internal
    problems (related to the SELinux subsystem inside the Linux kernel, such as supported
    netlink types), which need to be resolved by the SELinux maintainers themselves,
    and not by policy developers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在一些其他消息，尽管这些消息主要与SELinux内部问题有关（与Linux内核中的SELinux子系统相关，例如支持的netlink类型），这些问题需要由SELinux维护者自行解决，而不是由策略开发者解决。
- en: Invalid contexts
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无效上下文
- en: 'An invalid context is triggered when a context that is not valid according
    to the RBAC and SELinux user rules is created. This is usually the case during
    a domain transition, where the target type is not allowed for the role:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在RBAC和SELinux用户规则不允许的情况下创建无效上下文时，会触发无效上下文。这通常发生在域转换期间，目标类型对于该角色不被允许的情况下：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Another reason for an invalid context can be that a role transition is triggered,
    but this role is not allowed for an SELinux user:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个无效上下文的原因可能是触发了角色转换，但此角色不允许SELinux用户：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In both cases, it is important to look at the presented context and the `scontext`
    and `tcontext` fields. These show the contexts that SELinux finds invalid (presented
    context) as well as the source (domain initiating the action) and the object context
    (label through which the new context was decided upon). Based on these, it should
    be fairly easy to deduce what the error is about.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，重要的是查看提供的上下文和`scontext`以及`tcontext`字段。这些字段显示了SELinux找到的无效上下文（提供的上下文），以及发起动作的源（启动动作的域）和对象上下文（决定新上下文的标签）。基于这些信息，应该很容易推断出错误的原因。
- en: 'The first example shows an attempt to transition from the `logwatch_t` domain
    (which is allowed for the `system_r` role) to the `logwatch_mail_t` domain (which
    is not allowed for the `system_r` role). To solve this, `logwatch_mail_t` needs
    to be allowed for the `system_r` role:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子展示了试图从允许`system_r`角色的`logwatch_t`域转换到不允许`system_r`角色的`logwatch_mail_t`域的尝试。要解决此问题，需要允许`logwatch_mail_t`角色给`system_r`角色：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The second example is triggered through a role transition. A database administrator
    launches an `init` script, resulting in the `dbadm_u:dbadm_r:initrc_t` context.
    This domain executes the `mysqld_safe` application (whose file is labeled `mysqld_safe_exec_t`)
    that, through the SELinux policy, attempts to perform a role transition to the
    `system_r` role. Although the `system_r:mysqld_safe_t` context is a valid set,
    the database administration user itself is not allowed the `system_r` role.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子是通过角色转换触发的。数据库管理员启动一个`init`脚本，导致`dbadm_u:dbadm_r:initrc_t`上下文。该域执行`mysqld_safe`应用程序（其文件标记为`mysqld_safe_exec_t`），通过SELinux策略尝试执行到`system_r`角色的角色转换。虽然`system_r:mysqld_safe_t`上下文是一个有效集合，但数据库管理用户本身不被允许`system_r`角色。
- en: The main issue in this second example is that the context to start from (`dbadm_u:dbadm_r:initrc_t`)
    shouldn't be used. The `initrc_t` domain should only be allowed for the `system_r`
    role. This, by itself, requires that the `dbadm_u` SELinux user is also allowed
    the `system_r` role. So, even though allowing the `system_r` role is the right
    resolution, the approach taken in the example is wrong (role transition from `initrc_t`
    to `mysqld_safe_t` instead of role transitioning upon instantiating `initrc_t`).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中的主要问题是不应该使用起始上下文（`dbadm_u:dbadm_r:initrc_t`）。`initrc_t`域应仅允许`system_r`角色。这本身要求`dbadm_u`
    SELinux用户也被允许`system_r`角色。因此，即使允许`system_r`角色是正确的解决方案，但示例中采取的方法是错误的（从`initrc_t`到`mysqld_safe_t`的角色转换，而不是在实例化`initrc_t`时进行角色转换）。
- en: Denied transition validation
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拒绝转换验证
- en: 'Consider the following error message, which came up when an `init` script tried
    to increase the sensitivity of a file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下错误消息，当一个`init`脚本尝试增加文件的敏感性时出现：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Such a message occurs when a file transition is performed, but where the target
    security context is not allowed. SELinux validates whether this is allowed; if
    not allowed, it logs this through the message.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行文件转换但目标安全上下文不被允许时，会出现这样的消息。SELinux验证其是否允许；如果不允许，则通过消息记录此情况。
- en: AVC-like denials will be in place here, but the access vector cache system is
    only able to validate pair-wise contexts (the source and target contexts), whereas
    the transition validation needs to be done on three levels (old file context,
    new file context, and process context).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: AVC类似的拒绝将在此处生效，但访问向量缓存系统仅能验证成对上下文（源和目标上下文），而转换验证需要在三个级别上进行（旧文件上下文、新文件上下文和进程上下文）。
- en: The solution for the presented error will be to either allow `initrc_t` to raise
    the security level of a file (through the `mls_file_upgrade` interface) or to
    not have the `init` script domain try to update the MLS level of a file in the
    first place.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此错误的方法是允许 `initrc_t` 提升文件的安全级别（通过 `mls_file_upgrade` 接口），或者干脆不让 `init` 脚本域尝试更新文件的
    MLS 等级。
- en: Denied security-bounded transitions
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 被拒绝的安全受限转换
- en: 'An example where security-bounded transitions occur is when the `mod_selinux`
    module is used with Apache (which uses bounded domains and transitions for individual
    requests). When the target domain is not bounded by the source domain (that is,
    the SELinux policy does not prevent the target domain from executing an action
    not allowed by the source domain, as done through the `typebounds` statement),
    then the following error is displayed:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个发生安全受限转换的示例是当 `mod_selinux` 模块与 Apache 一起使用时（Apache 使用受限域和转换来处理单个请求）。当目标域没有受到源域的限制（即，SELinux
    策略没有通过 `typebounds` 语句防止目标域执行源域未允许的操作）时，将显示以下错误：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When this occurs, a bounded transition is requested by the main application
    domain (such as when a transition is done for threads), but the target domain
    is not marked as a bounded domain.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，主应用程序域（例如当为线程进行转换时）请求受限转换，但目标域未标记为受限域。
- en: Note that this is different from when a bounded domain is given more privileges—in
    such cases, SELinux will deny the specific permissions when they are invoked,
    showing AVC denials.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这与给定受限域更多权限的情况不同——在这种情况下，当特定权限被调用时，SELinux 会拒绝这些权限，并显示 AVC 拒绝。
- en: There's more...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: SELinux logging and audit logging is continuously being improved. Work is on
    the way to make the audit logs easier to parse by scripts and to provide more
    information. For instance, at the time of writing, a patch has just been accepted
    to add permissive state information in the AVC logging.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 日志记录和审计日志记录正在不断改进。当前正在进行的工作包括使审计日志更易于通过脚本解析，并提供更多信息。例如，在写作时，已接受一个补丁，旨在在
    AVC 日志中添加宽松状态信息。
- en: See also
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'More in-depth analysis and explanation of AVC messages is handled in *SELinux
    System Administration*, *Packt Publishing*. More resources related to SELinux
    audit events are available at the following links:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对 AVC 消息的更深入分析和解释可以参考*SELinux 系统管理*，*Packt 出版社*。关于 SELinux 审计事件的更多资源可通过以下链接获取：
- en: '[http://www.selinuxproject.org/page/NB_AL](http://www.selinuxproject.org/page/NB_AL)
    (including an overview of all possible fields in AVC events)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.selinuxproject.org/page/NB_AL](http://www.selinuxproject.org/page/NB_AL)（包括
    AVC 事件中所有可能字段的概述）'
- en: '[https://wiki.gentoo.org/wiki/SELinux/Tutorials/Where_to_find_SELinux_permission_denial_details](https://wiki.gentoo.org/wiki/SELinux/Tutorials/Where_to_find_SELinux_permission_denial_details)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://wiki.gentoo.org/wiki/SELinux/Tutorials/Where_to_find_SELinux_permission_denial_details](https://wiki.gentoo.org/wiki/SELinux/Tutorials/Where_to_find_SELinux_permission_denial_details)'
- en: Logging positive policy decisions
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录正向策略决策
- en: On some occasions, the system performs actions that the administrator might
    not expect, but which are allowed by the SELinux policy, making it harder to debug
    potential problems. An application might be SELinux-aware, causing its own behavior
    to depend on the SELinux policy, without actually using the SELinux subsystem
    to enforce access. The SELinux policy might also be configured to behave differently
    than expected.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，系统执行的操作可能是管理员未预料到的，但这些操作是 SELinux 策略允许的，这使得调试潜在问题变得更加困难。某个应用程序可能是 SELinux-aware，导致其行为依赖于
    SELinux 策略，而实际上并未使用 SELinux 子系统来强制执行访问。SELinux 策略也可能配置为与预期不同的行为。
- en: In such situations, it might be important to have SELinux log activities that
    were actually allowed rather than denied; for instance, logging domain transitions
    to make sure that a transition has indeed occurred.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，记录实际上被允许的活动而不是被拒绝的活动可能很重要；例如，记录域转换以确保转换确实发生。
- en: How to do it…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'In order to have domain transitions logged, create an SELinux policy by performing
    the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记录域转换，按照以下步骤创建 SELinux 策略：
- en: Identify the source and target domains to look out for.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定需要关注的源域和目标域。
- en: 'Create an SELinux policy that calls the `auditallow` statement on the access
    vector we want to log:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 SELinux 策略，在我们想要记录的访问向量上调用`auditallow`语句：
- en: '[PRE15]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Build and load the SELinux policy and try to reproduce the situation.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并加载 SELinux 策略，尝试重现该情况。
- en: 'Look at the audit logs and check whether an AVC granted message is displayed:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看审计日志并检查是否显示了AVC授予消息：
- en: '[PRE16]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Of the many policy statements that SELinux supports, the `auditallow` statement
    is interesting and does not alter the decisions made by SELinux: having an `auditallow`
    statement does not allow the action, but rather has the SELinux subsystem log
    it if it is allowed (through another `allow` statement).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在SELinux支持的众多策略语句中，`auditallow`语句很有趣，并且不会改变SELinux做出的决策：拥有`auditallow`语句并不允许执行该操作，而是如果该操作被允许（通过另一个`allow`语句），则让SELinux子系统记录下来。
- en: This makes it possible for SELinux policy developers and system administrators
    to explicitly ask the SELinux subsystem to inform them about decisions taken if
    the decision is to grant something rather than deny.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得SELinux策略开发人员和系统管理员可以明确要求SELinux子系统在做出授予而非拒绝决策时通知他们。
- en: Using the `auditallow` statement, we can track SELinux policy decisions and
    assist in the development of policies and debugging of application behavior, especially
    when a process is invoked in a very short time frame, as this makes it difficult
    for administrators to see whether the context of the process is correct (`ps -Z`
    or by checking the `/proc/<pid>/` contexts).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`auditallow`语句，我们可以跟踪SELinux策略决策，并帮助开发策略和调试应用程序行为，特别是当一个进程在非常短的时间内被调用时，因为这会使管理员难以查看进程的上下文是否正确（可以通过`ps
    -Z`或者检查`/proc/<pid>/`的上下文来查看）。
- en: Some administrators might want to put in some additional logging inside the
    scripts or commands that they invoke (such as to capture the output of `id -Z`).
    However, it is very much possible that the SELinux policy does not allow the script
    to execute the `id` command, let alone show its output or direct its output to
    a specific logfile.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一些管理员可能希望在他们调用的脚本或命令中添加一些额外的日志记录（例如捕获`id -Z`的输出）。然而，SELinux策略可能不允许脚本执行`id`命令，更不用说显示其输出或将输出定向到特定日志文件。
- en: Enhancing the SELinux policy with additional log types, enabling terminal output,
    allowing the execution of binaries, and more is quite some overhead just to find
    out whether the context of the process is as it should be. Using the `auditallow`
    statement is a great solution to this.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为SELinux策略增加额外的日志类型、启用终端输出、允许执行二进制文件等，会带来一定的开销，仅仅为了确定进程的上下文是否正确。使用`auditallow`语句是一个很好的解决方案。
- en: 'It goes beyond domain transitions, of course. If a file has been changed, and
    the administrator or engineer is uncertain which process or which context is causing
    the change, then it is possible to have SELinux audit writes on the file label,
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它不仅限于域转换。如果一个文件被更改，且管理员或工程师不确定是哪个进程或哪个上下文导致了更改，那么可以在文件标签上启用SELinux审计写入，如下所示：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Thanks to the additional information in the AVC log, we can see which process
    (PID) running in a particular context (`scontext`) is responsible for writing
    to the file.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 借助AVC日志中的附加信息，我们可以看到在特定上下文（`scontext`）下运行的哪个进程（PID）负责向文件写入数据。
- en: Looking through SELinux constraints
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看SELinux约束
- en: Some denials are caused by SELinux constraints—additional restrictions imposed
    by the SELinux policy that are not purely based on the SELinux types, but also
    on the SELinux role and SELinux user. This is often not clear from the denial.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一些拒绝是由SELinux约束引起的——这些是由SELinux策略施加的额外限制，不仅仅基于SELinux类型，还基于SELinux角色和SELinux用户。这通常在拒绝信息中并不明确。
- en: 'The `audit2why` application helps in informing developers that a denial came
    from a constraint violation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`audit2why`应用程序有助于通知开发人员，拒绝是由于约束违规引起的：'
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is, however, not always the case, so we need to find a way to investigate
    whether denials come from constraint violations too.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并非总是如此，因此我们需要找到一种方法来调查拒绝是否也来源于约束违规。
- en: How to do it…
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Although SELinux constraints can be queried easily, they are currently difficult
    to work with. The following approach helps in validating whether a constraint
    is applicable for a particular AVC denial that is under investigation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SELinux约束可以很容易地查询，但目前它们仍然难以使用。以下方法有助于验证某个约束是否适用于正在调查的特定AVC拒绝：
- en: 'Look through the SELinux policy to see whether the (denied) access has an AVC
    allow rule or not:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看SELinux策略，查看被拒绝的访问是否有AVC允许规则：
- en: '[PRE19]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Assuming there is an allow rule, see whether there are constraints applicable
    to the operation. This takes into account the class (in the example, this is `file`)
    and the permission (in the example, this is `read`):'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设有一个允许规则，请查看是否有适用于该操作的约束。这考虑到类（在示例中为 `file`）和权限（在示例中为 `read`）：
- en: '[PRE20]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If constraints might exist, look at the attributes of the source and target
    contexts, as this is usually how constraints are documented in the policy:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可能存在约束，请查看源和目标上下文的属性，因为这通常是约束在策略中如何记录的方式：
- en: '[PRE21]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Inside the SELinux policy, look through the `constraints` file (usually at `${POLICY_LOCATION}/policy/`)
    and the `mcs` or `mls` file (if the policy uses MCS or MLS), and look for the
    constraints on the class and permission requested, validating whether there are
    any expressions concerning the attributes mentioned.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 SELinux 策略中，查看 `constraints` 文件（通常位于 `${POLICY_LOCATION}/policy/`），以及 `mcs`
    或 `mls` 文件（如果策略使用了 MCS 或 MLS），并检查请求的类和权限上的约束，验证是否有涉及所述属性的表达式。
- en: How it works…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Constraints are currently difficult to validate. Luckily, there aren't many
    constraints in place, but still, not being able to easily verify and look at the
    constraints is a nuisance for developers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 目前验证约束比较困难。幸运的是，目前约束不多，但无法轻松验证和查看约束对开发人员来说仍然是一个麻烦。
- en: 'The complexity increases as the `seinfo --constrain` output, which is the only
    available method to query constraints next to reading the sources, has the following
    drawbacks:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 `seinfo --constrain` 输出的增加（这是查询约束的唯一可用方法，除非读取源代码），复杂性也随之增加，`seinfo --constrain`
    输出有以下几个缺点：
- en: It does not provide any name yet on the constraints (so referring to constraints
    is difficult)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前尚未提供有关约束的任何名称（因此很难引用约束）
- en: It uses **Reverse Polish Notation** (**RPN**), which isn't very user-friendly
    (although it is powerful for computers, people do not generally read RPN fluently)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用 **逆波兰表示法** (**RPN**)，这对用户并不友好（尽管对于计算机非常强大，但人们通常不擅长流利地阅读 RPN）
- en: It shows expanded attributes, so we get huge lists of types, rather than a limited
    set of attributes
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它显示了扩展的属性，因此我们得到的是类型的大量列表，而不是有限的一组属性
- en: 'The constraint definitions inside the `constraints`, `mcs`, and `mls` files
    (which are only accessible through the policy source code) are easier to look
    at. The following example is from the `constraints` file; constraints from `mcs`
    and `mls` will use the `mlsconstrain` keyword:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`constraints`、`mcs` 和 `mls` 文件中的约束定义（这些文件仅通过策略源代码访问）更容易查看。以下示例来自 `constraints`
    文件；`mcs` 和 `mls` 文件中的约束将使用 `mlsconstrain` 关键字：'
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The controls shown use attributes, which are easier to map with a specific situation.
    It also shows how flexible constraints can be. Next to pure type-oriented rules
    (`t1` and `t2`), constraints also work with roles (`r1` and `r2`) and can deal
    with SELinux users (`u1` and `u2`). The number is used to differentiate between
    the subject (`1`) and object (`2`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所展示的控制使用属性，这些属性更容易与特定情况匹配。它还展示了约束的灵活性。除了纯粹的面向类型的规则（`t1` 和 `t2`）外，约束还可以与角色（`r1`
    和 `r2`）一起使用，并且能够处理 SELinux 用户（`u1` 和 `u2`）。数字用于区分主体（`1`）和对象（`2`）。
- en: 'As an example, in constraint language, saying that something is allowed if
    the SELinux users are equal, or the SELinux user of the subject is `system_u`,
    will be documented as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在约束语言中，如果 SELinux 用户相等，或者主题的 SELinux 用户是 `system_u`，则允许某些操作，文档中将如下记录：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The output of the `seinfo --constrain` command has the advantage that it is
    easy for computer programs to interpret. Computer programs or scripts, which use
    the output of `seinfo` to visualize constraint information in a tree-like manner,
    can be created.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`seinfo --constrain` 命令的输出具有一个优点，即计算机程序容易解析。可以编写计算机程序或脚本，使用 `seinfo` 的输出以树状结构的方式可视化约束信息。'
- en: 'The following GraphViz-generated graph shows the UBAC constraints applicable
    to file reads, showing only the user domains and the `user_home_t` types (to not
    overload the graph):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下由 GraphViz 生成的图展示了适用于文件读取的 UBAC 约束，仅显示用户域和 `user_home_t` 类型（以免图表过于繁杂）：
- en: '![How it works…](img/9669OS_08_01.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/9669OS_08_01.jpg)'
- en: 'This graph shows how the UBAC constraints are constructed. File reads are prohibited
    (regardless of the type enforcement rules that are made in the policy), unless
    they match one of the rules shown in the graph, which are as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了如何构建 UBAC 约束。文件读取是被禁止的（无论政策中制定了什么类型的强制规则），除非它们与图中显示的某一规则匹配，规则如下：
- en: The SELinux user of the subject (domain) and object (resource) are the same
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该主题（域）和对象（资源）的 SELinux 用户相同
- en: The SELinux user of the subject is `system_u`
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该主题的 SELinux 用户是 `system_u`
- en: The SELinux user of the object is `system_u`
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该对象的 SELinux 用户是 `system_u`
- en: The SELinux type of the subject does not match any of the mentioned types (only
    a subset is shown in the drawing)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该主题的 SELinux 类型与任何提到的类型不匹配（图示中仅显示了一个子集）
- en: The SELinux type of the object does not match any of the mentioned types (only
    a subset is shown in the drawing)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该对象的 SELinux 类型与任何提到的类型不匹配（图示中仅显示了一个子集）
- en: The SELinux type of the subject is `sysadm_t`
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该主题的 SELinux 类型是 `sysadm_t`
- en: See also
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'More information on SELinux constraints can be found at the following resources:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 SELinux 约束的信息可以在以下资源中找到：
- en: '[https://wiki.gentoo.org/wiki/SELinux/Constraints](https://wiki.gentoo.org/wiki/SELinux/Constraints)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://wiki.gentoo.org/wiki/SELinux/Constraints](https://wiki.gentoo.org/wiki/SELinux/Constraints)'
- en: '[http://www.selinuxproject.org/page/ConstraintStatements](http://www.selinuxproject.org/page/ConstraintStatements)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.selinuxproject.org/page/ConstraintStatements](http://www.selinuxproject.org/page/ConstraintStatements)'
- en: Ensuring an SELinux rule is never allowed
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保 SELinux 规则永远不被允许
- en: It is possible to include statements in the SELinux policy that ensure that
    a particular access vector cannot be allowed, not even by enhancing the SELinux
    policy later. This is done with the `neverallow` statement.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 SELinux 策略中包含一些声明，确保某个特定的访问向量无法被允许，即使以后通过增强 SELinux 策略也无法实现。这是通过 `neverallow`
    声明来完成的。
- en: How to do it…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To include the `neverallow` statements in the policy and enforce them, go through
    the following steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `neverallow` 声明包含到策略中并执行它们，请按照以下步骤操作：
- en: 'In `/etc/selinux/semanage.conf`, enable support for the `neverallow` statements
    by setting the `expand-check` variable to `1`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/etc/selinux/semanage.conf` 中，通过将 `expand-check` 变量设置为 `1`，启用对 `neverallow`
    声明的支持：
- en: '[PRE24]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create an SELinux policy in which the access vectors that should be explicitly
    forbidden are listed. Consider the following instance:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 SELinux 策略，列出应显式禁止的访问向量。考虑以下实例：
- en: '[PRE25]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Build and load the policy.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并加载策略。
- en: 'Generate another policy that will allow the statement and attempt to load it:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成另一个策略，允许该声明并尝试加载它：
- en: '[PRE26]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Not all distributions enable the assertion checks by default as they incur
    some performance penalty during policy builds. Some distributions might even have
    policy incompatibilities due to this, because if the assertions are disabled,
    then the `neverallow` statements are never processed: the `neverallow` statement
    isn''t really a policy decision, but more a rule that influences loading of new
    policies, and is enforced by the policy linker (which combines the various policy
    modules in one final policy binary). As can be deduced from the (failure) output,
    the `neverallow` statements are implemented as assertions.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有发行版默认启用断言检查，因为它们在策略构建过程中会带来一些性能损失。有些发行版可能会因为此问题而存在策略不兼容性，因为如果禁用断言，则 `neverallow`
    声明将永远不会被处理：`neverallow` 声明实际上不是一个策略决定，而更像是一个影响新策略加载的规则，它由策略链接器强制执行（策略链接器将不同的策略模块合并为最终的策略二进制文件）。从（失败的）输出可以推断出，`neverallow`
    声明作为断言实现。
- en: 'Some `neverallow` statements are available as part of the base policy. For
    instance, the following statement ensures that only the domains with the `selinux_unconfined_type`
    or `can_load_policy` attribute set can actually load an SELinux policy:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 `neverallow` 声明作为基础策略的一部分是可用的。例如，以下声明确保只有具有 `selinux_unconfined_type` 或 `can_load_policy`
    属性的域才能实际加载 SELinux 策略：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This example uses the negation operator (`~`), which means *all types except
    those mentioned*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用了否定运算符（`~`），表示 *除非提到的那些类型之外的所有类型*。
- en: Unlike constraints (that can also be used to implement restrictions), the `neverallow`
    statements help by not accepting any policy that will violate the rule. It is
    also possible to add the `neverallow` rules through modules, unlike constraints
    that need to be part of the base SELinux policy (and as such, are governed by
    Linux distribution, an upstream policy, or developers that manage complete policies
    rather than individual SELinux policy modules).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与约束（也可以用于实现限制）不同，`neverallow` 声明通过不接受任何违反规则的策略来提供帮助。通过模块也可以添加 `neverallow` 规则，这与约束不同，后者必须是基础
    SELinux 策略的一部分（因此受 Linux 发行版、上游策略或管理完整策略的开发人员的控制，而不是单个 SELinux 策略模块）。
- en: The `expand-check` variable in `/etc/selinux/semanage.conf` tells the SELinux
    user space libraries that the assertion has to be checked. If this variable is
    set to `0`, then the `neverallow` statements have no impact on the policy and
    its loading whatsoever.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/selinux/semanage.conf` 中的 `expand-check` 变量告诉 SELinux 用户空间库需要检查该断言。如果该变量设置为
    `0`，则 `neverallow` 语句将对策略及其加载没有任何影响。'
- en: Using strace to clarify permission issues
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `strace` 来澄清权限问题
- en: The `strace` application is a popular debugging application on Linux systems.
    It allows developers and administrators to look at various system calls made by
    an application. As SELinux often has access controls on specific system calls,
    using `strace` can prove to be very useful in debugging permission issues.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`strace` 应用程序是 Linux 系统上一个流行的调试工具。它允许开发人员和管理员查看应用程序发出的各种系统调用。由于 SELinux 通常对特定的系统调用有访问控制，使用
    `strace` 在调试权限问题时会非常有用。'
- en: How to do it…
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To properly use `strace`, follow the next set of steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用 `strace`，请按照以下步骤操作：
- en: 'Enable the `allow_ptrace` Boolean:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用 `allow_ptrace` 布尔值：
- en: '[PRE28]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the application with `strace`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `strace` 运行应用程序：
- en: '[PRE29]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the resulting logfile, look for the error message that needs to be debugged.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生成的日志文件中，查找需要调试的错误信息。
- en: How it works…
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `allow_ptrace` Boolean (on some distributions, the inverse Boolean called
    `deny_ptrace` is available) needs to be toggled so that the domain that calls
    `strace` can use `ptrace` (the method that `strace` uses to view system calls)
    against the target domain. As the `ptrace` method can be a security concern (it
    allows reading target process' memory, for instance), it is, by default, disabled.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 需要切换 `allow_ptrace` 布尔值（在某些发行版中，也提供反向布尔值 `deny_ptrace`），使得调用 `strace` 的域可以对目标域使用
    `ptrace`（`strace` 用于查看系统调用的方法）。由于 `ptrace` 方法可能会成为安全隐患（例如，它允许读取目标进程的内存），因此默认情况下是禁用的。
- en: 'Once an application has been executed through the `strace` application, the
    logfile will contain all relevant system call information. Of course, on larger
    applications, or on daemons, this logfile can become massive, so it makes sense
    to limit the `strace` operation towards a particular subset of system calls, as
    shown in the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序通过 `strace` 启动，日志文件将包含所有相关的系统调用信息。当然，对于较大的应用程序或守护进程，日志文件可能会变得非常庞大，因此限制
    `strace` 操作仅针对特定的系统调用子集是有意义的，如下命令所示：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, only the `open` and `access` system calls are looked at.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，仅查看 `open` 和 `access` 系统调用。
- en: 'In the resulting logfile, the SELinux permission usually issues results in
    failed system calls with an `EACCES (Permission denied)` error code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的日志文件中，SELinux 权限通常会导致系统调用失败，并显示 `EACCES (Permission denied)` 错误代码：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Although an AVC denial will also be shown for most accesses, these denials often
    do not give a complete picture as to at what stage a denial is in. By using `strace`,
    we can follow the logic that the application performs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数访问会显示 AVC 拒绝，但这些拒绝通常无法全面说明拒绝发生的阶段。通过使用 `strace`，我们可以跟踪应用程序执行的逻辑。
- en: Sometimes, it isn't obvious why a failure occurs. In this case, it might be
    interesting to run the application twice—once in enforcing mode and once in permissive
    mode—and look at the differences in the `strace` logs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，错误发生的原因并不明显。在这种情况下，可能需要分别在强制模式和宽松模式下运行应用程序，并查看 `strace` 日志中的差异。
- en: Using strace against daemons
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `strace` 调试守护进程
- en: 'The `strace` application not only makes sense for command-line applications
    but also for daemons. A popular approach to debugging daemons is to start them
    from the command line, possibly with a specific debug flag, so that the daemon
    doesn''t detach and run in the background. However, this is often not possible
    on SELinux: the policy will not allow the daemon to run as a command-line foreground
    process.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`strace` 应用程序不仅适用于命令行应用程序，也适用于守护进程。调试守护进程的一种常见方法是从命令行启动它们，可能带有特定的调试标志，这样守护进程就不会分离并在后台运行。然而，在
    SELinux 上通常无法做到这一点：策略不允许守护进程作为命令行前台进程运行。'
- en: How to do it…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The approach to use `strace` against daemons is similar as with command lines,
    focusing on the process ID rather than the command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `strace` 调试守护进程的方法与调试命令行相似，重点是进程 ID 而不是命令：
- en: 'Find out what the process ID of the daemon is:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找守护进程的进程 ID：
- en: '[PRE32]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Use `strace` to attach to the running process:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `strace` 附加到正在运行的进程：
- en: '[PRE33]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Specify which system calls to watch out for. For instance, permission issues
    while binding or connecting to ports or sockets can be filtered as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定要监视的系统调用。例如，绑定或连接端口或套接字时的权限问题可以按如下方式进行过滤：
- en: '[PRE34]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Press *Ctrl* + *C* to interrupt the `strace` session; don't worry, the daemon
    will continue to run in the background, unharmed.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl* + *C*中断`strace`会话；不用担心，守护进程会继续在后台运行，不会受到影响。
- en: How it works…
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'A popular approach to debugging daemons, which is to start the daemon in the
    foreground from the command line, often does not work on SELinux systems:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的调试守护进程的方法是从命令行将守护进程启动到前台，但在SELinux系统上通常不起作用：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If a user has the rights to execute the daemon binary directly (which isn't
    default either), then the daemon usually runs with the permissions of the user
    domain—who hardly has the privileges needed to run the daemon—as there is no transition
    from the user domain to the daemon domain.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户有权直接执行守护进程二进制文件（这通常不是默认设置），则守护进程通常会以用户域的权限运行——而用户域通常没有执行守护进程所需的权限——因为没有从用户域到守护进程域的过渡。
- en: By using `strace` against the daemons, it is possible to debug them in more
    detail. The `strace` application will bind to the process (using the `ptrace`
    method) and be notified of every system call that the daemon performs. The `-f`
    option also ensures that new processes that the daemon launches (for instance,
    worker processes) are also looked at by `strace`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`strace`对守护进程进行调试，可以更详细地调试它们。`strace`应用程序会绑定到进程（使用`ptrace`方法），并通知守护进程执行的每一个系统调用。`-f`选项还确保守护进程启动的新进程（例如，工作进程）也会被`strace`监控。
- en: To end the `strace` session, it is enough to kill the `strace` session or interrupt
    it with *Ctrl* + *C*. The daemon itself is left untouched.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要结束`strace`会话，只需杀死`strace`会话或通过*Ctrl* + *C*中断它即可。守护进程本身不会受到影响。
- en: There's more...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Many other system analysis tools, which can be used in a very similar manner,
    exist. Some examples are SystemTap and Sysdig, with a port of DTrace to Linux
    being actively developed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他系统分析工具，可以以类似的方式使用。例如，SystemTap和Sysdig，以及正在积极开发的Linux版本的DTrace。
- en: See also
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'The following resources cover the use of `strace`, SystemTap, and Sysdig in
    more detail:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源更详细地介绍了`strace`、SystemTap和Sysdig的使用：
- en: '[http://www.dedoimedo.com/computers/strace.html](http://www.dedoimedo.com/computers/strace.html)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.dedoimedo.com/computers/strace.html](http://www.dedoimedo.com/computers/strace.html)'
- en: '[http://www.thegeekstuff.com/2011/11/strace-examples/](http://www.thegeekstuff.com/2011/11/strace-examples/)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.thegeekstuff.com/2011/11/strace-examples/](http://www.thegeekstuff.com/2011/11/strace-examples/)'
- en: '[http://www.sourceware.org/systemtap/](http://www.sourceware.org/systemtap/)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.sourceware.org/systemtap/](http://www.sourceware.org/systemtap/)'
- en: '[http://www.sysdig.org/wiki/](http://www.sysdig.org/wiki/)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.sysdig.org/wiki/](http://www.sysdig.org/wiki/)'
- en: Auditing system behavior
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审计系统行为
- en: Another approach to debugging application behavior is through Linux auditing,
    especially when it is not clear which process is responsible for performing a
    specific action, as this might make SELinux development a lot more difficult.
    When developers do not know which domain(s) they need to update privileges for,
    or do not know how exactly a resource is created, then the Linux audit subsystem
    can help.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种调试应用程序行为的方法是通过Linux审计，尤其是在不清楚哪个进程负责执行特定操作时，因为这可能会使SELinux开发变得更加困难。当开发人员不知道需要为哪些域更新权限，或者不清楚如何创建资源时，Linux审计子系统可以提供帮助。
- en: With the Linux auditing subsystem, administrators can enable rules to log activities.
    In the audit log, the SELinux context of the subject (process) is shown as well,
    allowing SELinux developers to properly identify the domain to work with.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Linux审计子系统，管理员可以启用规则来记录活动。在审计日志中，还会显示主题（进程）的SELinux上下文，从而使SELinux开发人员能够正确地识别需要操作的域。
- en: How to do it…
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Let''s look at how we can ask the Linux audit subsystem which process is responsible
    for creating a particular directory in a user''s home directory through the following
    steps:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何通过以下步骤询问Linux审计子系统，哪个进程负责在用户的主目录中创建特定的目录：
- en: 'As the root Linux user (and in an SELinux role with sufficient privileges),
    tell the audit subsystem to log all write- and attribute-changing operations inside
    the user''s home directory:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为root Linux用户（并且在具有足够权限的SELinux角色下），告诉审计子系统记录所有写入和属性更改操作，尤其是在用户的主目录中：
- en: '[PRE36]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Perform the necessary action(s) to trigger the behavior that needs to be debugged.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行必要的操作来触发需要调试的行为。
- en: 'Query the audit subsystem for the recent audit events with the `policydev`
    key:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`policydev`键查询审计子系统中的最近审计事件：
- en: '[PRE37]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Later, disable the audit rule again so that the audit logs are not cluttered
    with development-related events:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 后来，再次禁用审计规则，以防审计日志被与开发相关的事件弄得杂乱无章：
- en: '[PRE38]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The Linux audit subsystem uses audit rules to identify which activities need
    to be logged to the audit log. The rules can be manipulated using the `auditctl`
    command (audit control).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Linux审计子系统使用审计规则来识别哪些活动需要记录到审计日志中。可以使用`auditctl`命令（审计控制）来操作这些规则。
- en: In our example, a rule was added for the `/home/john/` path (`-w /home/john`)
    for which the write and attribute changes (`-p wa`) are logged. The events are
    tagged, so to speak, with a key called `policydev`. Administrators can choose
    this key freely. Its purpose is to structure audit events and simplify search
    queries.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，添加了一个针对`/home/john/`路径的规则（`-w /home/john`），用于记录写入和属性变化（`-p wa`）。事件会被标记，所谓的标记是一个名为`policydev`的键。管理员可以自由选择这个键，它的目的是构建审计事件并简化搜索查询。
- en: 'When the `auditctl` command is invoked, the rule is immediately active, so
    after executing the test, audit events will be displayed as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`auditctl`命令时，规则立即生效，因此在执行测试后，审计事件会显示如下：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The logs show that it is a `java` process that is responsible for creating a
    directory called `.dcinforc/` in the user's home directory. The important fields
    to consider here are the `nametype=CREATE` (which tells us that an object was
    created) and `syscall=83` (informing us which system call was trapped by the audit
    subsystem—in this case, the `mkdir` system call) fields, and of course the `subj=`
    and `obj=` parameters.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 日志显示，负责在用户主目录下创建名为`.dcinforc/`的目录的是一个`java`进程。这里需要考虑的重要字段是`nametype=CREATE`（告诉我们创建了一个对象）和`syscall=83`（告诉我们审计子系统捕获到的系统调用——在这种情况下是`mkdir`系统调用）字段，当然，还有`subj=`和`obj=`参数。
- en: 'From the example, we can see that there are two distinct `obj=` parameters:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例中，我们可以看到有两个不同的`obj=`参数：
- en: The first, `obj=user_u:object_r:user_home_t:s0`, is mentioned for the created
    directory, and it tells us what label the newly created directory received
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个，`obj=user_u:object_r:user_home_t:s0`，是针对已创建目录提到的，它告诉我们新创建的目录接收到的标签是什么。
- en: The second, `obj=user_u:object_r:user_home_dir_t:s0`, is mentioned for the parent
    directory (`nametype=PARENT`), informing us what the label of the directory in
    which `.dcinforc/` is created is
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个，`obj=user_u:object_r:user_home_dir_t:s0`，是针对父目录（`nametype=PARENT`）提到的，告诉我们`.dcinforc/`目录所在的目录标签是什么。
- en: Now, this is just an example of creating directories, but the audit system can
    trap many types of activities. This is where the `syscall=` field becomes important.
    This field tells us what specific system call was trapped and logged by the audit
    subsystem.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这只是创建目录的一个示例，但审计系统可以捕获许多类型的活动。这时，`syscall=`字段就变得非常重要。这个字段告诉我们审计子系统捕获并记录的具体系统调用是什么。
- en: 'A list of system calls and their associated numbers can be found in the proper
    `C` header file. For instance, the `/usr/include/asm/unistd_64.h` file (referenced
    indirectly through `/usr/include/syscalls.h`) contains the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在相应的`C`头文件中找到系统调用及其关联的编号。例如，`/usr/include/asm/unistd_64.h`文件（通过`/usr/include/syscalls.h`间接引用）包含以下代码：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Through this, we know that the directory was created using the `mkdir` system
    call and not by any other means (such as creating the directory as a different
    one first and then renaming it).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一点，我们知道该目录是通过`mkdir`系统调用创建的，而不是通过其他方式（例如，先创建一个不同的目录然后重命名）。
- en: There's more...
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: The audit subsystem receives the rules it needs to follow up on at boot. Most
    Linux distributions offer a file called `audit.rules` inside `/etc/audit/`, which
    contains various commands, locations, and system calls that need to be trapped
    and logged. This file is then read at boot time by the audit daemon `init` script.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 审计子系统在启动时接收需要跟踪的规则。大多数Linux发行版在`/etc/audit/`目录下提供一个名为`audit.rules`的文件，其中包含了需要被捕获和记录的各种命令、位置和系统调用。然后，审计守护进程的`init`脚本会在启动时读取这个文件。
- en: If we need to have certain rules loaded automatically—and not just for the duration
    of a short test—then it is recommended to add the rules to this `audit.rules`
    script, together with the appropriate comment explaining why this needs to be
    trapped.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要自动加载某些规则——而不仅仅是进行短期测试的时间——那么建议将这些规则添加到`audit.rules`脚本中，并附上适当的注释说明为何需要进行跟踪。
- en: 'Now, we only used path-based auditing capabilities in the example. The Linux
    audit subsystem, however, can do much more than just that. For instance, it is
    possible to audit particular system calls. This allows administrators to keep
    a close eye on suspicious system call usages, such as the use of `unshare` (which
    is used for Linux namespaces):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只是在示例中使用了基于路径的审计功能。然而，Linux 审计子系统可以做的远不止于此。例如，可以审计特定的系统调用。这使管理员能够密切关注可疑的系统调用使用，比如使用`unshare`（用于Linux命名空间）：
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: See also
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: A good set of default audit rules to work with is mentioned in the CISecurity
    Benchmark for Red Hat Enterprise Linux, available at [https://benchmarks.cisecurity.org/](https://benchmarks.cisecurity.org/)
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适合使用的一套默认审计规则已在《Red Hat企业版Linux的CIS安全基准》中提到，详情请见[https://benchmarks.cisecurity.org/](https://benchmarks.cisecurity.org/)
