- en: '*Chapter 5*: Understanding and Leveraging the Device Tree'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：理解和利用设备树'
- en: The device tree is an easy-to-read hardware description file, with a JSON-like
    formatting style. It is a simple tree structure where devices are represented
    by nodes and their properties. These properties can either be empty (that is,
    just the key to describe Boolean values) or key-value pairs, where the value can
    contain an arbitrary byte stream. This chapter is a simple introduction to device
    trees. Every kernel subsystem or framework has its own device tree binding, and
    we will talk about those specific bindings when we deal with the relevant topics.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树是一个易于阅读的硬件描述文件，具有类似JSON的格式风格。它是一个简单的树形结构，其中设备通过节点及其属性表示。这些属性可以为空（即仅通过键描述布尔值），也可以是键值对，其中值可以包含任意字节流。本章是设备树的简要介绍。每个内核子系统或框架都有其自己的设备树绑定，我们将在处理相关主题时讨论这些特定的绑定。
- en: 'The device tree originated from **Open Firmware** (**OF**), which is a standard
    endorsed by computer companies, and whose main purpose is to define interfaces
    for computer firmware systems. That said, you can find out more about device tree
    specification at [http://www.devicetree.org/](http://www.devicetree.org/). Therefore,
    this chapter will cover the basics of the device tree, including the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树起源于**Open Firmware**（**OF**），这是一个计算机公司支持的标准，其主要目的是定义计算机固件系统的接口。也就是说，你可以在[http://www.devicetree.org/](http://www.devicetree.org/)了解更多关于设备树规范的信息。因此，本章将介绍设备树的基础知识，包括以下内容：
- en: Understanding the basic concept of the device tree mechanism
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解设备树机制的基本概念
- en: Describing data types and their APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述数据类型及其API
- en: Representing and addressing devices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示和访问设备
- en: Handling resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理资源
- en: Understanding the basic concept of the device tree mechanism
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解设备树机制的基本概念
- en: 'The support of the device tree is enabled in the kernel by setting the `CONFIG_OF`
    option to `Y`. To pull the device tree API from your driver, you must add the
    following headers:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树的支持在内核中通过将`CONFIG_OF`选项设置为`Y`来启用。要从驱动程序中调用设备树API，必须添加以下头文件：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The device tree supports a few data types and writing conventions that we can
    summarize with a sample node description:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树支持一些数据类型和写作约定，我们可以通过一个示例节点描述来总结：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, `int-list-property` is a property where each number
    (or cell) is a 32-bit integer (`uint32`), and there are three cells in this property.
    Here, `mixed-list-property` is, as its name suggests, a property with mixed element
    types.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`int-list-property`是一个属性，其中每个数字（或单元）是一个32位整数（`uint32`），该属性包含三个单元。这里，`mixed-list-property`顾名思义，是一个具有混合元素类型的属性。
- en: 'The following are some definitions of the data types used in the device tree:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是设备树中使用的一些数据类型的定义：
- en: Text strings are represented with double quotes. You can use commas to create
    a list of the strings.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本字符串用双引号表示。你可以使用逗号来创建字符串的列表。
- en: Cells are 32-bit unsigned integers delimited by angle brackets.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元是由尖括号括起来的32位无符号整数。
- en: Boolean data is nothing more than an empty property. The true or false value
    depends on the property being there or not.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔数据不过是一个空属性。其真假值取决于该属性是否存在。
- en: We have easily enumerated the types of data that can be found in the device
    tree. Before we start learning about the APIs that can be used to parse this data,
    first, let's understand how the device tree naming convention works.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经轻松列举了可以在设备树中找到的数据类型。在开始学习可以用来解析这些数据的API之前，首先让我们了解一下设备树的命名约定是如何工作的。
- en: The device tree naming convention
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备树命名约定
- en: Every node must have a name in the form of `<name>[@<address>]`, where `<name>`
    is a string that can be up to 31 characters in length, and `[@<address>]` is optional,
    depending on whether the node represents an addressable device or not. That said,
    `<address>` should be the primary address used to access the device. For example,
    for a memory-mapped device, it must correspond to the starting address of its
    memory region, the bus device address for an I2C device, and the chip-select index
    (relative to the controller) for an SPI device node.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点必须有一个形式为`<name>[@<address>]`的名称，其中`<name>`是一个最长为31个字符的字符串，`[@<address>]`是可选的，取决于该节点是否表示一个可寻址的设备。也就是说，`<address>`应该是用来访问设备的主要地址。例如，对于一个内存映射设备，它必须对应其内存区域的起始地址，I2C设备的总线设备地址，和SPI设备节点的芯片选择索引（相对于控制器）。
- en: 'The following presents some examples of device naming:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些设备命名的示例：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding device tree excerpt, the I2C controller is a memory-mapped
    device. Therefore, the address part of the node name corresponds to the beginning
    of its memory region, relative to the **System on Chip** (**SoC**) memory map.
    However, the expander is an I2C device. Thus, the address part of its node name
    corresponds to its I2C address.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的设备树摘录中，I2C控制器是一个内存映射设备。因此，节点名称中的地址部分对应于其内存区域的起始位置，相对于**片上系统**（**SoC**）的内存映射。然而，扩展器是一个I2C设备。因此，其节点名称中的地址部分对应于其I2C地址。
- en: An introduction to the concept of aliases, labels, phandles, and paths
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 别名、标签、phandle和路径概念简介
- en: 'Aliases, labels, phandles, and paths are keywords that you need to be familiar
    with when dealing with the device tree. It is likely that you will face at least
    one, if not all, of these terms as and when you deal with device drivers. To describe
    these terms, let''s take the following device tree excerpt as an example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 别名、标签、phandle和路径是处理设备树时需要熟悉的关键字。处理设备驱动时，你很可能会遇到这些术语中的至少一个，甚至是所有术语。为了描述这些术语，我们以以下设备树摘录为例：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the device tree, there are two ways in which a node can be referenced: by
    a path or by a `phandle` property and, sometimes, duplicated in a `linux,phandle`
    property for historical reasons.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备树中，节点可以通过两种方式引用：通过路径或通过`phandle`属性，有时为了历史原因，可能会在`linux,phandle`属性中重复出现。
- en: However, the device tree source format allows labels to be attached to any node
    or property value. Given that a label must be unique all over the device tree
    source for a given board, it became obvious that it could be used to identify
    a node as well, and a decision was made to do so. Thus, logic has been added to
    the `&`) in a cell property, it is replaced with the phandle of the node to which
    this label is attached. Moreover, using the same logic, whenever a label is prefixed
    with an ampersand outside of a cell (a simple value assignment), it is replaced
    by the full path of the node to which the label is attached. This way, the phandle
    and path references can be automatically generated by referencing a label instead
    of explicitly specifying a phandle value or the full path to a node.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，设备树源格式允许将标签附加到任何节点或属性值上。由于标签必须在特定板卡的整个设备树源中是唯一的，因此显然可以使用标签来标识节点，并且已做出决定这么做。因此，已经在逻辑中加入了处理：当标签作为单元格属性中的`&`前缀时，它会被替换为该标签所附加节点的phandle。此外，使用相同的逻辑，当标签在单元格外（简单的值赋值）以`&`符号为前缀时，它会被替换为该标签所附加节点的完整路径。通过这种方式，phandle和路径引用可以通过引用标签来自动生成，而不必显式指定phandle值或节点的完整路径。
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Labels are only used in the device tree source format and are not encoded within
    the `dtc` tool will remove that label from the node and add a `phandle` property
    to that node, generating and assigning a unique 32-bit value. The `dtc` tool will
    then use this phandle in every cell where the node has been referenced by the
    label (prefixed with an ampersand).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 标签仅用于设备树源格式，并不会被编码在`dtc`工具中，该工具会从节点中移除该标签并为该节点添加一个`phandle`属性，生成并分配一个唯一的32位值。然后，`dtc`工具将在每个引用该节点的单元格中使用该`phandle`（以&符号为前缀）。
- en: Back to our preceding excerpt, the `gpio@0209c000` node is labeled `gpio1`,
    and this label is also used as a reference. This will instruct the DTC to generate
    a phandle for this node. Therefore, in the `accelerometer@1d` node, inside the
    `interrupt-parent` property, the cell value (`&gpio1`) will be replaced by the
    phandle of the node to which `gpio1` is attached (the assignment inside a cell).
    In the same way, inside the `aliases` node, `&gpio1` will be replaced with the
    full path of the node to which `gpio1` is attached (the assignment outside of
    a cell).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 回到前面的摘录，`gpio@0209c000`节点被标记为`gpio1`，这个标签也被作为引用使用。这将指示DTC为此节点生成一个phandle。因此，在`accelerometer@1d`节点中，`interrupt-parent`属性内的单元格值（`&gpio1`）将被替换为`gpio1`所附加的节点的phandle（单元格内部的赋值）。以同样的方式，在`aliases`节点中，`&gpio1`将被替换为`gpio1`所附加的节点的完整路径（单元格外部的赋值）。
- en: 'After compiling and decompiling our original device tree excerpt, we obtain
    the following, where labels no longer exist and label references have been replaced
    either by a phandle or by the full node path:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译和反编译原始设备树摘录后，我们得到以下内容，其中标签不再存在，标签引用已被phandle或完整节点路径所替代：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding snippet, the accelerometer node has its `interrupt-parent`
    property cell assigned the value of `0x40`. Looking at the `gpio@209c000` node,
    we can see that this value corresponds to the value of its `phandle` property,
    which has been generated at compile time by the DTC. It's the same for the `aliases`
    node, where the node references have been replaced by their full paths.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，加速度计节点的`interrupt-parent`属性单元被赋值为`0x40`。查看`gpio@209c000`节点，我们可以看到该值对应其`phandle`属性的值，该值在编译时由DTC生成。`aliases`节点也是如此，其中节点引用已经被替换为其完整路径。
- en: This leads us to the definition of aliases; aliases are simply nodes that are
    referenced via their absolute paths for a quick lookup. The `aliases` node can
    be seen as a fast lookup table. Unlike labels, aliases do appear in the output
    device tree, although paths are generated by referencing labels. With an alias,
    a handle to the node it is referring to is obtained by simply searching for it
    in the aliases section rather than searching for it in the entire device tree
    as it is done while looking up by phandle. Aliases can be seen as a shortcut or
    similar to the aliases we set in our Unix shell to refer to a complete/long/repetitive
    path/command.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了别名的定义；别名只是通过它们的绝对路径进行引用的节点，用于快速查找。`aliases`节点可以看作是一个快速查找表。与标签不同，别名确实会出现在输出的设备树中，尽管路径是通过引用标签生成的。使用别名时，可以通过在别名部分查找来获取它所引用节点的句柄，而不是像通过`phandle`查找时那样在整个设备树中查找。别名可以看作是一种快捷方式，类似于我们在Unix
    shell中设置的别名，用来引用完整的/长的/重复的路径/命令。
- en: The Linux kernel dereferences the aliases rather than using them directly in
    the device tree source. When using `of_find_node_by_path()` or `of_find_node_opts_by_path()`
    to find a node given its path, if the supplied path does not start with `/`, then
    the first element of the path must be a property name in the `/aliases` node.
    That element is replaced with the full path from the alias.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核会解除引用别名，而不是直接在设备树源中使用它们。当使用`of_find_node_by_path()`或`of_find_node_opts_by_path()`根据路径查找节点时，如果提供的路径没有以`/`开头，则路径的第一个元素必须是`/aliases`节点中的属性名称。该元素将被该别名的完整路径所替代。
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Labeling a node is only useful if the node is intended to be referenced from
    the property of another node. You can consider a label as a pointer to a node,
    either by the path or by the reference.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 给节点打标签只有在该节点打算从另一个节点的属性中引用时才有意义。你可以将标签视为指向节点的指针，可以通过路径或引用来进行。
- en: Understanding overwriting nodes and properties
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解节点和属性的覆盖
- en: 'After taking a closer look at the result of the decompiled excerpt, you should
    notice one more thing: in the original sources, the `i2c@21a0000` node has been
    referenced through its label as an external node (`&i2c1 { [...] }`) with some
    content inside. However, oddly, after decompiling, the final content of the `i2c@21a0000`
    node has been merged with the content of the external reference, and the external
    reference node no longer exists.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在仔细查看解编译片段的结果后，你应该注意到另一件事：在原始源文件中，`i2c@21a0000`节点是通过其标签作为外部节点（`&i2c1 { [...]
    }`）引用的，并且有一些内容。然而，奇怪的是，在解编译后，`i2c@21a0000`节点的最终内容已经与外部引用的内容合并，而外部引用节点不再存在。
- en: 'This is the third usage of labels: allowing you to overwrite nodes and properties.
    In the external reference, any new content (such as nodes or properties) will
    be appended to the original node content at compile time. However, in the case
    of duplication (either nodes or properties), the content of the external reference
    will take precedence over the original content.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是标签的第三种用途：允许你覆盖节点和属性。在外部引用中，任何新内容（如节点或属性）都将在编译时附加到原始节点内容上。然而，在出现重复时（无论是节点还是属性），外部引用的内容将优先于原始内容。
- en: 'Consider the following example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下示例：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s reference the `i2c@21a0000` node through its `i2c1` label, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过其`i2c1`标签引用`i2c@21a0000`节点，如下所示：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will see that the result from the compilation will be the `status` property
    having the value of `"okay"`. This is because the content of the external reference
    will have taken precedence over the original content.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到编译结果是`status`属性的值为`"okay"`。这是因为外部引用的内容优先于原始内容。
- en: To summarize, latter definitions always overwrite earlier definitions. For entire
    nodes to be overwritten, you simply have to redefine them as you would do so for
    properties.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，后面的定义总是会覆盖前面的定义。为了完全覆盖一个节点，你只需要像重新定义属性一样重新定义它们。
- en: Device tree sources and compilers
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备树源和编译器
- en: The `.dts` extension, while the binary forms have either a `.dtb` or `.dtbo`
    extension. .`dtbo` is a particular extension that is used for compiled device
    tree overlays (`.dtsi` text files (where the `i` at the end means "include").
    These host SoC-level definitions and are intended to be included in `.dts` files,
    hosting the board-level definitions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dts`扩展名，而二进制形式则有`.dtb`或`.dtbo`扩展名。`.dtbo`是一个特殊的扩展名，用于编译的设备树覆盖（`.dtsi`文本文件（其中末尾的`i`表示“包含”））。这些文件承载SoC级别的定义，并打算被包含在`.dts`文件中，后者则承载板级别的定义。'
- en: The syntax of the device tree allows you to use `/include/` or `#include` to
    include other files. This inclusion mechanism makes it possible to use `#define`,
    but above all, it allows you to factorize the common aspects of several platforms
    in the shared files.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树的语法允许你使用`/include/`或`#include`来包含其他文件。这个包含机制使得使用`#define`成为可能，但最重要的是，它允许你在共享文件中提取多个平台的共同部分。
- en: This factorization allows you to split the source files into tree levels, with
    the most common being the SoC level, which is provided by the SoC vendor (for
    example, NXP), the **System on Module** (**SoM**) level (for example, Engicam),
    and, finally, the carrier board or customer board level.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种提取使得你能够将源文件拆分为树形结构，其中最常见的是SoC级别，由SoC供应商（例如NXP）提供，其次是**系统模块**（**SoM**）级别（例如Engicam），最后是承载板或客户板级别。
- en: 'Therefore, all electronic boards using the same SoC do not redefine all of
    the peripherals of the SoC from scratch: this description is factored into a common
    file. By convention, such *common* files use the `.dtsi` extension, while final
    device trees use the `.dts` extension.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有使用相同SoC的电子板不需要从头开始重新定义SoC的所有外设：这些描述被提取到一个公共文件中。根据约定，这种*公共*文件使用`.dtsi`扩展名，而最终的设备树使用`.dts`扩展名。
- en: In the Linux kernel sources, ARM device tree source files can be found under
    the `arch/arm/boot/dts/` and `arch/arm64/boot/dts/<vendor>/` directories for the
    32-bit and 64-bit ARM SoCs/boards, respectively. In either directory, there is
    a `Makefile` file that lists the device tree source files that can be compiled.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux内核源码中，ARM设备树源文件可以在`arch/arm/boot/dts/`和`arch/arm64/boot/dts/<vendor>/`目录下找到，分别用于32位和64位ARM
    SoC/板卡。在这两个目录中，都有一个`Makefile`文件，列出了可以编译的设备树源文件。
- en: 'The utility used to compile the DTS files into DTB files is called DTC. The
    DTC sources exist in two places:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 用于将DTS文件编译为DTB文件的工具叫做DTC。DTC的源代码存在于两个地方：
- en: '**As a standalone upstream project**: The DTC upstream project is maintained
    in [https://git.kernel.org/cgit/utils/dtc/dtc.git](https://git.kernel.org/cgit/utils/dtc/dtc.git).
    It is pulled into the Linux kernel source tree on a regular basis.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为一个独立的上游项目**：DTC上游项目托管在[https://git.kernel.org/cgit/utils/dtc/dtc.git](https://git.kernel.org/cgit/utils/dtc/dtc.git)。它会定期拉取到Linux内核源树中。'
- en: '`scripts/dtc/`. New versions are pulled from the upstream project on a regular
    basis. The DTC is built by the Linux kernel build process as a dependency when
    needed (for example, before compiling the device tree). You can use the `make
    scripts` command if you wish to build it explicitly in the Linux kernel source
    tree.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts/dtc/`。新版本会定期从上游项目拉取。DTC在Linux内核构建过程中作为依赖项构建（例如，在编译设备树之前）。如果你希望在Linux内核源树中显式构建它，可以使用`make
    scripts`命令。'
- en: From the main directory in the kernel sources, you can either compile a specific
    device tree or all device trees for a specific SoC. In either case, the appropriate
    config option to enable this or these device tree files must be enabled. For a
    single device tree compilation, the make target is the name of the `.dts` file
    with `.dts` changed to `.dtb`. For all of the enabled device trees to be compiled,
    the make target that you should use is `dtbs`. In both cases, you should make
    sure that the config option that enables the `dtb` has been set.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核源代码的主目录中，你可以选择编译特定的设备树或为特定SoC编译所有设备树。在这两种情况下，必须启用适当的配置选项以启用这些设备树文件。对于单个设备树的编译，make目标是将`.dts`文件的名称中的`.dts`更改为`.dtb`。对于所有启用的设备树进行编译，应该使用的make目标是`dtbs`。在这两种情况下，你应确保已设置启用`dtb`的配置选项。
- en: 'Consider the following excerpt from `arch/arm/boot/dts/Makefile`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下来自`arch/arm/boot/dts/Makefile`的摘录：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By enabling `CONFIG_SOC_IMX6Q`, you can either compile all of the device tree
    files listed in there or target a specific device tree. By running `make dtbs`,
    the kernel DTC will compile all the device tree files listed in the enabled config
    options.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启用 `CONFIG_SOC_IMX6Q`，你可以编译列表中所有的设备树文件，或者针对特定的设备树进行编译。通过运行 `make dtbs`，内核
    DTC 将编译所有启用配置选项中列出的设备树文件。
- en: 'First, let''s make sure the appropriate config option has been set:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保已经设置了适当的配置选项：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, let''s compile all of the device tree files:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们来编译所有的设备树文件：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Assuming our platform is an ARM64 platform, we would use the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的平台是 ARM64 平台，我们将使用以下命令：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once again, the right kernel config options must be set.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，必须设置正确的内核配置选项。
- en: 'You could target a particular device tree build (let''s say `imx6q-hummingboard2.dts`),
    using a command such as the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令来针对特定的设备树构建（例如 `imx6q-hummingboard2.dts`）：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It must be noted that, given a compiled device tree (`.dtb`) file, you can
    do the reverse operation and extract the source (`.dts`) file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，给定一个已编译的设备树（`.dtb`）文件，你可以进行反向操作，提取源代码（`.dts`）文件：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For debug purposes, it might be useful to expose to user space the current device
    tree of a running system, that is, the so-called live device tree. To do so, the
    kernel `CONFIG_PROC_DEVICETREE` config option must be enabled. Then, you can explore
    and walk through the device tree in the `/proc/device-tree` directory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 出于调试目的，可能会将运行系统的当前设备树暴露给用户空间，也就是所谓的实时设备树。为此，必须启用内核 `CONFIG_PROC_DEVICETREE`
    配置选项。然后，你可以在 `/proc/device-tree` 目录中浏览和查看设备树。
- en: 'If installed on the running system, the DTC can be used to convert the filesystem
    tree into a more readable form using the following command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行的系统上安装了 DTC，可以使用以下命令将文件系统树转换为更易读的形式：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After this command returns, the `MySBC.dts` file will contain the sources corresponding
    to the current device tree.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令返回后，`MySBC.dts` 文件将包含与当前设备树相对应的源代码。
- en: The device tree overlay
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备树覆盖
- en: Device tree overlaying is a mechanism that allows you to patch a live device
    tree, that is, modify the current device tree at runtime. It allows you to update
    the current device tree at runtime by updating existing nodes and properties or
    creating new ones. However, it does not allow you to delete a node or a property.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树覆盖是一种机制，允许你对实时设备树进行修补，即在运行时修改当前的设备树。它通过更新现有的节点和属性或创建新的节点和属性，允许你在运行时更新当前的设备树。然而，它不允许删除节点或属性。
- en: 'A device tree overlay has the following format:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树覆盖具有以下格式：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: From the preceding excerpt, we can note that each node from the base device
    tree that needs to be overlayed must be enclosed inside a `fragment` node in the
    overlay device tree.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的摘录中，我们可以注意到，每个需要覆盖的基础设备树节点都必须被包含在覆盖设备树中的 `fragment` 节点内。
- en: 'Then, each fragment has two elements:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个片段有两个元素：
- en: 'One of these two properties could be as follows:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两个属性中的一个可能如下所示：
- en: '`target-path`: This specifies the absolute path to the node that the fragment
    will modify.'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target-path`: 这指定了片段将要修改的节点的绝对路径。'
- en: '`target`: This specifies the relative path to the node alias (prefixed with
    an ampersand symbol) that the fragment will modify.'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`: 这指定了片段将要修改的节点别名的相对路径（以 & 符号为前缀）。'
- en: A node, named `__overlay__`, that contains the changes that should be applied
    to the referred node. Such changes can be new nodes (which are added), new properties
    (which are added), or existing properties (which are overridden with the new value).
    There is no removal operation possible since a property or a node cannot be removed.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `__overlay__` 的节点，包含应该应用到被引用节点的更改。这些更改可以是新的节点（被添加的）、新的属性（被添加的），或者现有的属性（被新值覆盖）。不允许进行删除操作，因为无法删除节点或属性。
- en: Now that we are comfortable with the basics of device tree overlaying, we can
    learn how they are compiled and turned into a binary blob that can be loaded on
    demand.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了设备树覆盖的基础知识，接下来我们可以学习它们是如何被编译并转化为二进制 blob，随时加载的。
- en: Building device tree overlays
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建设备树覆盖
- en: Unless a device tree overlay adds new nodes under the root node only (in which
    case, it could specify `/` in the `target-path` property in the fragment), it
    would be much easier to specify the target node via its phandle (`<&label_name>`)
    as it would save us from manually computing the node's full path (especially if
    it is nested).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除非设备树覆盖仅在根节点下添加新节点（在这种情况下，它可以在片段中指定 `/` 作为 `target-path` 属性），否则指定目标节点时通过其 phandle（`<&label_name>`）会更容易，因为这可以避免我们手动计算节点的完整路径（尤其是当它是嵌套的）。
- en: The thing is, there is no direct correlation or link between the base device
    tree and the overlay. They are each built, standalone, on their sides. Therefore,
    referencing a remote node (that is, a node in the base device tree) from the device
    tree overlay will raise errors, and the build of the overlay will fail because
    of undefined references or labels. It would be like building a dynamically linked
    application without room for symbol resolution.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，基础设备树和覆盖之间没有直接的关联或链接。它们各自独立构建。因此，从设备树覆盖中引用远程节点（即基础设备树中的节点）会引发错误，覆盖的构建将因为未定义的引用或标签而失败。这就像在没有符号解析空间的情况下构建一个动态链接的应用程序。
- en: 'To address this issue, `-@` command-line flag support has been added to the
    DTC. This flag must be specified for both the base device tree and all of the
    overlays to be compiled. It will instruct the DTC to generate extra nodes in the
    root (such as `__symbols__`, `__fixups__`, and `__local_fixups__`) that contain
    resolution data for the translation of phandle names. These extra nodes are spread
    as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，DTC 已添加对 `-@` 命令行标志的支持。必须为基础设备树和所有覆盖指定该标志，才能编译。它会指示 DTC 在根节点中生成额外的节点（如
    `__symbols__`、`__fixups__` 和 `__local_fixups__`），这些节点包含用于解析 phandle 名称的翻译数据。这些额外的节点分布如下：
- en: When the `-@` option is added to build an overlay, it recognizes the `/plugin/;`
    line that marks a device tree fragment/object. That line controls the generation
    of `__fixups__` and `__local_fixups__` nodes.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `-@` 选项添加到构建覆盖时，它会识别标记设备树片段/对象的 `/plugin/;` 行。该行控制 `__fixups__` 和 `__local_fixups__`
    节点的生成。
- en: When the `-@` option is added to build the base device tree, `/plugin/;` is
    not present, so the source is recognized as being the base device tree, which
    causes the generation of `__symbols__` nodes only.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `-@` 选项添加到构建基础设备树时，`/plugin/;` 不存在，因此源被识别为基础设备树，这会导致仅生成 `__symbols__` 节点。
- en: These extra nodes add room for symbol resolution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的节点为符号解析提供了空间。
- en: Note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Support for the `-@` option can only be found in `dtc` version 1.4.4 or later.
    Only Linux kernel versions v4.14 or higher includes a built-in version of `dtc`
    that meets this requirement. This option is not needed if only `target-path` properties
    (that is, non-phandle-based) are used in the device tree overlay.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`-@` 选项的支持仅在 `dtc` 版本 1.4.4 或更高版本中找到。只有 Linux 内核版本 v4.14 或更高版本包括一个符合此要求的内置
    `dtc` 版本。如果设备树覆盖中仅使用 `target-path` 属性（即非 phandle 基于属性），则不需要此选项。'
- en: 'Building a binary device tree overlay follows the same process as building
    a traditional binary device tree. For example, let''s consider the following base
    device tree. Let''s call it `base.dts`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 构建二进制设备树覆盖的过程与构建传统的二进制设备树相同。例如，考虑以下基础设备树，我们将其命名为 `base.dts`：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, let''s build this base device tree with the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用以下命令构建基础设备树：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the next step, let''s consider the following device tree overlay. Let''s
    call it `foo-verlay.dts`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，让我们考虑以下设备树覆盖，我们将其命名为 `foo-verlay.dts`：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding device tree overlay, the `status` property of the `foo` node
    in the base device tree has been modified from `disabled` to `okay`, which will
    activate this node. Following this, the `overlay-1-property` Boolean property
    has been added, and finally, a `bar` sub-node has been added with a single Boolean
    property. This device tree overlay can be compiled with the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的设备树覆盖中，基础设备树中 `foo` 节点的 `status` 属性已从 `disabled` 修改为 `okay`，这将激活该节点。随后，添加了
    `overlay-1-property` 布尔属性，最后，添加了一个 `bar` 子节点，并包含一个布尔属性。此设备树覆盖可以通过以下命令进行编译：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, the `-@` flag has been added on both sides, enabling room for
    symbol resolution.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`-@` 标志已添加到两侧，提供了符号解析的空间。
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the Yocto build system, you could add this flag to the machine configuration
    or, during development, to the `local.conf` file, as follows: `DEVICETREE_FLAGS
    += "-@"`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yocto构建系统中，你可以将此标志添加到机器配置中，或者在开发过程中，将其添加到`local.conf`文件中，如下所示：`DEVICETREE_FLAGS
    += "-@"`。
- en: 'For the Linux kernel to build the device tree overlay, you should add it to
    the `Makefile` device tree of your SoC architecture, for example, `arch/arm64/boot/dts/freescale/Makefile`
    or `arm/arm/boot/dts/Makefile`, along with the `dtbo` extension, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Linux内核构建设备树覆盖文件，你应当将其添加到你所使用的SoC架构的`Makefile`设备树中，例如`arch/arm64/boot/dts/freescale/Makefile`或`arm/arm/boot/dts/Makefile`，并使用`dtbo`扩展名，如下所示：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we can manage to build our own device tree overlays, let's consider
    the logical next step, which consists of loading these overlays into the system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经能够构建自己的设备树覆盖文件，接下来我们可以考虑一个逻辑上的下一步，即将这些覆盖文件加载到系统中。
- en: Loading device tree overlays via configfs
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过configfs加载设备树覆盖文件
- en: This section is named such that it mentions the way the device tree overlay
    is going to be loaded (configfs) since there is not only one way to load device
    tree overlays. In this section, we will focus on doing this on a running system
    whose kernel has already booted and the root filesystem is already mounted.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的名称表明了设备树覆盖文件将被加载的方式（configfs），因为加载设备树覆盖文件的方式不止一种。在这一节中，我们将专注于在一个已经启动并且根文件系统已经挂载的系统中加载覆盖文件。
- en: 'In order to do this, your kernel must have been compiled with `CONFIG_OF_OVERLAY`
    and `CONFIG_CONFIGFS` for the following steps to work. The following is a check,
    assuming the kernel config is available in the target:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你的内核必须在编译时启用了`CONFIG_OF_OVERLAY`和`CONFIG_CONFIGFS`，才能使接下来的步骤有效。以下是一个检查示例，假设目标系统上已经有了内核配置：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now it''s time to insert the DTBs into a running kernel using `configfs`. First,
    we mount the `configfs` filesystem if it has not already been mounted on your
    system:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用`configfs`将DTB插入到正在运行的内核中了。首先，如果`configfs`文件系统尚未挂载，你需要先将其挂载：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When `configfs` has been mounted properly, the directory should be populated
    with base subdirectories (`device-tree/overlays`), which, according to our mount
    path, will result in `/sys/kernel/config/device-tree/overlays`, as demonstrated
    in the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当`configfs`正确挂载后，目录应该包含基本的子目录（`device-tree/overlays`），根据我们的挂载路径，这将会是`/sys/kernel/config/device-tree/overlays`，如下所示：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then, each overlay entry must be added from within the `overlays` directory.
    It has to be noted that overlay entries are created and manipulated using a standard
    filesystem I/O.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，必须从`overlays`目录中添加每个覆盖文件条目。需要注意的是，覆盖条目的创建和操作是通过标准的文件系统I/O进行的。
- en: 'To load an overlay, a directory corresponding to this overlay must be created
    under the `overlays` directory. For our example, let''s use the name `foo` :'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载一个覆盖文件，必须在`overlays`目录下创建一个与该覆盖文件对应的目录。以我们的例子为例，我们使用名称`foo`：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, to effectively load the overlay, you can `echo` the overlay firmware
    file path to the `path` property file, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了有效加载覆盖文件，你可以通过`echo`命令将覆盖固件文件路径写入到`path`属性文件中，如下所示：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Alternatively, you can `cat` the contents of the overlay to the `dtbo` file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以将覆盖文件的内容通过`cat`命令写入到`dtbo`文件中：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After that, the overlay file will be applied, and devices will be created/destroyed
    as required.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，覆盖文件将会应用，设备将会根据需要被创建或销毁。
- en: 'To remove the overlay and undo its changes, you should simply `rmdir` the corresponding
    overlay directory. In our example, it should be as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除覆盖文件并撤销其更改，你只需执行`rmdir`命令删除相应的覆盖文件目录。在我们的例子中，应该如下所示：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Although you have loaded the device tree overlay dynamically, it won't be sufficient;
    the device driver for the added device node needs to be loaded for the device
    to work unless this driver is built-in and enabled (that is, selected with `y`
    during `make menuconfig`).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你已经动态加载了设备树覆盖文件，但这还不够；为了让新添加的设备节点工作，设备驱动程序也需要加载，除非这个驱动程序是内建的并且已经启用（即在`make
    menuconfig`期间选择了`y`）。
- en: At this stage, we are done with our device tree compilation-related stuff. Now,
    we can learn how to write our own device trees, starting with device addressing
    and representation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经完成了设备树编译相关的工作。现在，我们可以开始学习如何编写我们自己的设备树，从设备寻址和表示开始。
- en: Representing and addressing devices
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示和寻址设备
- en: In the device tree, a node is the representational unit of a device. In other
    words, a device is represented by at least one node. Following this, device nodes
    can either be populated with other nodes (therefore, creating a parent-child relationship)
    or with properties (which would describe the device corresponding to the node
    they populate).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备树中，节点是设备的表示单元。换句话说，一个设备至少由一个节点表示。接下来，设备节点可以包含其他节点（从而创建父子关系）或包含属性（这些属性描述与它们所填充节点对应的设备）。
- en: While each device can operate standalone, there are situations where a device
    might want to be accessed by its parent or where a parent might want to access
    one of its children. For example, such situations occur when a bus controller
    (the parent node) wants to access one or more of the devices (declared as a sub-node)
    sitting on its bus. Typical examples include I2C controllers and I2C devices,
    SPI controllers and SPI devices, CPUs and memory-mapped devices, and more. Thus,
    the concept of device addressing has emerged. Device addressing has been introduced
    with a `reg` property, which is used in each addressable device but whose meaning
    or interpretation depends on the parent (most of the time, they are bus controllers).
    The meaning and interpretation of `reg` in a child device depends on the `#address-cells`
    and `#size-cells` properties of its parent. The `#` (sharp) character that prefixes
    `size-cells` and `address-cells` can be considered to mean "length of."
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个设备都可以独立操作，但也有一些情况，其中一个设备可能希望被其父设备访问，或者父设备可能希望访问其子设备。例如，当总线控制器（父节点）想要访问其总线上一个或多个设备（作为子节点声明）时，就会发生这种情况。典型的例子包括
    I2C 控制器与 I2C 设备，SPI 控制器与 SPI 设备，CPU 与内存映射设备等。因此，设备地址分配的概念应运而生。设备地址分配通过 `reg` 属性引入，该属性用于每个可寻址设备，但其含义或解释依赖于父设备（通常是总线控制器）。子设备中
    `reg` 的含义和解释取决于其父设备的 `#address-cells` 和 `#size-cells` 属性。`#`（井号）字符作为前缀出现在 `size-cells`
    和 `address-cells` 中，可以理解为“长度”。
- en: Each addressable device gets a `reg` property that is a list of tuples in the
    form of `reg = <address0 size0 [address1 size1] [address2 size2] ... >`, where
    each tuple represents an address range used by the device. `#size-cells` indicates
    how many 32-bit cells are used to represent the size, which might be 0 if the
    size is not relevant. On the other hand, `#address-cells` indicates how many 32-bit
    cells are used to represent the address. In other words, the address element of
    each tuple is interpreted according to `#address-cells`; this uses the same size
    as the size element, which is interpreted according to `#size-cells`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可寻址设备都会有一个 `reg` 属性，它是一个元组列表，形式为 `reg = <address0 size0 [address1 size1] [address2
    size2] ... >`，其中每个元组代表设备使用的地址范围。`#size-cells` 表示用于表示大小的 32 位单元数量，如果大小不相关，可能为 0。另一方面，`#address-cells`
    表示用于表示地址的 32 位单元数量。换句话说，每个元组的地址元素是根据 `#address-cells` 来解释的，它使用与大小元素相同的大小，而大小元素则根据
    `#size-cells` 来解释。
- en: To sum up, addressable devices inherit from the `#size-cell` and `#address-cell`
    properties of their parent, which is the node that represents the bus controller
    most of the time. The presence of `#size-cell` and `#address-cell` in a given
    device does not affect the device itself but its children if they are addressable.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，可寻址设备继承其父设备的 `#size-cell` 和 `#address-cell` 属性，而父设备通常是表示总线控制器的节点。某一设备中是否存在
    `#size-cell` 和 `#address-cell` 不会影响设备本身，但会影响它的子设备（如果它们是可寻址的）。
- en: Now that we have seen how addressing works in a general manner, let's address
    specific addressing for non-discoverable devices, starting with SPI and I2C.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了地址分配的一般原理，让我们开始讨论针对不可发现设备的具体地址分配，从 SPI 和 I2C 开始。
- en: Handling SPI and I2C device addressing
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 SPI 和 I2C 设备地址分配
- en: 'SPI and I2C devices both belong to non-memory-mapped devices because their
    addresses are not accessible to the CPU. Instead, the parent device''s driver
    (the bus controller driver) will perform indirect access on behalf of the CPU.
    Each I2C/SPI device node is always represented as a sub-node of the I2C/SPI controller
    node that the device sits on. For a non-memory-mapped device, the `#size-cells`
    property is 0, and the size element in the addressing tuple is empty. This means
    that the `reg` property for this kind of device is always one cell. The following
    is an example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: SPI和I2C设备都属于非内存映射设备，因为它们的地址无法被CPU访问。相反，父设备的驱动程序（总线控制器驱动程序）将代表CPU进行间接访问。每个I2C/SPI设备节点总是表示为设备所在的I2C/SPI控制器节点的子节点。对于非内存映射设备，`#size-cells`属性为0，寻址元组中的大小元素为空。这意味着这种设备的`reg`属性始终只有一个单元。以下是一个示例：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you look at the SoC-level file in `arch/arm/boot/dts/imx6qdl.dtsi`, you will
    notice that `#size-cells` and `#address-cells` are set to `0`, for the former,
    and `1`, for the latter, respectively, in both the I2C and SPI controller nodes
    (labeled `i2c3` and `ecspi1`). This helps you to understand their `reg` property,
    which is only one cell for the address value and none for the size value.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`arch/arm/boot/dts/imx6qdl.dtsi`中的SoC级文件，你会注意到，在I2C和SPI控制器节点（标记为`i2c3`和`ecspi1`）中，`#size-cells`和`#address-cells`分别被设置为`0`和`1`。这有助于你理解它们的`reg`属性，其中地址值只需要一个单元，而大小值不需要单元。
- en: The I2C device's `reg` property is used to specify the device's address on the
    bus. For SPI devices, `reg` represents the index of the chip-select line assigned
    to the device among the list of chip selects the controller node has. For example,
    for the `ad7606r8` ADC, the chip-select index is 1, which corresponds to `<&gpio5
    17 0>` in `cs-gpios.` This is the list of chip selects of the controller node.
    The binding of other controllers might differ, and you should refer to their documentation
    in`Documentation/devicetree/bindings/spi`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: I2C设备的`reg`属性用于指定设备在总线上的地址。对于SPI设备，`reg`表示在控制器节点所拥有的芯片选择线列表中分配给设备的芯片选择索引。例如，对于`ad7606r8`
    ADC，芯片选择索引为1，对应于`<&gpio5 17 0>`中的`cs-gpios`。这就是控制器节点的芯片选择列表。其他控制器的绑定方式可能不同，你应参考它们的文档，位于`Documentation/devicetree/bindings/spi`。
- en: Memory-mapped devices and device addressing
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存映射设备与设备寻址
- en: 'This section addresses simple memory-mapped devices where the memory region
    is accessible by the CPU. With such device nodes, the `reg` property still defines
    the device''s address, and the `reg = <address0 size0 [address1 size1] [address2
    size2] ... >` pattern takes place. Each region is represented with a tuple of
    cells, where the first cell is the base address of the memory region, and the
    second cell is the size of the region. It could be translated into the following
    pattern: `reg = <base0 length0 [base1 length1] [address2 length2] ... >`. Here,
    each tuple represents an address range used by the device.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论简单的内存映射设备，其中内存区域可以被CPU访问。对于这种设备节点，`reg`属性仍然定义设备的地址，并采用`reg = <address0 size0
    [address1 size1] [address2 size2] ... >`的模式。每个区域都用一个单元组表示，第一个单元是内存区域的基地址，第二个单元是该区域的大小。这可以转化为以下模式：`reg
    = <base0 length0 [base1 length1] [address2 length2] ... >`。在这里，每个元组表示设备使用的地址范围。
- en: 'Let''s consider the following example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding excerpt, device nodes that have `simple-bus` in their `compatible`
    properties are SoC internal memory-mapped bus controllers connecting IP cores
    (such as I2C, SPI, USB, Ethernet, and other internal SoC IPs) to the CPU. Their
    sub-nodes, which are either IP core or other internal buses, inherit from the
    `#address-cells` and `#size-cells` properties. We can see that the `i2c@021a0000`
    I2C controller (labeled `i2c1`) is connected to the `spba-bus@02000000` bus. All
    of them will appear as platform devices on the system at runtime. On the other
    hand, this I2C controller changes its addressing scheme by defining its own `#address-cells`
    and `#size-cells` properties, which the I2C devices connected to it will inherit.
    This is the same for the SPI controller.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的摘录中，`compatible`属性中包含`simple-bus`的设备节点是SoC内部内存映射总线控制器，用于将IP核心（如I2C、SPI、USB、以太网及其他内部SoC
    IP）连接到CPU。它们的子节点，可能是IP核心或其他内部总线，继承自`#address-cells`和`#size-cells`属性。我们可以看到，`i2c@021a0000`
    I2C控制器（标记为`i2c1`）连接到`spba-bus@02000000`总线。它们都会在运行时作为平台设备出现在系统中。另一方面，这个I2C控制器通过定义自己的`#address-cells`和`#size-cells`属性来更改其寻址方案，连接到它的I2C设备将继承这些属性。SPI控制器也是如此。
- en: To summarize, in the real world, you should not interpret a `reg` property in
    a node without knowing the `#size-cells` and `#address-cells` properties of its
    parent. Memory-mapped devices must have the `size` field of their `reg` property
    set with the size of the memory regions of the devices, but also the `address`
    field, which must be defined such that it corresponds to the beginning of the
    device memory regions in the SoC memory map, as shown in the SoC datasheet.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在实际应用中，如果不清楚父节点的`#size-cells`和`#address-cells`属性，你不应当解读节点中的`reg`属性。内存映射设备必须在其`reg`属性的`size`字段中设置设备内存区域的大小，同时还需要定义`address`字段，该字段必须与SoC内存映射中设备内存区域的起始位置对应，如SoC的数据手册所示。
- en: Note
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The simple-bus-compatible string also indicates that the bus has no special
    driver, that there's no way to dynamically probe the bus, and that direct child
    nodes (exclusively, level-1 children) will be registered as platform devices.
    Sometimes, this is used in board-level device trees to instantiate GPIO-based
    fixed regulators.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: simple-bus-compatible字符串还表明该总线没有特殊的驱动程序，无法动态探测该总线，且直接子节点（仅限一级子节点）将作为平台设备注册。有时，这在板级设备树中用于实例化基于GPIO的固定电压调节器。
- en: Handling resources
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源处理
- en: The main purpose of a device driver is to provide a set of driving functions
    for a given device and expose its capabilities to users. Here, the objective is
    to gather the device's configuration parameters, especially resources (such as
    the memory region, interrupt line, DMA channel, and more) that will help the driver
    to perform its job.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动的主要目的是为给定设备提供一组驱动功能，并向用户暴露其能力。在这里，目标是收集设备的配置参数，特别是资源（如内存区域、中断线、DMA通道等），这些资源将帮助驱动程序执行其工作。
- en: The struct resource
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`struct resource`'
- en: 'Once probed, device resources assigned to the device (either in the device
    or the board/machine file) are gathered and allocated either by `of_platform`
    or by the `platform` cores using `struct resource`, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦探测完成，分配给设备的资源（无论是在设备中还是在板/机器文件中）都会由`of_platform`或`platform`核心使用`struct resource`进行收集和分配，具体如下：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following lists the meanings of the elements in the data structure:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了数据结构中各个元素的含义：
- en: '`start`: Depending on the resource flag, this can be the starting address of
    a memory region, an IRQ line number, a DMA channel number, or a register offset.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`：根据资源标志，这可以是内存区域的起始地址、IRQ线编号、DMA通道编号或寄存器偏移量。'
- en: '`end`: This is the end of the memory region or the end of the register offset.
    In the case of an IRQ or DMA channel, most of the time, the `start` and `end`
    values are the same.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end`：这是内存区域的结束位置或寄存器偏移的结束位置。在IRQ或DMA通道的情况下，大多数时候，`start`和`end`的值是相同的。'
- en: '`name`: This is the name of the resource if any. We discuss it in more detail
    in the next section.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是资源的名称（如果有的话）。我们将在下一节中详细讨论它。'
- en: '`flags`: This indicates the type of resource. Possible values include the following:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`：指示资源的类型。可能的值包括以下几种：'
- en: '`IORESOURCE_IO`: This indicates the PCI/ISA I/O port region. `start` is the
    first port of the region, and `end` is the last one.'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IORESOURCE_IO`：指示PCI/ISA I/O端口区域。`start`是该区域的第一个端口，`end`是最后一个端口。'
- en: '`IORESOURCE_MEM`: This is used for the I/O memory regions. `start` indicates
    the starting address of the region, and `end` indicates where it ends.'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IORESOURCE_MEM`：用于I/O内存区域。`start`表示区域的起始地址，`end`表示区域的结束地址。'
- en: '`IORESOURCE_REG`: This refers to the register offsets. It is mostly used with
    MFD devices. `start` indicates the offset relative to a parent device register,
    and `end` indicates where the register section ends.'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IORESOURCE_REG`：这指的是寄存器偏移量。它主要用于MFD设备。`start`表示相对于父设备寄存器的偏移量，而`end`表示寄存器段的结束位置。'
- en: '`IORESOURCE_IRQ`: The resource is an IRQ line number. In this case, either
    both `start` and `end` have the same value or `end` is irrelevant.'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IORESOURCE_IRQ`：该资源是IRQ线编号。在这种情况下，`start`和`end`的值要么相同，要么`end`无关紧要。'
- en: '`IORESOURCE_DMA`: This indicates that the resource is a DMA channel number.
    You should consider `end` in the same way as an IRQ. However, what happens when
    you have more than one cell for the DMA channel identifier or when you have multiple
    DMA controllers is not very well defined. `IORESOURCE_DMA` is not scalable for
    multiple controller systems.'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IORESOURCE_DMA`：表示该资源是一个DMA通道编号。你应当像处理IRQ一样处理`end`。然而，当DMA通道标识符有多个单元，或者当有多个DMA控制器时，情况并没有很好地定义。`IORESOURCE_DMA`在多控制器系统中不可扩展。'
- en: There is one instance of this data structure allocated per resource. That means,
    for a device that is assigned two memory regions and one IRQ line, there will
    be three data structures allocated. Moreover, resources of the same type will
    be allocated and indexed (starting from 0) in the order they are declared in the
    device tree (or the board file). This means that the first memory region assigned
    will have index 0, and so on.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每个资源分配一个数据结构实例。这意味着，对于一个被分配了两个内存区域和一个IRQ线的设备，将分配三个数据结构。此外，同一类型的资源将按照它们在设备树（或板文件）中声明的顺序进行分配和索引（从0开始）。这意味着第一个分配的内存区域将具有索引0，依此类推。
- en: 'To get the appropriate resource, we will use a generic API, `platform_get_resource()`,
    given the resource type and its index in this type. This function is defined as
    follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取适当的资源，我们将使用一个通用的API，`platform_get_resource()`，并传入资源类型以及该类型下的资源索引。该函数的定义如下：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding prototype, `dev` is the platform device that we write the driver
    for, `type` is the resource type, and `num` is the index of this resource in the
    same type. On success, the function returns a valid pointer to `struct resource`,
    or `NULL` otherwise.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的原型中，`dev`是我们为其编写驱动程序的平台设备，`type`是资源类型，`num`是该资源在同一类型中的索引。成功时，该函数返回指向`struct
    resource`的有效指针，失败则返回`NULL`。
- en: When there is more than one resource in the same type, using indexes could be
    misleading. You might decide to rely on the resource name as an alternative, and
    the named variant of `platform_get_resource()` will be introduced, which is `platform_get_resource_byname()`.
    This function is given a resource flag (or type) and its name and returns the
    appropriate resource, whatever the order they are declared in.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当同一类型下有多个资源时，使用索引可能会导致误解。你可能决定依赖资源名称作为替代方案，这时将引入`platform_get_resource()`的命名版本，即`platform_get_resource_byname()`。该函数传入一个资源标志（或类型）及其名称，返回相应的资源，无论它们在设备树中的声明顺序如何。
- en: 'It is defined as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 它的定义如下：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To understand how to use this function, first, let's introduce the concept of
    named resources. We will discuss this next.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解如何使用这个功能，首先让我们介绍一下命名资源的概念。我们将接下来讨论这个内容。
- en: The concept of named resources
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名资源的概念
- en: When the driver expects a list of resources of a certain type (let's say two
    IRQ lines, where the first one is for Tx and the second for Rx), there is no guarantee
    of the way the list will be ordered, and the driver must make no assumption. What
    happens if the driver logic is hardcoded so that it expects Rx IRQ first, but
    the device tree has been populated with Tx first? To avoid such mismatches, the
    concept of named resources (such as clocks, IRQs, DMA channels, and memory regions)
    has been introduced. This consists of defining the resource list and naming them.
    This is so that, whatever their indexes are, a given name will always match the
    resource. The concept of a named resource also makes it easy to read and understand
    the device tree resource assignment.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当驱动程序期望某种类型的资源列表时（假设是两个IRQ线，第一个用于Tx，第二个用于Rx），列表的顺序并不能得到保证，驱动程序不能做任何假设。如果驱动程序的逻辑硬编码假设先是Rx
    IRQ，但设备树中是先配置了Tx，会发生什么情况呢？为了避免这种不匹配，提出了命名资源的概念（如时钟、IRQ、DMA通道和内存区域）。这包括定义资源列表并为其命名。无论它们的索引是什么，给定的名称总是能匹配到相应的资源。命名资源的概念还使得设备树的资源分配更加易于阅读和理解。
- en: 'The corresponding properties to name the resources are as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 用于命名资源的对应属性如下：
- en: '`reg-names`: This is the list of names for memory regions in the `reg` property.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg-names`：这是`reg`属性中内存区域的名称列表。'
- en: '`interrupt-names`: This gives a name to each interrupt line in the `interrupts`
    property.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interrupt-names`：这是为`interrupts`属性中的每个中断线命名的。'
- en: '`dma-names`: This is for the `dma` property.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dma-names`：这是用于`dma`属性的。'
- en: '`clock-names`: This is to name the clocks inside the `clocks` property. Note
    that clocks won''t be discussed in this book.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clock-names`：这是用来给`clocks`属性中的时钟命名的。请注意，书中不会讨论时钟的相关内容。'
- en: 'To demonstrate the concept, let''s consider the following fake device node
    entry:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个概念，假设我们有如下的虚拟设备节点条目：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding example, the device is assigned three memory regions and two
    interrupt lines. The resource name list and resources respect a one-to-one mapping.
    This means, for example, that the name at index `0` will be assigned to the resource
    at the same index. The code in the driver to extract each named resource is as
    follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，设备被分配了三个内存区域和两条中断线。资源名称列表和资源之间存在一一映射关系。这意味着，例如，索引为`0`的名称将被分配给相同索引的资源。驱动程序中提取每个命名资源的代码如下：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, requesting resources in the named manner is less error-prone.
    That said, both `platform_get_resource()` and `platform_get_resource_byname()`
    are generic APIs used to deal with resources. However, there are dedicated APIs
    that allow you to reduce the development effort (such as `platform_get_irq_byname()`,
    `platform_get_irq()`, or `platform_get_and_ioremap_resource()`), as we will learn
    in later chapters.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，以命名方式请求资源更不容易出错。也就是说，`platform_get_resource()`和`platform_get_resource_byname()`是通用API，用于处理资源。然而，也有专门的API可以帮助你减少开发工作量（例如`platform_get_irq_byname()`、`platform_get_irq()`或`platform_get_and_ioremap_resource()`），我们将在后面的章节中学习这些内容。
- en: Extracting application-specific data
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取特定应用数据
- en: 'Application-specific data is data that is beyond the common resources (neither
    IRQ numbers, memory regions, regulators, nor clocks). These are arbitrary properties
    and child nodes that can be assigned to a device. Usually, such properties use
    a manufacture prefix. These can be any kind of string, Boolean, or integer value,
    along with their API defined in `drivers/of/base.c` in the Linux sources. Note
    that the examples we discuss here are not exhaustive. Now, let''s reuse the node
    that was defined earlier in this chapter:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 特定应用数据是指超出通用资源的数据（既不是IRQ号、内存区域、调节器，也不是时钟）。这些是可以分配给设备的任意属性和子节点。通常，这些属性使用厂商前缀。它们可以是任何类型的字符串、布尔值或整数值，以及它们在Linux源代码中`drivers/of/base.c`中定义的API。请注意，我们在这里讨论的示例并不详尽。现在，让我们重用本章早些时候定义的节点：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the sections that follow, we will learn how to obtain each property in the
    preceding device tree node excerpt.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何获取前面设备树节点摘录中的每个属性。
- en: Extracting string properties
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取字符串属性
- en: 'The following is an excerpt of the previous example, showing a single string
    and multiple string properties:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面示例的摘录，展示了一个单独的字符串和多个字符串属性：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Back in the driver, there are different APIs that can be used depending on
    the need. You should use `of_property_read_string()` to read a single string value
    property. Its prototype is defined as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在驱动程序中，根据需求可以使用不同的API。你应该使用`of_property_read_string()`来读取单个字符串值属性。其原型定义如下：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding functions, `np` is the node from which the string property
    needs to be read. `propname` is the name of the property hosting the string or
    string list, and `sz` is the number of array elements to read. `out_string` is
    an output parameter whose pointer value will be changed to point to the string
    value(s).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，`np`是需要读取字符串属性的节点，`propname`是包含字符串或字符串列表的属性名称，`sz`是要读取的数组元素数量，`out_string`是一个输出参数，其指针值将被更改为指向字符串值。
- en: '`of_property_read_string()` and `of_property_read_string_index()` return `-ENODATA`
    if the property does not have a value. Alternatively, they return `-EINVAL` if
    the property does not exist at all. Additionally, `-EILSEQ` is returned if the
    string is not `NULL`-terminated within the length of the property data. Finally,
    on success, they return `0`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性没有值，`of_property_read_string()`和`of_property_read_string_index()`将返回`-ENODATA`。如果属性根本不存在，它们将返回`-EINVAL`。此外，如果字符串在属性数据的长度范围内没有以`NULL`结尾，则会返回`-EILSEQ`。最后，如果成功，它们将返回`0`。
- en: '`of_property_read_string_array()` searches for the specified property in the
    given device tree node, retrieves a list of `NULL`-terminated string values (actually
    a pointer to these strings, not a copy) inside that property, and assigns it to
    `out_strs`. In addition to the values returned by `of_property_read_string()`
    and `of_property_read_string_index()`, this function is special in the way that
    it returns the number of strings that have been read if the target array of pointers
    is not `NULL`. The `out_strs` parameter can be omitted (`NULL`) if you simply
    wish to count the number of strings in the property.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`of_property_read_string_array()` 在给定的设备树节点中搜索指定的属性，检索该属性中的一组 NULL 终止的字符串值（实际上是指向这些字符串的指针，而不是副本），并将其分配给
    `out_strs`。除了 `of_property_read_string()` 和 `of_property_read_string_index()`
    返回的值外，这个函数有个特别之处，即如果目标指针数组不是 `NULL`，它会返回已读取的字符串数量。如果您只是想计算属性中的字符串数量，可以省略 `out_strs`
    参数（设置为 `NULL`）。'
- en: 'The following code shows how you can use them:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用它们：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding example, we learned how to extract string properties, either
    from a single-value property or from a list. It must be noted that a pointer to
    the string (or string list) is returned, not a copy. Additionally, in the last
    line, we see how to extract a given number of NULL-terminated string elements
    in the array. Here again, a pointer to these elements are returned, not copies
    of these.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们学习了如何提取字符串属性，无论是来自单一值属性还是来自列表。需要注意的是，返回的是字符串（或字符串列表）的指针，而不是副本。此外，在最后一行中，我们看到如何提取数组中给定数量的
    NULL 终止字符串元素。同样，这里返回的是指向这些元素的指针，而不是它们的副本。
- en: Reading cells and unsigned 32-bit integers
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取单元格和无符号 32 位整数
- en: 'Here are our `int` properties:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的 `int` 属性：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Back in the driver, as with string properties, there is a set of APIs that
    you can choose according to your need. You should use `of_property_read_u32()`
    to read a cell value. Its prototype is defined as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在驱动程序中，与字符串属性一样，您可以根据需要选择一组 API。您应该使用 `of_property_read_u32()` 来读取单元格值。其原型定义如下：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding APIs behave in the same way as their `_string`, `_string_index`,
    and `_string_array` counterparts. This is because they all return `0` on success,
    `-EINVAL` if the property does not exist at all, or `-ENODATA` when the property
    does not have a value. The differences are that the type of value to read, in
    this case, is `u32`, that we have an `-EOVERFLOW` error if the property data isn't
    large enough, and that `out_values` must be allocated first because the values
    to be returned have been copied instead.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 API 的行为与它们的 `_string`、`_string_index` 和 `_string_array` 对应函数相同。这是因为它们在成功时都返回
    `0`，如果属性根本不存在，则返回 `-EINVAL`，如果属性没有值，则返回 `-ENODATA`。不同之处在于，读取的值类型在此情况下为 `u32`，如果属性数据不够大，则会返回
    `-EOVERFLOW` 错误，并且 `out_values` 必须先分配，因为返回的值是已复制的，而不是原始数据。
- en: 'The following is the usage of these APIs in our example, with `int` and our
    list of `int` properties:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在示例中使用这些 API 的方法，涉及 `int` 类型和我们的 `int` 属性列表：
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can use `of_property_read_u32_array` to read a list of cells. Its prototype
    is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `of_property_read_u32_array` 来读取一个单元格列表。其原型如下：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, `sz` is the number of array elements to read. Take a look at `drivers/of/base.c`
    to see how to interpret its return value:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`sz` 是要读取的数组元素数量。请查看 `drivers/of/base.c` 以了解如何解释其返回值：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we have demonstrated how easy it would be to deal with an array of cells,
    that is, arrays of 32-bit integer values. In the next section, we will see how
    to do that with Boolean properties.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们演示了如何轻松处理一系列单元格，即 32 位整数值的数组。在下一节中，我们将看到如何使用布尔属性来处理这些。
- en: Handling Boolean properties
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理布尔属性
- en: 'You should use `of_property_read_bool()` to read the Boolean property whose
    name is given in the second argument of the function:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该使用 `of_property_read_bool()` 来读取函数第二个参数中给定名称的布尔属性：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding example demonstrates how to deal with Boolean properties. Now
    we can learn about far more complex APIs, starting with extracting and parsing
    sub-nodes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例演示了如何处理布尔属性。现在我们可以学习更复杂的 API，从提取和解析子节点开始。
- en: Extracting and parsing sub-nodes
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取和解析子节点
- en: 'Note that you are allowed to add whatever sub-node you want to a device node.
    This usage is common in numerous use cases, such as population partitions in an
    MTD device node or describing regulator constraints in a power management chip
    node. For example, given a node representing a flash memory device, partitions
    can be represented as nested sub-nodes. The following excerpt shows how this is
    achieved:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以将任何你想要的子节点添加到设备节点中。这种用法在许多应用场景中很常见，例如在MTD设备节点中表示分区，或在电源管理芯片节点中描述调节器约束。例如，给定一个表示闪存设备的节点，分区可以作为嵌套的子节点来表示。以下示例展示了如何实现这一点：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can use `for_each_child_of_node()` to walk through sub-nodes of the given
    node:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`for_each_child_of_node()`来遍历给定节点的子节点：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding excerpt, we learned how to iterate over the sub-nodes of a
    given device tree node.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们学习了如何遍历给定设备树节点的子节点。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The time to switch from hardcoded device configurations to device trees has
    come. This chapter gave you all the bases to handle device trees. Now you have
    the necessary skills to customize or add whatever node and property you want to
    the device tree and extract them from your driver.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从硬编码的设备配置切换到设备树的时机已经到来。本章为你提供了处理设备树的所有基础知识。现在你已经具备了自定义或添加任何节点和属性到设备树中的必要技能，并能从驱动中提取它们。
- en: In the next chapter, we will discuss the I2C driver, and use the device tree
    API to enumerate and configure our I2C devices.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论I2C驱动，并使用设备树API来枚举和配置我们的I2C设备。
