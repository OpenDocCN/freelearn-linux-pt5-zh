- en: Texting and Driving
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开车与发短信
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下几种解决方案：
- en: Using regular expressions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式
- en: Searching and mining text inside a file with grep
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`grep`在文件中搜索和挖掘文本
- en: Cutting a file column-wise with cut
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`cut`按列切割文件
- en: Using `sed` to perform text replacement
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sed`执行文本替换
- en: Using `awk` for advanced text processing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`awk`进行高级文本处理
- en: Finding the frequency of words used in a given file
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找文件中单词的使用频率
- en: Compressing or decompressing JavaScript
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩或解压JavaScript
- en: Merging multiple files as columns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个文件合并为列
- en: Printing the n^(th) word or column in a file or line
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印文件或行中的第n^(th)个单词或列
- en: Printing text between line numbers or patterns
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印行号或模式之间的文本
- en: Printing lines in the reverse order
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按反向顺序打印行
- en: Parsing e-mail address and URLs from text
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文本中解析电子邮件地址和URL
- en: Removing a sentence in a file containing a word
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除包含某个单词的文件中的一句话
- en: Replacing a pattern with text in all the files in a directory
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目录中的所有文件中用文本替换模式
- en: Text slicing and parameter operations
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本切片和参数操作
- en: Introduction
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Shell scripting includes many problem-solving tools. There is a rich set of
    tools for text processing. These tools include utilities, such as `sed`, `awk`,
    `grep`, and `cut`, which can be combined to perform text processing needs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Shell脚本包括许多问题解决工具。它提供了丰富的文本处理工具集。这些工具包括`sed`、`awk`、`grep`和`cut`等实用程序，它们可以组合起来执行文本处理任务。
- en: These utilities process files by character, line, word, column, or row to process
    text files in many ways.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具通过字符、行、单词、列或行来处理文件，能够以多种方式处理文本文件。
- en: Regular expressions are a basic pattern-matching technique. Most text-processing
    utilities support regular expressions. With regular expression strings, we can
    filter, strip, replace, and search within text files.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一种基本的模式匹配技术。大多数文本处理工具都支持正则表达式。通过正则表达式字符串，我们可以在文本文件中进行过滤、去除、替换和搜索。
- en: This chapter includes a collection of recipes to walk you through many solutions
    to text processing problems.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括一系列解决方案，帮助你了解如何处理各种文本处理问题。
- en: Using regular expressions
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式
- en: Regular expressions are at the heart of pattern-based text-processing. To use
    regular expressions effectively, one needs to understand them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是基于模式的文本处理的核心。为了有效使用正则表达式，我们需要理解它们。
- en: Everyone who uses `ls` is familiar with glob style patterns. Glob rules are
    useful in many situations, but are too limited for text processing. Regular expressions
    allow you to describe patterns in finer detail than glob rules.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个使用`ls`的人都熟悉glob样式的模式。glob规则在很多情况下都很有用，但对于文本处理来说，它们的功能太有限了。正则表达式允许你比glob规则更详细地描述模式。
- en: 'A typical regular expression to match an e-mail address might look like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的正则表达式来匹配电子邮件地址可能是这样的：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If this looks weird, don't worry; it is really simple once you understand the
    concepts through this recipe.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来有些奇怪，别担心；一旦你通过本教程理解了这些概念，实际上它非常简单。
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: '**Regular expressions** are composed of text fragments and symbols with special
    meanings. Using these, we can construct a regular expression to match any text.
    Regular expressions are the basis for many tools. This section describes regular
    expressions, but does not introduce the Linux/Unix tools that use them. Later
    recipes will describe the tools.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**由文本片段和具有特殊含义的符号组成。利用这些，我们可以构建一个正则表达式来匹配任何文本。正则表达式是许多工具的基础。本节介绍了正则表达式，但没有介绍使用它们的Linux/Unix工具。稍后的教程将介绍这些工具。'
- en: Regular expressions consist of one or more elements combined into a string.
    An element may be a position marker, an identifier, or a count modifier. A position
    marker anchors the regular expression to the beginning or end of the target string.
    An identifier defines one or more characters. The count modifier defines how many
    times an identifier may occur.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式由一个或多个元素组成，这些元素结合成一个字符串。一个元素可以是位置标记、标识符或计数修饰符。位置标记将正则表达式固定到目标字符串的开头或结尾。标识符定义一个或多个字符。计数修饰符定义标识符出现的次数。
- en: Before we look at some sample regular expressions, let's look at the rules.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看一些示例正则表达式之前，先来看一下规则。
- en: Position markers
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置标记
- en: A position marker anchors a regular expression to a position in the string.
    By default, any set of characters that match a regular expression can be used,
    regardless of position in the string.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 位置标记将正则表达式固定到字符串中的某个位置。默认情况下，任何与正则表达式匹配的字符集都可以使用，而不论它们在字符串中的位置。
- en: '| **regex** | **Description** | **Example** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **正则表达式** | **描述** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `^` | This specifies that the text that matches the regular expression must
    start at the beginning of the string | `^tux` matches a line that starts with
    `tux` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 这指定正则表达式匹配的文本必须从字符串的开头开始 | `^tux` 匹配以 `tux` 开头的行 |'
- en: '| `$` | This specifies that the text that matches the regular expression must
    end with the last character in the target string | `tux$` matches a line that
    ends with `tux` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 这指定正则表达式匹配的文本必须以目标字符串的最后一个字符结尾 | `tux$` 匹配以 `tux` 结尾的行 |'
- en: Identifiers
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标识符
- en: Identifiers are the basis of regular expressions. These define the characters
    that must be present (or absent) to match the regular expression.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符是正则表达式的基础。这些定义了必须存在（或不存在）的字符，以匹配正则表达式。
- en: '| **regex** | **Description** | **Example** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **正则表达式** | **描述** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `A` character | The regular expression must match this letter. | `A` will
    match the letter A |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `A` 字符 | 正则表达式必须匹配此字母 | `A` 将匹配字母 A |'
- en: '| `.` | This matches any one character. | `"Hack."` matches `Hack1`, `Hacki`,
    but not `Hack12` or `Hackil`; only one additional character matches |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 这匹配任意一个字符 | `"Hack."` 匹配 `Hack1`、`Hacki`，但不匹配 `Hack12` 或 `Hackil`；仅匹配一个额外字符
    |'
- en: '| `[]` | This matches any one of the characters enclosed in the brackets. The
    enclosed characters may be a set or a range. | `coo[kl]` matches `cook` or `cool`;
    [0-9] matches any single digit |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `[]` | 这匹配方括号内的任意一个字符。方括号内的字符可以是一个集合或范围 | `coo[kl]` 匹配 `cook` 或 `cool`；`[0-9]`
    匹配任意一个数字 |'
- en: '| `[^]` | This matches any one of the characters except those that are enclosed
    in square brackets. The enclosed characters may be a set or a range. | `9[^01]`
    matches `92` and `93`, but not `91` and `90`; `A[^0-9]` matches an `A` followed
    by anything except a digit |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `[^]` | 这匹配除了方括号内的字符之外的任意一个字符。方括号内的字符可以是一个集合或范围。 | `9[^01]` 匹配 `92` 和 `93`，但不匹配
    `91` 和 `90`；`A[^0-9]` 匹配字母 `A` 后跟除数字外的任意字符 |'
- en: Count modifiers
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数修饰符
- en: An Identifier may occur once, never, or many times. The Count Modifier defines
    how many times a pattern may appear.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个标识符可以出现一次、永不出现或多次。计数修饰符定义了一个模式可以出现多少次。
- en: '| **regex** | **Description** | **Example** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **正则表达式** | **描述** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `?` | This means that the preceding item must match one or zero times | `colou?r`
    matches `color` or `colour`, but not `colouur` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 这意味着前面的项必须匹配一次或零次 | `colou?r` 匹配 `color` 或 `colour`，但不匹配 `colouur`
    |'
- en: '| `+` | This means that the preceding item must match one or more times | `Rollno-9+`
    matches `Rollno-99` and `Rollno-9`, but not `Rollno-` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 这意味着前面的项必须匹配一次或多次 | `Rollno-9+` 匹配 `Rollno-99` 和 `Rollno-9`，但不匹配 `Rollno-`
    |'
- en: '| `*` | This means that the preceding item must match zero or more times |
    `co*l` matches `cl`, `col`, and `coool` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 这意味着前面的项必须匹配零次或多次 | `co*l` 匹配 `cl`、`col` 和 `coool` |'
- en: '| `{n}` | This means that the preceding item must match n times | `[0-9]{3}`
    matches any three-digit number; `[0-9]{3}` can be expanded as `[0-9][0-9][0-9]`
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `{n}` | 这意味着前面的项必须匹配 n 次 | `[0-9]{3}` 匹配任意三位数；`[0-9]{3}` 可以扩展为 `[0-9][0-9][0-9]`
    |'
- en: '| `{n,}` | This specifies the minimum number of times the preceding item should
    match | `[0-9]{2,}` matches any number that is two digits or longer |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `{n,}` | 这指定了前面的项必须至少匹配 n 次 | `[0-9]{2,}` 匹配任意一个两位数或更长的数字 |'
- en: '| `{n, m}` | This specifies the minimum and maximum number of times the preceding
    item should match | `[0-9]{2,5}` matches any number that has two digits to five
    digits |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `{n, m}` | 这指定了前面的项应至少匹配 n 次，最多匹配 m 次 | `[0-9]{2,5}` 匹配任何一个两位数到五位数的数字 |'
- en: Other
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他
- en: Here are other characters that fine–tune how a regular expression will be parsed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些其他字符，用来微调正则表达式的解析方式。
- en: '| `()` | This treats the terms enclosed as one entity | `ma(tri)?x` matches
    `max` or `matrix` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `()` | 这将括号内的内容视为一个整体 | `ma(tri)?x` 匹配 `max` 或 `matrix` |'
- en: '| `&#124;` | This specifies alternation-; one of the items on either of side
    of `&#124;` should match | `Oct (1st &#124; 2nd)` matches `Oct 1st` or `Oct 2nd`
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 这指定了交替；`&#124;` 两边的任意一项应匹配 | `Oct (1st &#124; 2nd)` 匹配 `Oct 1st`
    或 `Oct 2nd` |'
- en: '| `\` | This is the escape character for escaping any of the special characters
    mentioned previously | `a\.b` matches `a.b`, but not `ajb`; it ignores the special
    meaning of `.` because of `\` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `\` | 这是转义字符，用于转义前面提到的任何特殊字符 | `a\.b` 匹配 `a.b`，但不匹配 `ajb`；它忽略了 `.` 的特殊含义，因为有了
    `\` |'
- en: For more details on the regular expression components available, you can refer
    to [http://www.linuxforu.com/2011/04/sed-explained-part-1/](http://www.linuxforu.com/2011/04/sed-explained-part-1/).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可用的正则表达式组件的更多细节，你可以参考[http://www.linuxforu.com/2011/04/sed-explained-part-1/](http://www.linuxforu.com/2011/04/sed-explained-part-1/)。
- en: There's more...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Let''s see a few examples of regular expressions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些正则表达式的例子：
- en: 'This regular expression would match any single word:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式会匹配任何单个单词：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The initial `+` characters say we need 1 or more spaces.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的`+`字符表示我们需要一个或多个空格。
- en: The `[a-zA-Z]` set is all upper– and lower–case letters. The following plus
    sign says we need at least one letter and can have more.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`[a-zA-Z]`集合是所有大写和小写字母。后面的加号表示我们需要至少一个字母，并且可以有更多字母。'
- en: The final `+` characters say we need to terminate the word with one or more
    spaces.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`+`字符表示我们需要以一个或多个空格终止单词。
- en: 'This would not match the last word in a sentence. To match the last word in
    a sentence or the word before a comma, we write the expression like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将不会匹配句子中的最后一个单词。为了匹配句子中的最后一个单词或逗号前的单词，我们可以这样写表达式：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `[?,\.]?` phrase means we might have a question mark, comma, or a period,
    but at most one. The period is escaped with a backslash because a bare period
    is a wildcard that will match anything.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`[?,\.]?`短语表示我们可能有一个问号、逗号或句点，但最多只有一个。句点被反斜杠转义，因为裸句点是一个通配符，能够匹配任何字符。'
- en: It's easier to match an IP address. We know we'll have four three-digit numbers
    separated by periods.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配IP地址更容易了。我们知道我们会有四个三位数的数字，且这些数字由句点分隔。
- en: 'The `[0-9]` phrase defines a number. The `{1,3}` phrase defines the count as
    being at least one digit and no more than three digits:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`[0-9]`短语定义了一个数字。`{1,3}`短语定义了计数为至少一个数字，最多三个数字：'
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also define an IP address using the `[[:digit:]]` construct to define
    a number:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`[[:digit:]]`构造来定义一个数字，从而定义IP地址：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We know that an IP address is in the range of four integers (each from 0 to
    255), separated by dots (for example, `192.168.0.2`).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，IP 地址由四个整数（每个整数从 0 到 255）组成，且由点分隔（例如，`192.168.0.2`）。
- en: This regex will match an IP address in the text being processed. However, it
    doesn't check for the validity of the address. For example, an IP address of the
    form `123.300.1.1` will be matched by the regex despite being an invalid IP.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式将匹配正在处理文本中的IP地址。然而，它并没有检查地址的有效性。例如，形式为`123.300.1.1`的IP地址虽然无效，但也会被这个正则表达式匹配。
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Regular expressions are parsed by a complex state machine that tries to find
    the best match for a regular expression with a string of target text. That text
    can be the output of a pipe, a file, or even a string you type on the command
    line. If there are multiple ways to fulfill a regular expression, the engine will
    usually select the largest set of characters that match.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是通过一个复杂的状态机解析的，状态机会尝试找到一个正则表达式与目标文本字符串的最佳匹配。这个文本可以是管道的输出、一个文件，甚至是你在命令行上输入的字符串。如果有多种方式可以满足正则表达式，引擎通常会选择匹配字符最多的一组。
- en: For example, given the string `this is a test` and a regular expression `s.*s`,
    the match will be `s is a tes`, not `s is`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定字符串`this is a test`和正则表达式`s.*s`，匹配结果将是`s is a tes`，而不是`s is`。
- en: For more details on the regular expression components available, you can refer
    to [http://www.linuxforu.com/2011/04/sed-explained-part-1/](http://www.linuxforu.com/2011/04/sed-explained-part-1/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可用的正则表达式组件的更多细节，你可以参考[http://www.linuxforu.com/2011/04/sed-explained-part-1/](http://www.linuxforu.com/2011/04/sed-explained-part-1/)。
- en: There's more...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The previous tables described the special meanings for characters used in regular
    expressions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表格描述了正则表达式中使用字符的特殊含义。
- en: Treatment of special characters
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊字符的处理
- en: Regular expressions use some characters, such as `$`, `^`, `.`, `*`, `+`, `{`,
    and `}`, as special characters. But, what if we want to use these characters as
    normal text characters? Let's see an example of a regex, `a.txt`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式使用一些字符，如`$`、`^`、`.`、`*`、`+`、`{`和`}`，作为特殊字符。但是，如果我们想将这些字符作为普通文本字符使用呢？我们来看一个正则表达式的例子，`a.txt`。
- en: This will match the character `a`, followed by any character (due to the `.`
    character), which is then followed by the `txt` string. However, we want `.` to
    match a literal `.` instead of any character. In order to achieve this, we precede
    the character with a backward slash `\` (doing this is called escaping the character).
    This indicates that the regex wants to match the literal character rather than
    its special meaning. Hence, the final regex becomes `a\.txt`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配字符`a`，后面跟着任何字符（因为`.`字符），然后是`txt`字符串。然而，我们希望`.`匹配字面上的`.`而不是任意字符。为了实现这一点，我们在字符前加上反斜杠`\`（这种做法称为转义字符）。这表示正则表达式要匹配字面字符，而不是它的特殊含义。因此，最终的正则表达式变为`a\.txt`。
- en: Visualizing regular expressions
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式的可视化
- en: 'Regular expressions can be tough to understand. Fortunately, there are utilities
    available to help in visualizing regex. The page at [http://www.regexper.com](http://www.regexper.com)
    lets you enter a regular expression and creates a graph to help you understand
    it. Here is a screenshot describing a simple regular expression:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式可能难以理解。幸运的是，有一些工具可以帮助可视化正则表达式。页面[http://www.regexper.com](http://www.regexper.com)允许你输入正则表达式，并创建一个图形来帮助你理解它。以下是描述一个简单正则表达式的截图：
- en: '![](img/B05265_04_image.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05265_04_image.png)'
- en: Searching and mining text inside a file with grep
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`grep`在文件中搜索和挖掘文本
- en: If you forget where you left your keys, you've just got to search for them.
    If you forget what file has some information, the `grep` command will find it
    for you. This recipe will teach you how to locate files that contain patterns.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了把钥匙放在哪里，你只需搜索它们。如果你忘记了哪个文件包含某些信息，`grep`命令会为你找到它。本篇将教你如何定位包含模式的文件。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The `grep` command is the magic Unix utility for searching text. It accepts
    regular expressions and can produce reports in various formats.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`命令是一个强大的Unix工具，用于搜索文本。它接受正则表达式并可以以各种格式生成报告。'
- en: 'Search `stdin` for lines that match a pattern:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`stdin`中搜索与模式匹配的行：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Search a single file for lines that contain a given pattern:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单个文件中搜索包含给定模式的行：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, this performs the same search:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，这也会执行相同的搜索：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Search multiple files for lines that match a pattern:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在多个文件中搜索与模式匹配的行：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To highlight the matching pattern, use the `-color` option. While the option
    position does not matter, the convention is to place options first.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要突出显示匹配的模式，可以使用`-color`选项。虽然选项的位置无关紧要，但约定是将选项放在前面。
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `grep` command uses basic regular expressions by default. These are a subset
    of the rules described earlier. The `-E` option will cause `grep` to use the **Extended
    Regular Expression** syntax. The `egrep` command is a variant of `grep` that uses
    extended regular expression by default:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`grep`命令默认使用基本正则表达式。这些是前面描述的规则的子集。`-E`选项将使`grep`使用**扩展正则表达式**语法。`egrep`命令是`grep`的变体，默认使用扩展正则表达式：'
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Or:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `-o` option will report only the matching characters, not the entire line:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-o`选项将仅报告匹配的字符，而不是整个行：'
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `-v` option will print all lines, except those containing `match_pattern`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-v`选项将打印所有行，除了包含`match_pattern`的行：'
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `-v` option added to `grep` inverts the match results.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`-v`选项到`grep`将反转匹配结果。
- en: 'The `-c` option will count the number of lines in which the pattern appears:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-c`选项将统计模式出现的行数：'
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It should be noted that `-c` counts the number of matching lines, not the number
    of times a match is made. Consider this example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，`-c`统计的是匹配行的数量，而不是匹配的次数。请看这个例子：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Even though there are six matching items, `grep` reports `2`, since there are
    only two matching lines. Multiple matches in a single line are counted only once.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有六个匹配项，`grep`只报告`2`，因为只有两行匹配。单行中的多个匹配项只计算一次。
- en: 'To count the number of matching items in a file, use this trick:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要计算文件中匹配项的数量，请使用这个技巧：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `-n` option will print the line number of the matching string:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-n`选项将打印匹配字符串的行号：'
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Or
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If multiple files are used, the `-c` option will print the filename with the
    result:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用多个文件，`-c`选项将打印带有结果的文件名：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `-b` option will print the offset of the line in which a match occurs.
    Adding the `-o` option will print the exact character or byte offset where the
    pattern matches:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-b`选项将打印匹配发生的行的偏移量。添加`-o`选项将打印模式匹配的精确字符或字节偏移量：'
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Character positions are numbered from `0`, not from `1`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 字符位置从`0`开始编号，而不是从`1`开始。
- en: 'The `-l` option lists which files contain the pattern:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-l`选项列出哪些文件包含模式：'
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The inverse of the `-l` argument is `-L`. The `-L` argument returns a list of
    nonmatching files.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`-l`参数的反向参数是`-L`。`-L`参数返回不匹配的文件列表。'
- en: There's more...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `grep` command is one of the most versatile Linux/Unix commands. It also
    includes options to search through folders, select files to search, and more options
    for identifying patterns.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`命令是最通用的Linux/Unix命令之一。它还包括选项来搜索文件夹、选择要搜索的文件以及更多用于识别模式的选项。'
- en: Recursively searching many files
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归搜索多个文件
- en: 'To recursively search for a text in files contained in a file hierarchy, use
    the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要递归地搜索文件层级结构中的文件中的文本，请使用以下命令：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this command, `.` specifies the current directory.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，`.`指定当前目录。
- en: The options `-R` and `-r` mean the same thing when used with `grep`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当与`grep`一起使用时，`-R`和`-r`选项的含义相同。
- en: 'Consider this example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`test_function()` exists in line number 16 of `miscutils/test.c`. The `-R`
    option is particularly useful if you are searching for a phrase in a website or
    source code tree. It is equivalent to this command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_function()`位于`miscutils/test.c`的第16行。`-R`选项在搜索网站或源代码树中的短语时特别有用。它等同于以下命令：'
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Ignoring case in patterns
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略模式中的大小写
- en: 'The `-i` argument matches patterns without considering the uppercase or lowercase:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i`参数在匹配模式时不考虑大小写：'
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: grep by matching multiple patterns
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个模式进行`grep`匹配
- en: 'The `-e` argument specifies multiple patterns for matching:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`-e`参数指定多个用于匹配的模式：'
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will print the lines that contain either of the patterns and output one
    line for each match. Consider this example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印包含任意模式的行，并为每个匹配输出一行。考虑以下示例：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Multiple patterns can be defined in a file. The `-f` option will read the file
    and use the line-separated patterns:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在一个文件中定义多个模式。`-f`选项将读取文件并使用按行分隔的模式：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Consider the following example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Including and excluding files in a grep search
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`grep`搜索中包括和排除文件
- en: '`grep` can include or exclude files in which to search with wild card patterns.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`可以通过通配符模式包含或排除文件进行搜索。'
- en: 'To recursively search only for the `.c` and `.cpp` files, use the -include
    option:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅递归搜索`.c`和`.cpp`文件，请使用`-include`选项：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that `some{string1,string2,string3}` expands as `somestring1 somestring2
    somestring3`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`some{string1,string2,string3}`扩展为`somestring1 somestring2 somestring3`。
- en: 'Use the `-exclude` flag to exclude all `README` files from the search:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-exclude`标志排除所有`README`文件的搜索：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `--exclude-dir` option will exclude the named directories from the search:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`--exclude-dir`选项将排除指定目录的搜索：'
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To read a list of files to exclude from a file, use `--exclude-from FILE`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文件中读取排除文件的列表，使用`--exclude-from FILE`。
- en: Using grep with xargs with the zero-byte suffix
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用带有零字节后缀的`xargs`与`grep`
- en: The `xargs` command provides a list of command-line arguments to another command.
    When filenames are used as command-line arguments, use a zero-byte terminator
    for the filenames instead of the default space terminator. Filenames can contain
    space characters, which will be misinterpreted as name separators, causing a filename
    to be broken into two filenames (for example, `New file.txt` might be interpreted
    as two filenames `New` and `file.txt`). Using the zero-byte suffix option solves
    this problem. We use `xargs` to accept `stdin` text from commands such as `grep`
    and `find`. These commands can generate output with a zero-byte suffix. The `xargs`
    command will expect `0` byte termination when the `-0` flag is used.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`命令将一系列命令行参数提供给另一个命令。当文件名作为命令行参数使用时，请使用零字节终止符代替默认的空格终止符。文件名可以包含空格字符，这将被误解释为名称分隔符，导致文件名被拆分成两个文件名（例如，`New
    file.txt`可能会被解释为两个文件名`New`和`file.txt`）。使用零字节后缀选项可以解决此问题。我们使用`xargs`从诸如`grep`和`find`等命令接收`stdin`文本。这些命令可以生成带有零字节后缀的输出。当使用`-0`标志时，`xargs`命令会期望使用零字节终止符。'
- en: 'Create some test files:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一些测试文件：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `-l` option tells `grep` to output only the filenames where a match occurs.
    The `-Z` option causes `grep` to use the zero-byte terminator (`\0`) for these
    files. These two options are frequently used together. The `-0` argument to `xargs`
    makes it read the input and separate filenames at the zero-byte terminator:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`-l`选项告诉`grep`仅输出匹配发生的文件名。`-Z`选项使`grep`为这些文件使用零字节终止符（`\0`）。这两个选项通常一起使用。`xargs`的`-0`参数使其读取输入并以零字节终止符分隔文件名：'
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Silent output for grep
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`grep`的静默输出'
- en: Sometimes, instead of examining at the matched strings, we are only interested
    in whether there was a match or not. The quiet option (`-q`), causes `grep` to
    run silently and not generate any output. Instead, it runs the command and returns
    an exit status based on success or failure. The return status is `0` for success
    and nonzero for failure.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们并不关心匹配的字符串，而只关心是否有匹配。安静选项（`-q`）使 `grep` 静默运行，并且不会生成任何输出。相反，它运行命令并返回基于成功或失败的退出状态。返回状态为
    `0` 表示成功，非零表示失败。
- en: 'The `grep` command can be used in quiet mode, for testing whether a match text
    appears in a file or not:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep` 命令可以在安静模式下使用，用于测试匹配文本是否出现在文件中：'
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `silent_grep.sh` script accepts two command-line arguments, a match word
    (`Student`), and a file name (`student_data.txt`):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`silent_grep.sh` 脚本接受两个命令行参数，一个是匹配词（`Student`），另一个是文件名（`student_data.txt`）：'
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Printing lines before and after text matches
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印匹配文本前后行
- en: Context-based printing is one of the nice features of `grep`. When grep finds
    lines that match the pattern, it prints only the matching lines. We may need to
    see *n* lines before or after the matching line. The `-B` and `-A` options display
    lines before and after the match, respectively.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 基于上下文的打印是 `grep` 的一个优点。当 `grep` 找到与模式匹配的行时，它只会打印匹配的行。我们可能需要查看匹配行之前或之后的 *n* 行。`-B`
    和 `-A` 选项分别显示匹配前后的行。
- en: 'The `-A` option prints lines after a match:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`-A` 选项打印匹配后的行：'
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `-B` option prints lines before the match:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`-B` 选项打印匹配前的行：'
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `-A` and `-B` options can be used together, or the `-C` option can be used
    to print the same number of lines before and after the match:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`-A` 和 `-B` 选项可以一起使用，或者使用 `-C` 选项打印匹配前后相同数量的行：'
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If there are multiple matches, then each section is delimited by a `--` line:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个匹配项，则每个部分由 `--` 行分隔：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Cutting a file column-wise with cut
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `cut` 按列切割文件
- en: The cut command splits a file by column instead of lines. This is useful for
    processing files with fixed-width fields, **Comma Separated Values** (**CSV**
    files), or space delimited files such as the standard log files.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`cut` 命令按列拆分文件，而不是按行拆分。这对于处理具有固定宽度字段的文件、**逗号分隔值**（**CSV** 文件）或像标准日志文件这样的空格分隔文件非常有用。'
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: The `cu`t command extracts data between character locations or columns. You
    can specify the delimiter that separates each column. In the `cut` terminology,
    each column is known as a **field**.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`cut` 命令提取字符位置或列之间的数据。你可以指定分隔符来分隔每一列。在 `cut` 的术语中，每一列被称为 **字段**。'
- en: 'The -f option defines the fields to extract:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-f` 选项定义要提取的字段：'
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`FIELD_LIST` is a list of columns that are to be displayed. The list consists
    of column numbers delimited by commas. Consider this example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`FIELD_LIST` 是一个要显示的列的列表。该列表由用逗号分隔的列号组成。参考以下示例：'
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, the second and the third columns are displayed.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，显示了第二列和第三列。
- en: The `cut` command also reads input from `stdin`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cut` 命令也可以从 `stdin` 读取输入。'
- en: '*Tab* is the default delimiter for fields. Lines without delimiters will be
    printed. The `-s` option will disable printing lines without delimiter characters.
    The following commands demonstrate extracting columns from a tab delimited file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*Tab* 是字段的默认分隔符。没有分隔符的行将被打印。`-s` 选项将禁用打印没有分隔符字符的行。以下命令演示了如何从制表符分隔的文件中提取列：'
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To extract multiple fields provide multiple field numbers separated by commas,
    using the following options:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要提取多个字段，请提供多个由逗号分隔的字段编号，使用以下选项：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `--complement` option will display all the fields except those defined
    by `-f`. This command displays all fields except `3`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`--complement` 选项将显示除了 `-f` 定义的字段之外的所有字段。此命令显示除了 `3` 之外的所有字段：'
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `-d` option will set the delimiter. The following command shows how to
    use `cut` with a colon-separated list:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-d` 选项将设置分隔符。以下命令展示了如何使用 `cut` 处理冒号分隔的列表：'
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There's more
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: The `cut` command has more options to define the columns displayed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`cut` 命令有更多选项来定义显示的列。'
- en: Specifying the range of characters or bytes as fields
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将字符或字节的范围指定为字段
- en: A report with fixed-width columns will have varying numbers of spaces between
    the columns. You can't extract values based on field position, but you can extract
    them based on the character location. The `cut` command can select based on bytes
    or characters as well as fields.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 固定宽度列的报告将在列之间有不同数量的空格。你不能根据字段位置提取值，但可以根据字符位置提取。`cut` 命令可以基于字节或字符以及字段进行选择。
- en: 'It''s unreasonable to enter every character position to extract, so cut accepts
    these notations as well as the comma-separated list:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 逐个字符位置提取是不合理的，因此`cut`命令接受这些符号以及逗号分隔的列表：
- en: '| `N-` | From the *N^(th)* byte, character, or field, to the end of the line
    |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `N-` | 从*第N次*字节、字符或字段到行的末尾 |'
- en: '| `N-M` | From the *N^(th)* to *M^(th)* (included) byte, character, or field
    |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `N-M` | 从*第N次*到*第M次*（包括）字节、字符或字段 |'
- en: '| `-M` | From the first to *M^(th)* (included) byte, character, or field |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `-M` | 从第一个到*第M次*（包括）字节、字符或字段 |'
- en: 'We use the preceding notations to specify fields as a range of bytes, characters,
    or fields with the following options:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用前面的符号来指定字节、字符或字段的范围，使用以下选项：
- en: '`-b` for bytes'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-b`表示字节'
- en: '`-c` for characters'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c`表示字符'
- en: '`-f` for defining fields'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`用于定义字段'
- en: 'Consider this example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个示例：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Display the second to fifth characters:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 显示第二到第五个字符：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Display the first two characters:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 显示前两个字符：
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Replace `-c` with `-b` to count in bytes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 用`-b`替换`-c`以按字节计数。
- en: 'The `-output-delimiter` option specifies the output delimiter. This is particularly
    useful when displaying multiple sets of data:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`-output-delimiter`选项指定输出分隔符。这在显示多个数据集时特别有用：'
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Using sed to perform text replacement
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`sed`执行文本替换
- en: '`sed` stands for **stream editor**. It''s most commonly used for text replacement.
    This recipe covers many common `sed` techniques.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`代表**流编辑器**。它最常用于文本替换。本教程涵盖了许多常见的`sed`技巧。'
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The `sed` command can replace occurrences of a pattern with another string.
    The pattern can be a simple string or a regular expression:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`命令可以将模式的出现替换为另一字符串。该模式可以是简单的字符串或正则表达式：'
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Alternatively, `sed` can read from `stdin`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，`sed`可以从`stdin`读取：
- en: '[PRE52]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If you use the `vi` editor, you will notice that the command to replace the
    text is very similar to the one discussed here. By default, `sed` only prints
    the substituted text, allowing it to be used in a pipe.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`vi`编辑器，你会注意到，替换文本的命令与此处讨论的非常相似。默认情况下，`sed`仅打印替换后的文本，可以在管道中使用它。
- en: '[PRE53]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `-I` option will cause `sed` to replace the original file with the modified
    data:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-I`选项将使`sed`用修改后的数据替换原始文件：'
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The previous example replaces the first occurrence of the pattern in each line.
    The `-g` parameter will cause `sed` to replace every occurrence:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一个示例替换了每行中模式的第一次出现。`-g`参数将使`sed`替换每次出现：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `/#g` option will replace from the *N^(th)* occurrence onwards:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`/#g`选项将从*第N次*出现位置开始替换：'
- en: '[PRE56]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `sed` command treats the character following `s` as the command delimiter.
    This allows us to change strings with a `/` character in them:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`命令将`s`后面的字符视为命令分隔符。这样我们就可以更改包含`/`字符的字符串：'
- en: '[PRE57]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When the delimiter character appears inside the pattern, we have to escape
    it using the `\` prefix, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当分隔符字符出现在模式内部时，必须使用`\`前缀对其进行转义，如下所示：
- en: '[PRE58]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`\|` is a delimiter appearing in the pattern replaced with escape.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`\|`是出现在模式中的分隔符，被转义替代。'
- en: There's more...
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: The `sed` command supports regular expressions as the pattern to be replaced
    and has more options to control its behavior.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`命令支持正则表达式作为要替换的模式，并提供更多选项来控制其行为。'
- en: Removing blank lines
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除空行
- en: Regular expression support makes it easy to remove blank lines. The `^$` regular
    expression defines a line with nothing between the beginning and end == a blank
    line. The final `/d` tells sed to delete the lines, rather than performing a substitution.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式支持使得删除空行变得容易。`^$`正则表达式定义了一个从开始到结束之间没有任何内容的行==空行。最后的`/d`命令告诉`sed`删除这些行，而不是进行替换。
- en: '[PRE59]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Performing replacement directly in the file
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在文件中直接进行替换
- en: 'When a filename is passed to `sed`, it usually prints to `stdout`. The `-I`
    option will cause `sed` to modify the contents of the file in place:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件名传递给`sed`时，它通常会打印到`stdout`。`-I`选项将使`sed`直接在文件中修改内容：
- en: '[PRE60]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For example, replace all three-digit numbers with another specified number
    in a file, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在文件中将所有三位数字替换为另一个指定的数字，如下所示：
- en: '[PRE61]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The preceding one-liner replaces three-digit numbers only. `\b[0-9]\{3\}\b`
    is the regular expression used to match three-digit numbers. `[0-9]` is the range
    of digits from `0` to `9`. The `{3}` string defines the count of digits. The backslash
    is used to give a special meaning for `{` and `}` and `\b` stands for a blank,
    the word boundary marker.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 上述单行命令只替换三位数的数字。`\b[0-9]\{3\}\b`是用来匹配三位数的正则表达式。`[0-9]`是从`0`到`9`的数字范围。`{3}`定义了数字的数量。反斜杠用于赋予`{`和`}`特殊意义，`\b`表示空白字符，表示单词边界。
- en: 'It''s a useful practice to first try the `sed` command without `-i` to make
    sure your regex is correct. After you are satisfied with the result, add the `-i`
    option to make changes to the file. Alternatively, you can use the following form
    of `sed`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的做法是首先尝试没有`-i`的`sed`命令，以确保你的正则表达式是正确的。等你对结果满意后，再加上`-i`选项以修改文件。或者，你也可以使用以下形式的`sed`：
- en: '[PRE62]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this case, `sed` will perform the replacement on the file and also create
    a file called `file.bak`, which contains the original contents.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`sed`会在文件上执行替换，并且还会创建一个名为`file.bak`的文件，包含原始内容。
- en: Matched string notation ()
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配字符串标记()
- en: 'The `&` symbol is the matched string. This value can be used in the replacement
    string:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`符号是匹配到的字符串。这个值可以在替换字符串中使用：'
- en: '[PRE63]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here, the `\w\+` regex matches every word. Then, we replace it with `[&]`, which
    corresponds to the word that is matched.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`\w\+`正则表达式匹配每个单词。然后，我们用`[&]`替换它，`&`对应于匹配的单词。
- en: Substring match notation (\1)
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子字符串匹配标记（\1）
- en: '`&` corresponds to the matched string for the given pattern. Parenthesized
    portions of a regular expression can be matched with `\#`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`对应给定模式的匹配字符串。正则表达式中的括号部分可以用`\#`来匹配：'
- en: '[PRE64]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The preceding command replaces `digit 7` with `7`. The substring matched is
    `7`. `\(pattern\)` matches the substring. The pattern is enclosed in `()` and
    is escaped with backslashes. For the first substring match, the corresponding
    notation is `\1`, for the second, it is `\2`, and so on.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将`digit 7`替换为`7`。匹配到的子字符串是`7`。`\ (pattern\)`匹配该子字符串。模式被包含在`()`中，并使用反斜杠进行转义。对于第一个子字符串匹配，相应的标记是`\1`，对于第二个是`\2`，以此类推。
- en: '[PRE65]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`([a-z]\+\)` matches the first word and `\([A-Z]\+\)` matches the second word;
    `\1` and `\2` are used for referencing them. This type of referencing is called
    **back referencing**. In the replacement part, their order is changed as `\2 \1`,
    and hence, it appears in the reverse order.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`([a-z]\+\)`匹配第一个单词，`\([A-Z]\+\)`匹配第二个单词；`\1`和`\2`用来引用它们。这种引用方式叫做**反向引用**。在替换部分，它们的顺序被更改为`\2
    \1`，因此出现的是反向顺序。'
- en: Combining multiple expressions
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合多个表达式
- en: 'Multiple `sed` commands can be combined with pipes, patterns separated by semicolons,
    or the `-e PATTERN` option:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 多个`sed`命令可以通过管道符连接，模式由分号分隔，或者使用`-e PATTERN`选项：
- en: '[PRE66]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The preceding command is equivalent to the following commands:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令等同于以下命令：
- en: '[PRE67]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Or:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE68]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Consider these examples:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 看这些例子：
- en: '[PRE69]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Quoting
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引号
- en: The `sed` expression is commonly quoted with single quotes. Double quotes can
    be used. The shell will expand double quotes before invoking sed. Using double
    quotes is useful when we want to use a variable string in a `sed` expression.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`表达式通常用单引号引起来。也可以使用双引号，shell会在调用sed之前展开双引号。使用双引号在我们想在`sed`表达式中使用变量字符串时非常有用。'
- en: 'Consider this example:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 看这个例子：
- en: '[PRE70]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`$text` is evaluated as `hello`.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`$text`被评估为`hello`。'
- en: Using awk for advanced text processing
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用awk进行高级文本处理
- en: The `awk` command processes data streams. It supports associative arrays, recursive
    functions, conditional statements, and more.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`命令处理数据流。它支持关联数组、递归函数、条件语句等。'
- en: Getting ready
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The structure of an `awk` script is:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`awk`脚本的结构是：
- en: '[PRE71]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `awk` command can also read from `stdin`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`命令也可以从`stdin`读取数据。'
- en: An `awk` script includes up to three parts–:`BEGIN`, `END`, and a common statement
    block with the pattern match option. These are optional and any of them can be
    absent in the script.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`awk`脚本包含最多三部分：`BEGIN`，`END`，以及带有模式匹配选项的常规语句块。这些部分是可选的，脚本中可以没有任何一部分。
- en: Awk will process the file line by line. The commands following `BEGIN` will
    be evaluated before `<code>awk</code>` starts processing the file. Awk will process
    each line that matches PATTERN with the commands that follow PATTERN. Finally,
    after processing the entire file, `<CODE>awk</CODE>` will process the commands
    that follow `END`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk` 会逐行处理文件。在 `<code>awk</code>` 开始处理文件之前，`BEGIN` 后的命令会被先行评估。`awk` 会处理与 PATTERN
    匹配的每一行，并执行紧随其后的命令。最后，在处理完所有文件内容后，`<CODE>awk</CODE>` 会执行 `END` 后的命令。'
- en: How to do it...
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s write a simple `awk` script enclosed in single quotes or double quotes:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的 `awk` 脚本，用单引号或双引号括起来：
- en: '[PRE72]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Or:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE73]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This command will report the number of lines in a file:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将报告文件中的行数：
- en: '[PRE74]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Or:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE75]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: How it works...
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `awk` command processes arguments in the following order:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk` 命令按以下顺序处理参数：'
- en: First, it executes the commands in the `BEGIN { commands }` block.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它执行 `BEGIN { commands }` 代码块中的命令。
- en: Next, `awk` reads one line from the file or `stdin`, and executes the `commands`
    block if the optional pattern is matched. It repeats this step until the end of
    file.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`awk` 会从文件或 `stdin` 中读取一行，并在可选模式匹配时执行 `commands` 代码块。它会重复这个过程直到文件末尾。
- en: When the end of the input stream is reached, it executes the `END { commands
    }` block.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当输入流结束时，它会执行 `END { commands }` 代码块。
- en: The `BEGIN` block is executed before `awk` starts reading lines from the input
    stream. It is an optional block. The commands, such as variable initialization
    and printing the output header for an output table, are common comamnds in the
    `BEGIN` block.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`BEGIN` 代码块在 `awk` 开始读取输入流中的行之前执行。它是一个可选的代码块。诸如变量初始化和为输出表格打印标题等命令，通常出现在 `BEGIN`
    代码块中。'
- en: The `END` block is similar to the `BEGIN` block. It gets executed when `awk`
    completes reading all the lines from the input stream. This is commonly printing
    results after analyzing all the lines.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`END` 代码块类似于 `BEGIN` 代码块。它会在 `awk` 完成读取输入流中的所有行后执行。通常在分析完所有行后，使用该代码块打印结果。'
- en: The most important block holds the common commands with the pattern block. This
    block is also optional. If it is not provided, `{ print }` gets executed to print
    each line read. This block gets executed for each line read by `awk`. It is like
    a `while` loop, with statements to execute inside the body of the loop.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的代码块包含常见命令和模式代码块。这个代码块也是可选的。如果未提供该代码块，`{ print }` 会被执行来打印每一行。这个代码块会在 `awk`
    读取的每一行上执行。它类似于一个 `while` 循环，循环体内会执行语句。
- en: When a line is read, `awk` checks whether the pattern matches the line. The
    pattern can be a regular expression match, conditions, a range of lines, and so
    on. If the current line matches the pattern, `awk` executes the commands enclosed
    in `{ }`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当一行被读取时，`awk` 会检查该行是否与模式匹配。模式可以是正则表达式匹配、条件、行范围等。如果当前行与模式匹配，`awk` 会执行 `{ }` 中的命令。
- en: 'The pattern is optional. If it is not used, all lines are matched:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 模式是可选的。如果不使用模式，则匹配所有行：
- en: '[PRE76]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: When `print` is used without an argument, `awk` prints the current line.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `print` 未带任何参数时，`awk` 会打印当前行。
- en: The print command can accept arguments. These arguments are separated by commas,
    they are printed with a space delimiter. Double quotes are used as the concatenation
    operator.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 命令可以接受多个参数。这些参数用逗号分隔，并会以空格为分隔符打印。双引号用于字符串连接操作。'
- en: 'Consider this example:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 看这个例子：
- en: '[PRE77]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The preceding command will display this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将显示如下内容：
- en: '[PRE78]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `echo` command writes a single line into the standard output. Hence, the
    statements in the `{ }` block of `awk` are executed once. If the input to `awk`
    contains multiple lines, the commands in `awk` will be executed multiple times.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo` 命令将一行内容写入标准输出。因此，`awk` 中 `{ }` 代码块的语句只会执行一次。如果 `awk` 的输入包含多行，`awk` 中的命令将会执行多次。'
- en: 'Concatenation is done with quoted strings:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串连接通过引用的字符串来完成：
- en: '[PRE79]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '`{ }` is like a block in a loop, iterating through each line of a file.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`{ }` 就像是一个循环中的代码块，用来逐行遍历文件。'
- en: It's a common practice to place initial variable assignments such as `var=0;`
    in the `BEGIN` block. The `END{}` block contains commands to print the results.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `BEGIN` 代码块中，通常会放置初始变量赋值语句，如 `var=0;`。`END{}` 代码块包含打印结果的命令。
- en: There's more...
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: The `awk` command differs from commands such as `grep`, `find`, and `tr`, in
    that it does more than a single function with options to change the behavior.
    The `awk` command is a program that interprets and executes programs and includes
    special variables just like the shell.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk` 命令与诸如 `grep`、`find` 和 `tr` 等命令不同，因为它具有更多的单一功能选项来更改行为。`awk` 命令是一个解释和执行程序的程序，包括像
    shell 一样的特殊变量。'
- en: Special variables
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊变量
- en: 'Some special variables that can be used with `awk` are as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可以与 `awk` 一起使用的特殊变量如下：
- en: '`NR`: This stands for the current record number, which corresponds to the current
    line number when `awk` uses lines as records.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NR`：这代表当前记录号，当 `awk` 使用行作为记录时，它对应于当前行号。'
- en: '`NF`: This stands for the number of fields, and corresponds to the number of
    fields in the current record being processed. The default field delimiter is a
    space.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NF`：这代表字段的数量，对应于正在处理的当前记录中的字段数量。默认字段分隔符是空格。'
- en: '`$0`: This is a variable that contains the text of the current record.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$0`：这是一个变量，包含当前记录的文本。'
- en: '`$1`: This is a variable that holds the text of the first field.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$1`：这是一个变量，保存第一个字段的文本。'
- en: '`$2`: This is a variable that holds the text of the second field.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$2`：这是一个变量，保存第二个字段的文本。'
- en: 'Consider this example:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[PRE80]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We can print the last field of a line as `print $NF`, the next to last as `$(NF-1)`,
    and so on.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打印一行的最后一个字段为 `print $NF`，倒数第二个为 `$(NF-1)`，依此类推。
- en: '`awk` also supports a `printf()` function with the same syntax as in C.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk` 还支持与 C 中相同语法的 `printf()` 函数。'
- en: 'The following command prints the second and third field of every line:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令打印每行的第二个和第三个字段：
- en: '[PRE81]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can use NR to count the number of lines in a file:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `NR` 计算文件中的行数：
- en: '[PRE82]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here, we only use the `END` block. Awk updates `NR` as each line is read. When
    `awk` reaches the end of the file, NR will contain the last line number. You can
    sum up all the numbers from each line of `field 1` as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只使用 `END` 块。当 `awk` 到达文件末尾时，`NR` 会包含最后一行的行号。可以按如下方式汇总每行的 `field 1` 中的所有数字：
- en: '[PRE83]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Passing an external variable to awk
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将外部变量传递给 `awk`
- en: 'Using the `-v` argument, we can pass external values other than `stdin` to
    `awk`, as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-v` 参数，我们可以传递除 `stdin` 以外的外部值给 `awk`，如下所示：
- en: '[PRE84]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'There is a flexible alternate method to pass many variable values from outside
    `awk`. Consider the following example:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种灵活的替代方法可以从外部传递许多变量值到 `awk`。考虑以下示例：
- en: '[PRE85]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'When an input is given through a file rather than standard input, use the following
    command:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过文件而非标准输入给出输入时，请使用以下命令：
- en: '[PRE86]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In the preceding method, variables are specified as key-value pairs, separated
    by a space, and `(v1=$var1 v2=$var2 )` as command arguments to `awk` soon after
    the `BEGIN`, `{ }`, and `END` blocks.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，变量被指定为键值对，用空格分隔，`(v1=$var1 v2=$var2 )` 作为 `awk` 命令的参数，紧跟在 `BEGIN`、`{
    }` 和 `END` 块之后。
- en: Reading a line explicitly using getline
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 明确使用 `getline` 读取一行
- en: The `awk` program reads an entire file by default. The `getline` function will
    read one line. This can be used to read header information from a file in the
    `BEGIN` block and then process actual data in the main block.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk` 程序默认读取整个文件。`getline` 函数将读取一行。这可用于在 `BEGIN` 块中从文件中读取标题信息，然后在主块中处理实际数据。'
- en: The syntax is `getline var`. The `var` variable will contain the line. If `getline`
    is called without an argument, we can access the content of the line with `$0`,
    `$1`, and `$2`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是 `getline var`。`var` 变量将包含该行的内容。如果调用 `getline` 时没有参数，我们可以使用 `$0`、`$1` 和 `$2`
    访问行的内容。
- en: 'Consider this example:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[PRE87]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Filtering lines processed by awk with filter patterns
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用过滤模式过滤 `awk` 处理的行
- en: 'We can specify conditions for lines to be processed:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定处理行的条件：
- en: '[PRE88]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Setting delimiters for fields
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置字段的分隔符
- en: By default, the delimiter for fields is a space. The `-F` option defines a different
    field delimiter.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，字段的分隔符是空格。`-F` 选项定义了一个不同的字段分隔符。
- en: '[PRE89]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Or:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE90]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: We can set the output field separator by setting `OFS="delimiter"` in the `BEGIN`
    block.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 `BEGIN` 块中设置 `OFS="delimiter"` 来设置输出字段分隔符。
- en: Reading the command output from awk
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 `awk` 读取命令输出
- en: 'Awk can invoke a command and read the output. Place a command string within
    quotes and use the vertical bar to pipe the output to `getline`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk` 可以调用命令并读取输出。将命令字符串放在引号内，并使用竖线将输出传输给 `getline`：'
- en: '[PRE91]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The following code reads a single line from `/etc/passwd` and displays the login
    name and home folder. It resets the field separator to a `:` in the `BEGIN` block
    and invokes `grep` in the main block.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码从`/etc/passwd`中读取一行，并显示登录名和主目录。它在`BEGIN`块中重置字段分隔符为`:`，并在主块中调用`grep`。
- en: '[PRE92]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Associative arrays in Awk
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Awk中的关联数组
- en: 'Awk supports variables that contain a number or string and also supports associative
    arrays. An associative array is an array that''s indexed by strings instead of
    numbers. You can recognize an associative array by the index within square brackets:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: Awk支持包含数字或字符串的变量，还支持关联数组。关联数组是一种由字符串而非数字作为索引的数组。你可以通过方括号中的索引识别出关联数组：
- en: '[PRE93]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'An array can be assigned a value with the equal sign, just like simple user-defined
    variables:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以通过等号进行赋值，就像简单的用户定义变量一样：
- en: '[PRE94]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Using loop inside awk
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Awk中使用循环
- en: 'Awk supports a numeric `for` loop with a syntax similar to `C`:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Awk支持一个类似于`C`语言的数值`for`循环语法：
- en: '[PRE95]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Awk also supports a list style for loop that will display the contents of an
    array:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Awk 还支持一种列表风格的循环，它将显示数组的内容：
- en: '[PRE96]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The following example shows how to collect data into an array and then display
    it. This script reads lines from `/etc/password`, splits them into fields at the
    `:` markers, and creates an array of names in which the index is the login ID
    and the value is the user''s name:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何将数据收集到一个数组中并显示它。此脚本从`/etc/password`读取行，将其按`:`符号分割成字段，并创建一个名字数组，其中索引是登录
    ID，值是用户的名字：
- en: '[PRE97]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: String manipulation functions in awk
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Awk中的字符串处理函数
- en: 'The language of `awk` includes many built-in string manipulation functions:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`语言包含了许多内置的字符串处理函数：'
- en: '`length(string)`: This returns the string length.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length(string)`：此函数返回字符串的长度。'
- en: '`index(string, search_string)`: This returns the position at which `search_string`
    is found in the string.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index(string, search_string)`：此函数返回在字符串中找到`search_string`的位置。'
- en: '`split(string, array, delimiter)`: This populates an array with the strings
    created by splitting a string on the delimiter character.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`split(string, array, delimiter)`：此函数将字符串按分隔符字符拆分后，填充到一个数组中。'
- en: '`substr(string, start-position, end-position)`: This returns the substring
    of the string between the start and end character offsets.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`substr(string, start-position, end-position)`：此函数返回从起始位置到结束位置之间的子字符串。'
- en: '`sub(regex, replacement_str, string)`: This replaces the first occurring regular
    expression match from the string with `replacment_str`.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sub(regex, replacement_str, string)`：此函数将替换字符串中第一次出现的符合正则表达式的匹配项，替换为`replacment_str`。'
- en: '`gsub(regex, replacment_str, string)`: This is like `sub()`, but it replaces
    every regular expression match.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gsub(regex, replacment_str, string)`：此函数类似于`sub()`，但它会替换每一个符合正则表达式的匹配项。'
- en: '`match(regex, string)`: This returns whether a regular expression (regex) match
    is found in the string. It returns a non-zero output if a match is found, otherwise
    it returns zero. Two special variables are associated with `match()`. They are
    `RSTART` and `RLENGTH`. The `RSTART` variable contains the position at which the
    regular expression match starts. The `RLENGTH` variable contains the length of
    the string matched by the regular expression.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match(regex, string)`：此函数返回正则表达式（regex）是否在字符串中找到匹配。如果找到了匹配项，则返回非零值，否则返回零。`match()`函数有两个与之关联的特殊变量，分别是`RSTART`和`RLENGTH`。`RSTART`变量包含正则表达式匹配开始的位置，`RLENGTH`变量包含匹配的字符串长度。'
- en: Finding the frequency of words used in a given file
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找文件中单词的使用频率
- en: Computers are good at counting. We frequently need to count items such as the
    number of sites sending us spam, the number of downloads different web pages get,
    or how often words are used in a piece of text. This recipes show how to calculate
    word usage in a piece of text. The techniques are also applicable to log files,
    database output, and more.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机擅长计数。我们经常需要计算一些项目，比如发送垃圾邮件的站点数量，不同网页的下载量，或者文本中单词的使用频率。本例展示了如何计算文本中的单词使用情况。这些技术同样适用于日志文件、数据库输出等。
- en: Getting ready
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We can use the associative arrays of `awk` to solve this problem in different
    ways. **Words** are alphabetic characters, delimited by space or a period. First,
    we should parse all the words in a given file and then the count of each word
    needs to be found. Words can be parsed using regex with tools such as `sed`, `awk`,
    or `grep`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`awk`的关联数组以不同的方式解决这个问题。**单词**是字母字符，以空格或句号为分隔符。首先，我们需要解析给定文件中的所有单词，然后找出每个单词的出现次数。可以使用正则表达式通过`sed`、`awk`或`grep`等工具解析单词。
- en: How to do it...
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We just explored the logic and ideas about the solution; now let''s create
    the shell script as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚探讨了解决方案的逻辑和思路，现在让我们按照如下方式创建shell脚本：
- en: '[PRE98]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The script will generate this output:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将生成以下输出：
- en: '[PRE99]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: How it works...
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `egrep` command converts the text file into a stream of words, one word
    per line. The `\b[[:alpha:]]+\b` pattern matches each word and removes whitespace
    and punctuation. The `-o` option prints the matching character sequences as one
    word in each line.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`egrep`命令将文本文件转换为单词流，每行一个单词。`\b[[:alpha:]]+\b`模式匹配每个单词，并移除空白字符和标点符号。`-o`选项将匹配的字符序列作为每行的一个单词打印出来。'
- en: The `awk` command counts each word. It executes the statements in the `{ }`
    block for each line, so we don't need a specific loop for doing that. The count
    is incremented by the `count[$0]++` command, in which `$0` is the current line
    and `count` is an associative array. After all the lines are processed, the `END{}`
    block prints the words and their count.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`命令统计每个单词的出现次数。它会对每一行执行`{ }`块中的语句，因此我们无需为此专门编写循环。计数通过`count[$0]++`命令递增，其中`$0`表示当前行，`count`是一个关联数组。处理完所有行后，`END{}`块将打印出单词及其计数。'
- en: 'The body of this procedure can be modified using other tools we''ve looked
    at. We can merge capitalized and non-capitalized words into a single count with
    the `tr` command, and sort the output using the sort command, like this:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 本过程的主体可以使用我们之前讨论过的其他工具进行修改。我们可以使用`tr`命令将大写和小写单词合并为一个计数，并使用`sort`命令对输出进行排序，如下所示：
- en: '[PRE100]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: See also
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: The *Using awk for advanced text processing* recipe in this chapter explains
    the `awk` command
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用awk进行高级文本处理*一节介绍了`awk`命令。
- en: The *Arrays and associative arrays* recipe in [Chapter 1](195d920d-33c2-41d6-bd33-37d75f9c37f1.xhtml),
    *Shell Something Out*, explains arrays in Bash
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书中[第1章](195d920d-33c2-41d6-bd33-37d75f9c37f1.xhtml)的*数组和关联数组*一节，介绍了Bash中的数组。
- en: Compressing or decompressing JavaScript
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压缩或解压JavaScript
- en: JavaScript is widely used in websites. While developing the JavaScript code,
    we use whitespaces, comments, and tabs for readability and maintenance of the
    code. This increases the file size, which slows page loading. Hence, most professional
    websites use compressed JavaScript speed page loading. This compression (also
    known as **minified JS**) is accomplished by removing the whitespace and newline
    characters. Once JavaScript is compressed, it can be decompressed by replacing
    enough whitespace and newline characters to make it readable. This recipe produces
    similar functionality in the shell.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在网站中广泛使用。在开发JavaScript代码时，我们使用空白符、注释和制表符来提高代码的可读性和可维护性。这会增加文件大小，从而降低页面加载速度。因此，大多数专业网站使用压缩后的JavaScript来加速页面加载。此压缩（也称为**最小化JS**）通过移除空白字符和换行符来实现。一旦JavaScript被压缩，可以通过替换足够的空白字符和换行符将其解压缩，使其可读。这个过程在shell中实现类似的功能。
- en: Getting ready
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We are going to write a JavaScript compressor tool as well as a decompressing
    tool. Consider the following JavaScript:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个JavaScript压缩工具以及一个解压缩工具。请考虑以下JavaScript：
- en: '[PRE101]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Our script needs to perform these steps to compress the JavaScript:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本需要执行以下步骤来压缩JavaScript：
- en: Remove newline and tab characters.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除换行符和制表符。
- en: Remove duplicated spaces.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除重复的空格。
- en: Replace comments that look like `/* content */`.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换类似`/* content */`的注释。
- en: 'To decompress or to make the JavaScript more readable, we can use the following
    tasks:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 要解压缩或使JavaScript更具可读性，我们可以执行以下任务：
- en: Replace `;` with `;\n`
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`;`替换为`;\n`
- en: Replace `{` with `{\n`, and `}` with `\n}`
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`{`替换为`{\n`，将`}`替换为`\n}`
- en: How to do it...
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Using these steps, we can use the following command chain:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们可以使用以下命令链：
- en: '[PRE102]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The output is as follows:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE103]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The following decompression script makes the obfuscated code readable:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 以下解压脚本将使混淆的代码变得可读：
- en: '[PRE104]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Or:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE105]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'There is a limitation in the script: that it even gets rid of extra spaces
    where their presence is intentional. For example, if you have a line like the
    following:                 `var a = "hello world"`'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本有一个限制：它会去掉本应存在的额外空格。例如，如果你有以下一行： `var a = "hello world"`
- en: The two spaces will be converted into one space. You can fix problems such as
    this using the pattern-matching tools we have discussed. Also, when dealing with
    a mission-critical JavaScript code, it is advised that you use well-established
    tools to do this.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个空格将被转换为一个空格。你可以使用我们讨论过的模式匹配工具来修复类似的问题。此外，在处理关键的 JavaScript 代码时，建议使用成熟的工具来完成这一操作。
- en: How it works...
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The compression command performs the following tasks:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩命令执行以下任务：
- en: 'Removing the `\n` and `\t` characters:'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除 `\n` 和 `\t` 字符：
- en: '[PRE106]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Removing extra spaces:'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除多余的空格：
- en: '[PRE107]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Removing comments:'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除注释：
- en: '[PRE108]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '`:` is used as a `sed` delimiter to avoid the need to escape `/` since we need
    to use `/*` and `*/`.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`:` 被用作 `sed` 的分隔符，避免了转义 `/` 的需要，因为我们需要使用`/*`和`*/`。'
- en: In sed, `*` is escaped as `\*`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在 sed 中，`*` 被转义为 `\*`。
- en: '`.*` matches all the text in between `/*` and `*/`.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`.*` 匹配`/*`和`*/`之间的所有文本。'
- en: 'Removing all the spaces preceding and suffixing the `{`, `}`, `(`, `)`, `;`,
    `:`, and `,` characters:'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除 `{`、`}`、`(`、`)`、`;`、`:` 和 `,` 字符前后所有空格：
- en: '[PRE109]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The preceding `sed` statement works like this:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 `sed` 语句是这样工作的：
- en: '`/ \?\([{}();,:]\) \?/` in the `sed` code is the match part, and `/\1 /g` is
    the replacement part.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/ \?\([{}();,:]\) \?/` 在 `sed` 代码中是匹配部分，`/\1 /g` 是替换部分。'
- en: '`\([{}();,:]\)` is used to match any one character in the `[ { }( ) ; , : ]`
    set (spaces inserted for readability). `\(` and `\)` are group operators used
    to memorize the match and back reference in the replacement part. `(` and `)`
    are escaped to give them a special meaning as a group operator.`\?` precedes and
    follows the group operators to match the space character that may precede or follow
    any of the characters in the set.'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\([{}();,:]\)` 用于匹配`[ { }( ) ; , : ]`集合中的任何一个字符（为可读性插入空格）。`\(` 和 `\)` 是分组操作符，用于记住匹配并在替换部分进行反向引用。`(`
    和 `)` 被转义以赋予它们作为分组操作符的特殊含义。`\?` 前后加在分组操作符旁，用来匹配可能出现在集合中的任意字符前后的空格字符。'
- en: In the replacement part, the match string (that is, the combination of `:`,
    a space (optional), a character from the set, and again an optional space) is
    replaced with the character matched. It uses a back reference to the character
    matched and memorized using the group operator `()`. Back-referenced characters
    refer to a group match using the `\1` symbol.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在替换部分，匹配的字符串（即`:`, 空格（可选），字符集中的字符，以及可选的空格）被替换为匹配的字符。它使用反向引用来引用通过分组操作符 `()` 记住的匹配字符。反向引用的字符通过
    `\1` 符号引用分组匹配。
- en: 'The decompression command works as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 解压命令的工作方式如下：
- en: '`s/;/;\n/g` replaces `;` with `;\n`'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s/;/;\n/g` 将 `;` 替换为 `;\n`。'
- en: '`s/{/{\n\n/g` replaces `{` with `{\n\n`'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s/{/{\n\n/g` 将 `{` 替换为 `{\n\n`。'
- en: '`s/}/\n\n}/g` replaces `}` with `\n\n}`'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s/}/\n\n}/g` 将 `}` 替换为 `\n\n}`。'
- en: See also
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: The *Using sed to perform text replacement* recipe in this chapter explains
    the `sed` command
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用 sed 进行文本替换*食谱解释了`sed`命令。
- en: The *Translating with tr* recipe in [Chapter 2](36986eeb-141a-496a-a6b1-4f78f612c14e.xhtml),
    *Have a Good Command*, explains the `tr` command
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第二章](36986eeb-141a-496a-a6b1-4f78f612c14e.xhtml)中的*使用 tr 进行翻译*食谱解释了`tr`命令。'
- en: Merging multiple files as columns
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多个文件合并为列。
- en: The can command can be used to merge two files by row, one file after the other.
    Sometimes we need to merge two or more files side by side, joining the lines from
    file 1 with the lines from file 2.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`can` 命令可用于按行合并两个文件，一个文件接一个文件。有时我们需要将两个或多个文件并排合并，将文件 1 的行与文件 2 的行连接在一起。'
- en: How to do it...
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `paste` command performs column-wise concatenation:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`paste`命令执行按列拼接：'
- en: '[PRE110]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Here is an example:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个例子：
- en: '[PRE111]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The default delimiter is tab. We can specify the delimiter with `-d`:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的分隔符是制表符。我们可以使用`-d`来指定分隔符：
- en: '[PRE112]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: See also
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: The *Cutting a file column-wise with cut* recipe in this chapter explains how
    to extract data from text files
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用 cut 按列切割文件*食谱解释了如何从文本文件中提取数据。
- en: Printing the nth word or column in a file or line
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印文件或行中的第 n 个单词或列。
- en: We often need to extract a few columns of useful data from a file. For example,
    in a list of students ordered by their scores, we want to get the fourth highest
    scorer. This recipe shows how to do this.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们常常需要从文件中提取几列有用的数据。例如，在一个按分数排序的学生列表中，我们想找到第四名得分者。本食谱展示了如何做到这一点。
- en: How to do it...
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The `awk` command is frequently used for this task.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`命令通常用于此任务。'
- en: 'To print the fifth column, use the following command:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打印第五列，请使用以下命令：
- en: '[PRE113]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: We can print multiple columns and insert a custom string between the columns.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以打印多个列，并在列之间插入自定义字符串。
- en: 'The following command will print the permission and filename of each file in
    the  current directory:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将打印当前目录中每个文件的权限和文件名：
- en: '[PRE114]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: See also
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: The *Using awk for advanced text processing* recipe in this chapter explains
    the `awk` command
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用awk进行高级文本处理*食谱解释了`awk`命令。
- en: The *Cutting a file column-wise with cut * recipe in this chapter explains how
    to extract data from text files
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*通过cut按列裁剪文件*食谱解释了如何从文本文件中提取数据。
- en: Printing text between line numbers or patterns
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印行号或模式之间的文本
- en: We may need to print a selected portion of a file, either a range of line numbers
    or a range matched by a start and end pattern.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要打印文件的选定部分，可能是一个行号范围，或者是由开始和结束模式匹配的范围。
- en: Getting ready
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: '`Awk`, `grep`, or `sed` will select lines to print, based on condition. It''s
    simplest to use `grep` to print lines that include a pattern. Awk is the most
    versatile tool.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`Awk`、`grep`或`sed`将根据条件选择要打印的行。使用`grep`打印包含某个模式的行是最简单的。`awk`是功能最强大的工具。'
- en: How to do it...
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To print the text between line numbers or patterns, follow these steps:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印行号或模式之间的文本，请按照以下步骤操作：
- en: 'Print the lines of a text in a range of line numbers, `M` to `N`:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印文本的行号范围，`M`到`N`：
- en: '[PRE115]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Awk can read from `stdin`:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`可以从`stdin`读取：'
- en: '[PRE116]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Replace `M` and `N` with numbers:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换`M`和`N`为数字：
- en: '[PRE117]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Print the lines of text between a `start_pattern` and `end_pattern`:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印`start_pattern`和`end_pattern`之间的文本行：
- en: '[PRE118]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Consider this example:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考此示例：
- en: '[PRE119]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The patterns used in `awk` are regular expressions.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`中使用的模式是正则表达式。'
- en: See also
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: The *Using awk for advanced text processing* recipe in this chapter explains
    the `awk` command
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用awk进行高级文本处理*食谱解释了`awk`命令。
- en: Printing lines in the reverse order
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按逆序打印行
- en: This recipe may not seem useful, but it can be used to emulate the stack data
    structure in Bash.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱可能看起来不太有用，但它可以用来模拟Bash中的堆栈数据结构。
- en: Getting ready
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The simplest way to accomplish this is with the `tac` command (the reverse of
    cat). The task can also be done with `awk`.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标最简单的方法是使用`tac`命令（`cat`的反向命令）。此任务也可以通过`awk`来完成。
- en: How to do it...
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will first see how to do this with `tac`.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看如何使用` tac`做到这一点。
- en: 'The syntax of `tac` is as follows:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tac`的语法如下：'
- en: '[PRE120]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The `tac` command can also read from `stdin`:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`tac`命令也可以从`stdin`读取：'
- en: '[PRE121]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The default line separator for `tac` is `\n`. The -s option will redefine this:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`tac`的默认行分隔符是`\n`。-s选项将重新定义此分隔符：'
- en: '[PRE122]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This `awk` script will print lines in the reverse order:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个`awk`脚本将按逆序打印行：
- en: '[PRE123]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '`\` in the shell script is used to break a single-line command sequence into
    multiple lines.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell脚本中，`\`用于将单行命令序列拆分为多行。
- en: How it works...
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `awk` script stores each of the lines into an associative array using the
    line number as the index (`NR` returns the line number). After reading all the
    lines, `awk` executes the `END` block. The `NR` variable is maintained by `awk`.
    It holds the current line number. When `awk` starts the END block, `NR` is the
    count of lines. Using `lno=NR` in the `{ }` block iterates from the last line
    number to `0`, to print the lines in reverse order.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`脚本将每一行存储到一个关联数组中，使用行号作为索引（`NR`返回行号）。读取完所有行后，`awk`会执行`END`块。`NR`变量由`awk`维护，它保存当前行号。当`awk`开始执行END块时，`NR`的值就是行数。通过在`{
    }`块中使用`lno=NR`，从最后一行号迭代到`0`，以逆序打印行。'
- en: Parsing e-mail address and URLs from text
  id: totrans-514
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文本中解析电子邮件地址和URL
- en: Parsing elements such as e-mail addresses and URLs is a common task. Regular
    expressions make finding these patterns easy.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 解析电子邮件地址和URL等元素是常见任务。正则表达式使得查找这些模式变得简单。
- en: How to do it...
  id: totrans-516
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The regular expression pattern to match an e-mail address is as follows:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配电子邮件地址的正则表达式模式如下：
- en: '[PRE124]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Consider the following example:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下示例：
- en: '[PRE125]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'As we are using extended regular expressions (`+`, for instance), we should
    use `egrep`:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是扩展正则表达式（例如`+`），所以我们应使用`egrep`：
- en: '[PRE126]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The `egrep` regex pattern for an HTTP URL is as follows:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '`egrep`正则表达式模式用于HTTP URL如下：'
- en: '[PRE127]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Consider this example:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考此示例：
- en: '[PRE128]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: How it works...
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Regular expressions are easy to design part-by-part. In the e-mail regex, we
    all know that an e-mail address takes the `name@domain.some_2-4_letter_suffix`
    form. Writing this pattern in the regex language will look like this:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式易于逐部分设计。在电子邮件的正则表达式中，我们都知道电子邮件地址的形式是`name@domain.some_2-4_letter_suffix`。在正则表达式语言中编写这个模式应该是这样的：
- en: '[PRE129]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '`[A-Za-z0-9.]+` means we need one or more characters in the `[]` block (`+`
    means at least one, maybe more). This string is followed by an `@` character.
    Next, we will see the domain name, a string of letters or numbers, a period, and
    then 2-4 more letters. The `[A-Za-z0-9]+` pattern defines an alpha-numeric string.
    The `\.` pattern means that a literal period must appear. The `[a-zA-Z]{2,4}`
    pattern defines 2, 3, or 4 letters.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`[A-Za-z0-9.]+`表示我们需要一个或多个字符在`[]`块中（`+`表示至少一个，可能更多）。这个字符串后面跟着一个`@`字符。接下来，我们将看到域名，它由字母或数字、一个点和2-4个字母组成。`[A-Za-z0-9]+`模式定义了一个字母数字字符串。`\.`模式表示必须出现一个字面上的点。`[a-zA-Z]{2,4}`模式定义了2、3或4个字母。'
- en: 'An HTTP URL is similar to an e-mail, but we don''t need the `name@` match part
    of the e-mail regex:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP URL 类似于电子邮件，但我们不需要电子邮件正则表达式中的`name@`匹配部分：
- en: '[PRE130]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: See also
  id: totrans-533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: The *Using sed to perform text replacement* recipe in this chapter explains
    the `sed` command
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用sed进行文本替换*章节解释了`sed`命令
- en: The *Using regular expressions* recipe in this chapter explains how to use regular
    expressions
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用正则表达式*章节解释了如何使用正则表达式
- en: Removing a sentence in a file containing a word
  id: totrans-536
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除包含特定单词的文件中的一句话
- en: Removing a sentence that contains a specific word is a simple task with regular
    expressions. This recipe demonstrates techniques for solving similar problems.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 删除包含特定单词的句子是一个简单的任务，可以通过正则表达式实现。本例展示了解决类似问题的技巧。
- en: Getting ready
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: '`sed` is the best utility for making substitutions. This recipe uses `sed`
    to replace the matched sentence with a blank.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`是执行替换操作的最佳工具。本例使用`sed`将匹配的句子替换为空白。'
- en: How to do it...
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s create a file with some text to carry out the substitutions. Consider
    this example:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含一些文本的文件来进行替换。考虑这个例子：
- en: '[PRE131]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'To remove the sentence containing the words `mobile phones`, use the following
    `sed` expression:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除包含`mobile phones`的句子，请使用以下`sed`表达式：
- en: '[PRE132]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: This recipe assumes that no sentence spans more than one line, for example,
    a sentence should always begin and end on the same line in the text.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 本例假设没有句子跨越多行，例如，一个句子应该始终在文本的同一行开始和结束。
- en: How it works...
  id: totrans-546
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `sed` regex `'s/ [^.]*mobile phones[^.]*\.//g'` has the `'s/substitution_pattern/replacement_string/g`
    format. It replaces every occurrence of `substitution_pattern` with the replacement
    string.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`正则表达式`''s/ [^.]*mobile phones[^.]*\.//g''`的格式是`''s/substitution_pattern/replacement_string/g`。它将每个`substitution_pattern`的出现替换为替代字符串。'
- en: The substitution pattern is the regex for a sentence. Every sentence begins
    with a space and ends with `.`. The regular expression must match the text in
    the format `"space" some text MATCH_STRING some text "dot"`. A sentence may contain
    any characters except a "dot", which is the delimiter. The `[^.]` pattern matches
    any character except a period`.` The `*` pattern defines any number of those characters.
    The `mobile phones` text match string is placed between the pattern for non-period
    characters. Every match sentence is replaced by `//` (nothing).
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 替换模式是句子的正则表达式。每个句子以空格开始，以`.`结束。正则表达式必须匹配格式为“空格 一些文本 匹配字符串 一些文本 点”的文本。一个句子可以包含除“点”之外的任何字符，“点”是分隔符。`[^.]`模式匹配任何非句点`.`字符。`*`模式定义了任意数量的这些字符。`mobile
    phones`文本匹配字符串放置在非句点字符的模式之间。每个匹配的句子被`//`（空）替换。
- en: See also
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: The *Using sed to perform text replacement* recipe in this chapter explains
    the `sed` command
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用sed进行文本替换*章节解释了`sed`命令
- en: The *Using regular expressions* recipe in this chapter explains how to use regular
    expressions
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用正则表达式*章节解释了如何使用正则表达式
- en: Replacing a pattern with text in all the files in a directory
  id: totrans-552
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在目录中所有文件中用文本替换模式
- en: We often need to replace a particular text with a new text in every file in
    a directory. An example would be changing a common URI everywhere in a website's
    source directory.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要在目录中的每个文件中将某些文本替换为新文本。例如，可能需要在网站的源代码目录中更改一个常见的URI。
- en: How to do it...
  id: totrans-554
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We can use `find` to locate the files to have text modified. We can use `sed`
    to do the actual replacement.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`find`来定位需要修改文本的文件。我们可以使用`sed`来执行实际的替换操作。
- en: 'To replace the `Copyright` text with the `Copyleft` word in all `.cpp` files,
    use the following command:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 要将所有`.cpp`文件中的`Copyright`文本替换为`Copyleft`，请使用以下命令：
- en: '[PRE133]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: How it works...
  id: totrans-558
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: We use `find` on the current directory (`.`) to find the files with a `.cpp`
    suffix. The find command uses -`print0` to print a null separated list of files
    (use `-print0` when filenames have spaces in them). We pipe the list to `xargs`,
    which will pass the filenames to `sed`, which makes the modifications.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在当前目录（` . `）使用`find`查找具有`.cpp`后缀的文件。`find`命令使用`-print0`打印一个以空字符分隔的文件列表（当文件名中有空格时，请使用`-print0`）。我们将该列表通过管道传递给`xargs`，`xargs`将文件名传递给`sed`，以进行修改。
- en: There's more...
  id: totrans-560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'If you recall, `find` has an `-exec` option, which can be used to run a command
    on each of the files that match the search criteria. We can use this option to
    achieve the same effect or replace the text with a new one:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，`find`有一个`-exec`选项，可以用于对匹配搜索条件的每个文件运行命令。我们可以使用这个选项来实现相同的效果或将文本替换为新文本：
- en: '[PRE134]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Or:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE135]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: These commands perform the same function, but the first form will call `sed`
    once for every file, while the second form will combine multiple filenames and
    pass them together to `sed`.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令执行相同的功能，但第一种形式会为每个文件调用一次`sed`，而第二种形式会将多个文件名合并并一起传递给`sed`。
- en: Text slicing and parameter operations
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本切片和参数操作
- en: This recipe walks through some simple text-replacement techniques and parameter-expansion
    shorthands available in Bash. A few simple techniques can help avoid writing multiple
    lines of code.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方介绍了一些简单的文本替换技巧和在Bash中可用的参数扩展快捷方式。几种简单的技巧可以帮助避免编写多行代码。
- en: How to do it...
  id: totrans-568
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: Let's get into the tasks.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入任务。
- en: 'Replace some text from a variable:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 替换变量中的一些文本：
- en: '[PRE136]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The `line` word is replaced with `REPLACED`.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '`line`词被替换为`REPLACED`。'
- en: 'We can produce a substring by specifying the start position and string length,
    using the following syntax:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定起始位置和字符串长度来生成一个子字符串，使用以下语法：
- en: '[PRE137]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Print from the fifth character onwards:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 从第五个字符开始打印：
- en: '[PRE138]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Print eight characters starting from the fifth character:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 从第五个字符开始打印八个字符：
- en: '[PRE139]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The first character in a string is at position `0`. We can count from the last
    letter as `-1`. When `-1` is inside a parenthesis, `(-1)` is the index for the
    last letter:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串中的第一个字符位于位置`0`。我们可以从最后一个字母开始计数为`-1`。当`-1`位于括号内时，`(-1)`是最后一个字母的索引：
- en: '[PRE140]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: See also
  id: totrans-581
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using sed to perform text replacement* recipe in this chapter explains
    other character manipulation tricks
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用sed进行文本替换*配方解释了其他字符操作技巧
