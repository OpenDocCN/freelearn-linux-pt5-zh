- en: Chapter 1. The SELinux Development Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章：SELinux开发环境
- en: 'This chapter covers the setup of the SELinux policy development environment.
    We will cover the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍SELinux策略开发环境的设置。我们将在本章讨论以下主题：
- en: Creating the development environment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建开发环境
- en: Building a simple SELinux module
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个简单的SELinux模块
- en: Calling refpolicy interfaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用refpolicy接口
- en: Creating our own interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们自己的接口
- en: Using the refpolicy naming convention
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用refpolicy命名约定
- en: Distributing SELinux policy modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发SELinux策略模块
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Similar to any other software development, having a well-functioning development
    environment is essential to successfully create and manage SELinux policies. Such
    an environment should not only support version control, but also be able to quickly
    search through the sources or show definitions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于其他任何软件开发，拥有一个良好的开发环境对成功创建和管理SELinux策略至关重要。这样的环境不仅应该支持版本控制，还应该能够快速搜索源代码或显示定义。
- en: With SELinux, this means that the policy module sources (which are all readable
    text files) should be stored in a structured manner, the upstream project that
    provides SELinux policies should be readily accessible, and the necessary functions
    or scripts to query and search through the policies should be available.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SELinux，这意味着策略模块源（这些都是可读的文本文件）应以结构化的方式存储，提供SELinux策略的上游项目应该容易访问，并且查询和搜索策略所需的功能或脚本应该可用。
- en: Adventurous users might want to take a look at the **SELinux Policy IDE** (**SLIDE**)
    as offered by Tresys Technology ([http://oss.tresys.com/projects/slide](http://oss.tresys.com/projects/slide)).
    In this book, we do not focus on this IDE; instead, we use whatever file editor
    the user wants (such as VIM, Emacs, or Kate) and enhance the environment through
    the necessary shell functions and commands.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有冒险精神的用户可能想看看Tresys Technology提供的**SELinux Policy IDE**（**SLIDE**）（[http://oss.tresys.com/projects/slide](http://oss.tresys.com/projects/slide)）。在本书中，我们不专注于这个IDE；相反，我们使用用户想要的任何文件编辑器（如VIM、Emacs或Kate），并通过必要的shell功能和命令来增强环境。
- en: Before we cover the setup of the development environment, let's do a quick recapitulation
    of what SELinux is.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论开发环境的设置之前，先简单回顾一下SELinux是什么。
- en: About SELinux
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于SELinux
- en: The **Security Enhanced Linux** (**SELinux**) project is the result of projects
    initiated and supported by the US **National Security Agency** (**NSA**) and came
    to life in December 2000\. It is the implementation of a security system architecture
    with a flexible, policy-driven configuration approach. This architecture is called
    the **Flux Advanced Security Kernel** (**Flask**), and its related resources are
    still an important read for everyone involved with SELinux.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**Security Enhanced Linux**（**SELinux**）项目是由美国**国家安全局**（**NSA**）发起和支持的项目，诞生于2000年12月。它实现了一个安全系统架构，采用灵活的、基于策略的配置方法。该架构被称为**Flux高级安全内核**（**Flask**），与其相关的资源仍然是每个与SELinux相关的人员需要阅读的重要资料。'
- en: 'Most papers are linked through the Flask website at [http://www.cs.utah.edu/flux/fluke/html/flask.html](http://www.cs.utah.edu/flux/fluke/html/flask.html).
    The following are some examples of these papers:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数论文可以通过Flask网站链接访问，网址为[http://www.cs.utah.edu/flux/fluke/html/flask.html](http://www.cs.utah.edu/flux/fluke/html/flask.html)。以下是其中一些论文的示例：
- en: 'The paper called *The Inevitability of Failure: The Flawed Assumption of Security
    in Modern Computing Environments* is still a very topical paper on why mandatory
    access controls are needed in operating systems'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 论文《*失败的必然性：现代计算环境中安全性假设的缺陷*》仍然是关于为何操作系统需要强制访问控制的非常有话题性的论文。
- en: The NSA publication, *Implementing SELinux as a Linux Security Module*, available
    at [http://www.nsa.gov/research/_files/publications/implementing_selinux.pdf](http://www.nsa.gov/research/_files/publications/implementing_selinux.pdf),
    goes deeper into how SELinux is implemented
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NSA发布的《*将SELinux作为Linux安全模块实现*》一文，详尽讲解了SELinux的实现过程，文献可在[http://www.nsa.gov/research/_files/publications/implementing_selinux.pdf](http://www.nsa.gov/research/_files/publications/implementing_selinux.pdf)获取。
- en: Nowadays, SELinux can be best seen as an additional layer of security services
    on top of the existing Linux operating system. It is part of the mainstream Linux
    kernel and uses the **Linux Security Modules** (**LSM**) interfaces to hook into
    the interaction between processes (user space) and resources. It manages various
    access services (such as the reading of files, getting directory attributes, binding
    to domain sockets, connecting to TCP sockets, and gaining additional capabilities)
    through a powerful approach called **type enforcement**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，SELinux 最好被看作是现有 Linux 操作系统之上的一个额外安全层。它是主流 Linux 内核的一部分，并通过 **Linux 安全模块**
    (**LSM**) 接口与进程（用户空间）和资源之间的交互进行挂钩。它通过一种称为 **类型强制**（type enforcement）的强大方法，管理各种访问服务（如读取文件、获取目录属性、绑定域套接字、连接
    TCP 套接字和获取额外的能力）。
- en: The following diagram displays the high-level functional position of the SELinux
    subsystem. Whenever a subject (in the drawing, this is the **Application**) wants
    to perform an action against a resource, this action is first checked by the Discretionary
    Access Control mechanism that the Linux kernel provides. After the action is checked
    and allowed by the DAC mechanism, the LSM implementation (against which SELinux
    is registered) calls the hooks that the SELinux subsystem has provided. SELinux
    then checks the policy (through the cache, and if the access is not registered
    in the cache yet, it checks in the entire policy) and returns whether the access
    should be allowed or not.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了 SELinux 子系统的高层次功能位置。当一个主体（图中为**应用程序**）想要对一个资源执行某个操作时，该操作首先会经过 Linux 内核提供的自愿访问控制机制的检查。如果该操作通过了
    DAC 机制的检查并被允许，LSM 实现（SELinux 在其上注册）会调用 SELinux 子系统提供的钩子。随后，SELinux 会检查策略（通过缓存进行检查，如果访问尚未在缓存中注册，它会检查整个策略），并返回是否允许该访问。
- en: '![About SELinux](img/9669OS_01_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![关于 SELinux](img/9669OS_01_01.jpg)'
- en: SELinux is a Mandatory Access Control system in which the governed activities
    on the system are defined in rules that are documented through a policy. This
    policy is applicable to all processes of the system and enforced through the SELinux
    subsystem, which is part of the Linux kernel. Anything that is not allowed by
    the policy will not be allowed at all—security is not left at the discretion of
    the user or correctness of the application. Unlike Linux DAC restrictions, enforcement
    itself (the SELinux code) is separate from the rules (the SELinux policy). The
    rules document what should be considered as acceptable behavior on the system.
    Actions that do not fit the policy will be denied by the SELinux subsystem.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 是一种强制访问控制系统，其中系统上的活动通过文档化的策略定义。这些策略适用于系统的所有进程，并通过 SELinux 子系统强制执行，而
    SELinux 子系统是 Linux 内核的一部分。任何不被政策允许的操作将完全被拒绝——安全性并不依赖于用户的判断或应用程序的正确性。与 Linux 的
    DAC（自愿访问控制）限制不同，SELinux 强制执行本身（即 SELinux 代码）与规则（即 SELinux 策略）是分开的。规则文档定义了系统上应当视为可接受行为的内容。任何不符合策略的操作都会被
    SELinux 子系统拒绝。
- en: In SELinux, a set of access control mechanisms are supported. The most visible
    one is its type enforcement in which privileges of a subject (be it the kernel
    or a Linux process) towards an object (such as a file, device, system capability,
    or security control) are granted based on the current security context of that
    subject. This security context is most often represented through a readable string
    such as `staff_u:staff_r:staff_t:s0:c0,c3`. This string represents the SELinux
    user (`staff_u`), SELinux role (`staff_r`), SELinux type/domain (`staff_t`), and
    optionally, the SELinux sensitivity level or security clearance, which provides
    both the sensitivity (`s0`) as well as assigned categories (`c0,c3`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SELinux 中，支持一套访问控制机制。最为显著的是其类型强制机制，其中主体（无论是内核还是 Linux 进程）对对象（如文件、设备、系统能力或安全控制）的权限授予，基于该主体当前的安全上下文。这种安全上下文通常通过可读字符串表示，如
    `staff_u:staff_r:staff_t:s0:c0,c3`。该字符串表示 SELinux 用户（`staff_u`）、SELinux 角色（`staff_r`）、SELinux
    类型/域（`staff_t`），并且可选地包括 SELinux 敏感度级别或安全许可，这提供了敏感度（`s0`）以及分配的类别（`c0,c3`）。
- en: Alongside type enforcement, SELinux has several other features as well. For
    instance, it provides a **role-based access control** system by assigning valid
    domains (which are SELinux types assigned to running processes) to roles. If a
    role is not granted a particular domain, then that role cannot execute tasks or
    applications associated with that domain. SELinux also supports user-based access
    controls, thus limiting information flow and governing data sharing between SELinux
    users.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类型强制执行外，SELinux 还具有其他几个特性。例如，它通过将有效域（分配给运行进程的 SELinux 类型）分配给角色来提供基于角色的访问控制系统。如果未授予角色特定域，则该角色无法执行与该域相关的任务或应用程序。SELinux
    还支持基于用户的访问控制，从而限制信息流和管理 SELinux 用户之间的数据共享。
- en: Another stronghold within SELinux is its support for sensitivities (which SELinux
    displays as integers, but these integers can very well be interpreted as public,
    internal, confidential, and so on) as well as access categories. Through the constraints
    that SELinux can impose in its policy, systems can be made to largely abide by
    the Bell-LaPadula model ([https://en.wikipedia.org/wiki/Bell-LaPadula_model](https://en.wikipedia.org/wiki/Bell-LaPadula_model)).
    This model supports information flow restrictions such as no read up (lower sensitivities
    cannot read information from higher sensitivities) and no write down (higher sensitivities
    cannot leak information to lower sensitivities).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 中的另一个支柱是其对敏感性的支持（SELinux 将其显示为整数，但这些整数可以很好地被解释为公开的、内部的、机密的等），以及访问类别。通过
    SELinux 可以在其策略中施加的约束，系统可以大致遵守贝尔-拉帕杜拉模型（[https://en.wikipedia.org/wiki/Bell-LaPadula_model](https://en.wikipedia.org/wiki/Bell-LaPadula_model)）。此模型支持信息流限制，如无读取上行（低敏感性无法从高敏感性读取信息）和无写入下行（高敏感性无法向低敏感性泄漏信息）。
- en: The role of the SELinux policy
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SELinux 策略的角色
- en: 'The SELinux policy itself is a representation of what the security administrator
    (the role that is usually mentioned as being the owner of what is and isn''t allowed
    on a system) finds acceptable, expected, and normalized behavior:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 策略本身是安全管理员（通常被称为系统上允许和不允许的所有者的角色）对可接受的、预期的和规范化行为的表示：
- en: '**Acceptable**: Application and user behavior will be acceptable because it
    will be allowed on the system by the policy'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可接受**：应用程序和用户行为将被认为是可接受的，因为它将在策略允许的系统上被允许。'
- en: '**Expected**: Application and user behavior will be expected as the policy
    usually doesn''t (or shouldn''t) contain access vectors (a permission assigned
    to a subject towards a particular object) that are not applicable to the system,
    even if it would be acceptable on other systems in the environment'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预期**：应用程序和用户行为将按预期进行，因为策略通常不包含系统不适用的访问向量（分配给主体对特定对象的权限），即使在环境中其他系统可能会接受这些访问向量也一样。'
- en: '**Normalized**: Application and user behavior will be normalized not in the
    sense of database normalization, but as in normality—something that is consistent
    with the most common behavior of the process'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规范化**：应用程序和用户行为将被规范化，不是指数据库规范化的意义上，而是指正常性——与进程最常见行为一致的东西。'
- en: As a policy represents these behaviors, correct tuning and development of the
    policy is extremely important. This is why the *SELinux Cookbook* will focus on
    policy development and policy principles.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 策略代表这些行为，正确调整和开发策略非常重要。这就是为什么 *SELinux Cookbook* 将专注于策略开发和策略原则。
- en: A policy that is too restrictive will cause applications to malfunction, often
    in ways that its users will find unexpected. It will not be surprising to the
    security administrator of course, as he knows that the policy dictates what is
    allowed, and he is (or at least should be) perfectly aware of what the policy
    says.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 过于严格的策略将导致应用程序出现故障，通常以用户发现意料之外的方式。当然，对于安全管理员来说并不奇怪，因为他知道策略规定了允许什么，他应该（至少应该）完全了解策略的内容。
- en: However, a policy that is too broad will not result in such behavior. On the
    contrary, everything will work as expected. Sadly, when nonstandard or abnormal
    behavior is triggered, the (too) broadly defined policy might still allow this
    nonstandard or abnormal behavior to happen. When this abnormal behavior is an
    exploited vulnerability, then SELinux—as powerful as it can be—has nothing to
    deter the exploit, as the policy itself has granted the access. Another example
    of this principle would be a network firewall, whose policy can be too open as
    well.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，过于宽泛的策略不会导致这种行为。相反，一切都会按预期工作。遗憾的是，当非标准或异常行为被触发时，定义过于宽泛的策略可能仍然允许这种非标准或异常行为的发生。当这种异常行为成为被利用的漏洞时，即便SELinux再强大，也无法阻止利用，因为策略本身已经授予了访问权限。这个原则的另一个例子是网络防火墙，其策略可能也过于宽松。
- en: Through the packaged approach that policies provide (SELinux policies are like
    loadable kernel modules, but then for the SELinux subsystem), administrators can
    push the policies to one or more systems, usually through the package management
    system or centralized configuration management system of choice. Unlike Linux
    DAC controls, which need to be applied on the files themselves, SELinux policies
    are much easier to handle and are even versionable—a trait much appreciated by
    administrators in larger environments.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过策略提供的打包方式（SELinux策略就像可加载的内核模块，但它是针对SELinux子系统的），管理员可以将策略推送到一个或多个系统，通常通过包管理系统或首选的集中配置管理系统来进行。与Linux的DAC控制需要直接应用于文件本身不同，SELinux策略更容易处理，甚至可以进行版本控制——这是大环境中管理员非常欣赏的特性。
- en: The example
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'Throughout this book, we will often come across settings that are optional
    or whose value is heavily dependent on the choices made by the system administrator.
    In order to not repeat documenting and explaining when a setting or value is configurable,
    we will use the following configuration settings:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将经常遇到一些可选的设置，或者这些设置的值依赖于系统管理员所做的选择。为了避免重复记录和解释当某个设置或值是可配置时的内容，我们将使用以下配置设置：
- en: The SELinux type (which is configured in `/etc/selinux/config`) will be MCS
    in this book. It uses an MLS-enabled, single-sensitivity policy definition. This
    means that contexts will always have a sensitivity level or security clearance
    assigned when displayed, and the location of the SELinux policy configuration
    will always be shown in `/etc/selinux/mcs/`. Make sure to substitute this path
    with your own if the policy store on your environment is named differently. For
    instance, a Red Hat or Fedora installation defaults to `/etc/selinux/targeted/`.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书中的SELinux类型将是MCS。它使用启用了MLS的单一敏感性策略定义。这意味着当显示时，所有上下文都会分配一个敏感性级别或安全许可，并且SELinux策略配置的位置将始终显示在`/etc/selinux/mcs/`中。如果您的环境中的策略存储路径不同，请确保将此路径替换为您自己的路径。例如，Red
    Hat或Fedora安装的默认路径是`/etc/selinux/targeted/`。
- en: Operations will be documented as they run through restricted users, which are
    aptly named `user` (for an unprivileged end user assigned the `user_r` role),
    `staff` (for a user that might perform administrative tasks and is assigned the
    `staff_r` and `sysadm_r` roles), and `root` (which is mapped to the `sysadm_r`
    role). Distributions might have users associated with the `unconfined_r` role.
    Whenever a step can be skipped for unconfined users, it will be explicitly mentioned.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作将按照通过受限用户的方式记录，这些用户分别命名为`user`（代表分配了`user_r`角色的无特权最终用户）、`staff`（代表可能执行管理任务并分配了`staff_r`和`sysadm_r`角色的用户）和`root`（映射到`sysadm_r`角色）。某些发行版可能会将用户与`unconfined_r`角色相关联。每当某个步骤对于无限制用户是可以跳过的时，我们将明确指出。
- en: Creating the development environment
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建开发环境
- en: 'We will now create a development environment in which the SELinux policies
    and upstream project code as well as the functions we use to easily query the
    SELinux policies will be stored. This environment will have the following three
    top-level locations:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个开发环境，在这个环境中将存储SELinux策略、上游项目代码以及我们用来轻松查询SELinux策略的功能。这个环境将具有以下三个顶级位置：
- en: '`local/`: This location contains the SELinux rules that are local to the system
    and not part of a cooperatively developed repository (that is, where other developers
    work)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local/`：此位置包含本地系统的SELinux规则，而非合作开发的代码库的一部分（即其他开发人员工作的位置）'
- en: '`centralized/`: This location contains checkouts of the various repositories
    used in the development environment'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`centralized/`：此位置包含开发环境中使用的各种代码库的检出版本'
- en: '`bin/`: This location contains the supporting script(s) we will use to query
    the policy sources as well as troubleshoot the SELinux issues'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin/`：此位置包含我们将用来查询策略源以及排查 SELinux 问题的支持脚本。'
- en: 'In this exercise, we will also populate the `centralized/` location with a
    checkout: the SELinux policy tree that is used by the current system.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们还将在`centralized/`位置填充一个检出项：当前系统使用的 SELinux 策略树。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Look for a good location where the development environment should be stored.
    This usually is a location in the user's home directory, such as `/home/staff/dev/selinux/`.
    Whenever this book references a location with respect to the development environment,
    it will use the `${DEVROOT}` variable to refer to this location.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找一个合适的位置来存储开发环境。这个位置通常是用户主目录中的某个位置，比如 `/home/staff/dev/selinux/`。每当本书提到开发环境的位置时，它将使用
    `${DEVROOT}` 变量来指代这个位置。
- en: 'Another piece of information that we need is the location of the repository
    that hosts the SELinux policies of the current system. This location is distribution
    specific, so consult the distribution site for more information. At the time of
    writing this book, the policies for Gentoo Linux and Fedora can be found at the
    following locations:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们需要的信息是托管当前系统 SELinux 策略的仓库位置。这个位置因发行版而异，因此请参考发行版网站以获取更多信息。在编写本书时，Gentoo
    Linux 和 Fedora 的策略可以在以下位置找到：
- en: '[https://github.com/sjvermeu/hardened-refpolicy](https://github.com/sjvermeu/hardened-refpolicy)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/sjvermeu/hardened-refpolicy](https://github.com/sjvermeu/hardened-refpolicy)'
- en: '[https://git.fedorahosted.org/git/selinux-policy.git](https://git.fedorahosted.org/git/selinux-policy.git)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://git.fedorahosted.org/git/selinux-policy.git](https://git.fedorahosted.org/git/selinux-policy.git)'
- en: Whenever version control is used, we will use `git` in this book. Other version
    control systems exist as well, but this too is outside the scope of this book.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每当使用版本控制时，本书将使用`git`。当然，还有其他版本控制系统，但这些超出了本书的范围。
- en: How to do it…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To create the development environment used in this book, perform the following
    steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建本书中使用的开发环境，请执行以下步骤：
- en: 'Create the necessary directories:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建必要的目录：
- en: '[PRE0]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a checkout of the distributions'' SELinux policy tree (which, in this
    example, is based on the Gentoo Linux repository):'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建发行版的 SELinux 策略树的检出（在这个例子中，基于 Gentoo Linux 仓库）：
- en: '[PRE1]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a `git` repository for the policies that we will develop throughout
    this book:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们将在本书中开发的策略创建一个 `git` 仓库：
- en: '[PRE2]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Add the `functions.sh` script, which is available through the download pack
    of this book, to the `${DEVROOT}/bin/` location.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `functions.sh` 脚本（可通过本书的下载包获取）添加到 `${DEVROOT}/bin/` 位置。
- en: 'Edit the `.profile`, `.bashrc`, or other shell configuration files that are
    sourced when our Linux user logs on to the system, and add in the following code:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `.profile`、`.bashrc` 或其他在我们的 Linux 用户登录系统时加载的 shell 配置文件，并添加以下代码：
- en: '[PRE3]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Log out and log in again, and verify that the environment is working by requesting
    the definition of the `files_read_etc_files` interface:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注销并重新登录，然后通过请求 `files_read_etc_files` 接口的定义来验证环境是否正常工作：
- en: '[PRE4]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The setup of the development environment helps us deal with policy development
    for further recipes. The checkout of the distributions' SELinux policy tree is
    to query the existing policy rules while developing new policies. SELinux does
    not require to have the policy sources available on a system (only the compiled
    binary SELinux policy modules and parts of the SELinux policy rules, which can
    be used by other policy modules). As a result, default installations usually do
    not have the policy rules available on the system.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 开发环境的设置帮助我们处理进一步配方的策略开发。发行版的 SELinux 策略树的检出用于在开发新策略时查询现有的策略规则。SELinux 不要求系统上必须有策略源（只有编译后的二进制
    SELinux 策略模块和部分 SELinux 策略规则可以被其他策略模块使用）。因此，默认安装通常不会在系统上提供策略规则。
- en: By having the checkout at our disposal, we can review the existing SELinux policy
    files and happily use examples from it for our own use. A major user of this checkout
    is the `functions.sh` script, which uses the `${POLICY_LOCATION}` variable to
    know where the checkout is hosted. This script provides several functions that
    we'll use throughout this book; they will also help in querying the sources.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用我们的检出版本，我们可以查看现有的 SELinux 策略文件，并高兴地将其中的示例用于自己的需求。此检出的一个主要用户是 `functions.sh`
    脚本，它使用 `${POLICY_LOCATION}` 变量来知道检出版本的托管位置。这个脚本提供了我们在本书中将使用的几个函数，它们还将帮助查询源。
- en: By sourcing this `functions.sh` script during log on, these functions are readily
    available in the user's shell. One of these functions is the `seshowif` function,
    which displays the rules of a particular interface. The example given shows the
    definition of the `files_read_etc_files` interface, which we used to validate
    that our setup is working correctly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在登录时加载此 `functions.sh` 脚本，这些函数便可以在用户的 shell 中立即使用。其中一个函数是 `seshowif` 函数，它显示特定接口的规则。给出的示例显示了
    `files_read_etc_files` 接口的定义，我们用它来验证我们的设置是否正常工作。
- en: 'The `functions.sh` script can also work with the interface files that are available
    through `/usr/share/selinux/devel/` (on Fedora/Red Hat systems), making the checkout
    of the policy repository optional if the user does not need access to the complete
    policy rules. The policy location defined then is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`functions.sh` 脚本还可以与通过 `/usr/share/selinux/devel/`（在 Fedora/Red Hat 系统中）提供的接口文件一起使用，这使得如果用户不需要访问完整的策略规则，则可以选择不检出策略库。然后定义的策略位置如下：'
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There's more...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Next to the distributions' SELinux policy tree, one can also use the reference
    policy SELinux tree. This is the upstream project that most, if not all, Linux
    distributions use as the source of their policies. It has to be said though that
    the reference policy often lags behind on the policy repositories of the individual
    distributions, as it has stricter acceptance criteria for policy enhancements.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了发行版的 SELinux 策略树外，还可以使用参考策略 SELinux 树。这是大多数（如果不是全部）Linux 发行版作为其策略来源所使用的上游项目。然而，必须指出的是，参考策略通常在个别发行版的策略库之后更新，因为它对策略增强有更严格的接受标准。
- en: It also doesn't hurt to check out the SELinux policy repositories of other distributions.
    Often, Linux distributions first do SELinux policy updates on their own repository
    before pushing their changes to the reference policy (which is called upstreaming
    in the free software development community). By looking at other distributions'
    repositories, developers can easily see if the necessary changes have been made
    in the past already (and are thus more likely to be correct).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 检查其他发行版的 SELinux 策略库也无妨。通常，Linux 发行版会先在自己的库中更新 SELinux 策略，然后再将更改推送到参考策略（在自由软件开发社区中称为上游）。通过查看其他发行版的库，开发人员可以轻松了解必要的更改是否已经做过（从而更有可能是正确的）。
- en: See also
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'For more information about the topics covered in this recipe, refer to the
    following resources:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解本食谱中涉及的主题的更多信息，请参阅以下资源：
- en: The reference policy project ([http://oss.tresys.com/projects/refpolicy/](http://oss.tresys.com/projects/refpolicy/))
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考策略项目 ([http://oss.tresys.com/projects/refpolicy/](http://oss.tresys.com/projects/refpolicy/))
- en: The Git tutorial ([http://git-scm.com/docs/gittutorial](http://git-scm.com/docs/gittutorial))
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 教程 ([http://git-scm.com/docs/gittutorial](http://git-scm.com/docs/gittutorial))
- en: Building a simple SELinux module
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个简单的 SELinux 模块
- en: Now that we have a development environment, it is time to create our first SELinux
    policy module. As its purpose does not matter at this point, we will focus on
    a privilege that is by default not allowed (and rightfully so) yet easy to verify,
    as we want to make sure that our policy development approach works. The privilege
    we are going to grant is to allow the system logger to write to a logfile labeled
    `named_conf_t` (the type used for the configuration of the BIND DNS server—known
    as `named`).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了开发环境，是时候创建我们的第一个 SELinux 策略模块了。由于此时其目的尚不重要，我们将专注于一个默认情况下不被允许（而且是合理的）但容易验证的特权，因为我们希望确保我们的策略开发方法有效。我们将授予的特权是允许系统日志记录器写入标记为
    `named_conf_t` 的日志文件（这是用于 BIND DNS 服务器配置的类型，也称为 `named`）。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Building SELinux policy modules is to extend the existing policy with more rules
    that allow certain accesses. It is not possible to create a policy module that
    reduces the allowed privileges for a domain. If this is needed, the policy module
    needs to recreate and substitute the existing policy (and thus, a distribution-provided
    policy will need to be removed from the system).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 构建SELinux策略模块是为了通过更多的规则扩展现有的策略，允许某些访问。不能创建一个减少域所允许权限的策略模块。如果需要这么做，策略模块需要重新创建并替代现有的策略（因此，分发提供的策略将需要从系统中移除）。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Before we get started, we first need to make sure that we can test the outcome
    of the change. A simple method would be to change the context of the `/var/log/messages`
    file (or another general logfile that the system logger is configured to use)
    and send messages through the system logger using the `logger` command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们首先需要确保能够测试更改的结果。一种简单的方法是更改`/var/log/messages`文件（或系统日志记录器配置使用的另一个常规日志文件）的上下文，并通过`logger`命令通过系统日志记录器发送消息：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Verify that the message has indeed been delivered by looking at the last lines
    shown through the `tail` command. Then, change the context and try again. The
    event should not be shown, and a denial should be logged by the audit daemon:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`tail`命令查看最后几行，验证消息是否已经发送。然后，改变上下文并重试。该事件不应显示，并且审核守护进程应记录拒绝事件：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this in place, we can now create our first simple SELinux module.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们现在可以创建我们的第一个简单的SELinux模块。
- en: How to do it…
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Building a new SELinux policy is a matter of going through the following steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个新的SELinux策略是经过以下步骤的过程：
- en: 'Create a file called `mylogging.te` inside `${DEVROOT}/local` with the following
    content:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`${DEVROOT}/local`中创建一个名为`mylogging.te`的文件，内容如下：
- en: '[PRE8]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Copy or link the `Makefile` file available in `/usr/share/selinux/devel/` or
    `/usr/share/selinux/mcs/include/` (the exact location is distribution specific)
    to the current directory:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或链接`/usr/share/selinux/devel/`或`/usr/share/selinux/mcs/include/`（具体位置取决于发行版）中的`Makefile`文件到当前目录：
- en: '[PRE9]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Build the SELinux policy module through this `Makefile`. The target is to name
    the (target) policy module with the `.pp` suffix:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这个`Makefile`构建SELinux策略模块。目标是将（目标）策略模块命名为`.pp`后缀：
- en: '[PRE10]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Switch to the root user, and if we are logged on through an unprivileged SELinux
    domain/role, switch to the `sysadm_r` or `secadm_r` role (this is not needed if
    the current user domain is already `sysadm_t` or `unconfined_t`):'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到root用户，如果我们通过非特权SELinux域/角色登录，切换到`sysadm_r`或`secadm_r`角色（如果当前用户域已经是`sysadm_t`或`unconfined_t`，则不需要此操作）：
- en: '[PRE11]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, load the SELinux policy module (which will immediately activate the newly
    defined SELinux policy):'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，加载SELinux策略模块（这将立即激活新定义的SELinux策略）：
- en: '[PRE12]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Verify that the newly defined SELinux policy is active by generating a new log
    event and by looking at the logfile to see if it has indeed been registered.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过生成一个新的日志事件并查看日志文件，验证新定义的SELinux策略是否已激活，并确认该事件是否已成功记录。
- en: 'Commit the newly created files to the repository:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的文件提交到版本库：
- en: '[PRE13]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When verified, reset the context of the logfile using `restorecon /var/log/messages`
    and remove the policy module from the subsystem using `semodule -r mylogging`.
    After all, we do not want this rule to stay active.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 验证后，使用`restorecon /var/log/messages`重置日志文件的上下文，并使用`semodule -r mylogging`从子系统中删除策略模块。毕竟，我们不希望这个规则一直处于激活状态。
- en: How it works…
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'There are three important, new aspects of SELinux policy development that we
    got in touch with in this recipe:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程里，我们接触到SELinux策略开发的三个重要新方面：
- en: A policy source file called `mylogging.te` was created
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个名为`mylogging.te`的策略源文件
- en: A generated, binary policy module called `mylogging.pp` was built
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建了一个名为`mylogging.pp`的生成的二进制策略模块
- en: The binary policy file, `mylogging.pp`, is added to the active policy store
    on the system
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制策略文件`mylogging.pp`已添加到系统的活动策略存储中
- en: At the end, we committed the file to our local repository. Using version control
    on policy files is recommended in order to track changes across time. A good hint
    would be to tag new releases of the policies—if users ever report issues with
    the policy, you can then ask them for the SELinux policy module version (through
    `semodule –l`) and use the tags in the repository to easily find rules for that
    particular policy module.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将文件提交到本地仓库。建议对策略文件使用版本控制，以便跟踪跨时间的变更。一个好的提示是为策略的每个新版本打标签——如果用户报告与策略相关的问题，您可以要求他们提供
    SELinux 策略模块的版本（通过 `semodule –l`），然后使用仓库中的标签轻松查找该特定策略模块的规则。
- en: In the remainder of this book, we will no longer use `git add`/`commit` so that
    we can focus on the SELinux recipes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将不再使用 `git add`/`commit`，以便专注于 SELinux 配方。
- en: The policy source file
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略源文件
- en: In the recipe, we created a policy source file called `mylogging.te`, which
    contains the raw SELinux policy rules. The name, `mylogging`, is not chosen at
    random; it is a common best practice to name custom modules starting with `my`
    and followed by the name of the SELinux policy module whose content we are enhancing
    (in our case, the logging module that provides the SELinux policy for everything
    that is system-logging related). The `.te` suffix is not just a convention (referring
    to the type enforcement part of SELinux); the build system requires the `.te`
    suffix.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在该配方中，我们创建了一个名为 `mylogging.te` 的策略源文件，其中包含原始的 SELinux 策略规则。`mylogging` 这个名称并非随机选择；按照常见的最佳实践，自定义模块通常以
    `my` 开头，后跟我们增强内容的 SELinux 策略模块的名称（在本例中，即提供系统日志相关 SELinux 策略的日志模块）。`.te` 后缀不仅仅是一个约定（指代
    SELinux 的类型强制部分）；构建系统要求使用 `.te` 后缀。
- en: 'The policy module rules start with the `policy_module(…)` call, which tells
    the build system that the file will become a loadable SELinux policy module with
    the given name and version. This name and version will be displayed by the `semodule`
    command if we ask it to list all the currently loaded SELinux policy modules:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模块规则以 `policy_module(…)` 调用开始，这告诉构建系统，该文件将成为一个可加载的 SELinux 策略模块，并指定其名称和版本。如果我们请求
    `semodule` 命令列出当前加载的所有 SELinux 策略模块，该名称和版本会被显示出来：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The best practice is to keep all rules for a single domain within a policy module.
    If rules for multiple unrelated domains are needed, it is recommended that you
    create multiple modules, as this isolates the policy rules and makes modifications
    more manageable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是将单一域的所有规则保留在一个策略模块中。如果需要多个不相关域的规则，建议创建多个模块，因为这可以将策略规则隔离开来，并使修改更易于管理。
- en: In this simple example, we did not follow this best practice (yet). Instead,
    we told the SELinux subsystem that the policy is going to be enhanced with an
    access vector for `syslogd_t`. The access vector here is to allow this domain
    a set of permissions against files that are labeled as `named_conf_t`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的示例中，我们没有遵循最佳实践（还没有）。相反，我们告诉 SELinux 子系统，策略将通过为 `syslogd_t` 提供一个访问向量来增强。这里的访问向量是允许该域对标记为
    `named_conf_t` 的文件执行一组权限。
- en: The binary policy module
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制策略模块
- en: When we called the `Makefile` file, the underlying scripts built a loadable
    binary SELinux policy module. Such files have the `.pp` suffix and are ready to
    be loaded into the policy store. The `Makefile` file called might not be installed
    by default; some distributions require specific development packages to be installed
    (such as `selinux-policy-devel` in Fedora).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `Makefile` 文件时，底层脚本会构建一个可加载的二进制 SELinux 策略模块。这类文件的后缀为 `.pp`，并准备好被加载到策略存储中。这个
    `Makefile` 文件可能默认没有安装；某些发行版需要安装特定的开发包（例如 Fedora 中的 `selinux-policy-devel`）。
- en: There is no nice way of retrieving the sources of a policy if we are only given
    the `.pp` file. Sure, there are commands such as `semodule_unpackage` and `sedismod`
    available, but these will only give a low-level view of the rules, not the original
    `.te` code. So, make sure to have backups, and as we saw in the example, use a
    versioning system to control changes across time.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只给定 `.pp` 文件，获取策略源代码的方式并不理想。当然，有诸如 `semodule_unpackage` 和 `sedismod` 这样的命令可以使用，但这些命令仅能提供规则的低级视图，而不是原始的
    `.te` 代码。因此，确保做好备份，并且正如我们在示例中看到的，使用版本控制系统来管理跨时间的变更。
- en: Loading a policy into the policy store
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将策略加载到策略存储中
- en: To load the newly created policy into the policy store, we called the `semodule`
    command. This application is responsible for managing the policy store (which
    is the set of all SELinux policy modules together with the base policy module)
    and linking or unlinking the modules together into a final policy.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新创建的策略加载到策略存储中，我们调用`semodule`命令。此应用程序负责管理策略存储（即所有SELinux策略模块与基础策略模块的集合），并将模块链接或取消链接到最终策略中。
- en: This final policy (which can be found at `/etc/selinux/mcs/policy`) is then
    loaded into the SELinux subsystem itself and enforced.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此最终策略（可在`/etc/selinux/mcs/policy`找到）然后加载到SELinux子系统本身并强制执行。
- en: There's more...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: Throughout this book, the build system used is based on the reference policy
    build system. This is a collection of M4 macros and affiliated scripts that make
    the development of SELinux policies easier. This is, however, not the only way
    of creating SELinux policies.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，使用的构建系统基于参考策略构建系统。这是一组M4宏和相关脚本，可使SELinux策略的开发更加简便。然而，这并非创建SELinux策略的唯一方法。
- en: 'When visiting online resources, you might come across SELinux policy modules
    whose structure looks like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问在线资源时，您可能会遇到类似以下结构的SELinux策略模块：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，直接通过电子邮件获取文件。
- en: 'These are policy files that do not use the reference policy build system. To
    build such files, we first create an intermediate module file with `checkmodule`,
    after which we package the module file towards a loadable binary SELinux policy
    with `semodule_package`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是不使用参考策略构建系统的策略文件。要构建这样的文件，我们首先使用`checkmodule`创建一个中间模块文件，然后使用`semodule_package`将模块文件打包成可加载的二进制SELinux策略：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To keep things simple, we will stick to the reference policy build system.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们将坚持参考策略构建系统。
- en: See also
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Many topics and areas have been touched upon in this recipe. More information
    can be found at the following resources:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此处涉及了许多主题和领域。更多信息可在以下资源找到：
- en: Most Linux distributions have distribution-specific information on how SELinux
    is integrated in the distribution. For Red Hat, these resources can be reached
    through [https://access.redhat.com](https://access.redhat.com). For Fedora, use
    [https://docs.fedoraproject.org](https://docs.fedoraproject.org). Gentoo has its
    documentation at [https://wiki.gentoo.org](https://wiki.gentoo.org).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数Linux发行版都有关于如何集成SELinux的特定于发行版的信息。对于Red Hat，可以通过[https://access.redhat.com](https://access.redhat.com)访问这些资源。对于Fedora，请使用[https://docs.fedoraproject.org](https://docs.fedoraproject.org)。Gentoo的文档位于[https://wiki.gentoo.org](https://wiki.gentoo.org)。
- en: For more information on how to administer SELinux on a system, consult the documentation
    provided by the distribution or read the *SELinux System Administration* book
    published by Packt Publishing at [http://www.packtpub.com/selinux-system-administration/book](http://www.packtpub.com/selinux-system-administration/book).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解如何在系统上管理SELinux的更多信息，请参阅发行版提供的文档或阅读Packt Publishing出版的*SELinux系统管理*书籍，网址为[http://www.packtpub.com/selinux-system-administration/book](http://www.packtpub.com/selinux-system-administration/book)。
- en: Extensive coverage of the SELinux language itself is provided by the SELinux
    Notebook, which is available online at [http://www.freetechbooks.com/the-selinux-notebook-the-foundations-t785.html](http://www.freetechbooks.com/the-selinux-notebook-the-foundations-t785.html).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux语言本身的广泛覆盖由在线可获得的SELinux笔记本提供，网址为[http://www.freetechbooks.com/the-selinux-notebook-the-foundations-t785.html](http://www.freetechbooks.com/the-selinux-notebook-the-foundations-t785.html)。
- en: Calling refpolicy interfaces
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用参考策略接口
- en: Writing up SELinux policies entirely using the standard language constructs
    offered by SELinux is doable, but it is prone to error and not manageable in the
    long term. To support a more simple language construct, the reference policy project
    uses a set of M4 macros that are expanded with the underlying SELinux policy statements
    when the policy is built.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 完全使用 SELinux 提供的标准语言构造编写 SELinux 策略是可行的，但容易出错，且在长期使用中不易管理。为了支持更简单的语言构造，参考策略项目使用了一组
    M4 宏，在策略构建时，底层的 SELinux 策略语句会扩展这些宏。
- en: The API that policy developers can use can be consulted online, but most systems
    also have this information available onsite at `/usr/share/doc/selinux-*/`. Finding
    proper interfaces requires some practice though, which is why one of the functions
    that we installed earlier (as part of the development environment) simplifies
    this for us.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 策略开发人员可以在线查阅 API，但大多数系统也会在`/usr/share/doc/selinux-*/`中提供此信息。然而，找到合适的接口需要一些实践，这就是为什么我们之前安装的其中一个函数（作为开发环境的一部分）简化了这一过程。
- en: In this recipe, we are going to edit the `mylogging.te` file we generated earlier
    with the right reference policy macro.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将编辑之前生成的`mylogging.te`文件，并使用正确的参考策略宏。
- en: How to do it…
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To use reference policy interfaces in an SELinux policy module, the following
    approach can be taken:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 SELinux 策略模块中使用参考策略接口，可以采取以下方法：
- en: 'Use the `sefinddef` function to find permission groups or patterns to write
    to files:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sefinddef`函数查找写入文件的权限组或模式：
- en: '[PRE17]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Use the `seshowdef` function to show the full nature of the `write_files_pattern`
    definition:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`seshowdef`函数显示`write_files_pattern`定义的完整性质：
- en: '[PRE18]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use the `sefindif` function to find the interface that will allow writing to
    `named_conf_t`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sefindif`函数查找允许写入`named_conf_t`的接口：
- en: '[PRE19]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, update the `mylogging.te` file to use this function. The file should now
    look like the following:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新`mylogging.te`文件以使用这个函数。文件现在应该如下所示：
- en: '[PRE20]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the use of the backtick (`` ` ``) and single quote (`'`). Whenever definitions
    are used, they need to start with a backtick and end with a single quote.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意使用反引号（`` ` ``）和单引号（`'`）。每当使用定义时，它们需要以反引号开始并以单引号结束。
- en: Rebuild and reload the policy module, and then rerun the tests we did earlier
    to verify that this still allows us to write to the `named_conf_t labeled` file.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建并重新加载策略模块，然后重新运行我们之前做的测试，以验证这仍然允许我们写入`named_conf_t`标记的文件。
- en: How it works…
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: One of the principles behind the build system of the reference policy is that
    an SELinux policy module should not directly mention SELinux types that are not
    related to that module. Whenever a policy module needs to define rules against
    a type that is defined by a different module, interfaces defined by that different
    module should be used instead.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 参考策略的构建系统背后的原则之一是，SELinux 策略模块不应直接提及与该模块无关的 SELinux 类型。每当策略模块需要针对由其他模块定义的类型定义规则时，应使用该其他模块定义的接口。
- en: In our example, we need the interface used by the BIND SELinux policy (which
    handles the BIND-named daemon policy rules); this interface allows us to write
    to the BIND DNS server configuration file type (`named_conf_t`). We can check
    the online API, the API documentation in `/usr/share/doc/selinux-*`, or just guess
    the interface name. However, in order to be certain that the interface does what
    we need, we need to query the interface definitions themselves.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们需要使用 BIND SELinux 策略（它处理 BIND-named 守护进程的策略规则）所使用的接口；该接口允许我们写入 BIND
    DNS 服务器配置文件类型（`named_conf_t`）。我们可以查阅在线 API、`/usr/share/doc/selinux-*`中的 API 文档，或者直接猜测接口名称。然而，为了确保接口做我们需要的事情，我们需要查询接口定义本身。
- en: That is where the `sefinddef`, `seshowdef`, `sefindif`, and `seshowif` functions
    come into play. These functions are not part of any SELinux user space—they are
    provided through the `functions.sh` file we installed earlier and are simple `awk`/`grep`/`sed`
    combinations against the SELinux policy files.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这时`sefinddef`、`seshowdef`、`sefindif`和`seshowif`函数就派上用场了。这些函数不是 SELinux 用户空间的一部分，它们是通过我们之前安装的`functions.sh`文件提供的，并且是针对
    SELinux 策略文件的简单`awk`/`grep`/`sed`组合。
- en: With `sefinddef` (the SELinux find definition), we can search through the support
    macros (not related to a particular SELinux policy module) for any definition
    that matches the expression given to it. In this recipe, we gave `file.*write`
    as the expression to look for. The `seshowdef` (SELinux show definition) function
    shows us the entire definition of the given pattern.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sefinddef`（SELinux查找定义），我们可以通过支持的宏（与特定的SELinux政策模块无关）搜索任何与给定表达式匹配的定义。在这个方案中，我们给出了`file.*write`作为查找的表达式。`seshowdef`（SELinux显示定义）函数会展示给定模式的完整定义。
- en: 'The `sefindif` (SELinux find interface) function then allows us to find an
    interface that the SELinux policy provides. In this recipe, we used it to search
    for the interface that allows a domain to write to the BIND DNS server configuration
    files. There is also a `seshowif` (SELinux show interface) function that shows
    us the entire interface definition like the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`sefindif`（SELinux查找接口）函数允许我们找到SELinux政策提供的接口。在这个方案中，我们用它来搜索允许一个域写入BIND DNS服务器配置文件的接口。还有一个`seshowif`（SELinux显示接口）函数，能显示出接口的完整定义，如下所示：'
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This example interface nicely shows how interfaces are handled by the SELinux
    reference policy build system. Whenever such an interface is called, one or more
    arguments are given to the interface. In our case, we passed on `syslogd_t` as
    the first (and only) argument.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例接口很好地展示了SELinux参考政策构建系统如何处理接口。每当调用此类接口时，都会向接口传递一个或多个参数。在我们的例子中，我们将`syslogd_t`作为第一个（也是唯一的）参数传递给它。
- en: 'The build system then substitutes every `$1` occurrence in the interface with
    the first argument, effectively expanding the call to the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，构建系统会将接口中的每个`$1`替换为第一个参数，实际扩展调用为以下代码：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The call to `write_files_pattern` is then expanded with the definition we saw
    earlier.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对`write_files_pattern`的调用随后会被我们之前看到的定义扩展。
- en: For the policy developer, this is all handled transparently. The sources of
    the SELinux policy file stay well-formatted and only call the interfaces. It is
    at build time that the expansion of the various interfaces is done. This allows
    developers to have nicely segregated, compartmentalized policy definitions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于政策开发者来说，这一切都由系统透明处理。SELinux政策文件的源代码保持良好的格式化，并且只调用接口。界面扩展的工作在构建时完成。这允许开发者拥有整洁分隔、模块化的政策定义。
- en: See also
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The reference policy project can be found online at [http://oss.tresys.com/projects/refpolicy/](http://oss.tresys.com/projects/refpolicy/)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考政策项目可以在线找到，[http://oss.tresys.com/projects/refpolicy/](http://oss.tresys.com/projects/refpolicy/)
- en: Creating our own interface
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们自己的接口
- en: Being able to call interfaces is nice, but when we develop SELinux policies,
    we will run into situations where we need to create our own interface for the
    SELinux module we are developing. This is done through a file with an `.if` extension.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 能够调用接口是很好的，但当我们开发SELinux政策时，会遇到需要为我们开发的SELinux模块创建自己的接口的情况。这是通过一个`.if`扩展名的文件来实现的。
- en: In this recipe, we are going to extend the `mylogging` policy with an interface
    that allows other domains to execute the system log daemon binary (but without
    running this binary with the privileges of the system logger itself; this would
    be called a domain transition in SELinux).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方案中，我们将通过一个接口扩展`mylogging`政策，允许其他域执行系统日志守护进程的二进制文件（但不会以系统日志记录器的权限运行该二进制文件；这在SELinux中称为域转换）。
- en: How to do it…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'If our current context is an unprivileged user domain (as unconfined domains
    are highly privileged and can do almost everything), we can try executing the
    system logger daemon (`syslog-ng` or `rsyslog`) directly and have it fail as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们当前的上下文是一个无特权用户域（因为未受限的域具有高度特权，并且几乎可以执行任何操作），我们可以尝试直接执行系统日志守护进程（`syslog-ng`或`rsyslog`），并使其失败，如下所示：
- en: '[PRE23]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, create the `mylogging.if` file (in the same location where `mylogging.te`
    is) with the following content, granting all permissions needed to execute the
    binary:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建`mylogging.if`文件（与`mylogging.te`位于同一位置），其内容如下，授予执行该二进制文件所需的所有权限：
- en: '[PRE24]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a new SELinux policy module for the user domain; this policy should
    be able to execute the system logger directly. For instance, for the `sysadm_t`
    domain, we would create a `mysysadm.te` file with the following content:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为用户域创建一个新的SELinux政策模块；该政策应能够直接执行系统日志记录器。例如，对于`sysadm_t`域，我们将创建一个`mysysadm.te`文件，其内容如下：
- en: '[PRE25]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Build the `mysysadm` policy module and load it. Then, test to see if the daemon
    binary can now be executed directly:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`mysysadm`策略模块并加载它。然后，测试是否现在可以直接执行守护进程二进制文件：
- en: '[PRE26]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Let's first look at how the build system knows where the interface definitions
    are. Then, we'll cover the in-line comment system used in the example.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看一下构建系统如何知道接口定义的位置。然后，我们将介绍示例中使用的内联注释系统。
- en: The location of the interface definitions
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口定义的位置
- en: 'Whenever an SELinux policy module is built, the build system sources all interface
    files it finds at the following locations:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每当构建一个SELinux策略模块时，构建系统会获取它在以下位置找到的所有接口文件：
- en: '`/usr/share/selinux/mcs/include/*` or `/usr/share/selinux/devel/include/*`
    (depending on the Linux distribution)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/share/selinux/mcs/include/*`或`/usr/share/selinux/devel/include/*`（具体取决于Linux发行版）'
- en: The current working directory
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前工作目录
- en: The first location is where the interface files of all the SELinux modules provided
    by the Linux distribution are stored. The files are inside subdirectories named
    after particular categories (the reference policy calls these layers, but this
    is only used to make some structure amongst the definitions, nothing else) such
    as `contrib/`, `system/`, and `roles/`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个位置是存储所有Linux发行版提供的SELinux模块的接口文件的地方。这些文件位于以特定类别命名的子目录中（参考策略将其称为层，但这仅用于在定义中创建一些结构，并无其他用途），例如`contrib/`、`system/`和`roles/`。
- en: For local development of SELinux policies, this location is usually not writable.
    If we develop our own policy modules, then this would mean that none of the locally
    managed SELinux policy files can use interfaces of the other local interface files.
    The `Makefile` file, therefore, also sources all interface files it finds in the
    current working directory.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SELinux策略的本地开发，通常该位置不可写。如果我们开发自己的策略模块，那么这意味着本地管理的SELinux策略文件不能使用其他本地接口文件的接口。因此，`Makefile`文件也会获取当前工作目录中找到的所有接口文件。
- en: The in-line documentation
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内联文档
- en: Inside the interface file created, we notice a few XML-like structures as comments.
    These comments are prefixed by a double hash sign (`##`) and are used by the reference
    policy build system to generate the API documentation (which can be found at `/usr/share/doc/selinux-*`).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建的接口文件中，我们会注意到一些类似XML的结构作为注释。这些注释以双井号（`##`）为前缀，并被参考策略构建系统用于生成API文档（可以在`/usr/share/doc/selinux-*`中找到）。
- en: For local policies, this in-line documentation is not used and, thus, not mandatory.
    However, writing the documentation even for local policies helps us in documenting
    the rules better. Also, if we ever want to push our changes upstream, this in-line
    documentation will be requested anyway.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地策略，不使用这种内联文档，因此也不是强制性的。然而，即使是对于本地策略，编写文档有助于更好地记录规则。此外，如果我们以后想将更改推送到上游，这种内联文档仍然是必需的。
- en: 'The comment system uses the following constructs:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注释系统使用以下结构：
- en: Right before an interface definition, we encounter a `<summary>` element, which
    provides a one-sentence description of the interface
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接口定义之前，我们会遇到一个`<summary>`元素，它提供了接口的单句描述。
- en: Additional information can then be provided through a `<desc>` element under
    which the HTML code can be placed for documenting the interface further
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的信息可以通过`<desc>`元素提供，并可以在其中放置HTML代码以进一步记录接口。
- en: Every parameter to an interface is documented through a `<param>` entity, which
    again contains a `<summary>` line
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个接口的参数都通过`<param>`实体进行文档化，该实体包含一个`<summary>`行。
- en: See also
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The reference policy API documentation can be found online at [http://oss.tresys.com/docs/refpolicy/api/](http://oss.tresys.com/docs/refpolicy/api/)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考策略API文档可以在线查看，网址是[http://oss.tresys.com/docs/refpolicy/api/](http://oss.tresys.com/docs/refpolicy/api/)
- en: Using the refpolicy naming convention
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用refpolicy命名约定
- en: The interface names used to simplify policy development can be freely chosen.
    However, the reference policy itself uses a naming convention to try and structure
    the names used so that the SELinux policy developers can easily find the interfaces
    they need—if they exist—and give an unambiguous name to an interface they want
    to create.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 用于简化策略开发的接口名称可以自由选择。然而，参考策略本身使用命名约定，尝试构造所使用的名称，以便SELinux策略开发人员能够轻松找到他们需要的接口（如果存在），并为他们想要创建的接口提供一个明确的名称。
- en: The naming convention for the reference policy is available online at [http://oss.tresys.com/projects/refpolicy/wiki/InterfaceNaming](http://oss.tresys.com/projects/refpolicy/wiki/InterfaceNaming).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 参考策略的命名约定可以在 [http://oss.tresys.com/projects/refpolicy/wiki/InterfaceNaming](http://oss.tresys.com/projects/refpolicy/wiki/InterfaceNaming)
    上找到。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we''ll do a pen-and-paper exercise to see how the naming convention
    works. In the example, we will create interface names for three situations:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方案中，我们将进行一个笔头练习，看看命名约定如何工作。在示例中，我们将为三种情况创建接口名称：
- en: To read all logfiles
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取所有日志文件
- en: To connect to the HTTP port over TCP
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过TCP连接到HTTP端口
- en: To not audit getting the attributes of user home directories
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不审计获取用户主目录的属性
- en: How to do it…
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'First we need to figure out the file types that are involved in the situations:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先我们需要弄清楚在这些情况下涉及到的文件类型：
- en: 'Generic logfiles are `var_log_t` (as can be seen by querying the label of `/var/log/`itself):'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用日志文件是`var_log_t`（可以通过查询`/var/log/`本身的标签看到）：
- en: '[PRE27]'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When we deal with all logfiles, we can safely assume this is handled by an
    SELinux attribute. Let''s look at the attributes for the generic `var_log_t` type:'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们处理所有日志文件时，可以安全地假设这是由SELinux属性处理的。我们来看一下通用`var_log_t`类型的属性：
- en: '[PRE28]'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `logfile` attribute looks like an interesting hit. We can now grep through
    the policy sources to figure out which SELinux policy modules handle the `logfile`
    attribute, or use `sefindif` (assuming that there are interfaces defined that
    handle this attribute):'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logfile`属性看起来是一个有趣的命中。我们现在可以通过查询策略源，找出哪些SELinux策略模块处理`logfile`属性，或者使用`sefindif`（假设有定义接口来处理此属性）：'
- en: '[PRE29]'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For the logfiles example, the module we need is called `logging` as can be seen
    from the `sefindif` output. Similarly, we will find that for the HTTP port, the
    module is `corenet`, and home directories are `userdom`.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于日志文件的例子，我们需要的模块叫做`logging`，可以通过`sefindif`的输出看到。同样，我们会发现对于HTTP端口，模块是`corenet`，而主目录是`userdom`。
- en: 'Next, we check whether there is a modifier. The first two situations have no
    specific modifier (all the actions are regular verbs). The last example has one:
    do not audit. In the SELinux policy language, this is known as a `dontaudit` statement.'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查是否有修饰符。前两种情况没有特定的修饰符（所有的动作都是常规动词）。最后一个例子有一个修饰符：do not audit。在 SELinux
    策略语言中，这被称为`dontaudit`语句。
- en: 'Now, let''s look at the verbs involved. This is mostly based on experience,
    but the situations show that there is a huge correlation between the verbs and
    the eventually chosen `refpolicy` name (which usually uses SELinux permission
    names):'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来看看涉及的动词。这主要基于经验，但这些情况表明，动词与最终选择的`refpolicy`名称（通常使用SELinux权限名称）之间有着很强的关联：
- en: In the first situation, this is `read`
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一种情况下，这是`读取`
- en: The second one has `connect over TCP`, which is translated into `tcp_connect`
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种情况有`通过TCP连接`，因此翻译为`tcp_connect`
- en: The last situation has `getting the attributes`, so it is translated as `getattr`
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一种情况涉及`获取属性`，因此翻译为`getattr`
- en: 'Finally, let''s look at the object that is being referenced:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们来看一下被引用的对象：
- en: In the first situation, this is `all logfiles`, which we will name `all_logs`
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一种情况下，这是`所有日志文件`，我们将其命名为`all_logs`
- en: In the second situation, this is `HTTP port`, so we will name `http_port`
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二种情况下，这是`HTTP端口`，因此我们将命名为`http_port`
- en: The third situation has `user home directories`, so we will name `user_home_dirs`
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种情况涉及`用户主目录`，因此我们将命名为`user_home_dirs`
- en: 'Combining this gives us the following interface names:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结合这些信息，我们得到了以下接口名称：
- en: '**Read all logfiles**: `logging_read_all_logs`'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取所有日志文件**：`logging_read_all_logs`'
- en: '**Connect to the HTTP port over TCP**: `corenet_tcp_connect_http_port`'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过TCP连接到HTTP端口**：`corenet_tcp_connect_http_port`'
- en: '**Do not audit getting the attributes of user home directories**: `userdom_dontaudit_getattr_user_home_dirs`'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不审计获取用户主目录的属性**：`userdom_dontaudit_getattr_user_home_dirs`'
- en: How it works…
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The naming convention that the reference policy uses is not mandated in a technical
    manner. Just like with coding styles, naming conventions are made so that collaboration
    is easier (everyone uses the same naming convention) and searching through the
    large set of interfaces can be directed more efficiently.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 参考策略使用的命名约定并没有在技术上强制要求。就像编程风格一样，命名约定的目的是为了让协作更容易（每个人使用相同的命名约定），并且能够更高效地搜索大量的接口。
- en: Using the proper naming convention is a matter of exercise. If uncertain, ask
    around in `#selinux` on `irc://irc.freenode.net` or on the reference policy mailing
    list.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适当的命名规范是一个练习过程。如果不确定，可以在`#selinux`频道或者在`irc://irc.freenode.net`上的参考策略邮件列表中询问。
- en: There's more...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Take some time to look through the interface files available at `/usr/share/selinux/devel/include/`.
    Next, for the more standard permission-based interface names, there are also interface
    names used for templates and type assignation.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 花一些时间查看位于`/usr/share/selinux/devel/include/`的接口文件。接下来，对于更标准的基于权限的接口名称，还有用于模板和类型分配的接口名称。
- en: For instance, there is a template called `apache_content_template`. Through
    it, additional SELinux types and permissions (used for web applications) are created
    in one go. Similarly, there is an interface called `apache_cgi_domain` that marks
    a particular type as being a domain that can be invoked through a web servers'
    CGI support.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有一个名为`apache_content_template`的模板。通过它，可以一次性创建附加的SELinux类型和权限（用于Web应用程序）。类似地，还有一个接口叫做`apache_cgi_domain`，它将某个特定类型标记为可以通过Web服务器的CGI支持调用的域。
- en: Besides the naming convention, the reference policy also has a style guide available
    at [http://oss.tresys.com/projects/refpolicy/wiki/StyleGuide](http://oss.tresys.com/projects/refpolicy/wiki/StyleGuide).
    Like the naming convention, this is purely a human aspect for improved collaboration—there
    is no consequence of violating the coding style beyond the changes that might
    not be accepted in the upstream repositories.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 除了命名规范，参考策略还有一个风格指南，网址为[http://oss.tresys.com/projects/refpolicy/wiki/StyleGuide](http://oss.tresys.com/projects/refpolicy/wiki/StyleGuide)。和命名规范一样，这纯粹是为了改善协作的一个人为方面——违反编码风格不会带来其他后果，只是可能会导致更改未被上游仓库接受。
- en: Distributing SELinux policy modules
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发SELinux策略模块
- en: We finish this chapter by explaining how SELinux policy modules can be distributed
    across multiple systems.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的结束部分解释了如何将SELinux策略模块分布到多个系统中。
- en: How to do it…
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To distribute SELinux policies, complete the following steps:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要分发SELinux策略，完成以下步骤：
- en: 'Take into account the different system configurations to which the SELinux
    policies need to be distributed:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑需要分发SELinux策略的不同系统配置：
- en: If multiple systems have different SELinux policy releases to be active, then
    build the SELinux policy module against each of these implementations. This is
    heavily distribution specific. For instance, on Gentoo, this is the version of
    the `sec-policy/selinux-base` package. On Red Hat and derived distributions, this
    is the version of the `selinux-policy` package.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果多个系统有不同的SELinux策略版本需要激活，那么需要针对每个实现构建SELinux策略模块。这是高度依赖发行版的。例如，在Gentoo上，这是`sec-policy/selinux-base`包的版本。在Red
    Hat及其衍生发行版上，这是`selinux-policy`包的版本。
- en: 'If multiple SELinux policy types are active (such as `mcs`, `targeted`, and
    `strict`) and there are both MLS-enabled as well as MLS-disabled policies, then
    the SELinux policy module will need to be built against both an MLS-enabled policy
    as well as an MLS-disabled policy. The output of `sestatus` will tell us whether
    MLS is enabled on an active policy or not:'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果多个SELinux策略类型处于激活状态（如`mcs`、`targeted`和`strict`），并且既有启用MLS的策略，也有禁用MLS的策略，那么需要同时针对启用和禁用MLS的策略构建SELinux策略模块。`sestatus`的输出将告诉我们是否在活动策略上启用了MLS：
- en: '[PRE30]'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Package the resulting `.pp` files and distribute them to the various systems.
    It is a common best practice to place the `.pp` files inside `/usr/share/selinux/mcs/`
    (this is for an SELinux policy store named `mcs`, you can adjust it where needed).
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的`.pp`文件打包并分发到不同的系统上。一个常见的最佳实践是将`.pp`文件放置在`/usr/share/selinux/mcs/`目录下（这是针对名为`mcs`的SELinux策略存储，你可以根据需要进行调整）。
- en: On each system, make sure that the `.pp` file is loaded through `semodule –I
    policyfile.pp`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个系统上，确保通过`semodule –I policyfile.pp`加载`.pp`文件。
- en: How it works…
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: SELinux policy modules (the files ending with `.pp`) contain everything SELinux
    needs to activate the policy. By distributing these files across many systems
    (and loading it through the `semodule` command), these systems receive the wanted
    updates against their current SELinux policy.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux策略模块（以`.pp`结尾的文件）包含了SELinux激活策略所需的一切内容。通过将这些文件分发到多个系统中（并通过`semodule`命令加载它们），这些系统将获得针对其当前SELinux策略的所需更新。
- en: Once loaded (and this only needs to happen once, as a loaded module is retained
    even after the system reboots), one does not really need the `.pp` files anymore
    (loaded modules are copied inside `/etc/selinux`). However, it is recommended
    that you keep the policies there so that administrators can reload policies as
    needed; this might help in troubleshooting the SELinux policy and system permission
    issues.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载（并且这只需要发生一次，因为加载的模块即使在系统重启后也会保留），实际上不再需要`.pp`文件了（加载的模块会被复制到`/etc/selinux`中）。然而，建议你保留这些策略文件，以便管理员可以根据需要重新加载策略；这可能有助于排查SELinux策略和系统权限问题。
- en: 'There are a few caveats to take into account though:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，仍然有一些需要注意的事项：
- en: Changes in interfaces
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口变化
- en: Kernel version changes
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核版本变化
- en: MLS-enabled or MLS-disabled policies
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用MLS或禁用MLS的策略
- en: Changes in interfaces
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口变化
- en: The `.pp` files contain all rules that SELinux needs to enforce the additional
    policy rules. This includes the (expanded) rules that were part of the interface
    definition files (the `.if` files) of the module itself as well as the interfaces
    referred to by the policy module.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`.pp`文件包含SELinux执行附加策略规则所需的所有规则。这包括（扩展的）规则，它们是模块自身接口定义文件（`.if`文件）的一部分，以及策略模块引用的接口。'
- en: When an update against an interface occurs, then all SELinux policy modules
    that might be affected by the change need to be rebuilt. As there is no simple
    way to know if a module needs to be rebuilt or not, it is recommended that you
    rebuild all policy modules every time a change has occurred to at least one interface.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当接口发生更新时，所有可能受该变化影响的SELinux策略模块都需要重新构建。由于没有简单的方法可以判断模块是否需要重新构建，因此建议每当至少一个接口发生变化时，都重新构建所有策略模块。
- en: Distributions will handle the rebuilding of the policies and the distribution
    of the rebuilt policies themselves, but for custom policy modules, we need to
    do this ourselves.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 发行版将处理策略的重建和重新分发，但对于自定义策略模块，我们需要自己执行此操作。
- en: Kernel version changes
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内核版本变化
- en: New kernel releases might include updates against the SELinux subsystem. When
    these updates provide additional features, the binary representation of a policy
    might be updated. This is then reflected in the binary version of the policy that
    the kernel supports.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 新的内核版本可能会包括对SELinux子系统的更新。当这些更新提供附加功能时，策略的二进制表示可能会更新。这将反映在内核支持的策略二进制版本中。
- en: 'Binary versions are backward compatible, so a system that supports a maximum
    version of `28` (SELinux''s binary versions are integers that are incremented
    with every change) will also support loading policy modules of a lower binary
    version:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制版本是向后兼容的，因此支持最大版本为`28`的系统（SELinux的二进制版本是每次更改时递增的整数）也支持加载较低二进制版本的策略模块：
- en: '[PRE31]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When the binary version of an SELinux policy module is higher than the maximum
    kernel policy version, this SELinux policy module will not load on the target
    system. A higher version means that the policy uses features that are only available
    in kernels that support this version, so the administrator will need to update
    the kernels on those systems to support the higher version or update the SELinux
    policy module to not use these features so that a rebuild creates a lower-versioned
    binary SELinux policy module.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当SELinux策略模块的二进制版本高于最大内核策略版本时，该SELinux策略模块将无法在目标系统上加载。较高版本意味着该策略使用了只有在支持该版本的内核中才能使用的功能，因此管理员需要更新这些系统上的内核，以支持较高版本，或更新SELinux策略模块，不使用这些功能，从而使重建的二进制SELinux策略模块为较低版本。
- en: MLS or not
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 是否启用MLS
- en: SELinux policy modules might contain sensitivity-related information. When a
    policy module is built, information is added to reflect whether it is built against
    an MLS-enabled system or not.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux策略模块可能包含与敏感性相关的信息。当构建策略模块时，会添加信息以反映该模块是针对启用了MLS的系统构建的，还是未启用MLS的系统构建的。
- en: Therefore, if we have hosts that have diverse policy usages (some policy stores
    are MLS-enabled and some are MLS-disabled), then the SELinux policy module will
    need to be built against both and distributed separately.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们有多个主机，它们使用了不同的策略（一些策略存储启用了MLS，而一些则禁用了MLS），那么SELinux策略模块需要同时针对这两种情况进行构建，并分别分发。
- en: Usually, this is done by providing SELinux policy modules for each particular
    SELinux policy type (be it `mcs`, `strict`, or `targeted`).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这是通过为每种特定的SELinux策略类型提供SELinux策略模块来实现的（无论是`mcs`、`strict`还是`targeted`）。
