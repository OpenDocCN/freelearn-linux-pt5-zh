- en: Have a Good Command
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥有一条好命令
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下技巧：
- en: Concatenating with `cat`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`cat`连接文件
- en: Recording and playing back terminal sessions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录和回放终端会话
- en: Finding files and file listing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找文件和文件列表
- en: Playing with `xargs`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`xargs`进行操作
- en: Translating with `tr`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tr`进行翻译
- en: Checksum and verification
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 校验和和验证
- en: Cryptographic tools and hashes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密工具和哈希
- en: Sorting unique and duplicate lines
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序唯一行和重复行
- en: Temporary file naming and random numbers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时文件命名和随机数
- en: Splitting files and data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分割文件和数据
- en: Slicing filenames based on extensions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于扩展名切割文件名
- en: Renaming and moving files in bulk
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量重命名和移动文件
- en: Spell–checking and dictionary manipulation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拼写检查和字典操作
- en: Automating interactive input
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化交互式输入
- en: Making commands quicker by running parallel processes
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过运行并行进程加速命令执行
- en: Examining a directory, files and subdirectories in it
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查目录、文件及其子目录
- en: Introduction
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Unix-like systems have the best command-line tools. Each command performs a
    simple function to make our work easier. These simple functions can be combined
    with other commands to solve complex problems. Combining simple commands is an
    art; you will get better at it as you practice and gain experience. This chapter
    introduces some of the most interesting and useful commands, including `grep`,
    `awk`, `sed`, and `find`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 类Unix系统拥有最好的命令行工具。每个命令执行简单的功能，以便使我们的工作更加轻松。这些简单的功能可以与其他命令组合在一起，解决复杂的问题。将简单命令组合起来是一门艺术；通过练习和积累经验，你会越来越擅长。
    本章介绍了一些最有趣和最有用的命令，包括`grep`、`awk`、`sed`和`find`。
- en: Concatenating with cat
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`cat`进行连接
- en: The `cat` command displays or concatenates the contents of a file, but `cat`
    is capable of more. For example, `cat` can combine standard input data with data
    from a file. One way of combining the `stdin` data with file data is to redirect
    `stdin` to a file and then append two files. The `cat` command can do this in
    a single invocation. The next recipes show basic and advanced usages of `cat`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`命令显示或连接文件的内容，但`cat`命令能做更多的事情。例如，`cat`可以将标准输入数据与文件中的数据结合起来。将`stdin`数据与文件数据结合的一种方式是将`stdin`重定向到文件中，然后将两个文件合并。`cat`命令可以通过一次调用完成此操作。接下来的技巧展示了`cat`的基本和高级用法。'
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: The `cat` command is a simple and frequently used command and it stands for
    **conCATenate**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`命令是一个简单且常用的命令，它代表**conCATenate**（连接）。'
- en: 'The general syntax of `cat` for reading contents is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 用于读取内容的`cat`命令的一般语法如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command concatenates data from the files specified as command-line arguments
    and sends that data to `stdout`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将命令行参数中指定的文件的数据连接起来，并将这些数据发送到`stdout`。
- en: 'To print contents of a single file, execute the following command:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要打印单个文件的内容，请执行以下命令：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To print contents of more than one file, execute the following command:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要打印多个文件的内容，请执行以下命令：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `cat` command not only reads from files and concatenates the data but also
    reads from the standard input.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`命令不仅可以从文件中读取并连接数据，还可以从标准输入读取数据。'
- en: 'The pipe operator redirects data to the cat command''s standard input as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 管道操作符将数据重定向到`cat`命令的标准输入，如下所示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `cat` command can also concatenate content from files with input from a
    terminal.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`命令也可以将文件内容与终端输入结合起来。'
- en: 'Combine `stdin` and data from another file, like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将`stdin`和另一个文件中的数据结合起来，像这样：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, `-` acts as the filename for the `stdin` text.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`-`充当`stdin`文本的文件名。
- en: There's more...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `cat` command has many other options for viewing files. You can view the
    complete list by typing `man cat` in a terminal session.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`命令有许多其他选项来查看文件。你可以通过在终端会话中输入`man cat`来查看完整的列表。'
- en: Getting rid of extra blank lines
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去除多余的空行
- en: 'Some text files contain two or more blank lines together. If you need to remove
    the extra blank lines, use the following syntax:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有些文本文件中包含两个或多个连续的空行。如果你需要去除多余的空行，可以使用以下语法：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Consider the following example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can remove all blank lines with `tr`, as discussed in the *Translating with
    tr* recipe in this chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`tr`删除所有空行，正如本章中的*使用tr进行翻译*技巧所讨论的那样。
- en: Displaying tabs as ^I
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将标签显示为 ^I
- en: It is hard to distinguish tabs and repeated space characters. Languages such
    as Python may treat tabs and spaces differently. Mixtures of tabs and spaces may
    look similar in an editor, but appear as different indentations to the interpreter.
    It is difficult to identify the difference between tabs and spaces when viewing
    a file in a text editor. `cat` can also identify tabs. This helps you to debug
    indentation errors.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 很难区分制表符和重复的空格字符。像 Python 这样的语言可能会对制表符和空格进行不同的处理。制表符和空格的混合在编辑器中可能看起来相似，但对解释器来说却是不同的缩进。当在文本编辑器中查看文件时，很难识别制表符和空格之间的区别。`cat`
    还可以识别制表符。这有助于你调试缩进错误。
- en: 'The `cat` command''s `-T` option displays tab characters as `^I`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat` 命令的 `-T` 选项将制表符显示为 `^I`：'
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Line numbers
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行号
- en: 'The cat command''s `-n` flag prefixes a line number to each line. Consider
    this example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat` 命令的 `-n` 标志会在每行前添加行号。请看这个示例：'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `cat` command never changes a file. It sends output to `stdout` after modifying
    the input according to the options. Do not attempt to use redirection to overwrite
    your input file. The shell creates the new output file before it opens the input
    file. The `cat` command will not let you use the same file as input and redirected
    output. Trying to trick `cat` with a pipe and redirecting the output will empty
    the input file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat` 命令不会更改文件。它会在根据选项修改输入后将输出发送到 `stdout`。不要尝试使用重定向来覆盖输入文件。Shell 会在打开输入文件之前创建新的输出文件。`cat`
    命令不会允许你将同一个文件作为输入和重定向输出。试图用管道和重定向输出来“欺骗” `cat` 会清空输入文件。'
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `-n` option generates line numbers for all lines, including blank lines.
    If you want to skip numbering blank lines, use the `-b` option.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`-n` 选项会为所有行生成行号，包括空白行。如果你想跳过空白行的编号，可以使用 `-b` 选项。'
- en: Recording and playing back terminal sessions
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录和回放终端会话
- en: Recording a screen session as a video is useful, but a video is an overkill
    for debugging terminal sessions or providing a shell tutorial.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 录制屏幕会话作为视频很有用，但对于调试终端会话或提供 Shell 教程来说，视频显得有些过于复杂。
- en: The shell provides another option. The `script` command records your keystrokes
    and the timing of keystrokes as you type, and saves your input and the resulting
    output in a pair of files. The `scriptreplay` command will replay the session.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 提供了另一个选项。`script` 命令会记录你输入的按键和按键的时间，同时将你的输入和结果输出保存到一对文件中。`scriptreplay`
    命令将重放这个会话。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好
- en: The `script` and `scriptreplay` commands are available in most GNU/Linux distributions.
    You can create tutorials of command-line hacks and tricks by recording the terminal
    sessions. You can also share the recorded files for others to playback and see
    how to perform a particular task with the command line. You can even invoke other
    interpreters and record the keystrokes sent to that interpreter. You cannot record
    vi, emacs, or other applications that map characters to particular locations on
    the screen.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`script` 和 `scriptreplay` 命令在大多数 GNU/Linux 发行版中都有提供。你可以通过录制终端会话来创建命令行技巧和技巧的教程。你还可以分享录制的文件，让别人回放并查看如何用命令行执行特定任务。你甚至可以调用其他解释器，并记录发送到该解释器的按键输入。你无法记录像
    vi、emacs 或其他将字符映射到屏幕上特定位置的应用程序。'
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Start recording the terminal session with the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令开始记录终端会话：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A full example looks like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的示例如下：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that this recipe will not work with shells that do not support redirecting
    only `stderr` to a file, such as the `csh` shell.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个方法在不支持将 `stderr` 仅重定向到文件的 Shell 中（如 `csh` shell）无法使用。
- en: The `script` command accepts a filename as an argument. This file will hold
    the keystrokes and the command results. When you use the `-t` option, the script
    command sends timing data to `stdout`. The timing data can be redirected to a
    file (`timing.log`), which records the timing info for each keystroke and output.
    The previous example used `2>` to redirect `stderr` to `timing.log`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`script` 命令接受一个文件名作为参数。这个文件将保存按键输入和命令结果。当使用 `-t` 选项时，`script` 命令将时间数据发送到 `stdout`。这些时间数据可以被重定向到一个文件（`timing.log`），记录每个按键输入和输出的时间信息。之前的示例使用了
    `2>` 来将 `stderr` 重定向到 `timing.log`。'
- en: 'Using the two files, `timing.log` and `output.session`, we can replay the sequence
    of command execution as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个文件，`timing.log` 和 `output.session`，我们可以按如下方式重放命令执行的序列：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: We often record desktop videos to prepare tutorials. However, videos require
    a considerable amount of storage, while a terminal script file is just a text
    file, usually only in the order of kilobytes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常录制桌面视频来准备教程。然而，视频需要大量存储空间，而终端脚本文件只是一个文本文件，通常只有几千字节大小。
- en: You can share the `timing.log` and `output.session` files to anyone who wants
    to replay a terminal session in their terminal.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`timing.log`和`output.session`文件共享给任何希望在终端中重放终端会话的人。
- en: Finding files and file listing
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找文件和文件列表
- en: The `find` command is one of the great utilities in the Unix/Linux command-line
    toolbox. It is useful both at the command line and in shell scripts. Like `cat`
    and `ls`, `find` has many features, and most people do not use it to its fullest.
    This recipe deals with some common ways to utilize `find` to locate files.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`命令是Unix/Linux命令行工具箱中的一个伟大工具。它在命令行和Shell脚本中都很有用。像`cat`和`ls`一样，`find`有许多功能，而大多数人并没有充分利用它。这个食谱介绍了几种常见的使用`find`来定位文件的方法。'
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The `find` command uses the following strategy:  `find` descends through a
    hierarchy of files, matches files that meet the specified criteria, and performs
    some actions. The default action is to print the names of files and folders, which
    can be specified with the `-print` option.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`命令采用以下策略：`find`通过文件层次结构进行递归查找，匹配满足指定条件的文件，并执行某些操作。默认操作是打印文件和文件夹的名称，可以通过`-print`选项指定。'
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To list all the files and folders descending from a given directory, use this
    syntax:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出从给定目录递归查找的所有文件和文件夹，请使用以下语法：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `base_path` can be any location from which `find` should start descending
    (for example, `/home/slynux/`).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`base_path`可以是`find`开始递归查找的任何位置（例如，`/home/slynux/`）。'
- en: 'Here''s an example of this command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个命令的一个示例：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `.` specifies the current directory and `..` specifies the parent directory.
    This convention is followed throughout the Unix filesystem.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`.`指定当前目录，`..`指定父目录。这一约定在整个Unix文件系统中都得到了遵循。'
- en: 'The print option separates each file or folder name with a `\n` (newline).
    The `-print0` option separates each name with a null character `''\0''`. The main
    use for `-print0` is to pass filenames containing newlines or whitespace characters
    to the `xargs` command. The `xargs` command will be discussed in more detail later:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`-print`选项将每个文件或文件夹的名称与`\n`（换行符）分开。`-print0`选项将每个名称与空字符`''\0''`分开。`-print0`的主要用途是将包含换行符或空格字符的文件名传递给`xargs`命令。`xargs`命令将在稍后详细讨论：'
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There's more...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The previous examples demonstrated using `find` to list all the files and folders
    in a filesystem hierarchy. The `find` command can select files based on glob or
    regular expression rules, depth in the filesystem tree, date, type of file, and
    more.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例演示了如何使用`find`列出文件系统层次结构中的所有文件和文件夹。`find`命令可以根据通配符或正则表达式规则、文件系统树中的深度、日期、文件类型等选择文件。
- en: Search based on name or regular expression match
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于名称或正则表达式匹配的搜索
- en: The `-name` argument specifies a selection pattern for the name. The `-name`
    argument accepts both glob-style wildcards and regular expressions. In the following
    example, `'*.txt'` matches all the file or folder names ending with `.txt` and
    prints them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`-name`参数指定名称的选择模式。`-name`参数接受通配符样式和正则表达式。在下面的示例中，`''*.txt''`匹配所有以`.txt`结尾的文件或文件夹名称并将其打印出来。'
- en: Note the single quotes around `*.txt`. The shell will expand glob wildcards
    with no quotes or using double-quotes (`"`). The single quotes prevent the shell
    from expanding the `*.txt` and passes that string to the `find` command.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`*.txt`周围的单引号。没有引号或使用双引号（`"`）时，Shell会展开通配符。单引号防止Shell展开`*.txt`，而是将该字符串传递给`find`命令。
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `find` command has an option `-iname` (ignore case), which is similar to
    `-name`, but it matches filenames regardless of case.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`命令有一个`-iname`（忽略大小写）选项，它类似于`-name`，但它匹配不区分大小写的文件名。'
- en: 'Consider the following example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下示例：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `find` command supports logical operations with the selection options. The
      `-a`  and     `-and` options perform a logical **AND**, while the `-o` and `-or`
    option perform a logical **OR**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`命令支持与选择选项的逻辑操作。`-a`和`-and`选项执行逻辑**与**，而`-o`和`-or`选项执行逻辑**或**。'
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous command will print all the `.txt` and `.pdf` files, since the `find`
    command matches both `.txt` and `.pdf` files. `\(` and `\)` are used to treat
    `-name "*.txt" -o -name "*.pdf"` as a single unit.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令将打印所有 `.txt` 和 `.pdf` 文件，因为 `find` 命令匹配了 `.txt` 和 `.pdf` 文件。`\( `和 `\)`
    用来将 `-name "*.txt" -o -name "*.pdf"` 作为一个单一单元来处理。
- en: The following command demonstrates using the `-and` operator to select only
    the file that starts with an `s` and has an `e` in the name somewhere.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令演示了使用 `-and` 运算符仅选择以 `s` 开头并且名称中有 `e` 的文件。
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `-path` argument restricts the match to files that match a path as well
    as a name. For example, `$ find /home/users -path '*/slynux/*' -name '*.txt' -print`
    will find `/home/users/slynux/readme.txt`, but not `/home/users/slynux.txt`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`-path` 参数将匹配限制为同时匹配路径和名称的文件。例如，`$ find /home/users -path ''*/slynux/*'' -name
    ''*.txt'' -print` 将找到 `/home/users/slynux/readme.txt`，但不会找到 `/home/users/slynux.txt`。'
- en: The `-regex` argument is similar to `-path`, but `-regex` matches the file paths
    based on regular expressions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`-regex` 参数类似于 `-path`，但 `-regex` 基于正则表达式来匹配文件路径。'
- en: Regular expressions are more complex than glob wildcards and support more precise
    pattern matching. A typical example of text matching with regular expressions
    is to recognize all e-mail addresses. An e-mail address takes the `name@host.root`
    form. It can be generalized as `[a-z0-9]+@[a-z0-9]+\.[a-z0-9]+`. The characters
    inside the square brackets represent a set of characters. In this case, `a-z`
    and `0-9` The `+` sign signifies that the previous class of characters can occur
    one or more times. A period is a single character wildcard (like a `?` in glob
    wildcards), so it must be escaped with a backslash to match an actual dot in the
    e-mail address. So, this regular expression translates to 'a sequence of letters
    or numbers, followed by an `@`, followed by a sequence of letters or numbers,
    followed by a period, and ending with a sequence of letters or numbers'. See the
    *Using regular expressions * recipe in [Chapter 4](22424a9e-fea7-49de-9589-ea32aeb0b829.xhtml),
    *Texting and Driving  *for more details.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式比通配符更复杂，支持更精确的模式匹配。一个典型的文本匹配示例是识别所有电子邮件地址。电子邮件地址通常是 `name@host.root` 的形式。它可以被概括为
    `[a-z0-9]+@[a-z0-9]+\.[a-z0-9]+`。方括号内的字符表示一组字符。在这个例子中，`a-z` 和 `0-9`。`+` 符号表示前面的字符类别可以出现一次或多次。点号是一个通配符字符（类似于通配符中的
    `?`），所以它必须用反斜杠转义以匹配电子邮件地址中的实际点。因此，这个正则表达式的意思是“一个字母或数字的序列，后跟一个 `@`，然后是一个字母或数字的序列，再后面是一个点，最后是一个字母或数字的序列”。有关更多详细信息，请参见
    [第4章](22424a9e-fea7-49de-9589-ea32aeb0b829.xhtml) 中的 *使用正则表达式* 章节，*开车与短信*。
- en: 'This command matches the `.py` or `.sh` files:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令匹配 `.py` 或 `.sh` 文件：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `-iregex` option ignores the case for regular expression matches.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`-iregex` 选项忽略正则表达式匹配的大小写。'
- en: 'Consider this example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下示例：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Negating arguments
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 否定参数
- en: 'The `find` command can also exclude things that match a pattern using `!`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 命令也可以使用 `!` 来排除匹配模式的内容：'
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will match all the files whose names do not end in `.txt`. The following
    example shows the result of the command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将匹配所有文件名不以 `.txt` 结尾的文件。以下示例显示了命令的结果：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Searching based on the directory depth
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于目录深度进行搜索
- en: The `find` command walks through all the subdirectories until it reaches the
    bottom of each subdirectory tree. By default, the `find` command will not follow
    symbolic links. The `-L` option will force it to follow symbolic links. If a link
    references a link that points to the original, `find` will be stuck in a loop.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 命令会遍历所有子目录，直到到达每个子目录树的底部。默认情况下，`find` 命令不会跟随符号链接。`-L` 选项会强制它跟随符号链接。如果一个链接引用了指向原始文件的链接，`find`
    会陷入循环。'
- en: The `-maxdepth` and `-mindepth` parameters restrict how far the `find` command
    will traverse. This will break the `find` command from an otherwise infinite search.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`-maxdepth` 和 `-mindepth` 参数限制了 `find` 命令的遍历深度。这会打破 `find` 命令的无限搜索。'
- en: The `/proc` filesystem contains information about your system and running tasks.
    The folder hierarchy for a task is quite deep and includes symbolic links that
    loop back on themselves. Each process running your system has an entry in `proc`,
    named for the process ID. Under each process ID is a folder called `cwd`, which
    is a link to that task's current working directory.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc` 文件系统包含关于你的系统和正在运行任务的信息。任务的文件夹层级非常深，并且包含指向自身的符号链接。每个正在运行的进程在 `proc`
    中都有一个条目，条目名称为进程 ID。每个进程 ID 下有一个名为 `cwd` 的文件夹，它是指向该任务当前工作目录的链接。'
- en: 'The following example shows how to list all the tasks that are running in a
    folder with a file named `bundlemaker.def`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何列出文件夹中所有运行的任务，文件名为 `bundlemaker.def`：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `-L` option tells the `find` command to follow symbolic links
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-L` 选项告诉 `find` 命令跟踪符号链接'
- en: The `/proc` is a folder to start searching
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc` 是开始搜索的文件夹'
- en: The `-maxdepth 3` option limits the search to only the current folder, not subfolders
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-maxdepth 3` 选项将搜索限制在当前文件夹中，而不包括子文件夹'
- en: The `-name 'bundlemaker.def'` option is the file to search for
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-name ''bundlemaker.def''` 选项是要搜索的文件'
- en: The `2>/dev/null` redirects error messages about recursive loops to the null
    device
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2>/dev/null` 将关于递归循环的错误信息重定向到空设备'
- en: 'The `-mindepth` option is similar to `-maxdepth`, but it sets the minimum depth
    for which `find` will report matches. It can be used to find and print files that
    are located with a minimum level of depth from the base path. For example, to
    print all files whose names begin with `f` and that are at least two subdirectories
    distant from the current directory, use the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`-mindepth` 选项类似于 `-maxdepth`，但它设置了 `find` 报告匹配项的最小深度。它可以用于查找并打印从基路径起至少有一定深度的文件。例如，要打印所有以
    `f` 开头并且至少距离当前目录两级子目录的文件，可以使用以下命令：'
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Files with names starting with `f` in the current directory or in `dir1` and
    `dir3` will not be printed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当前目录或 `dir1` 和 `dir3` 中以 `f` 开头的文件将不会显示。
- en: The `-maxdepth` and `-mindepth` option should be early in the `find` command.
    If they are specified as later arguments, it may affect the efficiency of `find`
    as it has to do unnecessary checks. For example, if `-maxdepth` is specified after
    a `-type` argument, the `find` command will first find the files having the specified
    `-type` and then filter out the files that don't match the proper depth. However,
    if the depth was specified before the `-type`, `find` will collect the files having
    the specified depth and then check for the file type, which is the most efficient
    way to search.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`-maxdepth` 和 `-mindepth` 选项应放在 `find` 命令的前面。如果它们被指定为后续参数，可能会影响 `find` 的效率，因为它必须进行不必要的检查。例如，如果
    `-maxdepth` 在 `-type` 参数之后指定，`find` 命令会首先找到具有指定 `-type` 的文件，然后过滤掉那些不匹配正确深度的文件。然而，如果深度在
    `-type` 之前指定，`find` 会先收集具有指定深度的文件，再检查文件类型，这样是最有效的搜索方式。'
- en: Searching based on file type
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于文件类型进行搜索
- en: Unix-like operating systems treat every object as a file. There are different
    kinds of file, such as regular files, directory, character devices, block devices,
    symlinks, hardlinks, sockets, FIFO, and so on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 类Unix操作系统将每个对象视为文件。文件有不同种类，如常规文件、目录、字符设备、块设备、符号链接、硬链接、套接字、FIFO 等。
- en: The `find` command filters the file search with the `-type` option. Using `-type`,
    we can tell the `find` command to match only files of a specified type.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 命令通过 `-type` 选项过滤文件搜索。使用 `-type`，我们可以告诉 `find` 只匹配指定类型的文件。'
- en: 'List only directories including descendants:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 仅列出包括后代在内的目录：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It is hard to list directories and files separately. But `find` helps to do
    it. List only regular files as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列出目录和文件是比较困难的，但 `find` 命令可以帮助完成。仅列出常规文件，如下所示：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'List only symbolic links as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 仅列出符号链接，如下所示：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following table shows the types and arguments `find` recognizes:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了 `find` 命令识别的类型和参数：
- en: '| **File type** | **Type argument** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **文件类型** | **类型参数** |'
- en: '| Regular file | `f` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 常规文件 | `f` |'
- en: '| Symbolic link | `l` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 符号链接 | `l` |'
- en: '| Directory | `d` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 目录 | `d` |'
- en: '| Character special device | `c` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 字符特殊设备 | `c` |'
- en: '| Block device | `b` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 块设备 | `b` |'
- en: '| Socket | `s` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 套接字 | `s` |'
- en: '| FIFO | `p` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| FIFO | `p` |'
- en: Searching by file timestamp
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于文件时间戳进行搜索
- en: 'Unix/Linux filesystems have three types of timestamp on each file. They are
    as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Unix/Linux 文件系统在每个文件上有三种时间戳。它们如下所示：
- en: '**Access time** (`-atime`): The timestamp when the file was last accessed'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问时间** (`-atime`): 文件最后被访问时的时间戳'
- en: '**Modification time** (`-mtime`): The timestamp when the file was last modified'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修改时间** (`-mtime`): 文件最后修改时的时间戳'
- en: '**Change time** (`-ctime`): The timestamp when the metadata for a file (such
    as permissions or ownership) was last modified'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修改时间** (`-ctime`): 文件元数据（如权限或所有权）最后修改时的时间戳'
- en: Unix does not store file creation time by default; however, some filesystems
    (`ufs2`, `ext4`, `zfs`, `btrfs`, `jfs`) save the creation time. The creation time
    can be accessed with the stat command.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 默认不存储文件创建时间；然而，一些文件系统（`ufs2`、`ext4`、`zfs`、`btrfs`、`jfs`）会保存创建时间。可以使用 `stat`
    命令访问创建时间。
- en: Given that some applications modify a file by creating a new file and then deleting
    the original, the creation date may not be accurate.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于某些应用程序通过创建新文件然后删除原始文件来修改文件，因此创建日期可能不准确。
- en: The `-atime`, `-mtime`, and `-ctime` option are the time parameter options available
    with `find`. They can be specified with integer values in *number of days*. The
    number may be prefixed with `-` or `+` signs. The `-` sign implies less than,
    whereas the `+` sign implies greater than.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`-atime`、`-mtime` 和 `-ctime` 选项是 `find` 命令中可用的时间参数选项。它们可以使用整数值指定，以 *天数* 为单位。该数字可以带有
    `-` 或 `+` 前缀。`-` 表示小于，而 `+` 表示大于。'
- en: 'Consider the following example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下示例：
- en: 'Print files that were accessed within the last seven days:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印在过去七天内被访问的文件：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Print files that have an access time exactly seven days old:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印出访问时间恰好是七天前的文件：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Print files that have an access time older than seven days:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印出访问时间超过七天的文件：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `-mtime` parameter will search for files based on the modification time;
    `-ctime` searches based on the change time.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`-mtime` 参数将根据修改时间搜索文件；`-ctime` 根据更改时间搜索文件。'
- en: 'The `-atime`, `-mtime`, and `-ctime` use time measured in days. The `find`
    command also supports options that measure in minutes. These are as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`-atime`、`-mtime` 和 `-ctime` 使用以天为单位的时间。`find` 命令还支持按分钟为单位的时间选项。具体如下：'
- en: '`-amin` (access time)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-amin`（访问时间）'
- en: '`-mmin` (modification time)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-mmin`（修改时间）'
- en: '`-cmin` (change time)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-cmin`（更改时间）'
- en: 'To print all the files that have an access time older than seven minutes, use
    the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印出所有访问时间超过七分钟的文件，使用以下命令：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `-newer` option specifies a reference file with a modification time that
    will be used to select files modified more recently than the reference file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`-newer` 选项指定一个参考文件，其修改时间将用于选择比参考文件更近期修改的文件。'
- en: 'Find all the files that were modified more recently than `file.txt` file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 查找所有比 `file.txt` 文件更近期修改的文件：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `find` command's timestamp flags are useful for writing backup and maintenance
    scripts.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 命令的时间戳标志对于编写备份和维护脚本非常有用。'
- en: Searching based on file size
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于文件大小的搜索
- en: 'Based on the file sizes of the files, a search can be performed:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文件的大小，可以执行搜索：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Instead of `k`, we can use these different size units:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `k`，我们还可以使用这些不同的大小单位：
- en: '`b`: 512 byte blocks'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`：512 字节块'
- en: '`c`: Bytes'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`：字节'
- en: '`w`: Two-byte words'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`：双字节词'
- en: '`k`: Kilobytes (1,024 bytes)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k`：千字节（1,024 字节）'
- en: '`M`: Megabytes (1,024 kilobytes)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M`：兆字节（1,024 千字节）'
- en: '`G`: Gigabytes (1,024 megabytes)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G`：千兆字节（1,024 兆字节）'
- en: Matching based on file permissions and ownership
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于文件权限和所有权匹配
- en: 'It is possible to match files based on the file permissions. We can list out
    the files with specified file permissions:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 可以根据文件权限匹配文件。我们可以列出具有指定文件权限的文件：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `-perm` option specifies that `find` should only match files with their
    permission set to a particular value. Permissions are explained in more detail
    in the *Working with file permissions, ownership, **and the sticky bit * recipe
    in Chapter 3, *File In, File Out*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`-perm` 选项指定 `find` 只匹配其权限设置为特定值的文件。权限的更多细节可以参考第 3 章《*文件进，文件出*》中的 *与文件权限、所有权和粘滞位*
    配方。'
- en: 'As an example usage case, we can consider the case of the Apache web server.
    The PHP files in the web server require proper permissions to execute. We can
    find PHP files that don''t have proper executing permissions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个使用案例，我们可以考虑 Apache web 服务器的情况。Web 服务器中的 PHP 文件需要适当的权限才能执行。我们可以找到没有适当执行权限的
    PHP 文件：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can also search files based on ownership. The files owned by a specific user
    can be found with the `-user USER` option.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以基于文件的所有权进行搜索。可以使用 `-user USER` 选项找到由特定用户拥有的文件。
- en: The `USER` argument can be a username or UID.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`USER` 参数可以是用户名或 UID。'
- en: 'For example, to print a list of all files owned by the `slynux` user, you can
    use the following command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要打印出所有由 `slynux` 用户拥有的文件，可以使用以下命令：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Performing actions on files with find
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对文件执行操作
- en: The find command can perform actions on the files it identifies. You can delete
    files, or execute an arbitrary Linux command on the files.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 命令可以对其识别的文件执行操作。你可以删除文件，或对文件执行任意的 Linux 命令。'
- en: Deleting based on file matches
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于文件匹配删除
- en: 'The `find` command''s `-delete` flag removes files that are matched instead
    of displaying them. Remove the `.swp` files from the current directory:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 命令的 `-delete` 标志会删除匹配的文件，而不是显示它们。删除当前目录中的 `.swp` 文件：'
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Executing a command
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行命令
- en: The `find` command can be coupled with many of the other commands using the
    `-exec` option.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 命令可以使用 `-exec` 选项与其他许多命令配合使用。'
- en: Consider the previous example. We used `-perm` to find files that do not have
    proper permissions. Similarly, in the case where we need to change the ownership
    of all files owned by a certain user (for example, `root`) to another user (for
    example, `www-data`, the default Apache user in the web server), we can find all
    the files owned by `root` using the `-user` option and use `-exec` to perform
    the ownership change operation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑之前的示例。我们使用 `-perm` 查找没有正确权限的文件。类似地，在需要将某个用户（例如 `root`）拥有的所有文件的所有权更改为另一个用户（例如
    `www-data`，Web 服务器中默认的 Apache 用户）时，我们可以使用 `-user` 选项查找所有 `root` 拥有的文件，并使用 `-exec`
    执行所有权更改操作。
- en: You must run the `find` command as root if you want to change the ownership
    of files or directories.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更改文件或目录的所有权，必须以 root 用户身份运行 `find` 命令。
- en: 'The `find` command uses an open/close curly brace pair `{}` to represent the
    filename. In the next example, each time `find` identifies a file it will replace
    the `{}` with the filename and change the ownership of the file. For example,
    if the `find` command finds two files with the `root` owner it will change both
    so they''re owned by `slynux`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 命令使用一对大括号 `{}` 来表示文件名。在下一个示例中，每当 `find` 识别出一个文件时，它会用文件名替换 `{}` 并更改文件的所有权。例如，如果
    `find` 命令找到两个 `root` 所有的文件，它将把它们都更改为 `slynux` 所有：'
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that the command is terminated with `\;`. The semicolon must be escaped
    or it will be grabbed by your command shell as the end of the `find` command instead
    of the end of the `chown` command.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，命令以 `\;` 结尾。分号必须被转义，否则它会被命令行 shell 作为 `find` 命令的结束符，而不是 `chown` 命令的结束符。
- en: Invoking a command for each file is a lot of overhead. If the command accepts
    multiple arguments (as `chown` does) you can terminate the command with a plus
    (`+`) instead of a semicolon. The plus causes `find` to make a list of all the
    files that match the search parameter and execute the application once with all
    the files on a single command line.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个文件调用命令会带来很大的开销。如果命令接受多个参数（如 `chown`），可以使用加号（`+`）而不是分号来结束命令。加号会使 `find` 创建一个包含所有匹配文件的列表，并使用单个命令行一次性执行该操作。
- en: 'Another usage example is to concatenate all the C program files in a given
    directory and write them to a single file, say, `all_c_files.txt`. Each of these
    examples will perform this action:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用法示例是将给定目录中的所有 C 程序文件连接起来并写入一个单一的文件，比如 `all_c_files.txt`。以下每个示例都会执行这个操作：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To redirect the data from `find` to the `all_c_files.txt` file, we used the
    `>` operator instead of `>>` (append) because the entire output from the `find`
    command is a single data stream (`stdin`); `>>` is necessary when multiple data
    streams are to be appended to a single file.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 `find` 的数据重定向到 `all_c_files.txt` 文件中，我们使用了 `>` 操作符，而不是 `>>`（追加）。这是因为 `find`
    命令的整个输出是一个单一的数据流（`stdin`）；当多个数据流需要追加到单个文件时，才需要使用 `>>`。
- en: 'The following command will copy all the `.txt` files that are older than 10
    days to a directory `OLD`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令会将所有超过 10 天的 `.txt` 文件复制到 `OLD` 目录中：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `find` command can be coupled with many other commands.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 命令可以与许多其他命令配合使用。'
- en: 'We cannot use multiple commands along with the `-exec` parameter. It accepts
    only a single command, but we can use a trick. Write multiple commands in a shell
    script (for example, `commands.sh`) and use it with `-exec` as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在 `-exec` 参数中使用多个命令。它只接受一个单独的命令，但我们可以使用一个技巧：将多个命令写入一个 shell 脚本（例如 `commands.sh`），并将其与
    `-exec` 一起使用，如下所示：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `-exec` parameter can be coupled with `printf` to produce `joutput`. Consider
    this example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`-exec` 参数可以与 `printf` 配合使用，以产生 `joutput`。请考虑这个示例：'
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Skipping specified directories when using the find command
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `find` 命令时跳过指定的目录
- en: Skipping certain subdirectories may improve performance during the operation
    of `find`. For example, when searching for files in a development source tree
    under a version control system such as `Git`, the filesystem contains a directory
    in each of the subdirectories where version-control-related information is stored.
    These directories may not contain useful files and should be excluded from the
    search.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过某些子目录可能会在执行 `find` 时提高性能。例如，在使用版本控制系统（如 `Git`）的开发源代码树中进行文件搜索时，文件系统中每个子目录都包含一个用于存储与版本控制相关的信息的目录。这些目录可能不包含有用的文件，应该从搜索中排除。
- en: The technique of excluding files and directories is known as **pruning**. The
    following example shows how to use the `-prune` option to exclude files that match
    a pattern.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 排除文件和目录的技术被称为**修剪**。以下示例展示了如何使用`-prune`选项排除与模式匹配的文件。
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `-name ".git" -prune` is the pruning section, which specifies that `.git`
    directories should be excluded. The `-type f -print` section describes the action
    to be performed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`-name ".git" -prune`是修剪部分，指定应该排除`.git`目录。`-type f -print`部分描述要执行的操作。'
- en: Playing with xargs
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转xargs
- en: Unix commands accept data either from the standard input (`stdin`) or as command
    line arguments. Previous examples have shown how to pass data from one application's
    standard output to another's standard input with a pipe.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Unix命令从标准输入（`stdin`）或作为命令行参数接受数据。前面的示例已经展示了如何通过管道将一个应用程序的标准输出传递给另一个应用程序的标准输入。
- en: 'We can invoke applications that accept command-line arguments in other ways.
    The simplest is to use the back-tic symbol to run a command and use its output
    as a command line:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以其他方式调用接受命令行参数的应用程序。最简单的方法是使用反引号符号来运行命令，并将其输出作为命令行：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This solution works fine in many situations, but if there are a lot of files
    to be processed, you'll see the dreaded `Argument list too long` error message.
    The `xargs` program solves this problem.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案在许多情况下都能正常工作，但如果需要处理的文件很多，你会看到那个可怕的`Argument list too long`错误信息。`xargs`程序可以解决这个问题。
- en: The `xargs` command reads a list of arguments from `stdin` and executes a command
    using these arguments in the command line. The `xargs` command can also convert
    any one-line or multiple-line text inputs into other formats, such as multiple
    lines (specified number of columns) or a single line, and vice versa.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`命令从`stdin`读取一组参数，并使用这些参数在命令行中执行一个命令。`xargs`命令还可以将任何一行或多行文本输入转换为其他格式，比如多个行（指定列数）或单行，反之亦然。'
- en: Getting ready
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The `xargs` command should be the first command to appear after a pipe operator.
    It uses standard input as the primary data source and executes another command
    using the values it reads from `stdin` as command-line arguments for the new command.
    This example will search for the main string in a collection of C files:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`命令应该是管道操作符后出现的第一个命令。它使用标准输入作为主要数据源，并通过将从`stdin`读取的值作为新命令的命令行参数来执行另一个命令。这个示例将在一组C语言文件中搜索主字符串：'
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The `xargs` command supplies arguments to a target command by reformatting
    the data received through `stdin`. By default, `xargs` will execute the `echo`
    command. In many respects, the `xargs` command is similar to the actions performed
    by the `find` command''s `-exec` option:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`命令通过重新格式化通过`stdin`接收到的数据来为目标命令提供参数。默认情况下，`xargs`将执行`echo`命令。在许多方面，`xargs`命令类似于`find`命令的`-exec`选项所执行的操作：'
- en: 'Converting multiple lines of input to a single-line output:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多行输入转换为单行输出：
- en: 'Xarg''s default `echo` command can be used to convert multiple-line input to
    single-line text, like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Xargs的默认`echo`命令可以用于将多行输入转换为单行文本，像这样：
- en: '[PRE47]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Converting single-line into multiple-line output:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单行转换为多行输出：
- en: 'The `-n` argument to `xargs` limits the number of elements placed on each command
    line invocation. This recipe splits the input into multiple lines of *N* items
    each:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`的`-n`参数限制每次命令行调用时放入的元素数量。这个例子将输入分成每行*N*个项目：'
- en: '[PRE48]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `xargs` command works by accepting input from `stdin`, parsing the data
    into individual elements, and invoking a program with these elements as the final
    command line arguments. By default, `xargs` will split the input based on whitespace
    and execute `/bin/echo`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`命令的工作方式是从`stdin`接收输入，将数据解析为单个元素，然后用这些元素作为最终命令行参数来调用程序。默认情况下，`xargs`将根据空格拆分输入，并执行`/bin/echo`。'
- en: Splitting the input into elements based on whitespace becomes an issue when
    file and folder names have spaces (or even newlines) in them. The `My Documents`
    folder would be parsed into two elements `My` and `Documents`, neither of which
    exists.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件和文件夹名中包含空格（甚至换行符）时，基于空白字符拆分输入会成为问题。`My Documents`文件夹会被解析为两个元素`My`和`Documents`，而这两个元素并不存在。
- en: Most problems have solutions and this is no exception.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数问题都有解决方案，这个也不例外。
- en: 'We can define the delimiter used to separate arguments. To specify a custom
    delimiter for input, use the `-d` option:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义用于分隔参数的分隔符。要为输入指定自定义分隔符，使用`-d`选项：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding code, `stdin` contains a string consisting of multiple `X`
    characters. We define `X` to be the input delimiter with the `-d option`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`stdin`包含由多个`X`字符组成的字符串。我们使用`-d`选项将`X`定义为输入分隔符。
- en: 'Using `-n` along with the previous command, we can split the input into multiple
    lines of two words each as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-n`与前面的命令一起使用，我们可以将输入拆分成每行两个单词，如下所示：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `xargs` command integrates well with the find command. The output from
    find can be piped to `xargs` to perform more complex actions than the `-exec`
    option can handle. If the filesystem has files with spaces in the name, the find
    command''s `-print0` option will use a `0` (NULL) to delimit the elements, which
    works with the `xargs -0` option to parse these. The following example searches
    for `.docx` files on a Samba mounted filesystem, where names with capital letters
    and spaces are common. It uses `grep` to report files with images:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`命令与find命令的结合非常好。find命令的输出可以通过管道传递给`xargs`，执行比`-exec`选项更复杂的操作。如果文件系统中有文件名带有空格，find命令的`-print0`选项会使用`0`（NULL）来分隔元素，这与`xargs
    -0`选项配合使用，可以解析这些元素。以下示例在Samba挂载的文件系统中查找`.docx`文件，其中包含大写字母和空格的文件名很常见。它使用`grep`来报告带有图片的文件：'
- en: '[PRE51]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: There's more...
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The previous examples showed how to use `xargs` to organize a set of data. The
    next examples show how to format sets of data on a command line.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例展示了如何使用`xargs`来组织一组数据。接下来的示例展示了如何在命令行中格式化数据集。
- en: Passing formatted arguments to a command by reading stdin
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过读取stdin传递格式化的参数给命令
- en: 'Here is a small `echo` script to make it obvious as to how `xargs` provides
    command arguments:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小的`echo`脚本，明确展示了`xargs`如何提供命令参数：
- en: '[PRE52]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'When arguments are passed to the `cecho.sh` shell, it will print the arguments
    terminated by the `#` character. Consider this example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数传递给`cecho.sh`脚本时，它会打印以`#`字符结束的参数。考虑以下示例：
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here''s a common problem:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见问题：
- en: 'I have a list of elements in a file (one per line) to be provided to a command
    (say, `cecho.sh`). I need to apply the arguments in several styles. In the first
    method, I need one argument for each invocation, like this:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我有一个包含元素列表的文件（每行一个），需要提供给一个命令（比如`cecho.sh`）。我需要以几种方式应用这些参数。在第一种方法中，我需要每次调用一个参数，如下所示：
- en: '[PRE54]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, I need to provide one or two arguments each for each execution of the
    command, like this:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我需要每次执行命令时提供一个或两个参数，如下所示：
- en: '[PRE55]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, I need to provide all arguments at once to the command:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我需要一次性提供所有参数给命令：
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Run the `cecho.sh` script and note the output before going through the following
    section. The `xargs` command can format the arguments for each of these requirements.
    The list of arguments is in a file called `args.txt`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`cecho.sh`脚本并注意输出，然后再进行以下部分。`xargs`命令可以格式化每个要求的参数。参数列表存储在名为`args.txt`的文件中：
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'For the first form, we execute the command multiple times with one argument
    per execution. The `xargs -n` option can limit the number of command line arguments
    to one:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种形式，我们多次执行命令，每次执行一个参数。`xargs -n`选项可以限制每次命令行参数为一个：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To limit the number of arguments to two or fewer, execute this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要限制参数数量为两个或更少，请执行以下操作：
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, to execute the command at once with all the arguments, do not use
    any `-n` argument:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了在一次执行中使用所有参数，不要使用任何`-n`选项：
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the preceding examples, the arguments added by `xargs` were placed at the
    end of the command. However, we may need to have a constant phrase at the end
    of the command and want `xargs` to substitute its argument in the middle, like
    this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`xargs`添加的参数被放置在命令的末尾。然而，我们可能需要在命令末尾保持一个常量短语，并希望`xargs`将它的参数替换到中间位置，如下所示：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the preceding command execution, `arg1` is the only variable text. All others
    should remain constant. The arguments from `args.txt` should be applied like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令执行中，`arg1`是唯一的变量文本。其他部分应该保持不变。从`args.txt`中的参数应按如下方式应用：
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `xargs-I` option specifies a replacement string to be replaced with the
    arguments xargs parses from the input. When `-I` is used with `xargs`, it will
    execute as one command execution per argument. This example solves the problem:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs -I`选项指定一个替换字符串，该字符串会被xargs从输入中解析出的参数替换。当与`xargs`一起使用`-I`时，它会将每个参数执行一次命令。这一示例解决了问题：'
- en: '[PRE63]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `-I {}` specifies the replacement string. For each of the arguments supplied
    for the command, the `{}` string will be replaced with arguments read through
    `stdin`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`-I {}`指定了替换字符串。对于命令的每个参数，`{}`字符串会被通过`stdin`读取的参数替换。'
- en: When used with `-I`, the command is executed in a loop. When there are three
    arguments, the command is executed three times along with the `{}` command. Each
    time, `{}` is replaced with arguments one by one.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 与`-I`一起使用时，命令会在循环中执行。当有三个参数时，命令会执行三次，并且每次都会替换`{}`为相应的参数。
- en: Using xargs with find
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用xargs与find
- en: 'The `xargs` and `find` command can be combined to perform tasks. However, take
    care to combine them carefully. Consider this example:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`和`find`命令可以结合使用来执行任务。然而，需要小心地组合它们。考虑以下示例：'
- en: '[PRE64]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This is dangerous. It may cause removal of unexpected files. We cannot predict
    the delimiting character (whether it is `'\n'` or `' '`) for the output of the
    `find` command. If any filenames contain a space character (`' '`) `xargs` may
    misinterpret it as a delimiter. For example, `bashrc text.txt` would be misinterpreted
    by `xargs` as `bashrc` and `text.txt`. The previous command would not delete `bashrc
    text.txt`, but would delete `bashrc`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常危险。它可能会导致意外文件的删除。我们无法预测`find`命令输出的分隔符（无论是`'\n'`还是`' '`）。如果任何文件名包含空格字符（`'
    '`），`xargs`可能会将其误解为分隔符。例如，`bashrc text.txt`会被`xargs`误解为`bashrc`和`text.txt`。此时，前一个命令不会删除`bashrc
    text.txt`，但会删除`bashrc`。
- en: Use the `-print0` option of `find` to produce an output delimited by the null
    character (`'\0'`); you use `find` output as `xargs` input.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`find`的`-print0`选项来生成以空字符（`'\0'`）分隔的输出；你可以将`find`的输出用作`xargs`的输入。
- en: 'This command will `find` and remove all `.txt` files and nothing else:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将会`find`并删除所有`.txt`文件，而不会删除其他文件：
- en: '[PRE65]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Counting the number of lines of C code in a source code directory
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统计源代码目录中C代码的行数
- en: 'At some point, most programmers need to count the **Lines of Code** (**LOC**)
    in their C program files The code for this task is as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些时候，大多数程序员需要统计他们C程序文件中的**代码行数**（**LOC**）。完成此任务的代码如下：
- en: '[PRE66]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If you want more statistics about your source code, a utility called `SLOCCount`,
    is very useful. Modern GNU/Linux distributions usually have packages or you can
    get it from [http://www.dwheeler.com/sloccount/](http://www.dwheeler.com/sloccount/).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取更多关于源代码的统计信息，一个名为`SLOCCount`的工具非常有用。现代的GNU/Linux发行版通常会提供该工具的包，或者你可以从[http://www.dwheeler.com/sloccount/](http://www.dwheeler.com/sloccount/)下载。
- en: While and subshell trick with stdin
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`while`和子Shell技巧与stdin
- en: 'The `xargs` command places arguments at the end of a command; thus, `xargs`
    cannot supply arguments to multiple sets of commands. We can create a subshell
    to handle complex situations. The subshell can use a `while` loop to read arguments
    and execute commands in a trickier way, like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`命令将参数放在命令的末尾；因此，`xargs`不能为多个命令集提供参数。我们可以创建一个子Shell来处理复杂的情况。子Shell可以使用`while`循环读取参数，并以更复杂的方式执行命令，像这样：'
- en: '[PRE67]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Here, by replacing `cat $arg` with any number of commands using a `while` loop,
    we can perform many command actions with the same arguments. We can pass the output
    to other commands without using pipes. Subshell `( )` tricks can be used in a
    variety of problematic environments. When enclosed within subshell operators,
    it acts as a single unit with multiple commands inside, like so:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过用`while`循环替换`cat $arg`为任何数量的命令，我们可以使用相同的参数执行多个命令操作。我们可以将输出传递给其他命令，而不需要使用管道。子Shell`(
    )`技巧可以在多种复杂环境中使用。将命令封装在子Shell操作符内，它会作为一个整体执行，内部包含多个命令，像这样：
- en: '[PRE68]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If `cmd1` is `cd /` within the subshell, the path of the working directory changes.
    However, this change resides inside the subshell only. The `cmd4` command will
    not see the directory change.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`cmd1`在子Shell中是`cd /`，工作目录的路径会发生变化。然而，这种变化仅限于子Shell内。`cmd4`命令不会看到目录的变化。
- en: 'The shell accepts a `-c` option to invoke a subshell with a command-line script.
    This can be combined with `xargs` to solve the problem of needing multiple substitutions.
    The following example finds all `C` files and echoes the name of each file, preceded
    by a newline (the `-e` option enables backslash substitutions). Immediately after
    the filename is a list of all the times `main` appears in that file:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: shell接受`-c`选项来调用带有命令行脚本的子Shell。此选项可以与`xargs`结合使用，以解决需要多个替换的问题。以下示例查找所有的`C`文件并输出每个文件的名称，前面加上一个换行符（`-e`选项启用反斜杠替换）。在文件名之后，列出该文件中所有出现`main`的次数：
- en: '[PRE69]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Translating with tr
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用tr进行翻译
- en: The `tr` command is a versatile tool in the Unix command–warrior's kit. It is
    used to craft elegant one-liner commands. It performs substitution of characters,
    deletes selected characters, and can squeeze repeated characters from the standard
    input. Tr is short for **translate**, since it translates a set of characters
    to another set. In this recipe, we will see how to use `tr` to perform basic translation
    between sets.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr`命令是Unix命令战士工具包中的一个多功能工具。它用于编写优雅的单行命令。它执行字符替换、删除选定的字符，并可以从标准输入中压缩重复字符。`tr`是**translate**（翻译）的缩写，因为它将一组字符转换为另一组字符。在这个例子中，我们将看看如何使用`tr`在字符集之间进行基本的翻译。'
- en: Getting ready
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好
- en: 'The `tr` command accepts input through **stdin** (**standard input**) and cannot
    accept input through command-line arguments. It has this invocation format:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr`命令通过**stdin**（**标准输入**）接收输入，不能通过命令行参数接收输入。它的调用格式如下：'
- en: '[PRE70]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Input characters from `stdin` are mapped from the first character in `set1`
    to the first character in `set2`, and so on and the output is written to `stdout`
    (standard output). `set1` and `set2` are character classes or a set of characters.
    If the length of sets is unequal, `set2` is extended to the length of `set1` by
    repeating the last character; otherwise if the length of `set2` is greater than
    that of `set1`, all the characters exceeding the length of `set1` are ignored
    from `set2`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 从`stdin`输入的字符从`set1`中的第一个字符映射到`set2`中的第一个字符，依此类推，输出写入`stdout`（标准输出）。`set1`和`set2`是字符类或字符集合。如果字符集的长度不相等，则`set2`会通过重复最后一个字符来扩展到与`set1`相同的长度；如果`set2`的长度大于`set1`，则`set1`长度以外的所有字符都将被忽略。
- en: How to do it...
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To perform translation of characters in the input from uppercase to lowercase,
    use this command:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行将输入中的大写字符转换为小写字符的操作，请使用以下命令：
- en: '[PRE71]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `'A-Z'` and `'a-z'` are the sets. We can specify custom sets as needed by
    appending characters or character classes.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`''A-Z''`和`''a-z''`是字符集。我们可以根据需要通过附加字符或字符类来指定自定义字符集。'
- en: The `'ABD-}'`, `'aA.,'`, `'a-ce-x'`, `'a-c0-9'`, and so on are valid sets. We
    can define sets easily. Instead of writing continuous character sequences, we
    can use the `'startchar-endchar'` format. It can also be combined with any other
    characters or character classes. If `startchar-endchar` is not a valid continuous
    character sequence, they are then taken as a set of three characters (for example,
    `startchar`, `-`, and `endchar`). You can also use special characters such as
    `'\t'`, `'\n'`, or any ASCII characters.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`''ABD-}''`、`''aA.,''`、`''a-ce-x''`、`''a-c0-9''`等是有效的字符集。我们可以轻松定义字符集。无需写连续的字符序列，我们可以使用`''startchar-endchar''`格式。它还可以与其他任何字符或字符类结合使用。如果`startchar-endchar`不是有效的连续字符序列，则它们被视为三个字符的集合（例如，`startchar`、`-`和`endchar`）。你还可以使用特殊字符，例如`''\t''`、`''\n''`或任何ASCII字符。'
- en: How it works...
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Using `tr` with the concept of sets, we can map characters from one set to
    another set easily. Let''s go through an example on using `tr` to encrypt and
    decrypt numeric characters:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有字符集概念的`tr`，我们可以轻松地将字符从一个集合映射到另一个集合。让我们通过一个示例来看看如何使用`tr`加密和解密数字字符：
- en: '[PRE72]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `tr` command can be used to encrypt text. **ROT13** is a well-known encryption
    algorithm. In the ROT13 scheme, characters are shifted by 13 positions, thus the
    same function can encrypt and decrypt text:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr`命令可以用来加密文本。**ROT13**是一种著名的加密算法。在ROT13方案中，字符通过13个位置进行偏移，因此相同的功能可以同时加密和解密文本：'
- en: '[PRE73]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output will be the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE74]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'By sending the encrypted text again to the same ROT13 function, we get this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将加密文本再次发送给相同的ROT13函数，我们将得到以下结果：
- en: '[PRE75]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The output will be the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE76]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `tr` can convert each tab character to a single space, as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr`可以将每个制表符字符转换为单个空格，如下所示：'
- en: '[PRE77]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: There's more...
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We saw some basic translations using the `tr` command. Let's see what else can
    `tr` help us achieve.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了一些使用`tr`命令的基本翻译方法。让我们看看`tr`还能帮助我们实现什么。
- en: Deleting characters using tr
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`tr`删除字符
- en: 'The `tr` command has an option `-d` to delete a set of characters that appear
    on `stdin` using the specified set of characters to be deleted, as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr`命令有一个`-d`选项，用于删除在`stdin`中出现的字符集合，按照指定的字符集进行删除，如下所示：'
- en: '[PRE78]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Consider this example:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个示例：
- en: '[PRE79]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Complementing character sets
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 补充字符集
- en: 'We can use a set to complement `set1` using the `-c` flag. `set2` is optional
    in the following command:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-c`标志来补充`set1`字符集。以下命令中`set2`是可选的：
- en: '[PRE80]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: If only `set1` is present, `tr` will delete all characters that are not in `set1`.
    If `set2` is also present, `tr` will translate characters that aren't in `set1`
    into values from `set2`. If you use the `-c` option by itself, you must use `set1`
    and `set2`. If you combine the `-c` and `-d` options, you only use `set1` and
    all other characters will be deleted.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仅有 `set1`，`tr` 将删除所有不在 `set1` 中的字符。如果 `set2` 也存在，`tr` 将把不在 `set1` 中的字符翻译为
    `set2` 中的值。如果单独使用 `-c` 选项，你必须使用 `set1` 和 `set2`。如果同时使用 `-c` 和 `-d` 选项，则只使用 `set1`，其他字符将被删除。
- en: 'The following example deletes all the characters from the input text, except
    the ones specified in the complement set:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例删除输入文本中所有字符，除了互补集指定的字符：
- en: '[PRE81]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This example replaces all characters that aren''t in `set1` with spaces:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将所有不在 `set1` 中的字符替换为空格：
- en: '[PRE82]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Squeezing characters with tr
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `tr` 压缩字符
- en: 'The `tr` command can perform many text-processing tasks. For example, it can
    remove multiple occurrences of a character in a string. The basic form for this
    is as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr` 命令可以执行许多文本处理任务。例如，它可以删除字符串中某个字符的多个出现。其基本形式如下：'
- en: '[PRE83]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'If you commonly put two spaces after a period, you''ll need to remove extra
    spaces without removing duplicated letters:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯在句号后加两个空格，你需要移除多余的空格，但不删除重复的字母：
- en: '[PRE84]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `tr` command can also be used to get rid of extra newlines:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr` 命令还可以用于去除多余的换行符：'
- en: '[PRE85]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'In the preceding usage of `tr`, it removes the extra `''\n''` characters. Let''s
    use `tr` in a tricky way to add a given list of numbers from a file, as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `tr` 用法中，它去除了多余的 `'\n'` 字符。让我们用一种巧妙的方式来使用 `tr` 从文件中求出给定数字列表的和，如下所示：
- en: '[PRE86]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: How does this hack work?
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧是如何工作的？
- en: Here, the `tr` command replaces `'\n'` with the `'+'` character, hence, we form
    the string `1+2+3+..5+``,` but at the end of the string we have an extra `+` operator.
    In order to nullify the effect of the `+` operator, `0` is appended.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，`tr` 命令将 `'\n'` 替换为 `'+'` 字符，因此我们形成了字符串 `1+2+3+..5+`，但在字符串的末尾有一个额外的 `+` 运算符。为了消除
    `+` 运算符的影响，附加了 `0`。
- en: 'The `$[ operation ]` performs a numeric operation. Hence, it forms this string:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`$[ operation ]` 执行一个数值操作。因此，它形成了这个字符串：'
- en: '[PRE87]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: If we used a loop to perform the addition by reading numbers from a file, it
    would take a few lines of code. With `tr`, a one–liner does the trick.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用循环通过读取文件中的数字来执行加法，它会占用几行代码。而使用 `tr` 命令，单行代码即可完成此操作。
- en: 'Even trickier is when we have a file with letters and numbers and we want to
    sum the numbers:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 更棘手的是当我们有一个包含字母和数字的文件，并且我们希望求和这些数字时：
- en: '[PRE88]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We can use `tr` to strip out the letters with the `-d` option, then replace
    the spaces with `+`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `tr` 删除字母，使用 `-d` 选项，然后将空格替换为 `+`：
- en: '[PRE89]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Character classes
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符类
- en: 'The `tr` command can use different character classes as sets. Here are the
    supported character classes:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr` 命令可以使用不同的字符类作为集合。以下是支持的字符类：'
- en: '`alnum`: Alphanumeric characters'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alnum`: 字母数字字符'
- en: '`alpha`: Alphabetic characters'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alpha`: 字母字符'
- en: '`cntrl`: Control (nonprinting) characters'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cntrl`: 控制字符（不可打印字符）'
- en: '`digit`: Numeric characters'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`digit`: 数字字符'
- en: '`graph`: Graphic characters'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graph`: 图形字符'
- en: '`lower`: Lowercase alphabetic characters'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lower`: 小写字母字符'
- en: '`print`: Printable characters'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print`: 可打印字符'
- en: '`punct`: Punctuation characters'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`punct`: 标点符号字符'
- en: '`space`: Whitespace characters'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`space`: 空白字符'
- en: '`upper`: Uppercase characters'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upper`: 大写字符'
- en: '`xdigit`: Hexadecimal characters'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xdigit`: 十六进制字符'
- en: 'We can select the required classes, like this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择所需的类，如下所示：
- en: '[PRE90]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Consider this example:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE91]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Checksum and verification
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 校验和与验证
- en: Checksum programs are used to generate a relatively small unique key from files.
    We can recalculate the key to confirm that a file has not changed. Files may be
    modified deliberately (adding a new user changes the password file), accidentally
    (a data read error from a CD-ROM drive), or maliciously (a virus is inserted).
    Checksums let us verify that a file contains the data we expect it to.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和程序用于从文件中生成一个相对较小的唯一键。我们可以重新计算该键，以确认文件未发生更改。文件可能被故意修改（添加新用户会更改密码文件）、意外修改（从CD-ROM驱动器读取数据时出错）或恶意修改（病毒被插入）。校验和可以让我们验证文件是否包含我们预期的数据。
- en: Checksums are used by backup applications to check whether a file has been modified
    and needs to be backed up.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和被备份应用程序用于检查文件是否已被修改并需要备份。
- en: Most software distributions also have a checksum file available. Even robust
    protocols such as TCP can allow a file to be modified in transit. Hence, we need
    to know whether the received file is the original one or not by applying some
    kind of test.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数软件分发包也提供校验和文件。即使像 TCP 这样强大的协议也可能允许文件在传输过程中被修改。因此，我们需要通过某种测试来确定接收到的文件是否为原始文件。
- en: By comparing the checksum of the file we downloaded with the checksum calculated
    by the distributer, we can verify that the received file is correct. If the checksum
    calculated from the original file at the source location matches the one calculated
    at the destination, the file has been received successfully.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们下载的文件的校验和与分发者计算的校验和进行比较，我们可以验证接收到的文件是否正确。如果从源位置计算的原始文件校验和与目标位置计算的校验和匹配，则文件已成功接收。
- en: Some system validation suites maintain a checksum of the critical files. If
    malware modifies a file, we can detect this from the changed checksum.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 一些系统验证套件会维护关键文件的校验和。如果恶意软件修改了文件，我们可以通过校验和的变化来检测到这一点。
- en: In this recipe, we will see how to compute checksums to verify the integrity
    of data.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何计算校验和来验证数据的完整性。
- en: Getting ready
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Unix and Linux support several checksum programs, but the most robust and widely
    used algorithms are **MD5** and **SHA-1**. The **ms5sum** and **sha1sum** programs
    generate checksum strings by applying the corresponding algorithm to the data.
    Let's see how to generate a checksum from a file and verify the integrity of that
    file.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 和 Linux 支持多个校验和程序，但最强大和广泛使用的算法是 **MD5** 和 **SHA-1**。**md5sum** 和 **sha1sum**
    程序通过将相应的算法应用于数据来生成校验和字符串。让我们来看一下如何从文件生成校验和并验证该文件的完整性。
- en: How to do it...
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To compute the md5sum, use the following command:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算 md5sum，请使用以下命令：
- en: '[PRE92]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The `md5sum` is a 32-character hexadecimal string as given.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`md5sum` 是一个 32 字符的十六进制字符串，如下所示。'
- en: 'We can redirect the checksum output to a file for later use, as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将校验和输出重定向到文件，以便稍后使用，如下所示：
- en: '[PRE93]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: How it works...
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The syntax for the `md5sum` checksum calculation is as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`md5sum` 校验和计算的语法如下：'
- en: '[PRE94]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'When multiple files are used, the output will contain a checksum for each of
    the files, one checksum report per line:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用多个文件时，输出将包含每个文件的校验和，每个校验和报告占一行：
- en: '[PRE95]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The integrity of a file can be verified with the generated file, like this:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的完整性可以通过生成的文件进行验证，操作如下：
- en: '[PRE96]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'If we need to check all the files using all `.md5` information available, use
    this:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要检查所有使用 `.md5` 文件信息的文件，请使用以下命令：
- en: '[PRE97]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: SHA-1 is another commonly used checksum algorithm. It generates a 40-character
    hex code from the input. The `sha1sum` command calculates an SHA-1 `checksum`.
    Its usage is similar to `md5sum`. Simply replace `md5sum` with `sha1sum` in all
    the commands previously mentioned. Instead of `file_sum.md5`, change the output
    filename to `file_sum.sha1`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-1 是另一个常用的校验和算法。它从输入中生成一个 40 字符的十六进制代码。`sha1sum` 命令计算一个 SHA-1 校验和。它的用法类似于
    `md5sum`。只需在之前提到的所有命令中，将 `md5sum` 替换为 `sha1sum`。将输出文件名从 `file_sum.md5` 改为 `file_sum.sha1`。
- en: Checksums are useful to verify the integrity of files downloaded from the Internet.
    ISO images are susceptible to erroneous bits. A few wrong bits and the ISO may
    be unreadable, or, worse, it might install applications that fail in strange ways.
    Most file repositories include an `md5` or `sha1` file you can use to verify that
    files were downloaded correctly.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和对于验证从互联网下载的文件的完整性非常有用。ISO 镜像容易受到错误位的影响。即使是几个错误的位，ISO 文件可能无法读取，或者更糟糕的是，它可能安装一些异常的应用程序。大多数文件仓库都提供一个
    `md5` 或 `sha1` 文件，可以用来验证文件是否正确下载。
- en: '![](img/B05265_02_01_New.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05265_02_01_New.png)'
- en: 'This is the MD5 sum checksum that is created:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建的 MD5 校验和：
- en: '[PRE98]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: There's more...
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Checksums are also useful when used with a number of files. Let's see how to
    apply checksums to a collection of files and verify the accuracy.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和在使用多个文件时也很有用。让我们来看一下如何对一组文件应用校验和并验证其准确性。
- en: Checksum for directories
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录的校验和
- en: Checksums are calculated for files. Calculating the checksum for a directory
    requires recursively calculating the checksums for all the files in the directory.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和是针对文件计算的。计算目录的校验和需要递归地计算目录中所有文件的校验和。
- en: 'The `md5deep` or `sha1deep` commands traverse a file tree and calculate checksums
    for all files. These programs may not be installed on your system. Use `apt-get`
    or `yum` to install the `md5deep` package. An example of this command is as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`md5deep` 或 `sha1deep` 命令可以遍历文件树并计算所有文件的校验和。这些程序可能未安装在您的系统上。使用 `apt-get` 或
    `yum` 安装 `md5deep` 包。此命令的示例如下：'
- en: '[PRE99]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The `-r` option allows md5deep to recurse into sub-directories. The `-l` option
    enables displaying the relative path, instead of the default absolute path.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`-r` 选项允许 md5deep 递归进入子目录。`-l` 选项启用显示相对路径，而不是默认的绝对路径。'
- en: '[PRE100]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The `find` and `md5sum` commands can be used to calculate checksums recursively:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 和 `md5sum` 命令可以递归地计算校验和：'
- en: '[PRE101]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'To verify, use this command:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证，请使用以下命令：
- en: '[PRE102]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The **md5** and **SHA-1 checksums** are unidirectional hash algorithms, which
    cannot be reversed to form the original data. These are also used to generate
    a unique key from a given data:'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**md5** 和 **SHA-1 校验和** 是单向哈希算法，不能反向还原成原始数据。这些算法也用于从给定数据生成唯一密钥：'
- en: '[PRE103]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: These hashes are commonly used to store passwords. Only the hash for a    password
    is stored. When a user needs to be authenticated, the password is read  and converted
    to the hash and that hash is compared to the stored hash. If they  are the same,
    the password is authenticated and access is provided. Storing  plain–text password
    strings is risky and poses a security risk.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这些哈希通常用于存储密码。只有密码的哈希值被存储。当需要验证用户身份时，密码会被读取并转换为哈希值，然后该哈希值与存储的哈希值进行比较。如果两者相同，则密码验证通过，允许访问。存储明文密码字符串是有风险的，存在安全隐患。
- en: Although commonly used, md5sum and SHA-1 are no longer considered secure. This
    is because the rise in computing power in recent times that makes it easier to
    crack them. It is recommended that you use tools such as `bcrypt` or **sha512sum**
    instead. Read more about this at [http://codahale.com/how-to-safely-store-a-password/](http://codahale.com/how-to-safely-store-a-password/).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 md5sum 和 SHA-1 常被使用，但它们已经不再被视为安全的算法。这是因为近年来计算能力的提升使得破解这些算法变得更加容易。建议您改用 `bcrypt`
    或 **sha512sum** 等工具。有关更多信息，请阅读 [http://codahale.com/how-to-safely-store-a-password/](http://codahale.com/how-to-safely-store-a-password/)。
- en: Shadow-like hash (salted hash)
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似 Shadow 的哈希（加盐哈希）
- en: 'The next recipe shows how to generate a shadow-like salted hash for passwords.
      The hash for user passwords in Linux is stored in the `/etc/shadow` file. A
               typical line in `/etc/shadow` will look like this:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段将展示如何为密码生成类似 Shadow 的加盐哈希。Linux 中用户密码的哈希存储在 `/etc/shadow` 文件中。`/etc/shadow`
    中的一行典型样式如下：
- en: '[PRE104]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '`$6$fG4eWdUi$ohTKOlEUzNk77.4S8MrYe07NTRV4M3LrJnZP9p.qc1bR5c.EcOruzPXfEu1uloBFUa18ENRH7F70zhodas3cR`
    is the hash corresponding to its password.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`$6$fG4eWdUi$ohTKOlEUzNk77.4S8MrYe07NTRV4M3LrJnZP9p.qc1bR5c.EcOruzPXfEu1uloBFUa18ENRH7F70zhodas3cR`
    是与其密码对应的哈希值。'
- en: In some situations, we need to write scripts to edit passwords or add users.
    In that case, we must generate a shadow password string and write a similar line
    to the preceding one to the shadow file. We can generate a shadow password using
    `openssl`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们需要编写脚本来编辑密码或添加用户。在这种情况下，我们必须生成一个 shadow 密码字符串，并向 shadow 文件中写入类似前述的行。我们可以使用
    `openssl` 生成一个 shadow 密码。
- en: Shadow passwords are usually salted passwords. `SALT` is an extra string used
    to obfuscate and make the encryption stronger. Salt consists of random bits that
    are used as one of the inputs to a key derivation function that generates the
    salted hash for the password.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: Shadow 密码通常是加盐密码。`SALT` 是用于混淆并增强加密强度的额外字符串。盐由随机位组成，作为密钥派生函数的输入之一，用于生成密码的加盐哈希。
- en: For more details on salt, refer to this Wikipedia page at [h t t p ://e n .
    w i k i p e d i a . o r g /w i k i /S a l t _ (c r y p t o g r a p h y )](http://en.wikipedia.org/wiki/Salt_(cryptography)).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 有关盐的更多信息，请参考此维基百科页面：[h t t p ://e n . w i k i p e d i a . o r g /w i k i /S
    a l t _ (c r y p t o g r a p h y )](http://en.wikipedia.org/wiki/Salt_(cryptography))。
- en: '[PRE105]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Replace `SALT_STRING` with a random string and `PASSWORD` with the password
    you want to use.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `SALT_STRING` 替换为随机字符串，将 `PASSWORD` 替换为您想要使用的密码。
- en: Cryptographic tools and hashes
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密工具和哈希函数
- en: Encryption techniques are used to protect data from unauthorized access. Unlike
    the checksum algorithms we just discussed, encryption programs can reconstruct
    the original data with no loss. There are many algorithms available and we will
    discuss those most commonly used in the Linux/Unix world.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 加密技术用于保护数据免受未经授权的访问。与我们刚才讨论的校验和算法不同，加密程序可以在不丢失数据的情况下重构原始数据。现在有很多可用的算法，我们将讨论在
    Linux/Unix 世界中最常用的那些。
- en: How to do it...
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'Let''s see how to use tools such as `crypt`, `gpg`, and `base64`:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `crypt`、`gpg` 和 `base64` 等工具：
- en: 'The `crypt` command is not commonly installed on Linux systems. It''s a simple
    and relatively insecure cryptographic utility that accepts input from `stdin`,
    requests a `passphrase`, and sends encrypted output to `stdout`:'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crypt` 命令在 Linux 系统上并不常见。它是一个简单且相对不安全的加密工具，接受来自 `stdin` 的输入，要求输入 `passphrase`（密码短语），并将加密后的输出发送到
    `stdout`：'
- en: '[PRE106]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We can provide a passphrase on the command line:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在命令行中提供密码短语：
- en: '[PRE107]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'In order to decrypt the file, use this:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密文件，请使用此命令：
- en: '[PRE108]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '`gpg` (GNU privacy guard) is a widely used tool for protecting files to ensure
    that data is not read until it reaches its intended destination.'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gpg`（GNU 隐私保护工具）是一个广泛使用的工具，用于保护文件，确保数据在到达预定目的地之前不会被读取。'
- en: '`gpg` signatures are also widely used in e-mail communications to "sign" e-mail
    messages, proving the authenticity of the sender.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpg` 签名也广泛用于电子邮件通信中，以“签署”电子邮件消息，证明发件人的真实性。'
- en: 'In order to encrypt a file with `gpg`, use this:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 若要使用 `gpg` 加密文件，请使用以下命令：
- en: '[PRE109]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This command reads the passphrase interactively and generates `filename.gpg`.
    In order to decrypt a `gpg` file, use the following command:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令交互式地读取密码短语，并生成 `filename.gpg` 文件。若要解密一个 `gpg` 文件，请使用以下命令：
- en: '[PRE110]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: This command reads a passphrase and decrypts the file.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令读取密码短语并解密文件。
- en: We are not covering `gpg` in much detail in this book. For more information,
    refer to [http://en.wikipedia.org/wiki/GNU_Privacy_Guard](http://en.wikipedia.org/wiki/GNU_Privacy_Guard).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中不详细介绍 `gpg`。有关更多信息，请参考 [http://en.wikipedia.org/wiki/GNU_Privacy_Guard](http://en.wikipedia.org/wiki/GNU_Privacy_Guard)。
- en: '**Base64** is a group of similar encoding schemes that represent binary data
    in an ASCII string format by translating it into a **radix-64** representation.
    These programs are used to transmit binary data via e-mail. The `base64` command
    encodes and decodes the Base64 string. To encode a binary file into the Base64
    format, use this:'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Base64** 是一类类似的编码方案，通过将二进制数据转换为 **radix-64** 表示法，来以 ASCII 字符串格式表示二进制数据。这些程序常用于通过电子邮件传输二进制数据。`base64`
    命令用于编码和解码 Base64 字符串。要将二进制文件编码为 Base64 格式，请使用以下命令：'
- en: '[PRE111]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Alternatively, use this command:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用此命令：
- en: '[PRE112]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: It can read from `stdin`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以从 `stdin` 读取。
- en: 'Decode Base64 data as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式解码 Base64 数据：
- en: '[PRE113]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Alternatively, use this:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用此命令：
- en: '[PRE114]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Sorting unique and duplicate lines
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序唯一行和重复行
- en: Sorting text files is a common task. The `sort` command sorts text files and
    `stdin`. It can be coupled with other commands to produce the required output.
    `uniq` is often used with `sort` to extract unique (or duplicate) lines. The following
    recipes illustrate some sort and `uniq` use cases.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 排序文本文件是一个常见任务。`sort` 命令可以排序文本文件和 `stdin`。它可以与其他命令结合使用以生成所需的输出。`uniq` 常与 `sort`
    一起使用，以提取唯一（或重复）行。以下示例展示了 `sort` 和 `uniq` 的一些用法。
- en: Getting ready
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开始
- en: The `sort` and `uniq` commands accept input as filenames or from `stdin` (standard
    input) and output the result by writing to `stdout`.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort` 和 `uniq` 命令接受文件名或来自 `stdin`（标准输入）的输入，并通过写入 `stdout` 输出结果。'
- en: How to do it...
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'We can sort a set of files (for example, `file1.txt` and `file2.txt`), like
    this:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以对一组文件（例如 `file1.txt` 和 `file2.txt`）进行排序，如下所示：
- en: '[PRE115]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Alternatively, use this:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用以下命令：
- en: '[PRE116]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'For a numerical sort, we use this:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于数字排序，使用以下命令：
- en: '[PRE117]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'To sort in the reverse order, we use the following command:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要按逆序排序，使用以下命令：
- en: '[PRE118]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'To sort by months (in the order Jan, Feb, March,...), use this:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要按月份排序（顺序为 1 月、2 月、3 月，...），请使用以下命令：
- en: '[PRE119]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'To merge two already sorted files, use this command:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要合并两个已排序的文件，请使用以下命令：
- en: '[PRE120]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'To find the unique lines from a sorted file, use this:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从已排序的文件中提取唯一行，请使用此命令：
- en: '[PRE121]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'To check whether a file has already been sorted, use the following code:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查文件是否已排序，请使用以下代码：
- en: '[PRE122]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Replace `filename` with the file you want to check and run the script.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `filename` 替换为您要检查的文件并运行脚本。
- en: How it works...
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As shown in the examples, `sort` accepts numerous parameters to define how the
    data is to be sorted. The sort command is useful with the `uniq` command, which
    expects sorted input.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，`sort` 命令接受多个参数来定义如何排序数据。`sort` 命令在与 `uniq` 命令结合使用时非常有用，`uniq` 期待排序过的输入。
- en: There are numerous scenarios where the `sort` and `uniq` commands can be used.
    Let's go through the various options and usage techniques.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort` 和 `uniq` 命令有很多种应用场景。让我们来看看各种选项和用法技巧。'
- en: To check whether a file is already sorted, we exploit the fact that `sort` returns
    an exit code (`$?`) of 0 if the file is sorted and nonzero otherwise.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查文件是否已经排序，我们可以利用`sort`命令的返回退出码（`$?`）。如果文件已排序，返回0，否则返回非零值。
- en: '[PRE123]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: There's more...
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'These were some basic usages of the `sort` command. Here are sections for using
    it to accomplish complex tasks:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是`sort`命令的一些基本用法。以下是使用它来完成复杂任务的部分：
- en: Sorting according to keys or columns
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据键或列进行排序
- en: 'We can use a column with sort if the input data is formatted like this:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入数据格式如下，我们可以使用列与`sort`命令进行排序：
- en: '[PRE124]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: We can sort this in many ways; currently it is sorted numerically, by the serial
    number (the first column). We can also sort by the second or third column.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式进行排序；当前它按序列号（第一列）进行数字排序。我们还可以按第二列或第三列进行排序。
- en: 'The `-k` option specifies the characters to sort by. A single digit specifies
    the column. The `-r` option specifies sorting in reverse order. Consider this
    example:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`-k`选项指定按字符排序。一个数字指定列。`-r`选项指定按逆序排序。请考虑以下示例：'
- en: '[PRE125]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Always be careful about the -n option for numeric sort. The sort command treats
    alphabetical sort and numeric sort differently. Hence, in order to specify numeric
    sort, the `-n` option should be provided.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 始终小心使用用于数字排序的`-n`选项。`sort`命令对字母排序和数字排序的处理方式不同。因此，为了指定数字排序，应提供`-n`选项。
- en: 'When `-k` is followed by a single integer, it specifies a column in the text
    file. Columns are separated by space characters. If we need to specify keys as
    a group of characters (for example, characters 4-5 of column 2), we define the
    range as two integers separated by a period to define a character position, and
    join the first and last character positions with a comma:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 当`-k`后跟一个整数时，它指定文本文件中的一列。列之间由空格分隔。如果需要将键指定为一组字符（例如，第2列的第4-5个字符），我们通过使用两个由句点分隔的整数定义字符位置范围，并使用逗号连接第一个和最后一个字符位置：
- en: '[PRE126]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The highlighted characters are to be used as numeric keys. To extract them,
    use their positions in the lines as the key format (in the previous example, they
    are `2` and `3`).
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的字符将用作数字键。要提取这些字符，请使用它们在行中的位置作为键格式（在上一个示例中，它们是`2`和`3`）。
- en: 'To use the first character as the key, use this:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用第一个字符作为键，请使用此命令：
- en: '[PRE127]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'To make the sort''s output `xargs` compatible with the `\0` terminator, use
    this command:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 要使排序的输出与`xargs`兼容并使用`\0`终止符，请使用以下命令：
- en: '[PRE128]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Sometimes, the text may contain unnecessary extraneous characters such as spaces.
    To sort them in dictionary order, ignoring punctuations and folds, use this:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，文本中可能包含不必要的多余字符，如空格。要按字典顺序排序并忽略标点符号和折叠，请使用以下命令：
- en: '[PRE129]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The `-b` option is used to ignore leading blank lines from the file and the
    `-d` option specifies sorting in dictionary order.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`-b`选项用于忽略文件中的前导空行，`-d`选项指定按字典顺序排序。'
- en: uniq
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: uniq
- en: The `uniq` command finds the unique lines in a given input (`stdin` or a filename
    command line argument) and either reports or removes the duplicated lines.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniq`命令用于查找给定输入（`stdin`或文件名命令行参数）中的唯一行，并报告或删除重复的行。'
- en: This command only works with sorted data. Hence, `uniq` is often used with the
    `sort` command.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令仅适用于已排序的数据。因此，`uniq`通常与`sort`命令一起使用。
- en: 'To produce the unique lines (all lines in the input are printed and duplicate
    lines are printed once), use this:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成唯一的行（输入中的所有行都将被打印，重复的行只打印一次），请使用以下命令：
- en: '[PRE130]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Alternatively, use this:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用此命令：
- en: '[PRE131]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Display only unique lines (the lines that are not repeated or duplicated in
    the input file):'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 仅显示唯一行（输入文件中没有重复或复制的行）：
- en: '[PRE132]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Alternatively, use this command:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用以下命令：
- en: '[PRE133]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'To count how many times each of the lines appears in the file, use the following
    command:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 要统计文件中每一行出现的次数，请使用以下命令：
- en: '[PRE134]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'To find duplicate lines in the file, use this:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找文件中的重复行，请使用以下命令：
- en: '[PRE135]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'To specify keys, we can use a combination of the `-s` and `-w` arguments:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定键，我们可以结合使用`-s`和`-w`参数：
- en: '`-s`: This specifies the number for the first *N* characters to be skipped'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s`：此选项指定跳过前*N*个字符的数量'
- en: '`-w`: This specifies the maximum number of characters to be compared'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-w`：此选项指定要比较的最大字符数'
- en: 'The following example describes using the comparison key as the index for the
    `uniq` operation:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例描述了使用比较键作为`uniq`操作的索引：
- en: '[PRE136]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'To test only the bold characters (skip the first two characters and use the
    next two) we use `-s 2` to skip the first characters and `-w 2` to use the next
    two:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 为了仅测试粗体字符（跳过前两个字符并使用接下来的两个字符），我们使用`-s 2`跳过前两个字符，使用`-w 2`来使用接下来的两个字符：
- en: '[PRE137]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: When the output from one command is passed as input to the `xargs` command,
    it's best to use a zero-byte terminator for each element of data. Passing output
    from `uniq` to `xargs` is no exception to this rule. If a zero-byte terminator
    is not used, the default space characters are used to split the arguments in the
    `xargs` command. For example, a line with the text `this is a line` from `stdin`
    will be taken as four separate arguments by the `xargs` command instead of a single
    line. When a zero-byte terminator, `\0`, is used as the delimiter character, the
    full line including spaces is interpreted as a single argument.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个命令的输出作为输入传递给`xargs`命令时，最好为每个数据元素使用零字节终止符。将`uniq`的输出传递给`xargs`命令时也遵循这一规则。如果没有使用零字节终止符，默认的空格字符将用来拆分`xargs`命令中的参数。例如，`stdin`中的一行文本`this
    is a line`将被`xargs`命令作为四个独立的参数处理，而不是一整行。当使用零字节终止符`\0`作为分隔符时，包括空格在内的完整行会被当作一个参数来处理。
- en: 'The `-z` option generates zero-byte-terminated output:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`-z`选项会生成零字节终止的输出：'
- en: '[PRE138]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'This command removes all the files, with filenames read from `files.txt`:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会删除所有文件，这些文件名是从`files.txt`中读取的：
- en: '[PRE139]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'If a filename appears multiple time, the `uniq` command writes the filename
    only once to `stdout`, thus avoiding a `rm: cannot remove FILENAME: No such file
    or directory` error.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '如果一个文件名出现多次，`uniq`命令只会将文件名输出一次到`stdout`，从而避免出现`rm: cannot remove FILENAME:
    No such file or directory`错误。'
- en: Temporary file naming and random numbers
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临时文件命名和随机数字
- en: Shell scripts often need to store temporary data. The most suitable location
    to do this is `/tmp` (which will be cleaned out by the system on reboot). There
    are two methods to generate standard filenames for temporary data.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: Shell脚本常常需要存储临时数据。最合适的位置是`/tmp`（该目录会在系统重启时被清空）。有两种方法可以为临时数据生成标准的文件名。
- en: How to do it...
  id: totrans-528
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `mktemp` command will create a unique temporary file or folder name:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`mktemp`命令会创建一个唯一的临时文件或文件夹名称：'
- en: 'Create a temporary file:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个临时文件：
- en: '[PRE140]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: This creates a temporary file, stores the name in filename, and then displays
    the name.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个临时文件，将文件名存储在filename中，然后显示该文件名。
- en: 'Create a temporary directory:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个临时目录：
- en: '[PRE141]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: This creates a temporary directory, stores the name in filename, and displays
    the name.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个临时目录，将目录名存储在filename中，然后显示该目录名。
- en: 'To generate a filename without creating a file or directory, use this:'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要生成一个文件名而不创建文件或目录，请使用以下命令：
- en: '[PRE142]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Here, the filename is stored in `$tmpfile`, but the file won't be created.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，文件名存储在`$tmpfile`中，但文件并不会被创建。
- en: 'To create the temporary filename based on a template, use this:'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要根据模板创建临时文件名，请使用以下命令：
- en: '[PRE143]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: How it works...
  id: totrans-541
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `mktemp` command is straightforward. It generates a file with a unique name
    and returns its filename (or directory name, in the case of directories).
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '`mktemp`命令非常简单。它会生成一个具有唯一名称的文件，并返回其文件名（或在目录的情况下，返回目录名）。'
- en: When providing custom templates, `X` will be replaced by a random alphanumeric
    character. Also note that there must be at least three `X` characters in the template
    for `mktemp` to work.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 提供自定义模板时，`X`将被随机的字母数字字符替换。还需要注意的是，模板中必须至少有三个`X`字符，`mktemp`才能正常工作。
- en: Splitting files and data
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分文件和数据
- en: Splitting a large file into smaller pieces is sometimes necessary. Long ago,
    we had to split files to transport large datasets on floppy disks. Today, we split
    files for readability, for generating logs, or for working around size-restrictions
    on e-mail attachments. These recipes will demonstrate ways of splitting files
    in different chunks.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个大文件拆分成小块有时是必要的。很久以前，我们必须拆分文件以便通过软盘传输大数据集。今天，我们拆分文件是为了提高可读性，生成日志，或绕过电子邮件附件的大小限制。这些示例将演示如何将文件拆分成不同大小的块。
- en: How to do it...
  id: totrans-546
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The split command was created to split files. It accepts a filename as an argument
    and creates a set of smaller files in which the first part of the original file
    is in the alphabetically first new file, the next set in the alphabetically next
    file, and so on.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '`split`命令是为拆分文件而创建的。它接受文件名作为参数，并创建一组较小的文件，其中原始文件的第一部分被放入按字母顺序排列的新文件中，接下来的部分按字母顺序依次放入其它文件中，依此类推。'
- en: For example, a 100 KB file can be divided into smaller files of 10k each by
    specifying the split size. The split command supports `M` for MB, `G` for GB,
    `c` for byte, and `w` for word.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以通过指定拆分大小将一个 100 KB 的文件拆分为每个 10k 的较小文件。`split` 命令支持 `M` 表示 MB，`G` 表示 GB，`c`
    表示字节，`w` 表示单词。
- en: '[PRE144]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The preceding code will split `data.file` into ten files of `10k` each. The
    new files are named `xab`, `xac`, `xad`, and so on. By default, split uses alphabetic
    suffixes. To use numeric suffixes, use the `-d` argument. It is also possible
    to specify a suffix length using `-a` length:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码会将 `data.file` 拆分为每个 `10k` 的十个文件。新文件的命名为 `xab`、`xac`、`xad` 等。默认情况下，`split`
    使用字母后缀。要使用数字后缀，请使用 `-d` 参数。还可以通过 `-a` 参数指定后缀长度：
- en: '[PRE145]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: There's more...
  id: totrans-552
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `split` command has more options. Let's go through them.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '`split` 命令有更多选项。让我们逐一了解它们。'
- en: Specifying a filename prefix for the split files
  id: totrans-554
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为拆分文件指定文件名前缀
- en: All the previous split filenames start with x. If we are splitting more than
    one file, we'll want to name the pieces, so it's obvious which goes with which.
    We can use our own filename prefix by providing a prefix as the last argument.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 所有之前的拆分文件名都以 x 开头。如果我们拆分多个文件，想要给文件命名以便于区分，我们可以通过在最后一个参数提供前缀来使用自己的文件名前缀。
- en: 'Let''s run the previous command with the `split_file` prefix:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `split_file` 前缀来运行上面的命令：
- en: '[PRE146]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'To split files based on the number of lines in each split rather than chunk
    size, use this:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据每个拆分的行数而非块大小来拆分文件，请使用以下命令：
- en: '[PRE147]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The `csplit` utility splits files based on context instead of size. It can split
    based on line count or regular expression pattern. It's particularly useful for
    splitting log files.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '`csplit` 工具根据上下文而非大小来拆分文件。它可以基于行数或正则表达式模式来拆分，特别适用于拆分日志文件。'
- en: 'Look at the following example log:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的示例日志：
- en: '[PRE148]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'We may need to split the files into `server1.log`, `server2.log`, and `server3.log`
    from the contents for each `SERVER` in each file. This can be done as follows:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要根据每个文件中 `SERVER` 内容拆分文件成 `server1.log`、`server2.log` 和 `server3.log`。可以按以下方式执行：
- en: '[PRE149]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The details of the command are as follows:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的详细信息如下：
- en: '`/SERVER/`: This is the line used to match a line by which a split is to be
    carried out.'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/SERVER/`：这是用于匹配拆分基准的行。'
- en: '`/[REGEX]/`: This is the format. It copies from the current line (first line)
    up to the matching line that contains `SERVER` excluding the match line.'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/[REGEX]/`：这是格式。它将从当前行（第一行）复制到包含 `SERVER` 的匹配行，但不包括匹配行本身。'
- en: '`{*}`: This specifies repeating a split based on the match up to the end of
    the file. We can specify the number of times it is to be continued by placing
    a number between the curly braces.'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{*}`：这指定了根据匹配一直拆分直到文件结束。我们可以通过在大括号中放置一个数字来指定拆分的次数。'
- en: '`-s`: This is the flag to make the command silent rather than printing other
    messages.'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s`：这是使命令静默运行的标志，而不是打印其他消息。'
- en: '`-n`: This specifies the number of digits to be used as suffix. `01`, `02`,
    `03`, and so on.'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-n`：这指定了用于后缀的数字位数。`01`、`02`、`03` 等。'
- en: '`-f`: This specifies the filename prefix for split files (`server` is the prefix
    in the previous example).'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`：这指定了拆分文件的文件名前缀（在前面的示例中，`server` 是前缀）。'
- en: '`-b`: This specifies the suffix format. `"%02d.log"` is similar to the `printf`
    argument format in C, Here, the *filename = prefix + suffix*, that is, `"server"
    + "%02d.log"`.'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-b`：这指定了后缀格式。`"%02d.log"` 类似于 C 语言中的 `printf` 参数格式，在这里，*文件名 = 前缀 + 后缀*，即 `"server"
    + "%02d.log"`。'
- en: We remove `server00.log` since the first split file is an empty file (the match
    word is the first line of the file).
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除 `server00.log`，因为第一个拆分文件是一个空文件（匹配词是文件的第一行）。
- en: Slicing filenames based on extensions
  id: totrans-574
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据扩展名切割文件名
- en: Many shell scripts perform actions that involve modifying filenames. They may
    need to rename the files and preserve the extension, or convert files from one
    format to another and change the extension, while preserving the name, extracting
    a portion of the filename, and so on.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Shell 脚本执行涉及修改文件名的操作。它们可能需要重命名文件并保留扩展名，或者将文件从一种格式转换为另一种格式并更改扩展名，同时保留文件名、提取文件名的一部分等等。
- en: The shell has built-in features for manipulating filenames.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 提供了内置功能来操作文件名。
- en: How to do it...
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'The `%` operator will extract the name from `name.extension`. This example
    extracts `sample` from `sample.jpg`:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '`%` 操作符将从 `name.extension` 中提取文件名。此示例从 `sample.jpg` 中提取 `sample`：'
- en: '[PRE150]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The output is this:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE151]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'The `#` operator will extract the extension:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '`#` 操作符将提取文件扩展名：'
- en: 'Extract `.jpg` from the filename stored in the `file_jpg` variable:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 从存储在 `file_jpg` 变量中的文件名中提取 `.jpg`：
- en: '[PRE152]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The output is as follows:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE153]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: How it works...
  id: totrans-587
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To extract the name from the filename formatted as `name.extension`, we use
    the `%` operator.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 要从格式为 `name.extension` 的文件名中提取名称，我们使用 `%` 操作符。
- en: '`${VAR%.*}` is interpreted as follows:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '`${VAR%.*}` 的解释如下：'
- en: Remove the string match from `$VAR` for the wildcard pattern that appears to
    the right of `%` (`.*` in the previous example). Evaluating from right to left
    finds the wildcard match.
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `$VAR` 中删除右侧 `%`（在前面的示例中为 `.*`）的通配符模式中的字符串匹配。按照从右到左的顺序评估会找到通配符匹配。
- en: Store the filename as `VAR=sample.jpg`. Therefore, the wildcard match for`.*`
    from right to left is `.jpg`. Thus, it is removed from the `$VAR` string and the
    output is `sample`.
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件名存储为 `VAR=sample.jpg`。因此，从右到左的通配符匹配 `.*` 为 `.jpg`。因此，它会从 `$VAR` 字符串中移除并输出
    `sample`。
- en: '`%` is a nongreedy operation. It finds the minimal match for the wildcard from
    right to left. The `%%` operator is similar to `%`, but it is greedy. This means
    that it finds the maximal match of the string for the wildcard. Consider this
    example, where we have this:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '`%` 是一个非贪婪操作。它从右到左找到通配符的最小匹配。`%%` 操作符与 `%` 类似，但它是贪婪的。这意味着它会找到通配符的最大匹配字符串。考虑这个例子，我们有：'
- en: '[PRE154]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Use the `%` operator for a nongreedy match from right to left and match `.txt`:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `%` 操作符进行从右到左的非贪婪匹配，并匹配 `.txt`：
- en: '[PRE155]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'The output will be: `hack.fun.book`.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：`hack.fun.book`。
- en: 'Use the `%%` operator for a greedy match, and match `.fun.book.txt`:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `%%` 操作符进行贪婪匹配，并匹配 `.fun.book.txt`：
- en: '[PRE156]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'The output will be: `hack`.'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：`hack`。
- en: The `#` operator extracts the extension from the filename. It is similar to
    `%`, but it evaluates from left to right.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '`#` 操作符提取文件名的扩展名。它与 `%` 类似，但从左到右进行评估。'
- en: '`${VAR#*.}` is interpreted as follows:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '`${VAR#*.}` 的解释如下：'
- en: Remove the string match from `$VARIABLE` for the wildcard pattern match that
    appears to the right of `#` (`*.` in the previous example). Evaluating from the
    left to right should make the wildcard match.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `$VARIABLE` 中删除右侧 `#`（在前面的示例中为 `*.`）的通配符模式中的字符串匹配。按照从左到右的顺序评估应该会找到通配符匹配。
- en: 'Similarly, as in the case of `%%`, the operator ## is a greedy equivalent to
    #.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `%%` 的情况，操作符 `##` 是与 `#` 相对应的贪婪匹配。
- en: 'It makes greedy matches by evaluating from left to right and removes the match
    string from the specified variable. Let''s use this example:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过从左到右的顺序进行贪婪匹配，并从指定的变量中移除匹配的字符串。我们来看看这个例子：
- en: '[PRE157]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'The `#` operator performs a nongreedy match from left to right and matches
    `hack`:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '`#` 操作符从左到右执行非贪婪匹配，并匹配 `hack`：'
- en: '[PRE158]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The output will be: `fun.book.txt`.'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：`fun.book.txt`。
- en: 'The `##` operator performs a greedy match from left to right and matches `hack.fun.book`:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '`##` 操作符从左到右进行贪婪匹配，并匹配 `hack.fun.book`：'
- en: '[PRE159]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The output will be: `txt`.'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：`txt`。
- en: The `##` operator is preferred over the `#` operator to extract the extension
    from a filename, since the filename may contain multiple `.` characters. Since
    `##` makes a greedy match, it always extracts extensions only.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '`##` 操作符比 `#` 操作符更优，用来提取文件名的扩展名，因为文件名中可能包含多个 `.` 字符。由于 `##` 进行的是贪婪匹配，因此它总是仅提取扩展名。'
- en: 'Here is a practical example to extract different portions of a domain name
    such as URL=`www.google.com`:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个实际的示例，提取域名（如 URL=`www.google.com`）的不同部分：
- en: '[PRE160]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Renaming and moving files in bulk
  id: totrans-615
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批量重命名和移动文件
- en: We frequently need to move and perhaps rename a set of files. System housekeeping
    often requires moving files with a common prefix or file type to a new folder.
    Images downloaded from a camera may need to be renamed and sorted. Music, video,
    and e-mail files all need to be reorganized eventually.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要移动文件，甚至可能重命名一组文件。系统维护通常需要将具有公共前缀或文件类型的文件移动到新文件夹中。从相机下载的图像可能需要重命名并排序。音乐、视频和电子邮件文件最终都需要重新组织。
- en: There are custom applications for many of these operations, but we can write
    our own custom scripts to do it **our** way.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 许多操作有自定义应用程序，但我们可以编写自己的自定义脚本以 **我们** 的方式来执行这些操作。
- en: Let's see how to write scripts to perform these kinds of operation.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何编写脚本来执行这些操作。
- en: Getting ready
  id: totrans-619
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `rename` command changes filenames using Perl regular expressions. By combining
    the `find`, `rename`, and `mv` commands, we can perform a lot of things.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '`rename` 命令使用 Perl 正则表达式来更改文件名。通过结合使用 `find`、`rename` 和 `mv` 命令，我们可以执行很多操作。'
- en: How to do it...
  id: totrans-621
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'The following script uses find to locate PNG and JPEG files, then uses the
    `##` operator and `mv` to rename them as `image-1.EXT`, `image-2.EXT`, and so
    on. This changes the file''s name, but not its extension:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本使用 `find` 查找 PNG 和 JPEG 文件，然后使用 `##` 操作符和 `mv` 命令将它们重命名为 `image-1.EXT`、`image-2.EXT`
    等等。这会改变文件的名称，但不会改变文件扩展名：
- en: '[PRE161]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'The output is as follows:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE162]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: The preceding script renames all the `.jpg` and `.png` files in the current
    directory to new filenames in the format `image-1.jpg`, `image-2.jpg`, `image-3.png`,
    `image-4.png`, and so on.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本将当前目录中的所有 `.jpg` 和 `.png` 文件重命名为新文件名，格式为 `image-1.jpg`、`image-2.jpg`、`image-3.png`、`image-4.png`，依此类推。
- en: How it works...
  id: totrans-627
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The previous script uses a `for` loop to iterate through the names of all files
    ending with a `.jpg` or `.png` extension. The `find` command performs this search,
    using the `-o` option to specify multiple `-iname` options for case-insensitive
    matches. The `-maxdepth 1` option restricts the search to the current directory,
    not any subdirectories.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个脚本使用 `for` 循环遍历所有以 `.jpg` 或 `.png` 扩展名结尾的文件名。`find` 命令执行此搜索，使用 `-o` 选项指定多个
    `-iname` 选项，以进行不区分大小写的匹配。`-maxdepth 1` 选项限制搜索范围为当前目录，而不包括子目录。
- en: The `count` variable is initialized to `1` to track the image number. Then the
    script renames the file using the `mv` command. The new name of the file is constructed
    using `${img##*.}`, which parses the extension of the filename currently being
    processed (refer to the *Slicing filenames based on extensions* recipe in this
    chapter for an interpretation of `${img##*.}`).
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '`count` 变量初始化为 `1` 用于跟踪图像编号。然后，脚本使用 `mv` 命令重命名文件。文件的新名称通过 `${img##*.}` 构造，该部分解析当前正在处理的文件名的扩展名（有关
    `${img##*.}` 的解释，请参见本章的 *基于扩展名切割文件名* 章节）。'
- en: '`let count++` is used to increment the file number for each execution of the
    loop.'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '`let count++` 用于在每次循环执行时递增文件编号。'
- en: 'Here are other ways to perform rename operations:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行重命名操作的其他方式：
- en: 'Rename `*.JPG` to `*.jpg` like this:'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如此将 `*.JPG` 重命名为 `*.jpg`：
- en: '[PRE163]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Use this to replace spaces in the filenames with the `"_"` character:'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令将文件名中的空格替换为 `"_"` 字符：
- en: '[PRE164]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '`# ''s/ /_/g''` is the replacement part in the filename and `*` is the wildcard
    for the target files. It can be `*.txt` or any other wildcard pattern.'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '`# ''s/ /_/g''` 是文件名中的替换部分，`*` 是目标文件的通配符。可以是 `*.txt` 或任何其他通配符模式。'
- en: 'Use these to convert any filenames from uppercase to lowercase and vice versa:'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令将文件名从大写转换为小写，反之亦然：
- en: '[PRE165]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Use this to recursively move all the `.mp3` files to a given directory:'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令递归地将所有 `.mp3` 文件移动到指定目录：
- en: '[PRE166]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Use this to recursively rename all the files by replacing spaces with the `_`
    character:'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令递归地通过将空格替换为 `_` 字符来重命名所有文件：
- en: '[PRE167]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Spell–checking and dictionary manipulation
  id: totrans-643
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拼写检查和字典操作
- en: Most Linux distributions include a dictionary file. However, very few people
    are aware of this, thus spelling errors abound. The `aspell` command-line utility
    is a spell checker. Let's go through a few scripts that make use of the dictionary
    file and the spell checker.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Linux 发行版都包含一个字典文件。然而，极少有人知道这一点，因此拼写错误层出不穷。`aspell` 命令行工具是一个拼写检查工具。让我们一起了解一些利用字典文件和拼写检查器的脚本。
- en: How to do it...
  id: totrans-645
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The `/usr/share/dict/` directory contains one or perhaps more dictionary files,
    which are text files with a list of words. We can use this list to check whether
    a word is a dictionary word or not:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '`/usr/share/dict/` 目录包含一个或多个字典文件，它们是包含单词列表的文本文件。我们可以使用这个列表来检查一个单词是否是字典中的单词：'
- en: '[PRE168]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'To check whether the given word is a dictionary word, use the following script:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查给定的单词是否为字典单词，请使用以下脚本：
- en: '[PRE169]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The usage is as follows:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 用法如下：
- en: '[PRE170]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: How it works...
  id: totrans-652
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In `grep`, `^` is the word-start marker character and the `$` character is the
    word-end marker. The `-q` option suppresses any output, making the `grep` command
    quiet.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `grep` 中，`^` 是单词起始符号，`$` 是单词结束符号。`-q` 选项抑制任何输出，使得 `grep` 命令保持安静。
- en: 'Alternatively, we can use the spell–check, `aspell`, to check whether a word
    is in a dictionary or not:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用拼写检查工具 `aspell` 来检查一个单词是否在字典中：
- en: '[PRE171]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: The `aspell list` command returns output text when the given input is not a
    dictionary word, and does not output anything when the input is a dictionary word.
    A `-z` command checks whether `$output` is an empty string or not.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '`aspell list` 命令在给定输入不是字典单词时返回输出文本，而在输入是字典单词时不输出任何内容。`-z` 命令检查 `$output` 是否为空字符串。'
- en: The `look` command will display lines that begin with a given string. You might
    use it to find the lines in a log file that start with a given date, or to find
    words in the dictionary that start with a given string. By default, `look` searches
    `/usr/share/dict/words`, or you can provide a file to search.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '`look`命令将显示以给定字符串开头的行。你可以用它来查找日志文件中以给定日期开头的行，或者查找字典中以给定字符串开头的单词。默认情况下，`look`会搜索`/usr/share/dict/words`，你也可以提供一个文件进行搜索。'
- en: '[PRE172]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Alternatively, this can be used:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用以下方法：
- en: '[PRE173]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Consider this example:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下示例：
- en: '[PRE174]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Use this to find lines with a given date in `/var/log/syslog`:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令查找`/var/log/syslog`中具有特定日期的行：
- en: '[PRE175]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Automating interactive input
  id: totrans-665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化交互式输入
- en: We looked at commands that accept arguments on the command line. Linux also
    supports many interactive applications ranging from `passwd` to `ssh`.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看了接受命令行参数的命令。Linux 还支持许多交互式应用程序，从`passwd`到`ssh`。
- en: 'We can create our own interactive shell scripts. It''s easier for casual users
    to interact with a set of prompts rather than remember command line flags and
    the proper order. For instance, a script to back up a user''s work, but not to
    back up and lock files, might look like this:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建自己的交互式 Shell 脚本。对于普通用户来说，通过一系列提示与系统交互比记住命令行标志和正确的顺序要容易得多。例如，一个用于备份用户工作的脚本，但不备份和锁定文件，可能如下所示：
- en: '[PRE176]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: What folder should be backed up? `notes`
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该备份哪个文件夹？ `notes`
- en: What type of files should be backed up? `.docx`
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该备份哪种类型的文件？ `.docx`
- en: Automating interactive applications can save you time when you need to rerun
    the same application and frustration while you're developing one.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化交互式应用程序可以节省你在需要重新运行相同应用程序时的时间，并减少在开发应用程序时的挫败感。
- en: Getting ready
  id: totrans-672
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在准备
- en: The first step to automating a task is to run it and note what you do. The script
    command discussed earlier may be of use.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化任务的第一步是运行它并记录你所做的操作。之前讨论过的脚本命令可能会有帮助。
- en: How to do it...
  id: totrans-674
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Examine the sequence of interactive inputs. From the previous code, we can
    formulate the steps of the sequence like this:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 检查交互式输入的序列。从前面的代码中，我们可以像这样构造序列的步骤：
- en: '[PRE177]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'In addition to the preceding steps, type `notes`, press `Return`, type `docx`,
    and finally press `Return` to convert into a single string like this:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的步骤外，输入`notes`，按`Return`键，输入`docx`，最后按`Return`键，将其转换为如下所示的单一字符串：
- en: '[PRE178]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: The `\n` character is sent when we press Return. By appending the return (`\n`)
    characters, we get the string that is passed to `stdin` (standard input).
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 Return 键时会发送`\n`字符。通过附加返回字符（`\n`），我们得到了传递给`stdin`（标准输入）的字符串。
- en: By sending the equivalent string for the characters typed by the user, we can
    automate passing input to the interactive processes.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 通过发送用户输入的字符等效字符串，我们可以实现自动化地将输入传递给交互式进程。
- en: How it works...
  id: totrans-681
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s write a script that reads input interactively for an automation example:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个脚本，以便交互式地读取输入，作为一个自动化示例：
- en: '[PRE179]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Let''s automate the sending of input to the command:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们自动化地将输入发送到命令：
- en: '[PRE180]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: This style of automating an interactive script can save you a lot of typing
    during developing and debugging. It also insures that you perform the same test
    each time and don't end up chasing a phantom bug because you mis-typed.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动化交互式脚本的方式可以在开发和调试过程中节省大量输入时间。它还确保你每次都执行相同的测试，避免因为输入错误而追踪到一个虚假的 bug。
- en: 'We used `echo -e` to produce the input sequence. The `-e` option signals to
    `echo` to interpret escape sequences. If the input is large we can use an input
    file and the redirection operator to supply input:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`echo -e`来生成输入序列。`-e`选项指示`echo`解释转义序列。如果输入内容较大，我们可以使用输入文件和重定向操作符来提供输入：
- en: '[PRE181]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'You can manually craft the input file without the `echo` commands by hand–typing.
    Consider this example:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以手动编写输入文件，而不使用`echo`命令，通过手动键入。考虑以下示例：
- en: '[PRE182]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: This redirects interactive input data from a file.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将交互式输入数据从文件中重定向。
- en: 'If you are a reverse engineer, you may have played with buffer overflow exploits.
    To exploit them we need to redirect a shell code such as `\xeb\x1a\x5e\x31\xc0\x88\x46`,
    which is written in hex. These characters cannot be typed directly on the keyboard
    as keys for these characters are not present. Therefore, we use:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个逆向工程师，你可能玩过缓冲区溢出漏洞。为了利用这些漏洞，我们需要重定向一个如`\xeb\x1a\x5e\x31\xc0\x88\x46`这样的
    Shell 代码，它是以十六进制书写的。这些字符无法直接在键盘上输入，因为这些字符的键并不存在。因此，我们使用：
- en: '[PRE183]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: This will redirect the byte sequence to a vulnerable executable.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把字节序列重定向到一个易受攻击的可执行文件。
- en: These echo and redirection techniques automate interactive input programs. However,
    these techniques are fragile, in that there is no validity checking and it's assumed
    that the target application will always accept data in the same order. If the
    program asks for input in a changing order, or some inputs are not always required,
    these methods fail.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 这些回显和重定向技术能够自动化交互式输入程序。然而，这些技术非常脆弱，因为没有有效性检查，并且假定目标应用程序始终按相同顺序接收数据。如果程序要求输入的顺序发生变化，或者某些输入并非始终需要时，这些方法就会失败。
- en: The expect program can perform complex interactions and adapt to changes in
    the target application. This program is in worldwide use to control hardware tests,
    validate software builds, query router statistics, and much more.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect` 程序能够执行复杂的交互，并适应目标应用程序的变化。这个程序被广泛用于控制硬件测试、验证软件构建、查询路由器统计信息等。'
- en: There's more...
  id: totrans-697
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多……
- en: The expect application is an interpreter similar to the shell. It's based on
    the TCL language. We'll discuss the spawn, expect, and send commands for simple
    automation. With the power of the TCL language behind it, expect can do much more
    complex tasks. You can learn more about the TCL language at the [www.tcl.tk](http://www.tcl.tk)
    website.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect` 应用程序是一个类似于 shell 的解释器，它基于 TCL 语言。我们将讨论 `spawn`、`expect` 和 `send` 命令来进行简单的自动化。借助
    TCL 语言的强大功能，`expect` 能执行更复杂的任务。你可以在 [www.tcl.tk](http://www.tcl.tk) 网站上了解更多关于
    TCL 语言的信息。'
- en: Automating with expect
  id: totrans-699
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 expect 进行自动化
- en: '`expect` does not come by default on all Linux distributions. You may have
    to install the expect package with your package manager (`apt-get` or `yum`).'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect` 并不是所有 Linux 发行版的默认安装包。你可能需要通过包管理器（`apt-get` 或 `yum`）安装 expect 包。'
- en: 'Expect has three main commands:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect` 有三个主要命令：'
- en: '| **Commands** | **Description** |'
  id: totrans-702
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **描述** |'
- en: '| `spawn` | Runs the new target application. |'
  id: totrans-703
  prefs: []
  type: TYPE_TB
  zh: '| `spawn` | 运行新的目标应用程序。 |'
- en: '| `expect` | Watches for a pattern to be sent by the target application. |'
  id: totrans-704
  prefs: []
  type: TYPE_TB
  zh: '| `expect` | 监视目标应用程序发送的模式。 |'
- en: '| `send` | Sends a string to the target application. |'
  id: totrans-705
  prefs: []
  type: TYPE_TB
  zh: '| `send` | 向目标应用程序发送字符串。 |'
- en: The following example spawns the backup script and then looks for the patterns
    `*folder*` and `*file*` to determine if the backup script is asking for a folder
    name or a filename. It will then send the appropriate reply. If the backup script
    is rewritten to request files first and then folders, this automation script still
    works.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例生成备份脚本，并查找模式 `*folder*` 和 `*file*` 来确定备份脚本是要求文件夹名还是文件名。然后它会发送适当的回复。如果备份脚本被重写为首先请求文件然后是文件夹，这个自动化脚本仍然有效。
- en: '[PRE184]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Run it as:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下方式运行：
- en: '[PRE185]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: The `spawn` command's parameters are the target application and arguments to
    be automated.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '`spawn` 命令的参数是目标应用程序及其需要自动化的参数。'
- en: The `expect` command accepts a set of patterns to look for and an action to
    perform when that pattern is matched. The action is enclosed in curly braces.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect` 命令接受一组要查找的模式，并在模式匹配时执行相应的操作。操作内容被大括号包围。'
- en: The `send` command is the message to be sent. This is similar to echo `-n -e`
    in that it does not automatically include the newline and does understand backslash
    symbols.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '`send` 命令是要发送的消息。这类似于 `echo -n -e`，即它不会自动包括换行符，并且能够识别反斜杠符号。'
- en: Making commands quicker by running parallel processes
  id: totrans-713
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过运行并行进程来加快命令执行速度
- en: Computing power constantly increases not only because processors have higher
    clock cycles but also because they have multiple cores. This means that in a single
    hardware processor there are multiple logical processors. It's like having several
    computers, instead of just one.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 计算能力不断提升，不仅是因为处理器的时钟周期更高，还因为它们拥有多个核心。这意味着在一个硬件处理器中有多个逻辑处理器。这就像拥有几台计算机，而不仅仅是一台。
- en: However, multiple cores are useless unless the software makes use of them. For
    example, a program that does huge calculations may only run on one core while
    the others will sit idle. The software has to be aware and take advantage of the
    multiple cores if we want it to be faster.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，多个核心是没有用的，除非软件能够充分利用它们。例如，一个进行巨大计算的程序可能仅在一个核心上运行，而其他核心则处于空闲状态。如果我们希望程序运行得更快，软件必须能够识别并利用多个核心。
- en: In this recipe, we will see how we can make our commands run faster.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何让命令运行得更快。
- en: How to do it...
  id: totrans-717
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Let''s take an example of the `md5sum` command we discussed in the previous
    recipes. This command performs complex computations, making it CPU-intensive.
    If we have more than one file that we want to generate a checksum for, we can
    run multiple instances of `md5sum` using a script like this:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个我们在前面配方中讨论的`md5sum`命令的例子。这个命令执行复杂的计算，因此非常占用CPU。如果我们有多个文件需要生成校验和，可以使用类似这样的脚本运行多个`md5sum`实例：
- en: '[PRE186]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'When we run this, we get the following output:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此命令时，得到以下输出：
- en: '[PRE187]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'The output will be the same as running the following command:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将与运行以下命令的结果相同：
- en: '[PRE188]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: However, if the `md5sum` commands run simultaneously, you'll get the results
    quicker if you have a multi–core processor (you can verify this using the `time`
    command).
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`md5sum`命令同时运行，并且你的处理器是多核的，你会更快地获得结果（你可以使用`time`命令验证这一点）。
- en: How it works...
  id: totrans-725
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We exploit the Bash operand `&`, which instructs the shell to send the command
    to the background and continue with the script. However, this means our script
    will exit as soon as the loop completes, while the `md5sum` processes are still
    running in the background. To prevent this, we get the PIDs of the processes using
    `$!`, which in Bash holds the PID of the last background process. We append these
    PIDs to an array and then use the `wait` command to wait for these processes to
    finish.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用Bash操作符`&`，它指示Shell将命令发送到后台并继续执行脚本。然而，这意味着脚本将在循环完成后退出，而`md5sum`进程仍在后台运行。为防止这种情况发生，我们使用`$!`获取进程的PID，`$!`在Bash中保存最后一个后台进程的PID。我们将这些PID添加到数组中，然后使用`wait`命令等待这些进程完成。
- en: There's more...
  id: totrans-727
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: The Bash `&` operand works well for a small number of tasks. If you had a hundred
    files to checksum, the script would try to start a hundred processes and might
    force your system into swapping, which would make the tasks run slower.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: Bash中的`&`操作符适用于少量任务。如果你有一百个文件需要生成校验和，脚本会尝试启动一百个进程，可能会导致系统交换，进而使任务运行变慢。
- en: The GNU parallel command is not part of all installations, but again it can
    be loaded with your package manager. The parallel command optimizes the use of
    your resources without overloading any of them.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: GNU parallel命令并非所有安装中都有，但它可以通过包管理器加载。parallel命令优化了资源的使用，而不会使其中任何一个过载。
- en: The parallel command reads a list of files on `stdin` and uses options similar
    to the find command's `-exec` argument to process these files. The `{}` symbol
    represents the file to be processed, and the `{.}` symbol represents the filename
    without a suffix.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: parallel命令读取`stdin`中的文件列表，并使用类似于find命令的`-exec`参数的选项来处理这些文件。`{}`符号表示要处理的文件，`{.}`符号表示没有后缀的文件名。
- en: 'The following command uses **Imagemagick''s **`convert` command to make new,
    resized images of all the images in a folder:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令使用**Imagemagick的**`convert`命令对文件夹中所有图片进行重新调整大小并生成新的图片：
- en: '[PRE189]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Examining a directory, files and subdirectories in it
  id: totrans-733
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查目录、文件和其中的子目录
- en: One of the commonest problems we deal with is finding misplaced files and sorting
    out mangled file hierarchies. This section will discuss tricks for examining a
    portion of the filesystem and presenting the contents.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理的最常见问题之一是查找丢失的文件并整理混乱的文件层次结构。本节将讨论检查文件系统部分并展示其内容的技巧。
- en: Getting ready
  id: totrans-735
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `find` command and loops we discussed give us tools to examine and report
    details in a directory and its contents.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的`find`命令和循环为我们提供了检查目录及其内容并报告详细信息的工具。
- en: How to do it...
  id: totrans-737
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The next recipes show two ways to examine a directory. First we'll display the
    hierarchy as a tree, then we'll see how to generate a summary of files and folders
    under a directory.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的配方展示了检查目录的两种方法。首先，我们将显示文件结构为树形图，然后我们将看到如何生成目录下文件和文件夹的汇总。
- en: Generating a tree view of a directory.
  id: totrans-739
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成目录的树状视图。
- en: Sometimes it's easier to visualize a file system if it's presented graphically.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果文件系统以图形方式呈现，可能更容易进行可视化。
- en: The next recipe pulls together several of the tools we discussed. It uses the
    find command to generate a list of all the files and sub-folders under the current
    folder.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个配方将我们讨论过的几个工具组合在一起。它使用find命令生成当前文件夹下所有文件和子文件夹的列表。
- en: The `-exec` option creates a subshell which uses echo to send the filenames
    to the `tr` command's `stdin`. There are two `tr` commands. The first deletes
    all alphanumeric characters, and any dash (`-`), underbar (`_`), or period (`.`).
    This passes only the slashes (`/`) in the path to the second `tr` command, which translates
    those slashes to spaces. Finally, the `basename` command strips the leading path
    from the filename and displays it.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '`-exec`选项会创建一个子shell，使用echo将文件名传递给`tr`命令的`stdin`。这里有两个`tr`命令，第一个删除所有字母数字字符，以及任何短横线（`-`）、下划线（`_`）或句点（`.`）。这样，路径中的斜杠（`/`）会传递到第二个`tr`命令，后者将斜杠转换为空格。最后，`basename`命令从文件名中去掉前缀路径并显示文件名。'
- en: 'Use these to view a tree of the folders in `/var/log`:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令查看`/var/log`目录中的文件夹树：
- en: '[PRE190]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'This output is generated:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出如下：
- en: '[PRE191]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Generating a summary of files and sub-directories
  id: totrans-747
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成文件和子目录的摘要
- en: We can generate a list of subdirectories, and the number of files in them, with
    a combination of the `find` command, `echo`, and `wc` commands, which will be
    discussed in greater detail in the next chapter.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过组合`find`命令、`echo`和`wc`命令来生成子目录的列表，以及其中文件的数量，接下来的章节会更详细地讨论这些命令。
- en: 'Use the following to get a summary of files in the current folder:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令获取当前文件夹的文件摘要：
- en: '[PRE192]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'If this script is run in `/var/log`, it will generate output like this:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`/var/log`目录下运行该脚本，它将生成如下输出：
- en: '[PRE193]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
