- en: Chapter 3. Using OpenLDAP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章 使用 OpenLDAP
- en: 'Now that we have a basic OpenLDAP server installed, configured, and running,
    it is time to turn our attention to using OpenLDAP. In this chapter we will be
    looking at what the various applications in the **OpenLDAP suite** do. In the
    process, we will discuss LDAP operations, create our initial directory tree, and
    use the OpenLDAP clients and utilities to interact with the directory server.
    As we do this we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装、配置并运行了基本的 OpenLDAP 服务器，是时候将注意力转向使用 OpenLDAP。在本章中，我们将了解 **OpenLDAP 套件**
    中各种应用的功能。在此过程中，我们将讨论 LDAP 操作，创建我们的初始目录树，并使用 OpenLDAP 客户端和实用程序与目录服务器进行交互。在此过程中，我们将覆盖以下内容：
- en: 'The basic functional division of the OpenLDAP tools: daemons, clients, and
    utilities'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenLDAP 工具的基本功能分为：守护进程、客户端和实用程序
- en: The basic directory server operations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的目录服务器操作
- en: Building an initial directory tree in an LDIF file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 LDIF 文件中构建初始目录树
- en: Loading the data into the directory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据加载到目录中
- en: Working with the directory records
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理目录记录
- en: Searching the directory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索目录
- en: Setting passwords and authenticating against the directory
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置密码并对目录进行身份验证
- en: Along the way, we will also see many new LDAP terms and concepts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们还将看到许多新的 LDAP 术语和概念。
- en: A Brief Survey of the LDAP Suite
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LDAP 套件简要调查
- en: In the last chapter we saw that the OpenLDAP suite was composed of daemons,
    libraries, clients, and utilities.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到 OpenLDAP 套件由守护进程、库、客户端和实用程序组成。
- en: 'In UNIX parlance, a daemon is a process that runs for long periods of time
    without user interaction. It is a process that runs in the background. A server
    is a type of daemon that answers requests from other applications (clients). There
    are two daemons in the OpenLDAP suite: the SLAPD daemon (server) and the SLURPD
    daemon. In the next section we will look at these two.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UNIX 术语中，守护进程是在长时间内运行而无需用户交互的进程。它是在后台运行的进程。服务器是一种守护进程，用于响应来自其他应用程序（客户端）的请求。在
    OpenLDAP 套件中有两个守护进程：SLAPD 守护进程（服务器）和 SLURPD 守护进程。在接下来的章节中，我们将详细讨论这两者。
- en: There are a host of utilities included with OpenLDAP too. Utilities are programs
    that assist in managing the directory but do not use the LDAP protocol. They do
    things like maintain indexes, dump the contents of the database, and assist with
    migrating records from one directory to another.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP 还包含许多实用程序。实用程序是帮助管理目录但不使用 LDAP 协议的程序。它们执行诸如维护索引、转储数据库内容和帮助从一个目录迁移记录到另一个目录等任务。
- en: Clients, in contrast to utilities, are programs that connect to the directory
    server using the LDAP protocol and perform directory operations, such as searching
    for, adding, modifying, and deleting records from the directory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端与实用程序相反，是使用 LDAP 协议连接到目录服务器并执行目录操作的程序，例如搜索、添加、修改和删除目录中的记录。
- en: We will look at all of the utilities and clients. But before we dive into that
    we will look at the daemons and some of the concepts involved in communication
    between LDAP clients and servers. This will give us the foundational knowledge
    for our work with the LDAP utilities and clients.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看所有实用程序和客户端。但在深入讨论之前，我们将查看守护进程以及 LDAP 客户端和服务器之间通信所涉及的一些概念。这将为我们使用 LDAP 实用程序和客户端提供基础知识。
- en: LDAP from the Server Side
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端的 LDAP
- en: 'OpenLDAP includes two daemons: **SLAPD** and **SLURPD**. SLAPD is the main
    server, and we will examine its operation throughout this book. SLURPD is a special-purpose
    daemon used for replicating directories. While it is still in use, it is now deprecated
    in favor of a more robust replication mechanism. We will cover it only briefly
    in this book.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP 包含两个守护进程：**SLAPD** 和 **SLURPD**。SLAPD 是主服务器，在本书中我们将详细讨论其操作。SLURPD 是用于复制目录的特殊用途守护进程。虽然它仍在使用中，但现在已不推荐使用，推荐使用更健壮的复制机制。在本书中我们将只简要介绍它。
- en: SLAPD
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SLAPD
- en: 'The first, SLAPD, is the stand-alone LDAP daemon. It is the LDAP server. It
    listens for client requests and, when it receives a request, performs the requested
    operation and returns any necessary data. In the most common case a client will
    send a query message to the server. The SLAPD server will then look up the information
    and return the results. Let''s consider an example (in conversational English):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 SLAPD 是独立的 LDAP 守护进程。它是 LDAP 服务器。它监听客户端请求，收到请求后执行请求的操作并返回任何必要的数据。在最常见的情况下，客户端将向服务器发送查询消息。然后
    SLAPD 服务器将查找信息并返回结果。让我们考虑一个例子（用口语化的英语）：
- en: 'Client: Log in as user Bob with the password Password'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端：使用密码Password登录用户Bob
- en: 'Server: Bob is now logged in'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器：Bob现在已登录
- en: 'Client: Bob wants all of the usernames of users whose email addresses start
    with ''m'''
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端：Bob想要获取所有电子邮件地址以“m”开头的用户的用户名。
- en: 'Server: There are four users with email addresses that start with ''m''. The
    user IDs are: mattb, markd, melaniek, melindaq'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器：有四个电子邮件地址以“m”开头的用户。用户ID分别是：mattb、markd、melaniek、melindaq
- en: 'Client: Log Bob off'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端：注销Bob
- en: 'Server: OK'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器：好的
- en: This example is very simplistic (and omits lots of the details of an LDAP transaction),
    but it should give you the main idea of what SLAPD does.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例非常简化（并省略了LDAP事务的很多细节），但它应该能给你SLAPD的主要工作流程。
- en: The SLAPD program is called, appropriately enough, `slapd`. It is located at
    `/usr/sbin` (if you compiled from source, it is in `/usr/local/libexec`). In the
    previous chapter we configured SLAPD using the `/etc/ldap/slapd.conf` configuration
    file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: SLAPD程序名恰如其分，叫做`slapd`。它位于`/usr/sbin`（如果你是从源代码编译的，它位于`/usr/local/libexec`）。在上一章中，我们使用`/etc/ldap/slapd.conf`配置文件配置了SLAPD。
- en: The SLAPD server handles all client interactions, including authentication,
    processing ACLs, performing searches, and handling changes, additions, and deletions
    of the data. It also manages the databases that store LDAP content. All of the
    clients that we look at in this chapter interact directly with SLAPD. The utilities
    provide maintenance services for SLAPD, though they rarely directly interact with
    the SLAPD server (they tend to operate on files that the directory uses).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: SLAPD服务器处理所有客户端交互，包括身份验证、处理ACL、执行搜索以及处理数据的更改、添加和删除。它还管理存储LDAP内容的数据库。本章中我们讨论的所有客户端都直接与SLAPD进行交互。实用程序为SLAPD提供维护服务，但它们很少直接与SLAPD服务器交互（它们通常对目录使用的文件进行操作）。
- en: 'Let''s take a slightly more technical look at the simple LDAP exchange that
    we outlined here. We can break the exchange into two major parts: the authentication
    process (called **binding** in LDAP parlance) and the search process.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更技术性地看一下我们在这里概述的简单LDAP交换。我们可以将交换分为两个主要部分：身份验证过程（在LDAP术语中称为**绑定**）和搜索过程。
- en: The Binding Operation
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定操作
- en: 'The first thing that must happen is the client must authenticate to the server.
    Keep in mind that in order to interact with an LDAP server the client must provide
    two pieces of information: a DN and a password.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先必须发生的事情是客户端必须对服务器进行身份验证。请记住，为了与LDAP服务器交互，客户端必须提供两项信息：DN和密码。
- en: 'Typically, there are two different ways by which a client can authenticate
    to a server: through a Simple Bind, and through an SASL Bind. It is possible to
    write custom methods of binding, too, but that''s a significant undertaking. Let''s
    look at the way clients connect to LDAP using the **Simple Bind** method.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，客户端可以通过两种不同的方式认证到服务器：通过简单绑定（Simple Bind）和通过SASL绑定（SASL Bind）。也可以编写自定义绑定方法，但这是一项复杂的工作。让我们来看一下客户端如何通过**简单绑定**方法连接到LDAP。
- en: 'Typically, to authenticate a user, SLAPD looks up the DN (and the DN''s `userPassword`
    attribute) in the directory and verifies the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了验证用户，SLAPD会在目录中查找DN（及DN的`userPassword`属性），并验证以下内容：
- en: The supplied DN exists in the directory.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供的DN存在于目录中。
- en: The DN is allowed to connect under the present conditions (such as from the
    originating IP address, or with the currently-implemented security features).
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前条件下，允许连接DN（例如从源IP地址或使用当前实施的安全特性）。
- en: The password supplied matches the value of the DN's `userPassword` attribute.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供的密码与DN的`userPassword`属性的值匹配。
- en: In our example scenario the user Bob wants to bind to the directory. For Bob
    to bind according to the outlined steps, the client would have to provide Bob's
    full DN, which might be something like `cn=Bob,dc=example,dc=net`. But, not all
    clients know the full DN of the user. Most applications require only a username
    and password, not a full DN. To solve this problem, LDAP servers support the idea
    of the **Anonymous** user.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例场景中，用户Bob希望绑定到目录。为了让Bob按照概述的步骤进行绑定，客户端必须提供Bob的完整DN，类似于`cn=Bob,dc=example,dc=net`。但是，并非所有客户端都知道用户的完整DN。大多数应用程序只需要用户名和密码，而不需要完整的DN。为了解决这个问题，LDAP服务器支持**匿名**用户的概念。
- en: When the LDAP server receives a bind request with an empty DN and an empty password
    field, the server treats the user as Anonymous. The Anonymous user can be granted
    or denied access to information in the directory based on the ACLs specified for
    SLAPD. Generally, the task of the Anonymous user is to get Bob's DN out of the
    directory and request that Bob be authenticated.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当LDAP服务器收到一个空DN和空密码字段的绑定请求时，服务器会将用户视为匿名用户。匿名用户可以根据SLAPD指定的ACLs被授予或拒绝访问目录中的信息。通常，匿名用户的任务是从目录中获取Bob的DN，并请求对Bob进行身份验证。
- en: 'How does this happen? The client first connects to the server as Anonymous,
    then searches the directory for Bob''s entry with a filter of something like this:
    *entries* *whose* *CN* *is* *"Bob"* *and* *who* *have* *the* *objectclass* *"organizationalPerson"*.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这怎么发生的呢？客户端首先以匿名身份连接到服务器，然后使用类似以下的过滤器在目录中搜索Bob的条目：*条目* *其* *CN* *为* *"Bob"*
    *并且* *其* *objectclass* *为* *"organizationalPerson"*。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The actual LDAP filter for this request would look like this: `(&(cn=Bob)(objectClass=oraganizationalPerson))`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此请求的实际LDAP过滤器将如下所示：`(&(cn=Bob)(objectClass=organizationalPerson))`
- en: 'Assuming that the filter is specific enough, and the directory actually has
    an entry for Bob, then the server would then send the client one DN: `cn=Bob,dc=example,dc=net`.
    The client would then re-bind, this time as `cn=Bob,dc=example,dc=net` (and with
    Bob''s password), rather than as Anonymous.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设过滤器足够具体，并且目录中确实有Bob的条目，那么服务器将返回一个DN给客户端：`cn=Bob,dc=example,dc=net`。客户端随后将重新绑定，这次作为`cn=Bob,dc=example,dc=net`（并使用Bob的密码），而不是作为匿名用户。
- en: In order for anonymous authentication to work, the ACLs will need to allow the
    Anonymous user to bind and attempt to perform authentication. The ACLs we added
    to `slapd.conf` in the previous chapter allowed the Anonymous user to request
    authentication services with the `userPassword` attribute.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使匿名身份验证工作，ACLs需要允许匿名用户进行绑定并尝试执行身份验证。我们在上一章中添加到`slapd.conf`的ACLs允许匿名用户请求使用`userPassword`属性的身份验证服务。
- en: In this chapter, we will use Simple Binding, though we will specify a full DN,
    rather than bind as Anonymous and search, and then rebind. Simple Bind sends the
    password from the client to the server. Without additional security (like SSL
    or TLS encryption), this makes the authentication process vulnerable to attacks.
    **SASL (Simple Authentication and Security Layer) Binding** provides another method
    of authenticating that relies on external security measures for added security.
    In Chapter 4, we will look at the authentication process in more detail, with
    particular emphasis on security.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用简单绑定，尽管我们将指定一个完整的DN，而不是像匿名身份一样先搜索再重新绑定。简单绑定将密码从客户端发送到服务器。没有额外的安全措施（如SSL或TLS加密），这使得身份验证过程容易受到攻击。**SASL（简单认证和安全层）绑定**提供了另一种依赖外部安全措施以增强安全性的认证方法。在第4章中，我们将更详细地探讨身份验证过程，特别关注安全性。
- en: The Search Operation
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索操作
- en: In our example scenario, after Bob authenticates to the server he searches for
    all the email addresses that begin with the letter *m*. Let's examine that process
    in a little more detail.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例场景中，Bob在成功身份验证后搜索所有以字母*m*开头的电子邮件地址。让我们更详细地检查这个过程。
- en: 'In order to search the directory we need to know the following things:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了搜索目录，我们需要知道以下内容：
- en: '**Base DN**: Where in the directory to start from'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础DN**：从目录中的哪个位置开始'
- en: '**Scope**: How deep in the tree to look'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范围**：在树形结构中查找的深度'
- en: '**Attributes**: What information we want retrieved'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：我们想要检索的信息'
- en: '**Filter**: What to look for'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤器**：查找的内容'
- en: Let's look at what Bob wants to get out of the directory. Bob wants to get a
    list of all of the people in his organization, Example.Com, who have email addresses
    that begin with the letter *m*. From this information, we can construct a search.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Bob想从目录中获取什么。Bob想要获取他所在的Example.Com组织中，所有电子邮件地址以字母*m*开头的人的列表。从这些信息中，我们可以构建一个搜索条件。
- en: 'First, Bob wants to know about everyone in the Example.Com organization. In
    the directory, this is everything under the Example.Com entry: `dc=example,dc=com`.
    Also, since we know that Bob wants all of the email addresses that begin with
    *m*, not just one layer down; we know that Bob wants to search the entire subtree
    under `dc=example,dc=com`. So we have:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Bob希望了解Example.Com组织中的所有人。在目录中，这就是Example.Com条目下的所有内容：`dc=example,dc=com`。另外，由于我们知道Bob希望获取所有以*m*开头的电子邮件地址，而不仅仅是下一级；我们知道Bob想要搜索`dc=example,dc=com`下的整个子树。因此，我们有：
- en: '**Base DN**: `dc=example,dc=com`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础 DN**: `dc=example,dc=com`'
- en: '**Scope**: Entire subtree'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范围**: 整个子树'
- en: 'Next, we want to know what attributes Bob wants the server to return. The DN
    will be automatically returned. Other than that, Bob is concerned only with the
    attribute that stores the email address. Email addresses are stored in the `mail`
    attribute. We could also grab any number of attributes, such as the user''s name
    (`cn`) and telephone number (`telephoneNumber`). So we have:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想知道 Bob 想要服务器返回哪些属性。DN 会自动返回。除此之外，Bob 只关心存储邮箱地址的属性。邮箱地址存储在 `mail` 属性中。我们还可以获取任何数量的属性，例如用户的名字
    (`cn`) 和电话号码 (`telephoneNumber`)。因此，我们有：
- en: '**Attributes**: `mail`, `cn`, `telephoneNumber`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**: `mail`, `cn`, `telephoneNumber`'
- en: Note
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Attribute Descriptions**'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**属性描述**'
- en: 'The attribute referred to by `mail` also has a second name: `rfc822Mailbox`.
    These two names are called **attribute descriptions** because they both describe
    a common attribute. Each attribute has at least one attribute description, but
    it is legal to have multiple descriptions (such as `cn` and `commonName`, or `dc`
    and `domainComponent`). When you have an attribute with more than one description
    it doesn''t matter which description you use. All should return the same results.'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`mail` 属性还有一个别名：`rfc822Mailbox`。这两个名称被称为**属性描述**，因为它们都描述了一个共同的属性。每个属性至少有一个属性描述，但可以有多个描述（例如
    `cn` 和 `commonName`，或 `dc` 和 `domainComponent`）。当一个属性有多个描述时，使用哪个描述并不重要。所有描述应该返回相同的结果。'
- en: Finally, we need to create a filter from Bob's criteria. Bob wants all of the
    entries where the email address starts with the letter *m*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要根据 Bob 的标准创建一个过滤器。Bob 想要所有邮箱地址以字母 *m* 开头的条目。
- en: 'Here is the search filter:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是搜索过滤器：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This simple filter is composed of four parts:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的过滤器由四个部分组成：
- en: First, the filter is enclosed in parentheses. Parentheses are used for grouping
    elements within the filter. For any filter, the entire filter should always be
    enclosed in parentheses.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，过滤器被括号括起来。括号用于在过滤器中分组元素。对于任何过滤器，整个过滤器应始终被括号包围。
- en: 'Second, the filter begins with an attribute description: `mail`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，过滤器以属性描述开始：`mail`。
- en: 'Third is the matching rule. There are four matching rules: equality (`=`),
    approximate match (`~=`), greater than or equal to (`>=`), and less than or equal
    to (`<=`). How these are used (and whether they can be used) is determined to
    a large degree by the directory schema, which we will discuss at length in Chapter
    6\. In this case the filter performs string matching.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个是匹配规则。匹配规则有四种：相等 (`=`)，近似匹配 (`~=`)，大于或等于 (`>=`)，和小于或等于 (`<=`)。这些规则的使用（以及是否可以使用）在很大程度上由目录模式决定，我们将在第
    6 章详细讨论。在这种情况下，过滤器执行字符串匹配。
- en: Finally, we have the assertion value—the string or pattern that we want results
    to match. In this case it is composed of the character `m` and the wildcard character
    (`*`). This indicates that the string must start with `m`, and can then have zero
    or more characters following it.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有了断言值——我们希望结果匹配的字符串或模式。在这种情况下，它由字符 `m` 和通配符字符 (`*`) 组成。这表示字符串必须以 `m` 开头，后面可以跟零个或多个字符。
- en: This type of search is called a **substring search**, because the filter provides
    only part of the string, and requests that the server respond with any entries
    that match the substring (according to the pattern supplied).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的搜索称为**子字符串搜索**，因为过滤器只提供部分字符串，并请求服务器响应所有匹配该子字符串（根据提供的模式）的条目。
- en: 'What if Bob also needed all of the users with email addresses that started
    with `n`? We could run two separate searches, or we could create a more elaborate
    filter:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Bob 还需要所有以 `n` 开头的邮箱地址的用户怎么办？我们可以进行两次独立的搜索，或者我们可以创建一个更复杂的过滤器：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This filter is composed of two subfilters: `(mail=m*)` and `(mail=n*)`. The
    first matches only mail addresses that start with *m*, while the second matches
    only addresses that start with *n*. These two subfilters are disjoined using the
    pipe (`|`) symbol. That means that an OR operation will be performed, and the
    filter will match a record if the record matches either `(mail=m*)` or `(mail=n*)`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过滤器由两个子过滤器组成：`(mail=m*)` 和 `(mail=n*)`。第一个只匹配以 *m* 开头的邮箱地址，而第二个只匹配以 *n* 开头的地址。这两个子过滤器通过管道符号
    (`|`) 连接。意味着将执行一个 OR 操作，如果记录匹配 `(mail=m*)` 或 `(mail=n*)` 中的任意一个，过滤器就会匹配该记录。
- en: The syntax may seem a little unusual at first, as the operator (the OR) comes
    before the two filters are listed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 语法可能一开始看起来有点不寻常，因为操作符（OR）位于两个过滤条件之前。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are three logical operators that can be used in filters: AND (`&`), OR
    (`|`), and NOT (`!`).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在过滤器中可以使用三种逻辑运算符：AND (`&`)、OR (`|`) 和 NOT (`!`)。
- en: 'Just to make things more interesting, let''s say that Bob wants to restrict
    the list to only people whose offices have room numbers of 300 or above. We can
    simply add one more sub-filter to our list, and we will have the results that
    Bob is looking for:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让事情更有趣，假设 Bob 想要将列表限制为只有办公室房间号为 300 或以上的人。我们可以简单地在我们的列表中添加一个子过滤条件，就能得到 Bob
    想要的结果：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To visualize this a little better let''s add some line breaks and spaces:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地可视化这一点，我们可以添加一些换行和空格：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now it should be a little easier to see how this filter is interpreted. In the
    innermost level, mail addresses are considered matches if they start with *m*
    OR *n*. Now, these matches are only returned if they also have a room number greater
    than or equal to 300\. They must match either `(mail=m*)` OR `(mail=n*)`, AND,
    in addition, must also have `(roomNumber >= 300)`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应该更容易理解这个过滤器是如何被解释的。在最内层，电子邮件地址如果以 *m* 或 *n* 开头则视为匹配。现在，只有当它们的房间号大于或等于 300
    时，才会返回这些匹配项。它们必须匹配 `(mail=m*)` 或 `(mail=n*)`，并且还必须满足 `(roomNumber >= 300)`。
- en: 'Once Bob performs the search, with the base DN, scope, attributes, and filter,
    he will receive a response from the server that will contain a list of records
    that look something like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Bob 执行搜索，指定了基础 DN、范围、属性和过滤条件后，他将收到来自服务器的响应，其中包含类似以下内容的记录列表：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The search returns everything in appearing in the subtree below the DN `dc=example,dc=com`
    that matches our filter. The returned records only have the DN and the attributes
    that we specified: `mail`, `cn`, and `telephoneNumber`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索返回的是位于 `dc=example,dc=com` DN 下子树中匹配我们过滤条件的所有内容。返回的记录只包含 DN 和我们指定的属性：`mail`、`cn`
    和 `telephoneNumber`。
- en: In our most complex filter, we used the `roomNumber` attribute. Why isn't it
    present in the records above? Even though it was used in the filter the attribute
    value would not be returned in the response unless we requested it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最复杂的过滤器中，我们使用了 `roomNumber` 属性。为什么它在上面的记录中没有出现？即使在过滤器中使用了它，属性值也不会在响应中返回，除非我们明确请求它。
- en: Before going on, there is one last thing to mention about searching. During
    a search the entire request is checked against the list of access controls.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，有一件事需要提及关于搜索的内容。在搜索过程中，整个请求会被检查与访问控制列表是否匹配。
- en: If an ACL specifies that Bob does not have access to the `telephoneNumber` attribute,
    then the search will return the same DNs but without the `telephoneNumber` attribute.
    Similarly, if an ACL denied Bob access to the records of certain people in the
    directory, then the server would send back the results for only those that Bob
    does have permission to see.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 ACL 指定 Bob 无法访问 `telephoneNumber` 属性，那么搜索将返回相同的 DN，但不包括 `telephoneNumber`
    属性。同样，如果 ACL 阻止 Bob 访问某些人的记录，那么服务器将仅返回 Bob 有权限查看的记录。
- en: The server will not give Bob any indication that some information has been withheld
    because of an ACL.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器不会向 Bob 提供任何信息，表明某些数据因为 ACL 的原因被隐藏。
- en: 'More Operations: Additions, Modifications, and Deletions'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多操作：添加、修改和删除
- en: In our illustration of Bob's search for email addresses we covered only binding
    and searching. Of course, LDAP supports adding, modifying, and deleting, as well.
    All three of these also require that the user first bind. And all three of these
    are also subject to ACL restrictions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们展示 Bob 查找电子邮件地址的过程中，我们只涵盖了绑定和搜索。当然，LDAP 也支持添加、修改和删除。这三项操作都需要用户首先进行绑定，且都受到
    ACL 的限制。
- en: The Addition Operation
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加操作
- en: In an addition operation a new record is added to the server. In this case the
    client will have to provide a new (and unique) DN, and set of attribute/value
    pairs. The attribute/value pairs must include a list of object classes to which
    the entry belongs. For example, if the entry is going to be a new user with a
    user ID and an email account, then the modification would have to include at least
    three object class attribute/value pairs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加操作中，一个新记录将被添加到服务器中。在这种情况下，客户端必须提供一个新的（且唯一的）DN 和一组属性/值对。这些属性/值对必须包括该条目所属的对象类列表。例如，如果该条目是一个新用户，并且包含用户
    ID 和电子邮件账户，那么修改操作必须包括至少三个对象类的属性/值对。
- en: 'An entire record for a user to be added might look something like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的用户记录可能如下所示：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Modification Operation
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改操作
- en: Modification acts on a particular record, specified by DN. Any number of changes
    can be done on a single record in one modification request.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 修改作用于特定记录，由DN指定。一次修改请求中可以对同一记录进行多个更改。
- en: 'For a particular record, a modification operation can add, replace, or remove
    attributes. And it can combine operations in the same request. That is, it can
    remove one attribute and replace another attribute in one request. Let''s see
    these attributes:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定记录，修改操作可以添加、替换或删除属性。而且它可以在同一请求中组合操作。也就是说，它可以在一个请求中移除一个属性并替换另一个属性。让我们来看这些属性：
- en: 'An **add** request takes an attribute name and one or more values. It will
    add those values to the existing set of values for that attribute. For example,
    consider a record like this:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加**请求需要一个属性名称和一个或多个值。它将这些值添加到该属性现有值的集合中。例如，考虑如下记录：'
- en: '[PRE6]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we want to modify this record by adding `cn: Matthew`, the result will look
    like this:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '如果我们想通过添加`cn: Matthew`来修改此记录，结果将如下所示：'
- en: '[PRE7]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Modification operations are processed in an "all or nothing" fashion. When multiple
    modifications are sent in one request, either they all succeed, or they all fail.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 修改操作是以“全有或全无”的方式处理的。当多个修改一起发送时，要么它们全部成功，要么它们全部失败。
- en: 'A **replace** request also takes an attribute and one or more values. But the
    list of values replaces the existing values. For example, if Matt relocated and
    his telephone number changed, then replacing with the new attribute `telephoneNumber`:
    `1 555 555 6543` would result in a record that looked like this:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**替换**请求也需要一个属性和一个或多个值。但值列表会替换现有的值。例如，如果Matt搬家并且电话号码发生变化，则用新的属性`telephoneNumber`:
    `1 555 555 6543`替换后，记录会变成这样：'
- en: '[PRE8]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The new number is added and the old numbers are removed.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新的号码被添加，旧的号码被移除。
- en: 'A **delete** request also takes an attribute and a list of values. It deletes
    only the values for an attribute that are specified in the list of values. For
    example, deletion of `cn: Matthew` would give us the following record:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**请求也需要一个属性和一个值列表。它只删除在值列表中指定的属性值。例如，删除`cn: Matthew`将得到以下记录：'
- en: '[PRE9]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Only the matching CN was removed. If, however, a delete request only specifies
    the attribute (with no values), then all instances of that attribute will be removed.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只有匹配的CN被删除。如果删除请求仅指定属性（没有值），那么该属性的所有实例将被移除。
- en: The Delete Operation
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除操作
- en: Finally, an entire LDAP record can be deleted. Like modifications, deletion
    operates on a particular record, the record's DN. During a delete operation, the
    entire record is removed from the directory—the DN and all attributes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，整个LDAP记录可以被删除。像修改一样，删除操作作用于特定记录，即记录的DN。在删除操作中，整个记录都会从目录中移除——DN及所有属性。
- en: Only records that do not have children can be deleted from the directory. If
    an entry has children, the children must be removed from the directory (or relocated
    to another part of the tree) before the parent entry can be removed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 只有没有子项的记录才能从目录中删除。如果条目有子项，则必须先从目录中删除子项（或将其移至树的另一部分），然后才能删除父条目。
- en: Infrequent Operations
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不常用操作
- en: There are a few operations that clients can call, but that tend to be used less
    than binding, searching, adding, modifying, and deleting. Three that we will look
    at just briefly are **ModifyDN**, **Compare**, and **Extended Operation**.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以调用一些操作，但它们的使用频率通常低于绑定、搜索、添加、修改和删除。我们将简要地看一下三个操作：**ModifyDN**、**Compare**和**Extended
    Operation**。
- en: The ModifyDN Operation
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ModifyDN 操作
- en: 'ModifyDN is used in cases where the DN for a record must be changed. Generally,
    DNs should not be changed frequently as they are intended to be used as unique
    and stable locators within a directory tree. However, it is not difficult to envision
    cases where a DN needs to be changed. The following figure displays a (full) DN:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ModifyDN用于需要更改记录DN的情况。通常，DN不应频繁更改，因为它们旨在作为目录树中的唯一且稳定的定位符。然而，可以想象到一些需要更改DN的情况。下图展示了一个（完整的）DN：
- en: '![The ModifyDN Operation](img/1021_03_01.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![ModifyDN 操作](img/1021_03_01.jpg)'
- en: 'A (full) DN is composed of two parts:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个（完整的）DN由两部分组成：
- en: First, there is the part specific to the immediate record, called the **Relative
    DN** or the **RDN**. For example, in the DN `cn=Matt,dc=example,dc=com`, the RDN
    is the `cn=Matt` part.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，有一个特定于即时记录的部分，称为**相对 DN** 或 **RDN**。例如，在 DN `cn=Matt,dc=example,dc=com` 中，RDN
    部分是 `cn=Matt`。
- en: Second, there is the part that refers to the parent record of the DN. It is
    specific to this record. The `dc=example,dc=com` part in the same example points
    to the parent of this record.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，有一个部分是指 DN 的父记录。它是特定于此记录的。示例中 `dc=example,dc=com` 部分指向该记录的父级。
- en: Given the DN, we know how far down the directory tree this record is. It is
    one layer below the root of the tree—the base DN (`dc=example,dc=com`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 DN，我们知道该记录位于目录树中的哪一层。它位于树根以下的一层——基础 DN（`dc=example,dc=com`）。
- en: The ModifyDN operation provides a way to change just the RDN or the entire DN.
    Changing the latter equates to moving the record to another part of the directory
    tree.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ModifyDN 操作提供了一种仅更改 RDN 或整个 DN 的方法。更改后者等同于将记录移动到目录树的另一部分。
- en: The Compare Operation
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Compare 操作
- en: A Compare operation takes a DN and an attribute value assertion (attribute =
    value), and checks to see if that attribute assertion is true or false. For example,
    if the client supplies the DN `cn=Matt,dc=example,dc=com` and the attribute value
    assertion `cn=Matthew`, then the server will return *true* if the record has an
    attribute `cn` with the value `Matthew`, or *false* otherwise. This operation
    can be faster (and also more secure) than fetching a record and doing the comparison
    on the client side.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Compare 操作接受一个 DN 和一个属性值断言（属性 = 值），并检查该属性断言是否为真或假。例如，如果客户端提供 DN `cn=Matt,dc=example,dc=com`
    和属性值断言 `cn=Matthew`，那么如果记录中有一个属性 `cn` 其值为 `Matthew`，服务器将返回*true*，否则返回*false*。与在客户端进行比较操作相比，此操作可能更快（同时也更安全）。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In OpenLDAP ACLs, the `auth` permission setting (as well as the `=x` permission
    setting that we will look at in the next chapter) allows the Compare operation
    to be used, but does not allow the attribute value to be returned in a search.
    The `read` permission (`=xw`) allows both the Compare operation and the return
    of the attribute value in search results.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenLDAP ACL 中，`auth` 权限设置（以及我们将在下一章中查看的 `=x` 权限设置）允许使用 Compare 操作，但不允许在搜索中返回属性值。`read`
    权限（`=xw`）允许 Compare 操作和在搜索结果中返回属性值。
- en: The Extended Operation
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 扩展操作
- en: Finally, OpenLDAP implements the LDAP v.3 Extended Operation, which makes it
    possible for a server to implement custom operations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，OpenLDAP 实现了 LDAP v.3 扩展操作，使得服务器能够实现自定义操作。
- en: 'The exact syntax of an Extended Operation will depend on the implementation
    of the extension. The supported Extended Operations are listed in the root DSE
    under the `supportedExtension` attribute. Take a look at the root DSE at the end
    of Chapter 2\. In that record there are two extended operations:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展操作的具体语法将取决于扩展的实现。支持的扩展操作在根 DSE 下的 `supportedExtension` 属性中列出。请查看第 2 章末的根 DSE。在该记录中有两个扩展操作：
- en: '1.3.6.1.4.1.4203.1.11.1: This **Modify Password extension** is defined in RFC
    3062 ([http://www.rfc-editor.org/rfc/rfc3062.txt](http://www.rfc-editor.org/rfc/rfc3062.txt)).
    This extension provides an operation for updating a password in the directory.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1.3.6.1.4.1.4203.1.11.1：此**修改密码扩展**在 RFC 3062 中定义（[http://www.rfc-editor.org/rfc/rfc3062.txt](http://www.rfc-editor.org/rfc/rfc3062.txt)）。该扩展提供了一种在目录中更新密码的操作。
- en: '1.3.6.1.4.1.4203.1.11.3: This **Who Am I? extension** is defined in RFC 4532
    ([http://www.rfc-editor.org/rfc/rfc4532.txt](http://www.rfc-editor.org/rfc/rfc4532.txt)).
    This extension makes it possible for the currently active DN to find out about
    itself from the server.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1.3.6.1.4.1.4203.1.11.3：此**Who Am I? 扩展**在 RFC 4532 中定义（[http://www.rfc-editor.org/rfc/rfc4532.txt](http://www.rfc-editor.org/rfc/rfc4532.txt)）。该扩展使得当前活动的
    DN 可以从服务器了解自己。
- en: Later in this chapter we will look at tools that use the Modify Password and
    the Who Am I? extensions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章稍后，我们将查看使用修改密码和 Who Am I？ 扩展的工具。
- en: SLAPD Summary
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SLAPD 概述
- en: In this section we have looked at some of the operations that the SLAPD server
    makes available to the clients. We've looked at the most common operations (binding,
    searching, modifying, adding, and deleting). We've also looked at a few of the
    less-known operations like modifyDN, Compare, and Extended Operations as well.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经查看了 SLAPD 服务器提供给客户端的一些操作。我们查看了最常见的操作（绑定、搜索、修改、添加和删除）。我们还查看了一些较少为人知的操作，如
    modifyDN、Compare 和扩展操作。
- en: By now you should have a good idea of what services the SLAPD server provides
    to clients. Clients can bind (or authenticate) to a SLAPD server and perform powerful
    searches of the directory. And through SLAPD the information in the directory
    tree can be maintained.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经对 SLAPD 服务器为客户端提供的服务有了较好的了解。客户端可以绑定（或认证）到 SLAPD 服务器并执行强大的目录搜索。通过
    SLAPD，目录树中的信息可以得到维护。
- en: These concepts will be central to the rest of this chapter, and the rest of
    this book.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念将是本章及本书其余部分的核心内容。
- en: Next, we'll look at the SLURPD daemon, though we will not go into much detail.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 SLURPD 守护进程，但我们不会深入细节。
- en: SLURPD
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SLURPD
- en: SLAPD and SLURPD are the two daemons included in the OpenLDAP suite. Above,
    we looked at the SLAPD server. Now we will turn to the second daemon.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: SLAPD 和 SLURPD 是 OpenLDAP 套件中包含的两个守护进程。上面，我们已经讨论了 SLAPD 服务器。现在我们将转向第二个守护进程。
- en: SLURPD, the Stand-alone LDAP Update Replication Daemon, is used less frequently
    than SLAPD, and is on its way to obsolescence. SLURPD provides one way of keeping
    multiple copies of an LDAP directory synchronized (see the discussion in Chapter
    1). Basically it works by tracking the changes (additions, deletions, modifications)
    to a *master* SLAPD directory server. When a change is made to the master directory,
    SLURPD sends updates to all of the subordinate *slave* servers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: SLURPD，独立的 LDAP 更新复制守护进程，比 SLAPD 使用的频率低，并且正逐渐走向过时。SLURPD 提供了一种保持多个 LDAP 目录副本同步的方式（参见第一章的讨论）。基本上，它通过跟踪对
    *主* SLAPD 目录服务器的更改（添加、删除、修改）来工作。当主目录发生更改时，SLURPD 会将更新发送到所有下属的 *从属* 服务器。
- en: The SLURPD program, `slurpd`, is located at `/usr/sbin` (or `/usr/local/libexec`,
    if you compiled from source). In configurations where SLURPD is used, `slurpd`
    is typically started immediately after `slapd`. SLURPD does not have its own configuration
    file. It searches the `slapd.conf` file for configuration information.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`SLURPD` 程序位于 `/usr/sbin` （如果是从源代码编译的，则位于 `/usr/local/libexec`）。在使用 SLURPD
    的配置中，`slurpd` 通常会在 `slapd` 启动后立即启动。SLURPD 没有自己的配置文件，它会在 `slapd.conf` 文件中查找配置信息。'
- en: 'In Chapter 7 we will look at the technology that will likely replace SLURPD:
    the LDAP Sync Replication capability that is built into recent (OpenLDAP 2.2 and
    later) versions of SLAPD.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在第七章，我们将讨论可能替代 SLURPD 的技术：最近版本（OpenLDAP 2.2 及更高版本）的 SLAPD 内置的 LDAP 同步复制功能。
- en: Creating Directory Data
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建目录数据
- en: In the previous section we looked at the two LDAP daemons, SLAPD and SLURPD.
    But though we have a directory running already, we do not have any entries in
    our directory (other than the ones that are created by SLAPD, such as schema records
    and the root DSE).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了两个 LDAP 守护进程，SLAPD 和 SLURPD。但是，尽管我们已经有一个正在运行的目录，但我们的目录中并没有任何条目（除了由
    SLAPD 创建的条目，如架构记录和根 DSE）。
- en: In this section we will create a file for holding our LDAP data, and we will
    devise some directory entries to go in this file. In the next section we will
    load the data into the directory.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个文件来存储我们的 LDAP 数据，并设计一些要放入该文件的目录条目。下一节我们将把数据加载到目录中。
- en: The LDIF File Format
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LDIF 文件格式
- en: 'Throughout this book we look at examples of LDAP records presented in plain
    text, with each line having an attribute description, followed by a colon and
    a value. The first line of the record is the DN, and usually the last lines of
    the record are the object class attributes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们展示了以纯文本形式呈现的 LDAP 记录示例，每行包含一个属性描述，后面跟着冒号和一个值。记录的第一行是 DN，通常记录的最后几行是对象类属性：
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This format is the standard way of representing LDAP directory entries in a
    text file. It is an example of a record written in the **LDAP Data Interchange
    Format (LDIF)**, version 1.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式是以文本文件表示 LDAP 目录条目的标准方式。它是写成 **LDAP 数据交换格式 (LDIF)** 版本 1 的记录示例。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The LDIF file format was developed as part of the University of Michigan LDAP
    server project. In 2000, LDIF version 1 was standardized in RFC 2849\. The standard
    is available online at [http://www.rfc-editor.org/rfc/rfc2849.txt](http://www.rfc-editor.org/rfc/rfc2849.txt).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: LDIF 文件格式是作为密歇根大学 LDAP 服务器项目的一部分开发的。2000 年，LDIF 版本 1 在 RFC 2849 中进行了标准化。该标准可以在线查看，链接为
    [http://www.rfc-editor.org/rfc/rfc2849.txt](http://www.rfc-editor.org/rfc/rfc2849.txt)。
- en: The LDIF standard defines a file format not only for representing the contents
    of a directory, but for representing certain LDAP operations, such as additions,
    changes, and deletions. In the section on the `ldapmodify` client, we will use
    LDIF to specify changes to records in the directory server, but right now we are
    interested in creating a file that represents the contents of our directory.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: LDIF 标准定义了一种文件格式，不仅用于表示目录的内容，还用于表示某些 LDAP 操作，如添加、修改和删除。在 `ldapmodify` 客户端的章节中，我们将使用
    LDIF 来指定目录服务器中记录的更改，但现在我们关心的是创建一个表示目录内容的文件。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'LDIF is not the only directory file format. There is an XML-based directory
    markup language called **DSML** (**Directory Services Markup Language**). While
    there is a standardized DSML version 1, the project seems to have lost momentum
    to the extent that the official website, [dsml.org](http://dsml.org), is now gone.
    However, one Open Source DSML tools website hosts a mirror of the old [dsml.org](http://dsml.org)
    site: [http://www.dsmltools.org/dsml.org/](http://www.dsmltools.org/dsml.org/).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: LDIF 不是唯一的目录文件格式。还有一种基于 XML 的目录标记语言，叫做 **DSML**（**目录服务标记语言**）。虽然有一个标准化的 DSML
    版本 1，但该项目似乎已经失去动力，以至于官方网站 [dsml.org](http://dsml.org) 已经消失。然而，某个开源 DSML 工具网站仍然托管着旧版
    [dsml.org](http://dsml.org) 网站的镜像：[http://www.dsmltools.org/dsml.org/](http://www.dsmltools.org/dsml.org/)。
- en: The OpenLDAP suite does not directly support DSML.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP 套件不直接支持 DSML。
- en: Anatomy of an LDIF File
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LDIF 文件的结构
- en: An LDIF file consists of a list of records, each of which represents an entry
    in the directory. Each entry must have a DN (since any LDAP entry requires a DN),
    and then one or more attributes or change records (`add`, `modify`, `delete`,
    `modrdn`, `moddn`). For now we will confine ourselves to attributes, and put off
    discussion of change records until we discuss `ldapmodify`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 LDIF 文件由一系列记录组成，每条记录代表目录中的一个条目。每个条目必须有一个 DN（因为任何 LDAP 条目都需要 DN），然后是一个或多个属性或更改记录（`add`、`modify`、`delete`、`modrdn`、`moddn`）。现在我们将仅讨论属性，并将更改记录的讨论推迟到我们讨论
    `ldapmodify` 时再进行。
- en: 'Records are separated by empty lines, and each record must begin with a DN:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 记录通过空行分隔，每条记录必须以 DN 开头：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Lines that begin with a pound or number sign (`#`) are treated as comments,
    and ignored. Note that the pound sign must be the first character on the line,
    not preceded by any whitespace characters.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以井号或数字符号（`#`）开头的行被视为注释，并会被忽略。请注意，井号必须是该行的第一个字符，前面不能有任何空白字符。
- en: While it is customary for records to end with the `objectClass` attributes,
    this is done because it is considered easier to read. There is no requirement
    to do so. The order of attributes in an LDIF record is inconsequential.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管记录通常以 `objectClass` 属性结束，这是因为这样更易于阅读，但并没有强制要求这样做。LDIF 记录中属性的顺序是无关紧要的。
- en: An object class (which is defined in a schema definition) indicates what type
    or types of object the record represents. In the precvious example, the two records
    are both `documents`. The object class definition determines which attributes
    are required, and which are merely allowed. When authoring an LDIF file you will
    need to know which fields are required. The DN of any entry is, of course, required,
    as is the `objectclass` attribute. In the `top` object class, which represents
    the root of the schema hierarchy, there are no required fields other than `objectclass`.
    The `document` object class definition requires `documentIdentifier`, and allows
    eleven additional fields, including `documentTitle` (which takes a string value)
    and `documentAuthor` (which takes a DN value, pointing to another record in the
    directory).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类（在模式定义中定义）表示记录所代表的对象类型或类型。在前面的示例中，两个记录都是 `documents`。对象类定义决定了哪些属性是必需的，哪些属性是允许的。当编写
    LDIF 文件时，你需要知道哪些字段是必需的。任何条目的 DN 当然是必需的，`objectclass` 属性也是必需的。在表示模式层次结构根的 `top`
    对象类中，除了 `objectclass` 外没有其他必需字段。`document` 对象类定义要求有 `documentIdentifier`，并允许包含十一种其他字段，包括
    `documentTitle`（其值为字符串）和 `documentAuthor`（其值为 DN，指向目录中的另一个记录）。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The Document Object Class**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档对象类**'
- en: LDAP directories can model a variety of different types of objects. The `document`
    object class, used in the previous example, represents documents (such as books,
    papers, and manuals) in the directory. The schema for the `document` object class
    and the related `documentSeries` object class is contained in `cosine.schema`
    and defined in section 3.2 of RFC 4524 ([ftp://ftp.rfc-editor.org/in-notes/rfc4524.txt](ftp://ftp.rfc-editor.org/in-notes/rfc4524.txt)).
    Schemas will be discussed at length in Chapter 6.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP目录可以建模多种不同类型的对象。前面例子中使用的`document`对象类代表目录中的文档（如书籍、论文和手册）。`document`对象类及相关的`documentSeries`对象类的模式包含在`cosine.schema`中，并在RFC
    4524的第3.2节中定义（[ftp://ftp.rfc-editor.org/in-notes/rfc4524.txt](ftp://ftp.rfc-editor.org/in-notes/rfc4524.txt)）。模式将在第6章中详细讨论。
- en: 'Let''s look at the list of attributes for the document and documentSeries object
    classes:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`document`和`documentSeries`对象类的属性列表：
- en: '![Anatomy of an LDIF File](img/1021_03_02.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![LDIF文件的结构](img/1021_03_02.jpg)'
- en: Any attributes that are used in the DN but are not part of the directory's base
    DN must be present in the record. For example, consider the case where the base
    DN is `dc=example,dc=com`. An entry with the DN `cn=Matt,dc=example,dc=com` would
    have to have a `cn` attribute with the value `Matt`. In the previous examples,
    since `documentIdentifier` is used in the DN, there must be a matching `documentIdentifier`
    attribute in the record.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在DN中使用但不属于目录基础DN的属性必须出现在记录中。例如，假设基础DN为`dc=example,dc=com`。如果条目的DN为`cn=Matt,dc=example,dc=com`，则该条目必须包含一个值为`Matt`的`cn`属性。在前面的例子中，由于`documentIdentifier`在DN中被使用，因此记录中必须有一个匹配的`documentIdentifier`属性。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: In fact, the `document` object class requires the `documentIdentifier` attribute
    so, in this case, even if the attribute was not used in the DN, any document record
    would still need a `documentIdentifier`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`document`对象类需要`documentIdentifier`属性，因此，即使该属性在DN中未被使用，任何文档记录仍然需要一个`documentIdentifier`。
- en: Likewise, an entry with the DN `cn=Matt,ou=Users,dc=example,dc=com` would have
    to have the attributes `cn:Matt` and `ou:Users`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一个DN为`cn=Matt,ou=Users,dc=example,dc=com`的条目必须包含属性`cn:Matt`和`ou:Users`。
- en: Representing Attribute Values in LDIF
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在LDIF中表示属性值
- en: Not all attribute values are simple and short ASCII strings. LDIF provides facilities
    for encoding more complex types of data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有的属性值都是简单的短ASCII字符串。LDIF提供了对更复杂数据类型进行编码的功能。
- en: 'Sometimes attribute values won''t fit on one line. If an attribute value is
    too long to fit on one line it can be continued on the next line, provided that
    the first character on the continued line is a whitespace character:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有时属性值无法在一行内显示。如果属性值过长，无法在一行中显示，可以将其续行，前提是续行的第一字符是空白字符：
- en: '[PRE12]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'According to the RFC, an LDIF file can only contain characters in the ASCII
    character set. However, characters that are not in ASCII can be represented in
    LDIF using a base-64 encoded value. Entries whose value is base-64 encoded differ
    slightly. The attribute description is followed by two colons, instead of one:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 根据RFC，LDIF文件只能包含ASCII字符集中的字符。然而，非ASCII字符可以通过Base-64编码值在LDIF中表示。Base-64编码的属性值略有不同，属性描述后面跟着两个冒号，而不是一个：
- en: '[PRE13]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should consider base-64 encoding under the following circumstances:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，你应该考虑使用Base-64编码：
- en: When the attribute value contains binary data (such as a JPEG photo).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当属性值包含二进制数据（例如JPEG照片）时。
- en: When the character set is not ASCII. Generally, the directory data should be
    stored in UTF-8, but that means that in order to remain compliant to the LDIF
    standard, values should be base-64 encoded.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当字符集不是ASCII时。通常，目录数据应该以UTF-8格式存储，但这意味着为了保持与LDIF标准的兼容性，值应该进行Base-64编码。
- en: When there are line breaks or other non-printing characters within the value.
    (Note that for such values to be accepted the schema must allow these characters
    or the directory server will not allow them to be uploaded even if they are encoded.)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当值中有换行符或其他不可打印字符时。（请注意，为了接受这样的值，模式必须允许这些字符，否则目录服务器即使这些字符已被编码，也不会允许它们被上传。）
- en: When the value begins with or ends with whitespace characters (that you want
    preserved), or begins with a colon (`:`) or a less-than sign (`<`).
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当值以空白字符开始或结束（并且希望保留这些空白字符），或以冒号（`:`）或小于号（`<`）开始时。
- en: Even DNs can be base-64 encoded, and you can use UTF-8 characters in a DN as
    long as the DN is base-64 encoded.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是DN，也可以进行Base-64编码，只要DN是Base-64编码的，你就可以在DN中使用UTF-8字符。
- en: 'There are several UNIX/Linux utilities which can be used to base-64 encoded
    values. The most popular is the `uuencode` program that comes in the `sharutils`
    package. However, this program is not installed by default in Ubuntu. You can
    install it quickly from the command line with `apt-get`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种 UNIX/Linux 工具可以用来进行 base-64 编码。最流行的是 `uuencode` 程序，它包含在 `sharutils` 包中。然而，这个程序在
    Ubuntu 中并不是默认安装的。你可以通过命令行使用 `apt-get` 快速安装它：
- en: '[PRE14]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once `sharutils` is installed you can encode a value with `uuencode`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 `sharutils`，你可以使用 `uuencode` 编码一个值：
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example we are converting the string `" test"` (note the leading white
    space) into a base-64 encoded string. This is done with a couple of commands on
    the command line (using the Bash shell in this example).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将字符串 `" test"`（注意前导空格）转换为 base-64 编码的字符串。这是通过命令行中的几个命令来完成的（此例中使用 Bash
    shell）。
- en: The `uuencode` command is typically used to encode files for attachment to an
    email message, so we have to do a little work to get it to operate the way we
    want. First, we `echo` the string that we want to encode. The `echo` program,
    by default, adds a newline character onto the end of the string that it echoes.
    We use the `-n` flag to prevent it from adding the newline character.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`uuencode` 命令通常用于将文件编码为电子邮件附件，因此我们需要做一点工作，让它按我们想要的方式运行。首先，我们使用 `echo` 命令回显我们想要编码的字符串。`echo`
    程序默认会在回显的字符串末尾添加一个换行符。我们使用 `-n` 标志来防止它添加换行符。'
- en: The string `" test"` is echoed to the standard output (`/dev/stdout`), and then
    piped (`|`) into the `uuencode` command. The `-m` flag instructs `uuencode` to
    use base-64 encoding, and the `name` string is used by `uuencode` to generate
    a name for the attachment. While this is useful when using `uuencode` to generate
    email attachements, it serves no purpose for us. Since we are not attaching this
    file to anything it doesn't really matter what you put there; `foo` would work
    equally as well.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 `" test"` 被回显到标准输出（`/dev/stdout`），然后通过管道符（`|`）传递到 `uuencode` 命令中。`-m` 标志指示
    `uuencode` 使用 base-64 编码，`name` 字符串被 `uuencode` 用来为附件生成名称。当使用 `uuencode` 生成电子邮件附件时，这很有用，但对我们来说没有实际作用。因为我们不将这个文件附加到任何东西上，所以放什么内容都无所谓；`foo`
    也能同样起作用。
- en: 'The `uuencode` program then prints three lines of output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`uuencode` 程序然后会打印出三行输出：'
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Only the second line of the code (highlighted one), the actual base-64 encoded
    value, matters to us. We can copy `IHRlc3Q=` and paste it into our LDIF file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 只有代码中的第二行（高亮的那一行），即实际的 base-64 编码值，对我们来说才重要。我们可以复制 `IHRlc3Q=` 并将其粘贴到我们的 LDIF
    文件中。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Another popular tool for base-64 encoding is `mimencode`, provided by the `metamail`
    package. Both the Perl and Python scripting languages have base-64 encoding tools
    as well.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的 base-64 编码工具是 `mimencode`，它由 `metamail` 包提供。Perl 和 Python 脚本语言也有 base-64
    编码工具。
- en: In some cases, inserting a lengthy attribute value (such as the entire base-64
    encoded image file, or even a lengthy bit of text) into the LDIF file would make
    the file too large to efficiently edit with a text editor. Even a small image
    file would be hundreds of characters long when base-64 encoded. Instead of inserting
    the base-64 encoded string directly into the file you can use a special file reference,
    and the contents of the file will be retrieved and loaded into the directory when
    the LDIF file is imported.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，将一个较长的属性值（例如整个 base-64 编码的图像文件，甚至是大量文本）插入到 LDIF 文件中会使文件过大，以至于无法高效地使用文本编辑器进行编辑。即使是一个小的图像文件，经过
    base-64 编码后，也会有数百个字符。与其直接将 base-64 编码的字符串插入到文件中，不如使用特殊的文件引用，文件的内容将在导入 LDIF 文件时被检索并加载到目录中。
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The highlighted line of code shows an example of inserting a reference to an
    external file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮的代码行展示了如何插入外部文件的引用。
- en: 'There are two important features to note in this example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中有两个重要的特点需要注意：
- en: The left angle bracket (`<`) character is used to indicate that the file should
    be imported. This character evokes the UNIX/Linux shell, which uses the left angle
    bracket for the same purpose.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左尖括号（`<`）字符用于表示应该导入文件。这个字符在 UNIX/Linux shell 中也用于相同的目的。
- en: The path to the file follows the standard `file://` URL scheme to represent
    the file path.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的路径遵循标准的 `file://` URL 方案来表示文件路径。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that in the file scheme, you will usually need three slashes at the beginning
    (`file:///path/to/file`) to indicate that there is no host field. RFC 3986 ([ftp://ftp.rfc-editor.org/in-notes/rfc3986.txt](ftp://ftp.rfc-editor.org/in-notes/rfc3986.txt))
    defines the general structures of URIs and URLs. `file://` is one particular URL
    scheme, and is roughly defined in section 3.1 of RFC 1738 ([ftp://ftp.rfc-editor.org/in-notes/rfc1738.txt](ftp://ftp.rfc-editor.org/in-notes/rfc1738.txt)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在文件方案中，通常需要在开头使用三个斜杠（`file:///path/to/file`）来指示没有主机字段。RFC 3986 ([ftp://ftp.rfc-editor.org/in-notes/rfc3986.txt](ftp://ftp.rfc-editor.org/in-notes/rfc3986.txt))
    定义了 URI 和 URL 的一般结构。`file://` 是一种特定的 URL 方案，大致定义见 RFC 1738 的第 3.1 节 ([ftp://ftp.rfc-editor.org/in-notes/rfc1738.txt](ftp://ftp.rfc-editor.org/in-notes/rfc1738.txt))。
- en: 'In cases where you have attribute values in multiple languages you can store
    language information along with the attribute description:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有多种语言的属性值时，你可以将语言信息与属性描述一起存储：
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The language information is stored in the directory, and clients will be able
    to use it to display the language appropriate to the locale.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 语言信息存储在目录中，客户端将能够使用它来显示与地区相符的语言。
- en: This covers the basics of the LDIF file format, now we will move on and create
    an LDIF file to load into the directory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了 LDIF 文件格式的基本内容，接下来我们将创建一个 LDIF 文件并加载到目录中。
- en: Example.Com in LDIF
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Example.Com 的 LDIF
- en: Now we are ready to model our directory tree in an LDIF file. The first thing
    to do is to decide on a directory structure. We are going to represent an organization
    in our directory tree. Of course the possibilities for the types of trees you
    can model are boundless, but we will stick to those most commonly used for LDAP
    directories.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备在 LDIF 文件中建模我们的目录树。首先需要做的是决定目录结构。我们将代表一个组织在我们的目录树中。当然，你可以建模的树种类几乎是无限的，但我们将坚持使用那些在
    LDAP 目录中最常见的类型。
- en: 'There are two popular ways of defining the roots of an organizational directory
    tree:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 定义组织目录树根节点有两种流行的方法：
- en: 'The first is to create a root entry that indicates the official name of the
    organization and the geographic location (usually just the country) of the organization.
    Here are a few examples:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个方法是创建一个根条目，指示组织的官方名称和组织的地理位置（通常只是国家）。以下是几个示例：
- en: '[PRE19]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In each of these three examples, `o` represents the organization name, and `c`
    is the two-character country code.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这三个示例中，`o` 代表组织名称，`c` 是两字符的国家代码。
- en: 'The second popular model is to use the organization''s domain name. For example,
    if the company Airius has registered the `airus.co.uk` domain name, then the root
    DN would be composed of three **domain component** (`dc`) attributes:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二种流行的模型是使用组织的域名。例如，如果 Airius 公司注册了 `airus.co.uk` 域名，那么根 DN 将由三个 **域组件**（`dc`）属性组成：
- en: '[PRE20]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Likewise, the other two records could be re-written using their respective
    domain components:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，其他两个记录也可以使用各自的域组件重新编写：
- en: '[PRE21]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using the organization/country configuration has its advantages. Corporations
    with multiple domains may find this form more appealing. But the second form,
    relying upon domain components instead, has become much more prevalent. In most
    circumstances, I prefer the domain component form because it is more closely related
    to the way much information is referenced on the Internet.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组织/国家配置有其优点。拥有多个域的公司可能会发现这种形式更具吸引力。但第二种形式，依赖于域组件的方式，已变得更加普遍。在大多数情况下，我更喜欢域组件形式，因为它与互联网上信息的引用方式更为相关。
- en: Of course, there is no hard and fast rule about how exactly the DN must be structured,
    and you may find other base DN structures more appealing.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，关于 DN 结构的具体要求并没有硬性规定，你可能会发现其他基本 DN 结构更具吸引力。
- en: Defining the Base DN Record
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义基本 DN 记录
- en: Now that we have chosen a base DN style, let's begin building a directory for
    Example.Com. LDIF files are read sequentially, record by record. So, the base
    DN must come first, since all other records will refer to it in their DNs. Likewise,
    as we build the directory information tree, we will need to make sure that the
    parent entries always appear in the file before their children.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经选择了基本 DN 风格，接下来让我们开始为 Example.Com 构建一个目录。LDIF 文件是按顺序逐条读取的。因此，基本 DN 必须排在最前面，因为所有其他记录都会在它们的
    DN 中引用它。同样，在构建目录信息树时，我们需要确保父条目始终出现在子条目之前。
- en: 'Our base DN looks like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本 DN 看起来是这样的：
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s start from the bottom and work backwards through the example. The record
    has three object classes: `top`, `dcObject`, and `organization`. As we have seen
    already, the `top` object class is the root of the hierarchy of object classes,
    and all records within the directory are in the `top` object class.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从底部开始，按顺序反向分析这个示例。该记录有三个对象类：`top`、`dcObject`和`organization`。正如我们已经看到的，`top`对象类是对象类层次结构的根节点，目录中的所有记录都属于`top`对象类。
- en: 'Here is the figure displaying the object classes:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是显示对象类的图示：
- en: '![Defining the Base DN Record](img/1021_03_03.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![定义基础DN记录](img/1021_03_03.jpg)'
- en: 'The `dcObject` object class simply describes domain components—pieces of a
    domain name. The domain [www.packtpub.com](http://www.packtpub.com), for example,
    has three domain components: `www`, `packtpub`, and `com`. Since we are using
    domain components in the DN, we need the `dcObject` class, which requires one
    attribute: `dc`.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`dcObject`对象类仅描述域组件——域名的组成部分。例如，域[www.packtpub.com](http://www.packtpub.com)有三个域组件：`www`、`packtpub`和`com`。由于我们在DN中使用了域组件，所以需要`dcObject`类，它要求有一个属性：`dc`。'
- en: You may notice that while in the DN there are two `dc` attributes (`dc=example`
    and `dc=com`), there is only one (`dc:example`) listed in the record. While it
    seems counter-intuitive at first glance, the reason is actually straightforward.
    The record is not describing the entire domain—just a single domain component
    (`example`). Like a DNS record, the parent component (`com`) refers to another
    entity somewhere else in a great big hierarchy.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到，虽然在DN中有两个`dc`属性（`dc=example`和`dc=com`），但在记录中只列出了一个（`dc:example`）。虽然乍一看似乎不太直观，但其实原因非常简单。该记录并未描述整个域，而只是单个域组件（`example`）。就像DNS记录一样，父组件（`com`）指向层次结构中另一个地方的实体。
- en: So, each record that uses the `dcObject` object class can describe only one
    domain component, and hence have only one `dc` attribute in the record (though
    the DN may have multiple `dc` attributes, specifying in which part of the domain
    hierarchy this record resides).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用`dcObject`对象类的每条记录只能描述一个域组件，因此记录中只能有一个`dc`属性（尽管DN可能有多个`dc`属性，指明该记录在域层次结构中的位置）。
- en: But is the `dc=com` record supposed to be in our directory? Since the root of
    this directory (as specified in the `slapd.conf` file) is `dc=example,dc=com`,
    we would not expect to find the `dc=com` record within the database, as it is
    not under the `dc=example,dc=com` part of the tree (rather, `dc=com` is above,
    or superior to, this part of the tree).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`dc=com`的记录是否应该在我们的目录中？由于该目录的根节点（如`slapd.conf`文件中指定的）是`dc=example,dc=com`，我们不应在数据库中找到`dc=com`的记录，因为它不在`dc=example,dc=com`树部分下（而是`dc=com`位于该部分之上，或者说是该部分的上级）。
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Handling Requests for Records Outside the Directory Tree**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理目录树外的记录请求**'
- en: 'What if a search request comes into our `Example.Com` directory for `dc=com`?
    Or what if we get a request for `dc=otherExample,dc=com`? These are records not
    expected to be in our directory. Using the referral directive in the `slapd.conf`
    file, you can direct requests of this sort to another server that might prove
    more authoritative on the matter. The syntax for the directive is `referral <ldap
    URL>`, for example: `referral ldap://root.openldap.org`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们收到针对`dc=com`的搜索请求，该怎么办？或者，如果我们收到`dc=otherExample,dc=com`的请求呢？这些是我们目录中不应有的记录。通过在`slapd.conf`文件中使用转介指令，您可以将这类请求引导到另一个可能在该问题上更具权威性的服务器。该指令的语法是`referral
    <ldap URL>`，例如：`referral ldap://root.openldap.org`。
- en: Now we have specified what domain component our record describes. But we still
    need a little more. We can't just have a record with `top` and `dcObject` object
    classes for two reasons—one practical and the other technical.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经指定了记录描述的域组件。但我们仍然需要更多的信息。我们不能只依赖`top`和`dcObject`对象类的记录，因为这样有两个原因——一个是实际的，另一个是技术性的。
- en: Practically speaking, the record would not be particularly useful with just
    this sparse information, as it wouldn't really tell us about the base of the directory
    tree (other than that, it has a domain name).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，仅凭这些简略信息，这条记录并不会特别有用，因为它并没有真正告诉我们目录树的基础（除了它有一个域名之外）。
- en: Technically speaking, neither of the two object classes, `top` and `dcObject`,
    are sufficient for a complete record. The reason for this is that neither of these
    object classes are **structural object classes**, (`top` is abstract, and `dcObject`
    is auxiliary) and every record in the directory must have one object class that
    is considered the structural object class for that record. For a detailed explanation,
    as well as some useful information about structuring records, see Chapter 6.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，`top` 和 `dcObject` 这两个对象类都不足以构成完整的记录。原因在于，这两个对象类都不是**结构化对象类**，(`top` 是抽象的，`dcObject`
    是辅助的)，而且目录中的每一条记录都必须有一个被视为该记录结构化对象类的对象类。有关详细的解释，以及一些有关记录结构的有用信息，请参阅第六章。
- en: What would make our base record more useful (and fulfill the record's requirement
    to have a structural object class)? The `organization` object class describes
    an organization, as the name suggests. It requires one field, `o` (or its synonym,
    `organizationName`), which is used to specify the (legal) name of the organization.
    Additionally the organization object class allows twenty-one optional fields that
    provide more detailed information about the organization, such as `postalAddress`,
    `telephoneNumber`, and `location`. In the previous example we used the `description`
    field, which is also among the twenty-one attributes allowed by the `organization`
    object class.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使我们的基本记录更加有用（并满足记录必须具有结构化对象类的要求）呢？`organization` 对象类描述了一个组织，顾名思义。它要求一个字段，`o`（或其同义词
    `organizationName`），用于指定组织的（法定）名称。此外，`organization` 对象类还允许使用二十一个可选字段，提供有关组织的更详细信息，例如
    `postalAddress`、`telephoneNumber` 和 `location`。在前面的示例中，我们使用了 `description` 字段，它也是
    `organization` 对象类允许的二十一种属性之一。
- en: That is our base entry for our directory. It describes the record at the root
    of our directory information tree. Next we want to add some structure to our directory.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们目录的基本入口。它描述了目录信息树根部的记录。接下来，我们希望为目录添加一些结构。
- en: Structuring the Directory with Organizational Units
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用组织单位（OU）结构化目录
- en: One of the strengths of LDAP's directory server model is its ability to represent
    data organized into hierarchies. In this section, we will use **Organizational
    Units (OUs)** to create a several subtrees beneath our `dc=example,dc=com` root.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP 目录服务器模型的一个优势是它能够将数据组织成层级结构。在这一节中，我们将使用**组织单位（OUs）**在我们的 `dc=example,dc=com`
    根目录下创建多个子树。
- en: Our Example.Com directory is intended primarily for holding user and account
    information. For that reason, we will want to use Organizational Units to create
    subtrees.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Example.Com 目录主要用于保存用户和账户信息。因此，我们将希望使用组织单位（OU）来创建子树。
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we were, for example, creating a directory of `document` records (as we did
    in the section entitled *The* *LDIF* *File* *Format*), instead of using OUs, we
    might instead use `documentSeries` records.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们正在创建一个 `document` 记录的目录（正如我们在 *LDIF 文件格式* 章节中所做的那样），我们可能不会使用 OUs，而是使用
    `documentSeries` 记录。
- en: OpenLDAP does not provide a default OU subtree structure, so you will need to
    create your own. This can be done in many ways, but here we will see the two prominent
    theories of how OUs should be structured.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP 并不提供默认的 OU 子树结构，因此你需要创建自己的结构。这可以通过多种方式实现，但在这里我们将看到两种主要理论，说明 OUs 应该如何结构化。
- en: 'Theory 1: Directory as Organizational Chart'
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理论 1：目录作为组织结构图
- en: 'The first theory is that the directory should be structured to represent the
    organizational chart of the organization you are modeling. For example, if the
    organization has three main units—Accounting, Human Resources (HR), and Information
    Technology (IT)—then you should have three OUs. Here is a figure for the same:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个理论是，目录应当结构化为表示你正在建模的组织的组织结构图。例如，如果该组织有三个主要部门——会计、人力资源（HR）和信息技术（IT）——那么你应该有三个
    OUs。以下是相应的图示：
- en: '![Theory 1: Directory as Organizational Chart](img/1021_03_04.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![理论 1：目录作为组织结构图](img/1021_03_04.jpg)'
- en: In the given screenshot, each OU represents a unit in the organizational chart.
    Employees who work in Accounting will have their user accounts in the directory
    subtree `ou=Accounting,dc=example,dc=com`, while employees in IT will have accounts
    in `ou=IT,dc=example,dc=com`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的截图中，每个 OU 代表组织结构图中的一个单位。在会计部门工作的员工将会在目录子树 `ou=Accounting,dc=example,dc=com`
    中拥有他们的用户账户，而在 IT 部门工作的员工则会在 `ou=IT,dc=example,dc=com` 中拥有账户。
- en: This method has some obvious advantages. Knowledge of how the organization works
    will help you locate information in the directory. Conversely, the directory will
    serve as a tool for understanding how the organization is structured. Organizational
    relationships between people or records in the directory will be more easily ascertained.
    For example, a glance at the record (or just the DN) of `uid=Marvin,ou=Accounting,dc=example,dc=com`,
    and you will know that Marvin works in the same department as Barbara.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一些明显的优点。了解组织如何运作将有助于你在目录中查找信息。相反，目录将作为一个工具，帮助你理解组织的结构。组织中人与人之间或记录与记录之间的关系将更容易被识别。例如，只需看一下`uid=Marvin,ou=Accounting,dc=example,dc=com`的记录（或仅查看DN），你就会知道Marvin与Barbara在同一个部门工作。
- en: 'There are a few things to consider before structuring your directory this way
    though:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在以这种方式构建目录之前，需要考虑以下几点：
- en: First, while organizational structures change—sometimes too frequently—relocating
    DNs within the directory is not an easy task (and in some cases requires deleting
    a record from one part of the tree and creating a similar version in another part
    of the tree).
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，虽然组织结构会发生变化——有时变化过于频繁——但在目录中重新定位DN并不是一项简单的任务（在某些情况下需要删除树中某个部分的记录，并在树的另一个部分创建类似的记录）。
- en: If Barbara, the manager of Accounting, is transferred to Human Resources, her
    DN must change (to reflect the new OU). Some (older) backends do not allow DN
    changes, and so Barbara's Accounting record would need to be deleted, and then
    a new one created for her in the HR OU. Also, applications that stored the DN
    of the user would have to be reconfigured. Similarly, some employees may split
    their time between two departments. How would this case be handled?
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果会计部经理Barbara调任人力资源部，她的DN必须更改（以反映新的OU）。一些（较旧的）后台不允许更改DN，因此Barbara的会计部记录需要被删除，然后在HR
    OU中为她创建新的记录。此外，存储用户DN的应用程序也必须重新配置。类似地，一些员工可能会在两个部门之间分配时间。如何处理这种情况？
- en: A second consideration, and one that is not at all obvious, has to do with the
    technical use of the LDAP directory. If user records are spread throughout the
    directory tree, then applications will need to be smart enough to search all over
    the tree for user records.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个考虑因素是与LDAP目录的技术使用有关的，而这一点并不那么明显。如果用户记录分散在目录树的各个地方，那么应用程序需要足够智能，能够在整个树中搜索用户记录。
- en: This problem is usually solved by pre-authentication search techniques, such
    as binding as Anonymous or as a special authentication user, searching the directory
    for the account that will be used for authentication, and then binding as the
    correct account (if found). But not all clients (and not all directories, for
    that matter) allow pre-authentication searching. And pre-authentication searching
    can impose a bigger load on the server, whereas other techniques may be easier
    on the server.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个问题通常通过预认证搜索技术来解决，例如以匿名用户或特定认证用户身份绑定，搜索目录中用于认证的账户，然后以正确的账户身份绑定（如果找到的话）。但并非所有客户端（更不用说所有目录）都允许预认证搜索。并且预认证搜索可能会给服务器带来更大的负担，而其他技术可能对服务器更为友好。
- en: A third consideration has to do with what other sorts of information you want
    to store in your directory. If you are using the directory primarily as a tool
    for modeling the organizational chart, then this particular method of structuring
    the directory will be ideal for you. You can track employees, assets (fleet vehicles,
    computers, and so on), and other resources within the directory, and locate their
    position in the organization.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个考虑因素是你希望在目录中存储哪些其他类型的信息。如果你主要将目录作为建模组织结构图的工具，那么这种特定的目录结构方法将非常适合你。你可以在目录中跟踪员工、资产（车队车辆、计算机等）和其他资源，并定位它们在组织中的位置。
- en: But if the main purpose of the directory is to create a directory of users of
    IT services, then this structure will be less than ideal, requiring applications
    to do much more work to locate users (and in some cases, requiring users to know
    more about their LDAP accounts).
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，如果目录的主要目的是创建一个IT服务用户的目录，那么这种结构就不太理想了，需要应用程序做更多的工作来定位用户（在某些情况下，还要求用户了解更多关于他们的LDAP账户信息）。
- en: 'Theory 2: Directory as IT Service'
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理论2：目录作为IT服务
- en: The second theory is that the directory should be structured to represent the
    way your system (networks, servers, user applications) will need to access the
    records. In this case the structure of the LDAP directory should be optimized
    for use by such IT services. While the organizational chart technique groups records
    by their relation to the organization, this method groups records into functional
    units, where a position in the directory is determined primarily by the tasks
    that applications and services will require the directory to perform.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种理论是，目录应当结构化为系统（网络、服务器、用户应用）访问记录的方式。在这种情况下，LDAP目录的结构应当针对这些IT服务的使用进行优化。虽然组织结构图方法是按记录与组织的关系进行分组，但这种方法则是按功能单元分组记录，目录中的位置主要由应用程序和服务所需的任务来决定。
- en: 'One common way to structure the directory is to split it into a unit for users,
    a unit for groups, and a unit for system-level records that applications need,
    but users will not require access to. Let''s see an example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的目录结构方式是将其拆分为一个用于用户的单元、一个用于组的单元以及一个系统级记录的单元，后者是应用程序所需的，但用户无需访问。我们来看一个示例：
- en: '![Theory 2: Directory as IT Service](img/1021_03_05.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![理论2：目录作为IT服务](img/1021_03_05.jpg)'
- en: 'In this case, all of the user accounts are under a particular subtree of the
    directory: `ou=Users,dc=example,dc=com`. Applications need only search in one
    part of the directory to find user accounts, and when the organization changes,
    the structure of the directory need not also change.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，所有用户账户都位于目录的特定子树下：`ou=Users,dc=example,dc=com`。应用程序只需在目录的一部分中进行搜索即可找到用户账户，当组织发生变化时，目录的结构不必也发生变化。
- en: Note
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is nothing magical about using organizational units (OUs) for partitioning
    the directory information tree. You can use other record types, and other attributes
    (such as `cn`—common name) to divide a directory into multiple branches. Using
    OUs is traditional, though perhaps not the most appropriate in cases where the
    directory information tree does not model the organizational chart.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组织单位（OU）来划分目录信息树并没有什么神奇之处。你可以使用其他记录类型和其他属性（如`cn`——常用名称）将目录划分为多个分支。尽管如此，使用OU是传统做法，但在目录信息树并未反映组织结构图的情况下，可能并不是最合适的选择。
- en: This method, Also has some drawbacks. First, the directory structure does not,
    by design, provide any overt clues to the structure of the organization. Of course
    organizational information, such as department IDs, can be stored in individual
    records, and so can be retrieved that way.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也有一些缺点。首先，目录结构从设计上看并未提供组织结构的任何明确线索。当然，组织信息，比如部门ID，可以存储在单独的记录中，便于通过这种方式进行检索。
- en: More importantly though, if the directory supports a large number of users,
    the `ou=Users` branch is going to have a lot of records. This is not necessarily
    a performance problem, but it can make browsing the directory (as opposed to searching
    the directory) a tedious process.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，如果目录支持大量用户，那么`ou=Users`分支将会有大量记录。这不一定是性能问题，但它可能使浏览目录（与搜索目录相对）变得冗长。
- en: 'In some cases, this problem is mitigated by adding additional subtrees under
    the user''s branch. Sometimes this is done by creating a hybrid configuration
    where `ou=User` has subtrees that represent departments in the organization, such
    as `ou=Accounting,ou=Users,dc=example,dc=com`. Sometimes other classification
    systems, such as alphabetical schemes, are used to handle this situation: `uid=matt,ou=m-p,ou=Users,dc=example,dc=com`.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，通过在用户的分支下添加额外的子树来缓解这个问题。有时，这通过创建一个混合配置来实现，其中`ou=Users`下有表示组织部门的子树，例如`ou=Accounting,ou=Users,dc=example,dc=com`。有时也会使用其他分类系统，例如按字母顺序的方案来处理这种情况：`uid=matt,ou=m-p,ou=Users,dc=example,dc=com`。
- en: But for small and medium-sized ones, a user's branch typically does not have
    any additional subtrees, which eases the process of integrating with other applications.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 但是对于小型和中型的目录，用户的分支通常没有任何额外的子树，这简化了与其他应用程序的集成过程。
- en: LDAP also has object classes designed to describe groups of records in the directory.
    Usually, it does not make sense to store these in with the user accounts, so they
    can be moved to a separate branch.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP还具有描述目录中记录组的对象类。通常，将这些与用户账户存储在一起没有意义，因此它们可以被移动到一个单独的分支。
- en: Finally, the System branch is used to store records for things like system accounts,
    mail servers, web servers, and other miscellaneous applications often need (or
    perform best with) their own LDAP accounts. But if it can be helped, they shouldn't
    be grouped in with user accounts.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，系统分支用于存储诸如系统账户、邮件服务器、Web服务器等记录，其他各种应用程序通常需要（或者在拥有自己LDAP账户时表现更好）。但如果可以避免的话，应该避免将它们与用户账户放在一起。
- en: I've outlined two different ways of structuring the directory information tree—one
    mirroring the organization, and the other facilitating IT services. But these
    are only two ways of structuring the directory. You may find that other structures
    meet your needs better. However, for our purposes, we will use the IT services
    structure as we continue to build our LDIF file.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我概述了两种不同的目录信息树结构方式——一种反映组织结构，另一种便于IT服务。但这些只是两种目录结构方式，你可能会发现其他结构更适合你的需求。然而，对于我们的目的，接下来的LDIF文件构建将采用IT服务结构。
- en: Expressing the OUs in LDIF
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在LDIF中表示组织单位
- en: 'Now we are ready to write out our chosen OUs in LDIF. We will create three
    OUs—Users, Groups, and System—as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备将选定的组织单位写入LDIF文件。我们将创建三个组织单位——Users、Groups和System，如下所示：
- en: '[PRE23]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The three OUs have the same structure.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个组织单位的结构相同。
- en: 'Each OU must have the `organizationalUnit` object class. This object class
    has one required attribute: `ou`. Here is a figure displaying the **organizationalUnit**:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组织单位必须有`organizationalUnit`对象类。该对象类有一个必填属性：`ou`。下面是显示**组织单位**的图示：
- en: '![Expressingdirectory treedirectory, structuring the OUs in LDIF](img/1021_03_06.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![表示目录树目录，结构化LDIF中的组织单位](img/1021_03_06.jpg)'
- en: Note
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that the `objectClass: top` has been omitted from these records, as well
    as all of the following records in this chapter. All records are automatically
    assumed to be instances of the `top` object class, so it is not necessary to explicitly
    include the `objectClass: top` attribute.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，`objectClass: top`在这些记录中已被省略，接下来的所有记录也同样省略。在所有记录中，默认假设它们是`top`对象类的实例，因此不需要显式地包含`objectClass:
    top`属性。'
- en: The `description` attribute is optional and there are more than twenty additional
    (optional) attributes that can be added—most of which provide contact information
    of the organization unit, such as `telephoneNumber`, `postOfficeBox`, and `postalAddress`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`description`属性是可选的，除此之外还有二十多个其他（可选）属性可以添加——其中大多数提供组织单位的联系信息，例如`telephoneNumber`、`postOfficeBox`和`postalAddress`。'
- en: 'With our OUs in place we are ready to add a third tier to our directory tree.
    Before we start creating individual records let''s get an overview of what this
    next tier will look like. Here is the directory tree structure with a group, a
    system account, and a pair of users:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织单位（OUs）已经设置好后，我们准备在目录树中添加第三层。在开始创建单独的记录之前，让我们先了解一下下一层的结构。下面是包含一个组、一个系统账户和一对用户的目录树结构：
- en: '![Expressingdirectory treedirectory, structuring the OUs in LDIF](img/1021_03_07.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![表示目录树目录，结构化LDIF中的组织单位](img/1021_03_07.jpg)'
- en: This is the directory information tree that we will create in the remainder
    of this section. Next, we will continue building an LDIF file first by adding
    the users, followed by a system record, and then a group.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将在本节余下部分中创建的目录信息树。接下来，我们将继续构建LDIF文件，首先添加用户记录，然后是系统记录，最后是组记录。
- en: Adding User Records
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加用户记录
- en: We will reserve the `Users` OU for records that describe people in the organization.
    In these accounts we want to store information about the user—things like first
    and last name, title, and department. Since the directory will also be a central
    resource for application information, we also want to store user ID, email address,
    and password.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留`Users`组织单位用于描述组织中人员的记录。在这些账户中，我们希望存储有关用户的信息——例如名字、姓氏、职称和部门。由于目录还将作为应用程序信息的中央资源，我们还希望存储用户ID、电子邮件地址和密码。
- en: 'A basic user record looks like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的用户记录如下所示：
- en: '[PRE24]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The user record for Barbara belongs to three object classes: `person`, `organizationalPerson`,
    and `inetOrgPerson`. All three of these are structural object classes, where `inetOrgPerson`
    is a child of the `organizationalPerson` class, which, in turn, is a child of
    the `person` object class. The attributes in Barbara''s record are a mixture of
    the required and allowed attributes from the three object classes. The following
    figure displays the attributes in Barbara''s record:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 芭芭拉的用户记录属于三个对象类：`person`、`organizationalPerson` 和 `inetOrgPerson`。这三个都是结构化对象类，其中
    `inetOrgPerson` 是 `organizationalPerson` 类的子类，而 `organizationalPerson` 又是 `person`
    对象类的子类。芭芭拉记录中的属性是这三个对象类中的必需属性和允许属性的混合。下图展示了芭芭拉记录中的属性：
- en: '![Addingdirectory treedirectory, structuring User Records](img/1021_03_08.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![添加目录树结构，构建用户记录](img/1021_03_08.jpg)'
- en: Since `inetOrgPerson` inherits from `organizationalPerson`, a record that has
    the `inetOrgPerson` object class also must have the `organizationalPerson` object
    class. And `organizationalPerson` inherits from the `person` object class, so
    `person`, is also required.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `inetOrgPerson` 继承自 `organizationalPerson`，因此拥有 `inetOrgPerson` 对象类的记录必须同时拥有
    `organizationalPerson` 对象类。而 `organizationalPerson` 又继承自 `person` 对象类，所以 `person`
    也是必需的。
- en: This means that all of the `inetOrgPerson` records will require `cn` (the user's
    full name) and `sn` (the user's surname) attributes, as all `inetOrgPerson` records
    are also person records. It also means that the record can have any combination
    of the forty-nine optional attributes defined between the three object classes.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着所有 `inetOrgPerson` 记录都将需要 `cn`（用户的全名）和 `sn`（用户的姓氏）属性，因为所有的 `inetOrgPerson`
    记录也是 `person` 记录。这也意味着该记录可以有三者对象类中定义的四十九个可选属性的任何组合。
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since `uid` and `ou` attributes were used in the DN, they are effectively required
    attributes as well. Furthermore, OpenLDAP will require that the record have a
    `uid` attribute and an `ou` attribute that have values that match the values in
    the DN—in other words, since the `ou` in the DN is `Users`, the `ou` attribute
    in the record must have the value `Users`. This behavior is dictated by the LDAP
    standard.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `uid` 和 `ou` 属性在 DN 中被使用，因此它们实际上也是必需的属性。此外，OpenLDAP 会要求记录中必须有 `uid` 和 `ou`
    属性，并且这两个属性的值与 DN 中的值匹配——换句话说，由于 DN 中的 `ou` 是 `Users`，记录中的 `ou` 属性必须有 `Users` 这个值。这种行为是由
    LDAP 标准决定的。
- en: Tip
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Different object classes, different schemas**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**不同的对象类，不同的架构**'
- en: 'While `person` and `organizationalPerson` are defined in the core schema (`core.schema`),
    `inetOrgPerson` is defined in its own schema (`inetOrgPerson.schema`), and is
    standardized on its own in RFC 2798 ([http://rfc-editor.org/rfc/rfc2798.txt](http://rfc-editor.org/rfc/rfc2798.txt)).
    The reason for this is largely historical: `person` and `organizationalPerson`
    were defined well before `inetOrgPerson` (and by different parties).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `person` 和 `organizationalPerson` 定义在核心架构文件（`core.schema`）中，`inetOrgPerson`
    是在它自己的架构文件（`inetOrgPerson.schema`）中定义的，并且在 RFC 2798 中进行了标准化（[http://rfc-editor.org/rfc/rfc2798.txt](http://rfc-editor.org/rfc/rfc2798.txt)）。之所以这样，主要是历史原因：`person`
    和 `organizationalPerson` 在 `inetOrgPerson` 之前就已被定义（并且是由不同方定义的）。
- en: 'An `inetOrgPerson` record that utilizes more of the available attributes might
    look like this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更多可用属性的 `inetOrgPerson` 记录可能看起来是这样的：
- en: '[PRE25]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this example we are still using the same three object classes, but have
    selected many more of the optional attributes. One thing that may stand out in
    both Barbara''s and Matt''s records, is that there are an awful lot of attributes
    used simply for specifying the name of the person; `cn`, `sn`, `givenName`, and
    `displayName` are all fields related to the person''s name. What''s the point
    in having so many? There are two benefits achieved by providing diverse name fields:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们仍然使用相同的三个对象类，但选择了更多的可选属性。在芭芭拉和马特的记录中，有一件事可能会显得特别突出，那就是有许多属性仅仅用于指定个人的姓名；`cn`、`sn`、`givenName`
    和 `displayName` 都是与个人姓名相关的字段。为什么会有这么多呢？提供多种姓名字段有两个好处：
- en: This reduces the amount of guess work that an application has to do when parsing
    names. Names can be ambiguous—for instance, John Stuart Mill's surname is Mill,
    while Mary Stuart Masterson's surname is Stuart Masterson. Explicitly specifying
    such things can reduce ambiguity.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这减少了应用程序在解析姓名时需要进行的猜测工作。姓名可能会有歧义——例如，约翰·斯图尔特·密尔的姓是密尔，而玛丽·斯图尔特·马斯特森的姓是斯图尔特·马斯特森。明确指定这些内容可以减少歧义。
- en: The different attributes allow additional information to be specified. Multiple
    `cn` and `givenName` values can specify different forms of a person's name, while
    `displayName` (which can only have one value, and cannot be used multiple times
    in the same record) ensures that the applications will consistently display the
    same name.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的属性允许指定附加信息。多个 `cn` 和 `givenName` 值可以指定一个人姓名的不同形式，而 `displayName`（只能有一个值，并且在同一记录中不能多次使用）确保应用程序始终一致地显示相同的姓名。
- en: Tip
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Common Names**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见名称**'
- en: The `cn` field is used by many different object classes in the directory, many
    of which do not describe persons. For this reason, a `cn` does not always contain
    the full name of a person. Groups, devices, and documents are amongst the things
    that may use the `cn` (or `commonName`) attribute.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`cn` 字段被目录中的许多不同对象类使用，其中许多并不描述人员。因此，`cn` 并不总是包含一个人的全名。组、设备和文档等事物可能会使用 `cn`（或
    `commonName`）属性。'
- en: In the previous examples the `userPassword` field, which contains the person's
    password, is in plain text. When this file is loaded into the directory, the value
    will be base-64 encoded, but it will not be *encrypted*. It is not at all secure
    to store clear-text passwords in the directory (and base-64 encoding does not
    improve the security of the password). Later in this section we will look at the
    `ldappasswd` tool, which encrypts passwords before storing them in the directory.
    Production directories should always store the `userPassword` value in encrypted
    form.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，包含个人密码的 `userPassword` 字段是明文的。当该文件加载到目录时，密码的值会进行 base-64 编码，但它并没有被 *加密*。将明文密码存储在目录中是极不安全的（而且
    base-64 编码并不能提高密码的安全性）。在本节后面，我们将查看 `ldappasswd` 工具，它在将密码存储到目录之前会对密码进行加密。生产环境中的目录应该始终将
    `userPassword` 值以加密形式存储。
- en: Note
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may notice that in the `homePostalAddress` field, dollar signs (`$`) are
    used where one would normally expect to see line breaks. OpenLDAP does not automatically
    convert these to line breaks. But use of the dollar sign is an older way of representing
    line breaks without using base-64 encoding. Typically, it is only used in postal
    address related fields—and it is up to implementing applications to correctly
    interpret the dollar signs.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在 `homePostalAddress` 字段中，美元符号（`$`）被用来代替通常期望看到的换行符。OpenLDAP 不会自动将这些符号转换为换行符。但是，使用美元符号是一种较老的方式，表示换行符而不使用
    base-64 编码。通常，它仅用于与邮政地址相关的字段——并且由实现应用程序来正确解释这些美元符号。
- en: Both of these examples use the `inetOrgPerson` object class as their primary
    structural object class. This is because these records describe a person and use
    the `uid` attribute (and use it as part of the DN). Additionally, `inetOrgPerson`
    provides a number of attributes that are useful for modern information infrastructures;
    `jpegPhoto`, `preferredLanguage`, and `displayName` (amongst others) are all intended
    to be used primarily by modern computer agents rather than humans. As it is standardized
    and widely deployed (LDAP servers from Sun to Microsoft use it), it is the preferred
    object class for describing people within an organization.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例都使用 `inetOrgPerson` 对象类作为其主要结构化对象类。这是因为这些记录描述的是一个人，并且使用了 `uid` 属性（并将其作为
    DN 的一部分）。此外，`inetOrgPerson` 提供了许多对现代信息基础设施有用的属性；如 `jpegPhoto`、`preferredLanguage`
    和 `displayName`（等等）主要是供现代计算机代理使用，而非人类使用。由于它已被标准化并广泛部署（从 Sun 到 Microsoft 的 LDAP
    服务器都在使用它），它成为了描述组织内人员的首选对象类。
- en: Thus far we have created a base DN entry, some organizational units, and a few
    users. Now we will add a record describing a system account.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个基本的 DN 条目、一些组织单位和几个用户。现在我们将添加一个记录，描述一个系统账户。
- en: Adding System Records
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加系统记录
- en: Some of the entries in our tree—entries that we will need—do not describe users,
    and so do not belong in the Users organizational unit (OU). Instead, we will put
    such special records in the `System` OU. Likewise, the entities we are describing
    are not people, and so using the `person`, `organizationalPerson`, and `inetOrgPerson`
    object classes is not appropriate.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们树中的一些条目——我们需要的条目——并不描述用户，因此不属于用户组织单位（OU）。相反，我们将这些特殊记录放入 `System` OU。同样，我们所描述的实体并不是人，因此使用
    `person`、`organizationalPerson` 和 `inetOrgPerson` 对象类并不合适。
- en: In this section we will create a new record for an account that will assist
    users in logging in. The function of the account will be described in detail in
    Chapter 4, but this account will need to be able to authenticate to the directory
    server and perform operations. But, again, this account is not for a specific
    person, and so it will not have personal data (like a surname or a given name).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个新的账户记录，帮助用户进行登录。账户的功能将在第 4 章详细描述，但这个账户需要能够对目录服务器进行身份验证并执行操作。然而，这个账户并非为特定的人而创建，因此它不会拥有个人数据（如姓氏或名字）。
- en: 'Here''s what our new system account, called `authenticate`, looks like:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新系统账户 `authenticate` 看起来是这样的：
- en: '[PRE26]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This record has two object classes: `account` and `simpleSecurityObject`. The
    first one, `account`, is the structural object class. An `account` object, which
    is defined in the Cosine schema (`cosine.schema`), describes an account used to
    access computers or networks. Let''s have a look at the two object classes:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 该记录有两个对象类：`account` 和 `simpleSecurityObject`。第一个对象类，`account`，是结构化对象类。一个 `account`
    对象，定义在 Cosine 模式（`cosine.schema`）中，描述了用于访问计算机或网络的账户。我们来看一下这两个对象类：
- en: '![Adding System Records](img/1021_03_09.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![添加系统记录](img/1021_03_09.jpg)'
- en: 'Our account, whose DN is `uid=authenticate,ou=System,dc=example,dc=com`, uses
    the `uid` attribute required by the `account` object class, as well as the `ou`
    and `description` fields from account. But the account object class does not have
    a field for storing a password. For that reason we need to add to the record the
    auxiliary object class `simpleSecurityObject`, which has one attribute: the required
    attribute `userPassword`.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的账户，DN 为 `uid=authenticate,ou=System,dc=example,dc=com`，使用了 `account` 对象类所要求的
    `uid` 属性，以及账户中的 `ou` 和 `description` 字段。但账户对象类没有用于存储密码的字段。因此，我们需要在记录中添加辅助对象类 `simpleSecurityObject`，它有一个属性：必需的
    `userPassword` 属性。
- en: Note
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Auxiliary object classes can be combined with any other structural or auxiliary
    object classes. While using multiple structural object classes in one record requires
    that the object classes be related (for example as `organizationalPerson` is a
    child of `person`), auxiliary object classes do not need to be related to the
    object classes with which they are used. In this case `simpleSecurityObject` has
    no direct relation to `account`. See Chapter 6 for a more detailed explanation.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助对象类可以与任何其他结构化或辅助对象类结合使用。虽然在一个记录中使用多个结构化对象类要求这些对象类必须是相关的（例如 `organizationalPerson`
    是 `person` 的子类），但辅助对象类不需要与它们所使用的对象类相关联。在这种情况下，`simpleSecurityObject` 与 `account`
    没有直接关系。请参阅第 6 章获取更详细的解释。
- en: 'By adding the `simpleSecurityObject` auxiliary object class, we have now made
    it possible for our `account` record to have a password. Again, in our example,
    we have specified the password (`userPassword: secret`) in clear text. It is not
    safe to store unencrypted passwords in the directory. For information on encrypting
    LDAP passwords, see the section on `ldappasswd` later in this chapter.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '通过添加 `simpleSecurityObject` 辅助对象类，我们现在使得我们的 `account` 记录能够拥有密码。同样，在我们的示例中，我们以明文的形式指定了密码（`userPassword:
    secret`）。在目录中存储未加密的密码是不安全的。有关加密 LDAP 密码的信息，请参阅本章稍后部分关于 `ldappasswd` 的章节。'
- en: 'Now we have created some records under two of our three organizational units:
    Users and System. Next, we will add a group under the Groups OU.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在三个组织单位中的两个下创建了一些记录：用户（Users）和系统（System）。接下来，我们将在“组（Groups）”组织单位下添加一个组。
- en: Adding Group Records
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加组记录
- en: The last record we will add to our LDIF file is a record that describes a group
    of DNs. Groups provide a flexible method for collecting similar DNs by whatever
    criterion is needed. The DNs in a group do not have to be structurally similar—they
    can have completely different attributes and object classes, and can describe
    completely different things (such as a document and a person). Thus, it is up
    to the directory administrators and directory applications as to what sorts of
    DNs will be grouped into any particular group.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加到 LDIF 文件的最后一条记录是描述 DN 组的记录。组提供了一种灵活的方法，通过任何所需的标准收集相似的 DN。组中的 DN 不必在结构上相似——它们可以具有完全不同的属性和对象类，甚至可以描述完全不同的内容（例如文档和人员）。因此，目录管理员和目录应用程序可以决定哪些
    DN 会被分组到特定的组中。
- en: In our case, we are going to create a group to represent our directory administrators,
    and all of the DNs that belong to this group are DNs for users (in the `Users`
    OU, and with the `inetOrgPerson` structural object class).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将创建一个组来代表我们的目录管理员，该组的所有 DNs 都是用户的 DNs（在 `Users` 组织单位中，并且具有 `inetOrgPerson`
    结构化对象类）。
- en: '[PRE27]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Our group has the DN `cn=LDAP Admins,ou=Groups,dc=example,dc=com`. Note that
    we use the `cn` attribute, rather than `uid`, to identify the group. That is because
    the `groupOfUniqueNames` object class does not allow a `uid` attribute (and `cn`
    is required).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组的 DN 是 `cn=LDAP Admins,ou=Groups,dc=example,dc=com`。请注意，我们使用 `cn` 属性，而不是
    `uid`，来标识该组。因为 `groupOfUniqueNames` 对象类不允许使用 `uid` 属性（而 `cn` 是必需的）。
- en: Tip
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Usually, you should use the `groupOfNames` object class rather than `groupOfUniqueNames`,
    because `groupOfNames` is the default grouping object class in OpenLDAP. We use
    a `groupOfUniqueNames` here to exhibit some of the features of LDAP group management
    in thelater chapters.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你应该使用 `groupOfNames` 对象类，而不是 `groupOfUniqueNames`，因为 `groupOfNames` 是 OpenLDAP
    中默认的分组对象类。我们在这里使用 `groupOfUniqueNames` 来展示后续章节中 LDAP 组管理的一些特性。
- en: A `groupOfUniqueNames` class is one of three grouping object classes defined
    in the core LDAP version 3 schema (`core.schema`). The other two are `groupOfNames`
    and `organizationalRole`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupOfUniqueNames` 类是 LDAP 版本 3 核心架构（`core.schema`）中定义的三种分组对象类之一。其他两种是 `groupOfNames`
    和 `organizationalRole`。'
- en: 'These have been diplayed in the following figure:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这些已经在下图中显示：
- en: '![Adding Group Records](img/1021_03_10.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![添加组记录](img/1021_03_10.jpg)'
- en: All three of these object classes are designed for collecting DNs. Each has
    an attribute that specifies the DN of a member of the group. In `groupOfNames`,
    the attribute is called, simply enough, `member`. The `groupOfUniqueNames` class,
    which does not differ in function from `groupOfNames`, uses `uniqueMember` as
    its membership attribute. The `organizationalRole` grouping class, which is intended
    to represent the group responsible for performing a particular role in the context
    of the organization, uses the `roleOccupant` attribute for membership.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种对象类都是为了收集 DNs 而设计的。每个类都有一个属性，用于指定该组成员的 DN。在 `groupOfNames` 中，该属性简单地被称为 `member`。`groupOfUniqueNames`
    类，功能上与 `groupOfNames` 相同，使用 `uniqueMember` 作为其成员属性。`organizationalRole` 分组类旨在表示组织中负责执行特定角色的组，它使用
    `roleOccupant` 属性作为成员属性。
- en: In all three grouping object classes, the membership attribute (`member`, `uniqueMember`,
    or `roleOccupant`) can be specified multiple times, as we saw in the LDIF snippet
    for the `LDAP Admins` group.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三种分组对象类中，成员属性（`member`、`uniqueMember` 或 `roleOccupant`）可以多次指定，正如我们在 `LDAP
    Admins` 组的 LDIF 片段中所看到的那样。
- en: Tip
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**What Kind of Group Should I Use?**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**我应该使用哪种类型的组？**'
- en: How do you decide whether to use a `groupOfNames`, `groupOfUniqueNames`, or
    `organizationalRole`? By default, it is best to use `groupOfNames`, as it is treated
    as the default grouping object class by OpenLDAP. The `organizationalRole` object
    class is intended to be used as a way of defining what a person does within an
    organization. The `groupOfUniqueNames` object class was intended for a different
    use from `groupOfNames`, but implementation-wise, they function identically on
    OpenLDAP.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如何决定是使用 `groupOfNames`、`groupOfUniqueNames` 还是 `organizationalRole`？默认情况下，最好使用
    `groupOfNames`，因为它被 OpenLDAP 视为默认的分组对象类。`organizationalRole` 对象类用于定义一个人在组织中的角色。`groupOfUniqueNames`
    对象类的用途与 `groupOfNames` 不同，但在 OpenLDAP 中，它们的功能是相同的。
- en: The `groupOfUniqueNames` and `groupOfNames` object classes both allow the `owner`
    attribute, which can also be used more than once (to, for example, model cases
    where a group has two owners). An `owner` attribute holds the DN of the record
    that is considered the owner of the group.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupOfUniqueNames` 和 `groupOfNames` 对象类都允许使用 `owner` 属性，并且可以多次使用（例如，建模某个组有两个所有者的情况）。`owner`
    属性保存的是被认为是该组所有者的记录的 DN。'
- en: Note
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a fourth (but experimental) general purpose method for grouping in
    OpenLDAP, called **dynlist**/**dyngroup**. This uses a specific object class,
    the dynamic **groupOfURLs** grouping class, in conjunction with a special directory
    overlay. This method of grouping is expected to reach maturity in OpenLDAP 2.4.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP 中有一种第四种（但实验性的）通用分组方法，叫做 **dynlist**/**dyngroup**。它使用特定的对象类，动态的 **groupOfURLs**
    分组类，并结合特殊的目录覆盖。这种分组方法预计将在 OpenLDAP 2.4 中成熟。
- en: 'In our example group, which is `groupOfUniqueNames`, we specified two `uniqueMember`
    attributes:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例群组 `groupOfUniqueNames` 中，我们指定了两个 `uniqueMember` 属性：
- en: '[PRE28]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Both of these DNs are members of the group. Note that SLAPD does not actively
    check to make sure that these DNs exist, nor does it automatically remove a DN
    from groups when the DN is removed from the directory.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 DN 都是群组的成员。请注意，SLAPD 不会主动检查这些 DN 是否存在，也不会在 DN 从目录中删除时自动将其从群组中移除。
- en: Note
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Integrity Checking**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整性检查**'
- en: SLAPD can be configured to do integrity checking on records using the RefInt
    (Referential Integrity) overlay discussed in Chapter 5\. This overlay can be used
    to make sure that group member DNs stay synchronized with the entries in the directory
    information tree.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: SLAPD 可以通过第五章中讨论的 RefInt（参照完整性）覆盖层来配置执行记录的完整性检查。这个覆盖层可以确保群组成员的 DN 与目录信息树中的条目保持同步。
- en: Thus, directory administrators and directory applications must be careful to
    perform additional verification and cleanup when working with groups. When a DN
    is deleted from the directory, a directory-wide search for attributes that take
    DN values should be performed to make sure that attributes such as `member` and
    `roleOccupant` (and, for that matter, `seeAlso`) do not point to the newly-deleted
    DN.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，目录管理员和目录应用程序在处理群组时必须小心，进行额外的验证和清理。当一个 DN 从目录中删除时，应该进行全目录范围的搜索，查找那些使用 DN 值的属性，以确保像
    `member` 和 `roleOccupant`（以及 `seeAlso`）等属性不会指向新删除的 DN。
- en: The Complete LDIF File
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整的 LDIF 文件
- en: 'Finally , we have finished building our LDIF file. We will save it in a file
    named `basics.ldif`, since it contains the basic elements of our directory. Here
    is what it looks like:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们完成了 LDIF 文件的构建。我们将它保存在一个名为 `basics.ldif` 的文件中，因为它包含了我们目录的基本元素。下面是它的样子：
- en: '[PRE29]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the next section, we will look at the OpenLDAP utilities, and we will use
    these utilities to load our LDIF file into the directory.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍 OpenLDAP 工具，并将使用这些工具将我们的 LDIF 文件加载到目录中。
- en: Using the Utilities to Prepare the Directory
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工具准备目录
- en: So far in this chapter we have looked at the server operations, and created
    an LDIF file representing our initial directory information tree. In the remainder
    of this chapter we are going to look at two groups of tools. In this part we are
    going to look at the OpenLDAP utilities. In the next part we will look at the
    OpenLDAP clients.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中我们已经查看了服务器操作，并创建了一个表示初始目录信息树的 LDIF 文件。在本章的剩余部分，我们将探讨两组工具。在这一部分，我们将介绍
    OpenLDAP 工具。在下一部分，我们将介绍 OpenLDAP 客户端。
- en: Unlike the OpenLDAP clients, the utilities do not use the LDAP protocol to connect
    to a server and perform directory operations. Instead they work on a lower level,
    interacting directly with OpenLDAP directories and data files. The OpenLDAP suite
    includes eight utilities that perform administrative tasks. We will look at these
    tools as we go through the process of creating, loading, and verifying directory
    data.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 与 OpenLDAP 客户端不同，这些工具不使用 LDAP 协议连接到服务器并执行目录操作。相反，它们在更低的层次上工作，直接与 OpenLDAP 目录和数据文件进行交互。OpenLDAP
    套件包括八个用于执行管理任务的工具。我们将在创建、加载和验证目录数据的过程中，逐步了解这些工具。
- en: The aim of this section is to explain the basic use of these utilities. Each
    utility has a handful of command-line flags that can be used to further modify
    the behavior of the utility. We will see some of the more useful flags, but if
    you want detailed information, you should consult the excellent OpenLDAP man pages.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的是解释这些工具的基本使用方法。每个工具都有一些命令行标志，可以用来进一步修改工具的行为。我们将介绍一些常用的标志，但如果需要详细信息，应该查阅优秀的
    OpenLDAP 手册页。
- en: 'In recent versions of OpenLDAP the utilities do not actually exist as stand-alone
    programs. Instead, they are all compiled into the `slapd` program, and symbolic
    links are created to point from the utility name to the `slapd` program. Using
    the `ls` command, we can look at the utilities to see how this is done:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenLDAP 的新版本中，这些工具实际上并不存在作为独立的程序。相反，它们都被编译进了 `slapd` 程序，并且创建了符号链接，将工具名称指向
    `slapd` 程序。使用 `ls` 命令，我们可以查看这些工具，了解它们是如何实现的：
- en: '[PRE30]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is what we get:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们得到的结果：
- en: '[PRE31]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: All eight of the utilities are just symbolic links to the `slapd` program. When
    `slapd` gets executed, it checks to see what program name was used when it was
    executed, and then it acts like that program. For example, when `slapd` is called
    as `slapadd`, it acts as a program for loading data into the directory. If it
    is called as `slaptest`, it acts as a program for verifying the format of and
    directives in the configuration file.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这八个工具都是`slapd`程序的符号链接。当执行`slapd`时，它会检查执行时使用的程序名称，然后按照该程序的行为运行。例如，当`slapd`作为`slapadd`调用时，它会作为一个将数据加载到目录中的程序运行。如果作为`slaptest`调用，它会作为一个用于验证配置文件格式和指令的程序运行。
- en: As we proceed through the description of the utilities we will cover them as
    if they were separate programs because that is how they are treated.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续描述这些工具时，我们将把它们视为独立的程序来讲解，因为它们就是如此被处理的。
- en: Since we created an LDIF file in the last part, we will begin this section by
    looking at the tool that loads the LDIF file into the directory backend.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在上一部分创建了一个LDIF文件，因此本节将首先介绍将LDIF文件加载到目录后端的工具。
- en: slapadd
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: slapadd
- en: The `slapadd` program is used to load directory data, formated as LDIF files,
    directly into OpenLDAP. It is executed from within an operating system shell (for
    example a command prompt or shell script).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`slapadd`程序用于将格式化为LDIF文件的目录数据直接加载到OpenLDAP中。它是在操作系统的Shell中执行的（例如命令提示符或Shell脚本）。'
- en: The `slapadd` program does not use the LDAP protocol to connect to a running
    server. Instead, it works directly with the OpenLDAP backend. For that reason,
    when you run `slapadd` you must first shut down the directory server. Otherwise,
    you may end up with conflicts between the `slapd` server process and the `slapadd`
    process as they both try to exclusively manage the same databases.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`slapadd`程序不会使用LDAP协议连接到正在运行的服务器。相反，它直接与OpenLDAP后端进行交互。因此，当你运行`slapadd`时，必须首先关闭目录服务器。否则，可能会出现`slapd`服务器进程和`slapadd`进程之间的冲突，因为它们都试图独占管理相同的数据库。'
- en: When Should slapadd be Used?
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时应该使用slapadd？
- en: There are many tools for loading records into the directory, including the OpenLDAP
    client `ldapadd` (which connects to the server over the LDAP protocol and performs
    one or more add operations). So, how do we figure out which program to use under
    any particular set of circumstances?
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以将记录加载到目录中，包括OpenLDAP客户端`ldapadd`（它通过LDAP协议连接到服务器并执行一个或多个添加操作）。那么，如何在特定情况下确定使用哪个程序呢？
- en: Well, `slapadd` is intended to be used to load large amounts of directory data,
    generally for the purpose of creating a new directory, or restoring a directory
    from a backup. Because it requires that the directory be taken offline, this utility
    is not generally a good candidate for performing routine updates. The `ldapadd`
    program (discussed in the *Clients* section later in this chapter) is a much better
    candidate for that sort of operation.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 其实，`slapadd`旨在加载大量的目录数据，通常用于创建新目录或从备份恢复目录。由于它要求目录下线，因此这个工具通常不适合用于执行常规更新。`ldapadd`程序（稍后在*客户端*部分中讨论）更适合这种操作。
- en: What Does slapadd Do?
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`slapadd`做什么？'
- en: The `slapadd` utility reads the `slapd.conf` file (and any included files),
    loads the appropriate backend databases, and then reads LDIF data (usually from
    a file). As it reads the data, it verifies that all of the records are correctly
    constructed (that the DNs are in a tree that the server manages, that the records
    use the right attributes for their object classes, that all required fields are
    there, that the record is formatted correctly, and so on), and then it loads the
    records into the appropriate backend.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`slapadd`工具读取`slapd.conf`文件（及任何包含的文件），加载适当的后端数据库，然后读取LDIF数据（通常来自一个文件）。在读取数据时，它验证所有记录是否构造正确（例如，DN是否位于服务器管理的树中，记录是否使用正确的对象类属性，是否包含所有必需字段，记录格式是否正确等），然后将记录加载到适当的后端中。'
- en: Since `slapadd` does not connect over the LDAP protocol, it does not require
    any authentication to the directory. It does, however, require write access to
    the directory database files. So `slapadd` is usually run from the shell of either
    the user that runs the directory (often `ldap` or `slapd`) or from the root account.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`slapadd`不会通过LDAP协议连接，因此不需要对目录进行身份验证。不过，它确实需要对目录数据库文件的写访问权限。因此，`slapadd`通常由运行目录服务的用户（通常是`ldap`或`slapd`）或根账户从Shell中运行。
- en: Loading the LDIF File
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载LDIF文件
- en: 'In the previous part of this chapter we created an LDIF file containing a handful
    of records for our directory tree. Now we will load this LDIF file into our directory.
    This will take four steps:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面部分，我们创建了一个包含我们目录树中少量记录的 LDIF 文件。现在，我们将把这个 LDIF 文件加载到目录中。这将包括四个步骤：
- en: Stop the `slapd` server
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止 `slapd` 服务器
- en: Test the LDIF file with `slapadd`
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `slapadd` 测试 LDIF 文件
- en: Load the directory with `slapadd`
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `slapadd` 加载目录
- en: Restart the `slapd` server
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重启 `slapd` 服务器
- en: Stopping the Server
  id: totrans-374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 停止服务器
- en: 'We covered the process of starting and stopping the server at the end of Chapter
    2\. To summarize, though, we can stop a version installed from the Ubuntu package
    using the `invoke-rc.d` command:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 2 章的结尾已经讲解了启动和停止服务器的过程。简而言之，我们可以使用 `invoke-rc.d` 命令停止通过 Ubuntu 软件包安装的版本：
- en: '[PRE32]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With the version compiled from source (see [Appendix A](apa.html "Appendix A. Building
    OpenLDAP from Source")), this can be done by finding the `slapd` process ID and
    killing the process (or using the `killall` program):'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从源代码编译的版本（请参阅[附录 A](apa.html "附录 A. 从源代码构建 OpenLDAP")），可以通过查找 `slapd` 进程 ID
    并终止该进程（或使用 `killall` 程序）来实现：
- en: '[PRE33]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, we need to make sure that the LDIF file we created in the last part is
    correctly formatted.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保我们在上一部分创建的 LDIF 文件格式正确。
- en: Running ldapadd in Test Mode
  id: totrans-380
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在测试模式下运行 ldapadd
- en: Running in test mode before doing the actual load can greatly reduce the amount
    of time it takes to load a new LDIF file because it will help you catch LDIF errors
    before things get written to the directory. Normally `slapadd` adds records one
    at a time as it reads them. So if there are three records in a file, the first
    record will be added to the directory before the second or third records are read.
    If there is an error in a record later in the file, then the directory will be
    partially loaded, and you will either have to creatively alter the LDIF file or
    destroy the database and start again.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际加载之前运行测试模式可以大大减少加载新的 LDIF 文件所需的时间，因为它能帮助您在记录写入目录之前捕捉到 LDIF 错误。通常，`slapadd`
    会一条一条地添加记录。所以如果文件中有三条记录，第一条记录会在读取第二条或第三条记录之前被添加到目录中。如果文件中的后续记录有错误，那么目录将会部分加载，您将不得不创造性地修改
    LDIF 文件，或者销毁数据库并重新开始。
- en: Using test mode, we can make sure that the LDIF file does not have any errors
    before we start loading records into the directory. This should just eliminate
    cases where an LDIF file is only partially imported because of bad records.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 使用测试模式，我们可以在开始将记录加载到目录之前确保 LDIF 文件没有任何错误。这应该可以消除因为错误记录导致 LDIF 文件只部分导入的情况。
- en: 'We can use the `slapadd` program to do this before we try to load the data
    into the directory:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `slapadd` 程序在将数据加载到目录之前进行此操作：
- en: '[PRE34]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This command uses five flags:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令使用五个标志：
- en: '`-v` flag: This puts the program into "verbose" mode, where it will print out
    extra information about what is happening (and, if the process fails, what led
    to the failure). Usually it is a good idea to run `slapadd` in verbose mode, especially
    when loading an untested LDIF file.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v` 标志：此标志将程序设置为“详细”模式，在该模式下，程序会打印出额外的信息，说明正在发生的事情（如果过程失败，还会显示导致失败的原因）。通常，建议在加载未经测试的
    LDIF 文件时以详细模式运行 `slapadd`。'
- en: '`-u` flag: This tells `slapadd` to run in test (or *dry-run*) mode. When this
    is enabled, `slapadd` will evaluate the file as if it were going to load the file
    into the directory, but it won''t actually put any records in the directory.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-u` 标志：这告诉 `slapadd` 以测试（或 *干运行*）模式运行。当启用此模式时，`slapadd` 会评估文件，就像它要将文件加载到目录中一样，但实际上不会将任何记录放入目录。'
- en: '`-c` flag: This tells `slapadd` to keep processing the file even if it hits
    a bad record. Using this flag, we can run through the file once and get a list
    of all of the records that are not correctly formatted.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c` 标志：这告诉 `slapadd` 即使遇到错误的记录也继续处理文件。使用此标志，我们可以先运行一遍文件并获取所有格式不正确的记录列表。'
- en: '`-f` flag: This flag, which takes as an argument the path to the server''s
    configuration file, specifies which configuration file should be used. In most
    cases you can omit this, and `slapadd` will just look in the default place (usually
    `/etc/ldap/slapd.conf`).'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f` 标志：此标志接受服务器配置文件路径作为参数，指定应该使用哪个配置文件。在大多数情况下，您可以省略此标志，`slapadd` 会默认查看配置文件的位置（通常是
    `/etc/ldap/slapd.conf`）。'
- en: '`-l` flag: This points to the LDIF file we want to load. In this case we are
    loading the `basics.ldif` file, which is located in the system''s `/tmp` directory.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-l` 标志：此标志指向我们要加载的 LDIF 文件。在本例中，我们正在加载位于系统 `/tmp` 目录中的 `basics.ldif` 文件。'
- en: 'In cases where there is an error in the LDIF file, `slapadd` will print out
    some helpful information. For example, if we try to load an obviously broken file
    that looks like this:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果LDIF文件中存在错误，`slapadd`会打印出一些有用的信息。例如，如果我们尝试加载一个明显损坏的文件，它看起来像这样：
- en: '[PRE35]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this file the broken lines are highlighted. When we run `slapadd`, we will
    get an error:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，损坏的行已被高亮显示。当我们运行`slapadd`时，我们将得到一个错误：
- en: '[PRE36]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, `slapadd` tested our first record, `dc=example,dc=com`, without problems,
    but then encountered a line that did not begin with a DN (on line 11). It skipped
    that record. On line 18 it encountered another error: the `ferble` attribute is
    not defined by any of the object classes in the record.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`slapadd`成功测试了我们的第一个记录`dc=example,dc=com`，没有问题，但在第11行遇到了一行没有以DN开头的内容，跳过了那个记录。在第18行，它遇到了另一个错误：`ferble`属性在记录中的任何对象类中都没有定义。
- en: 'When run successfully against the LDIF file we created earlier in this chapter,
    the output looks like this:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当对本章早些时候创建的LDIF文件运行成功时，输出如下：
- en: '[PRE37]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'No errors. We are ready to proceed to the third step: importing the records
    into the directory.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 没有错误。我们已经准备好进行第三步：将记录导入目录。
- en: Importing the Records Using slapadd
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 slapadd 导入记录
- en: To do the actual import of the records into the directory, we use the `slapadd`
    command with a subset of the flags used in the previous section. We omit the `-u`
    flag (for testing) and the `-c` flag (so that it doesn't continue if it encounters
    a bad record).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 要将记录实际导入目录，我们使用`slapadd`命令，并使用上一节中使用的标志的子集。我们省略了`-u`标志（用于测试）和`-c`标志（以便遇到错误记录时不继续）。
- en: Tip
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Using the -q flag**'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 -q 标志**'
- en: To load the directory faster, you can add the `-q` flag, which turns off some
    of the time-consuming checks `slapadd` performs on the data. But before using
    this flag, make sure you test the LDIF data first (using the method just described).
    Otherwise you might end up with an unusable directory.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更快地加载目录，你可以添加`-q`标志，关闭`slapadd`在处理数据时执行的一些耗时检查。但是在使用此标志之前，请确保先测试LDIF数据（使用刚才描述的方法）。否则，你可能会遇到无法使用的目录。
- en: 'Now, the command looks like this:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，命令看起来是这样的：
- en: '[PRE38]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And, this is what we get as output:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们得到的输出：
- en: '[PRE39]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that the output is just slightly different this time; at the end of each
    line, there is an ID number enclosed in parentheses. This ID number makes up part
    of the record's `entryCSN` attribute, which is used internally to monitor the
    record.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次的输出只是稍有不同；每行的末尾都有一个括号括起来的ID号。这个ID号是记录的`entryCSN`属性的一部分，内部用于监控记录。
- en: Note
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As with many LDAP servers, OpenLDAP attaches special **operational attributes**
    to records. In these attributes, OpenLDAP stores directory-centric information
    about the record. We will talk about these more when we discuss the `slapcat`
    utility.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多LDAP服务器一样，OpenLDAP 会向记录附加特殊的**操作属性**。在这些属性中，OpenLDAP 存储有关记录的目录中心信息。我们稍后将在讨论`slapcat`工具时详细说明这些内容。
- en: We have just populated our directory with the eight records we created earlier
    in the chapter. We are now ready to start the directory.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚用本章前面创建的八个记录填充了我们的目录。现在我们准备好启动目录了。
- en: Restarting the Directory
  id: totrans-412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重启目录
- en: 'In Chapter 2 we discussed starting and stopping the directory. This can be
    done with the init script:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们讨论了启动和停止目录。这可以通过初始化脚本完成：
- en: '[PRE40]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Or, if you installed according to [Appendix A](apa.html "Appendix A. Building
    OpenLDAP from Source"), `slapd` can be run directly:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你按照[附录 A](apa.html "附录 A. 从源代码构建 OpenLDAP")安装，`slapd`可以直接运行：
- en: '[PRE41]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If Something Went Wrong...
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如果出了问题……
- en: 'It sometimes happens that midway through a `slapadd`, the program encounters
    an error—either in the LDIF file itself, or from some external consideration—and
    aborts the directory import part way through. In these cases you may need to start
    over. But merely re-running the `slapadd` operation will give errors like this
    (the error may vary depending on the backend you are using):'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在执行`slapadd`的过程中，程序会遇到错误——无论是LDIF文件本身的问题，还是外部因素的影响——并且会在导入目录的过程中中止。在这种情况下，你可能需要重新开始。但是，仅仅重新运行`slapadd`操作会出现像这样的错误（具体的错误信息可能根据你使用的后端不同而有所不同）：
- en: '[PRE42]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: What is going on here?
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？
- en: What has happened is that some of the entries from the `basics.ldif` file have
    already been imported into the directory, but perhaps not all of them. There are
    various ways to attempt to work around this. You can try to prune the LDIF file
    down to just the records that haven't been added already. You can try to run the
    `slapadd` program in continuation mode (with the `-c` flag) and hope that all
    of the remaining records are added correctly.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的情况是，`basics.ldif` 文件中的一些条目已经导入到目录中，但可能并不是全部。你可以尝试各种方法来解决这个问题。你可以尝试将 LDIF
    文件精简，只保留那些尚未添加的记录。你也可以尝试以继续模式（使用 `-c` 标志）运行 `slapadd` 程序，并希望所有剩余的记录都能正确添加。
- en: 'But you may find that the best way of dealing with these cases is to simply
    destroy and rebuild the directory. While this sounds like a rather extreme measure,
    it has one distinct advantage over other methods: it avoids the problem of inconsistent
    records that can be caused with failed `slapadd` commands. Thus, it is often the
    best way of recovering from failed directory imports.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可能会发现，处理这些情况的最佳方法是简单地销毁并重建目录。虽然这听起来是一种极端的措施，但与其他方法相比，它有一个明显的优势：它避免了由于 `slapadd`
    命令失败而导致的不一致记录的问题。因此，它通常是从失败的目录导入中恢复的最佳方法。
- en: Tip
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Errors in the index files can also be induced by `slapadd` failures. If you
    decide not to destroy and recreate your directory after a failed `slapadd`, make
    sure you run the `slapindex` utility (covered later in this chapter) after loading
    new records to the directory.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 索引文件中的错误也可能是由 `slapadd` 失败引起的。如果你决定在 `slapadd` 失败后不销毁并重建目录，确保在向目录加载新记录后运行 `slapindex`
    工具（本章稍后会介绍）。
- en: Destroying and Recreating the Directory Files
  id: totrans-425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 销毁并重建目录文件
- en: In most of the OpenLDAP backends that can be loaded with `slapadd`, the backend
    stores data somewhere on the file system or in a relational database. After a
    failed `slapadd` you may find that the best way to recover is to destroy all of
    the data in the underlying backend, and then start over.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数可以通过 `slapadd` 加载的 OpenLDAP 后端中，后端将数据存储在文件系统中的某个位置或关系型数据库中。在 `slapadd` 失败后，你可能会发现恢复的最佳方法是销毁底层后端中的所有数据，然后重新开始。
- en: Currently, we are using the `hdb` backend (see Chapter 2). The method used here
    will apply equally well to other BerkeleyDB backends (`bdb` and `ldbm` in `bdb`
    mode), and can be easily adapted to cover the (deprecated) `ldbm` with `gdbm`
    backend.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在使用 `hdb` 后端（见第二章）。这里使用的方法同样适用于其他 BerkeleyDB 后端（在 `bdb` 模式下的 `bdb` 和 `ldbm`），并且可以轻松适配（已弃用的）`ldbm`
    和 `gdbm` 后端。
- en: For other sorts of backends, such as those that use relational databases like
    PostgreSQL, or custom backends like `back-perl`, you will need to examine the
    documentation on those backends to determine the best way of clearing the records
    from the directory.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他类型的后端，例如使用关系型数据库（如 PostgreSQL）或自定义后端（如 `back-perl`），你需要查看这些后端的文档，以确定清除目录记录的最佳方法。
- en: For the `hdb` and `bdb` backends, the directory data files are stored on the
    file system. In Ubuntu, these are located at `/var/lib/ldap`. If you followed
    the directions in [Appendix A](apa.html "Appendix A. Building OpenLDAP from Source"),
    the database files are located at `/usr/local/var/openldap-data/`.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `hdb` 和 `bdb` 后端，目录数据文件存储在文件系统中。在 Ubuntu 中，这些文件位于 `/var/lib/ldap`。如果你按照 [附录
    A](apa.html "附录 A. 从源代码构建 OpenLDAP") 的指示操作，数据库文件位于 `/usr/local/var/openldap-data/`。
- en: 'Here''s what the contents of the `/var/lib/ldap` directory look like:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `/var/lib/ldap` 目录的内容：
- en: '[PRE43]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here you can see all of the directory database files (which start with `__db.`),
    the directory index files (which end with `.bdb`), and the BerkeleyDB transaction
    logs (which begin with `log.`). There are a few other files in this directory,
    such as `alock` and `DB_CONFIG`, that we don''t need to delete. To delete the
    files, we use `rm` with a list of expressions that match only the files we want
    to delete:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到所有的目录数据库文件（以 `__db.` 开头）、目录索引文件（以 `.bdb` 结尾）和 BerkeleyDB 事务日志（以 `log.`
    开头）。该目录中还有一些其他文件，例如 `alock` 和 `DB_CONFIG`，我们不需要删除它们。要删除文件，我们使用 `rm` 命令，并配合一个表达式列表，仅匹配我们想要删除的文件：
- en: '[PRE44]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This removes just the files we don''t want. Now the directory should contain
    only a couple of files:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就只删除了我们不需要的文件。现在目录中应该只包含几个文件：
- en: '[PRE45]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'That''s all it takes to destroy the database. Now we can re-create the directory
    by loading the (corrected, if necessary) LDIF file with the `slapadd` command:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是销毁数据库所需要做的一切。现在，我们可以通过使用 `slapadd` 命令加载（如果需要，已修正的）LDIF 文件来重新创建目录：
- en: '[PRE46]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And this message is returned:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 并且返回以下消息：
- en: '[PRE47]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: That is all there is to destroying and recreating a directory.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是销毁并重建目录的全部内容。
- en: slapindex
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: slapindex
- en: The next utility that we will examine is `slapindex`. This utility manages the
    index files for OpenLDAP backends that use indexes (such as `hdb`, `bdb`, and
    the deprecated `ldbm`).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将查看的工具是`slapindex`。这个工具管理使用索引的OpenLDAP后端的索引文件（例如`hdb`、`bdb`和已废弃的`ldbm`）。
- en: OpenLDAP maintains a set of index files to expedite searching for records. These
    are stored outside of the main directory database, and as records are added, modified,
    and removed from the directory, the `slapd` server modifies the index files accordingly.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP维护一组索引文件，以加速搜索记录。这些文件存储在主目录数据库之外，随着记录的添加、修改和删除，`slapd`服务器会相应地修改索引文件。
- en: But in certain circumstances, the `slapd` server may not have sufficient information
    to know about changes it needs to make to the index files and, in those cases,
    the indexes will need to be rebuilt manually.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 但在某些情况下，`slapd`服务器可能没有足够的信息来了解需要对索引文件进行的更改，在这些情况下，索引需要手动重建。
- en: Note
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Like `slapadd`, `slapindex` should not be run while the server is running. Before
    running `slapindex`, you should stop `slapd`.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 像`slapadd`一样，在服务器运行时不应运行`slapindex`。在运行`slapindex`之前，应停止`slapd`。
- en: 'There are three common cases that require use of the `slapindex` command:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种常见情况需要使用`slapindex`命令：
- en: When a utility, usually `slapadd`, is used to add records to an *existing* database.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用工具（通常是`slapadd`）向*现有*数据库添加记录时。
- en: When the indexing directives in `slapd.conf` are changed, or new indexes are
    added (see Chapter 2 and the *Performance* *Tuning* section of Chapter 5).
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`slapd.conf`中的索引指令发生更改或添加了新的索引时（参见第2章和第5章的*性能* *调优*部分）。
- en: On other (rare) occasions, external conditions or failed `slapadd` commands
    may get the directory database and the directory indexes out of sync. The main
    symptom of this synchronization error is that searches using `ldapsearch` will
    fail to return records that are known to be in the directory.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其他（罕见的）情况下，外部条件或失败的`slapadd`命令可能会导致目录数据库和目录索引不同步。这种同步错误的主要症状是使用`ldapsearch`进行搜索时，无法返回已知存在于目录中的记录。
- en: 'In these three cases, `slapindex` should be run:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三种情况下，应该运行`slapindex`：
- en: '[PRE48]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will rebuild all of the indexes for the first database defined in `slapd.conf`
    (we only have one database defined).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重建`slapd.conf`中定义的第一个数据库的所有索引（我们只定义了一个数据库）。
- en: The `-q` flag instructs slapindex to perform some additional checking operations,
    which will greatly expedite the process of re-indexing. Skipping such checks is
    generally safe with the `slapindex` utility, though it should only be done with
    great care when using `slapadd`.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`-q`标志指示slapindex执行一些额外的检查操作，这将大大加速重新索引的过程。跳过这些检查通常在使用`slapindex`时是安全的，但在使用`slapadd`时应谨慎操作。'
- en: The `-f` flag, which takes the path to a configuration file, specifies the `slapd`
    configuration file. If this flag is omitted (as we have done), `slapindex` will
    look in the default location for the `slapd.conf` file.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f`标志用于指定配置文件的路径，它指定了`slapd`配置文件。如果省略此标志（如我们所做的那样），`slapindex`将查找默认位置中的`slapd.conf`文件。'
- en: If you want to monitor the progress of `slapindex`, you can use the `-v` flag
    to turn on verbose output.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想监控`slapindex`的进度，可以使用`-v`标志启用详细输出。
- en: slapcat
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: slapcat
- en: The `slapcat` program dumps the entire contents of a directory into an LDIF
    file. It is a convenient tool for creating a backup of the directory, and can
    also be useful for examining the data is in the directory.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`slapcat`程序将目录的所有内容转储到LDIF文件中。它是创建目录备份的方便工具，也可以用于检查目录中的数据。'
- en: Of course, there is a similar client application, `ldapsearch`, which can also
    dump the entire contents of the directory. How do you know when to use each? Since
    `ldapsearch` uses the LDAP protocol to contact the server, bind, and then run
    LDAP search operations, it incurs more overhead. `slapcat`, on the other hand,
    works directly with the backend. `ldapsearch` is limited by time and size limits,
    set both in the client configuration file, `ldap.conf`, and in the server's configuration
    in `slapd.conf` (see Chapter 2). The `ldapsearch` command is also limited by ACLs,
    while no ACLs are applied to `slapcat`.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也有类似的客户端应用程序 `ldapsearch`，它也可以导出整个目录内容。那么你如何判断何时使用每个工具呢？由于 `ldapsearch` 使用
    LDAP 协议来联系服务器、绑定并执行 LDAP 搜索操作，它的开销更大。另一方面，`slapcat` 直接与后端进行交互。`ldapsearch` 受时间和大小限制，这些限制在客户端配置文件
    `ldap.conf` 和服务器的配置文件 `slapd.conf` 中都有设置（请参见第 2 章）。`ldapsearch` 命令还受到 ACL 的限制，而
    `slapcat` 不受 ACL 的影响。
- en: Clearly then, for operations such as backing up the directory, `slapcat` ought
    to be used rather than `ldapsearch`.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，对于像备份目录这样的操作，应该使用 `slapcat` 而不是 `ldapsearch`。
- en: As of version 2.3 of OpenLDAP, if you are using the `hdb` or `bdb` backends,
    you can safely run `slapcat` while `slapd` is running; there is no need to shutdown
    the directory server in order to make a backup copy.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 从 OpenLDAP 2.3 版本开始，如果你使用的是 `hdb` 或 `bdb` 后端，你可以在 `slapd` 运行时安全地运行 `slapcat`；不需要关闭目录服务器就能备份副本。
- en: Note
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The man page for `slapcat` in OpenLDAP incorrectly indicates that it is unsafe
    to run `slapcat` while the directory server is running. This is simply an artifact
    of the earlier versions of OpenLDAP (2.2 and earlier), in which `slapcat` could
    not be run while `slapd` was running. Note that it is still unsafe to run `slapcat`
    against an `ldbm` backend while `slapd` is running.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP 中的 `slapcat` 手册页错误地指出，在目录服务器运行时运行 `slapcat` 是不安全的。这只是早期版本的 OpenLDAP（2.2
    及更早版本）的遗留问题，在那些版本中，`slapcat` 不能在 `slapd` 运行时执行。需要注意的是，在 `slapd` 运行时，仍然不安全对 `ldbm`
    后端执行 `slapcat`。
- en: When we covered `slapadd` earlier in this chapter, we used that utility to load
    records in `basics.ldif` into the directory. Now we can use `slapcat` to view
    those records.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章之前介绍 `slapadd` 时，我们使用该工具将 `basics.ldif` 中的记录加载到目录中。现在我们可以使用 `slapcat`
    查看这些记录。
- en: '[PRE49]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `-l` flag, which takes a path for an argument, indicates what file the output
    should be written to. In this case it is writing to the file `basics-out.ldif`.
    If `-l` is omitted, then the LDIF data will be sent to standard output, which
    will usually be printed straight to your screen.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`-l` 标志需要一个路径作为参数，指示输出应该写入到哪个文件。在本例中，它将写入文件 `basics-out.ldif`。如果省略 `-l`，则 LDIF
    数据将被发送到标准输出，通常直接打印到屏幕上。'
- en: 'As with the other utilities, the `-f` flag can be used to specify the path
    to the SLAPD configuration file. The `-a` flag, which takes an LDAP filter, can
    be used to specify a pattern that records must match before they are dumped to
    output. You can use this flag to dump just a subtree. For example, we could dump
    only records in the `Users` OU with this command:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他工具一样，`-f` 标志可用于指定 SLAPD 配置文件的路径。`-a` 标志需要一个 LDAP 过滤器，可以用来指定记录必须匹配的模式，才能被导出到输出中。你可以使用此标志仅导出一个子树。例如，我们可以使用以下命令仅导出
    `Users` 组织单位中的记录：
- en: '[PRE50]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This would return complete records for only the following three DNs:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅返回以下三个 DN 的完整记录：
- en: '`ou=Users,dc=example,dc=com`'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ou=Users,dc=example,dc=com`'
- en: '`uid=matt,ou=Users,dc=example,dc=com`'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uid=matt,ou=Users,dc=example,dc=com`'
- en: '`uid=barbara,ou=Users,dc=example,dc=com`'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uid=barbara,ou=Users,dc=example,dc=com`'
- en: Operational Attributes
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作属性
- en: 'Let''s take a closer look at the output for just the record of the base DN:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细查看仅关于基础 DN 记录的输出：
- en: '[PRE51]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The highlighted attributes should look unfamiliar, as they did not exist in
    the original LDIF file that we created. These are internal **operational attributes**
    that OpenLDAP automatically maintains.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮显示的属性应该看起来不熟悉，因为它们在我们创建的原始 LDIF 文件中并不存在。这些是 OpenLDAP 自动维护的内部 **操作属性**。
- en: Different operational attributes play different roles in OpenLDAP, and these
    attributes may be useful for directory managers and LDAP-aware applications.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的操作属性在 OpenLDAP 中扮演不同的角色，这些属性对目录管理员和支持 LDAP 的应用程序可能很有用。
- en: 'For example, the `creatorsName`, `modifiersName`, `createTimestamp`, and `modifyTimestamp`
    fields often come in useful. OpenLDAP automatically retains the following record-level
    information:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`creatorsName`、`modifiersName`、`createTimestamp` 和 `modifyTimestamp` 字段通常非常有用。OpenLDAP
    会自动保留以下记录级别的信息：
- en: When and by whom each record was created.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每条记录的创建时间和创建人。
- en: When and by whom each record was last modified.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每条记录的最后修改时间和修改人。
- en: The `entryUUID` attribute provides a **Universally Unique Identifier (UUID)**
    for a record, which serves as an identifier that is more stable than DN (which
    can change), and is supposed to be, according to the specification in RFC 4122
    ([http://rfc-editor.org/rfc/rfc4122.txt](http://rfc-editor.org/rfc/rfc4122.txt)),
    "an identifier unique across both space and time, with respect to the space of
    all UUIDs." See the `entryUUID` RFC at [http://rfc-editor.org/rfc/rfc4530.txt](http://rfc-editor.org/rfc/rfc4530.txt).
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`entryUUID` 属性为记录提供了 **全局唯一标识符（UUID）**，该标识符作为比 DN 更稳定的标识符（DN 可能会变化），并且根据 RFC
    4122 中的规范（[http://rfc-editor.org/rfc/rfc4122.txt](http://rfc-editor.org/rfc/rfc4122.txt)）应当是“在所有
    UUID 空间内，跨越空间和时间的唯一标识符”。请参阅 `entryUUID` 的 RFC [http://rfc-editor.org/rfc/rfc4530.txt](http://rfc-editor.org/rfc/rfc4530.txt)。'
- en: The `entryCSN` (**Change Sequence Number**) attribute is used by the SyncRepl
    replication provider to determine what records need to be synchronized between
    LDAP servers. We will see this in more detail in Chapter 7.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '`entryCSN` (**变更序列号**) 属性由 SyncRepl 复制提供程序使用，用于确定需要在 LDAP 服务器之间同步的记录。我们将在第
    7 章详细讨论这一点。'
- en: 'Finally, the attribute `structuralObjectClass` is added. This attribute specifies
    which of the object classes is to be treated as the structural object class. Recall
    that when we created our records for Matt and Barbara, each record had three object
    classes: `person`, `organizationalPerson`, and `inetOrgPerson`. All three are
    structural object classes, and all three are related (`inetOrgPerson` is a child
    of `organizationalPerson`, which in turn is a child of `person`). But each record
    can have only one structural object class. As I noted above, the one farthest
    down the tree becomes the structural object class, and the others are treated,
    essentially, as abstract object classes. We can see this if we use `slapcat` to
    dump Barbara''s record:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加了 `structuralObjectClass` 属性。该属性指定了哪个对象类应作为结构对象类。回想一下，当我们为 Matt 和 Barbara
    创建记录时，每个记录有三个对象类：`person`、`organizationalPerson` 和 `inetOrgPerson`。这三个都是结构对象类，并且它们之间有关联（`inetOrgPerson`
    是 `organizationalPerson` 的子类，`organizationalPerson` 又是 `person` 的子类）。但每条记录只能有一个结构对象类。如上所述，树结构中最深的一个成为结构对象类，其他的则被视为抽象对象类。如果我们使用
    `slapcat` 导出 Barbara 的记录，就可以看到这一点：
- en: '[PRE52]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that the `structuralObjectClass` attribute has the value `inetOrgPerson`.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`structuralObjectClass` 属性的值为 `inetOrgPerson`。
- en: At this point we've examined the `slapcat` tool, as well as the `slapindex`
    and `slapadd` tools. These three are the most often used utilities. But there
    are a few others that can come in handy in certain circumstances. So next, we
    will look at `slapacl`.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经研究了 `slapcat` 工具，以及 `slapindex` 和 `slapadd` 工具。这三者是最常用的工具。但在某些情况下，还有一些其他工具也可能非常有用。接下来，我们将看一下
    `slapacl`。
- en: slapacl
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: slapacl
- en: Writing ACLs can be frustrating and difficult to test. In order to ease the
    process of testing the efficacy of ACLs in the `slapd.conf` file, the OpenLDAP
    suite includes a tool for testing ACLs directly. We will make greater use of this
    tool when we test ACLs in Chapter 4, but we will see an introduction to the utility
    here.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 ACL（访问控制列表）可能会令人沮丧且难以测试。为了简化在 `slapd.conf` 文件中测试 ACL 效果的过程，OpenLDAP 套件包括一个用于直接测试
    ACL 的工具。我们将在第 4 章测试 ACL 时更多地使用这个工具，但在这里我们将先介绍该工具。
- en: 'In Chapter 2, we added the following ACL to `slapd.conf`:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章中，我们向 `slapd.conf` 添加了以下 ACL：
- en: '[PRE53]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This ACL specifies that for any given record in the directory, if it has `userPassword`,
    the following rules should be applied to requests for access to that attribute:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 ACL 指定了对于目录中的任何给定记录，如果该记录具有 `userPassword`，则应对访问该属性的请求应用以下规则：
- en: The `anonymou s` user should be able to authenticate using `userPassword`.
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anonymous` 用户应该能够使用 `userPassword` 进行身份验证。'
- en: It should allow a DN the permissions to modify (and read) its own password.
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该允许 DN 修改（和读取）自己的密码。
- en: It should deny all other DNs all access to this record's `userPassword`.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该拒绝所有其他 DN 访问该记录的 `userPassword`。
- en: 'That means that `uid=matt,ou=Users,dc=example,dc=com` should not be able to
    write a new `userPassword` value for `uid=barbara,ou=Users,dc=example,dc=com`.
    We can use the `slapacl` utility to test this:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `uid=matt,ou=Users,dc=example,dc=com` 不应能够为 `uid=barbara,ou=Users,dc=example,dc=com`
    写入新的 `userPassword` 值。我们可以使用 `slapacl` 工具来测试这一点：
- en: '[PRE54]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This command might look daunting at first, but it is actually very simple.
    Let''s look at the arguments in sequence:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令一开始看起来可能很复杂，但实际上非常简单。我们按顺序来看一下这些参数：
- en: The `-v` flag tuns on verbose output.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v`标志打开详细输出。'
- en: 'The `-D` flag is used to tell `slapacl` which DN is trying to access the directory.
    In this case, we said: `-D "uid=matt,ou=Users,dc=example,dc=com"`. That is, `slapacl`
    is testing to see if the DN for Matt can get access.'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-D`标志用于告诉`slapacl`哪个DN正在尝试访问目录。在这种情况下，我们设置了：`-D "uid=matt,ou=Users,dc=example,dc=com"`。也就是说，`slapacl`正在测试Matt的DN是否可以访问。'
- en: 'The `-b` flag indicates which record we want the given DN to try to access.
    In this case it is Barbara''s DN, since we want to test if Matt can write Barbara''s
    password: `-b "uid=barbara,ou=Users,dc=example,dc=com"`.'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-b`标志指示我们希望给定的DN尝试访问哪个记录。在这种情况下，它是Barbara的DN，因为我们想测试Matt是否能写Barbara的密码：`-b
    "uid=barbara,ou=Users,dc=example,dc=com"`。'
- en: Finally, the last argument specifies what attribute we want to access, and what
    sort of privilege we are requesting. In this case, we want the `userPassword`
    attribute, and we want to see if Matt has `write` access to it (`"userPassword/write"`).
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，最后一个参数指定了我们希望访问的属性，以及我们请求的权限类型。在这种情况下，我们想要访问`userPassword`属性，并且我们想查看Matt是否对其具有`write`权限（`"userPassword/write"`）。
- en: 'So, in the end, we are testing to see if Matt''s DN can write a new `userPassword`
    for Barbara''s record. Here is the result of the `slapacl` command:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终我们是在测试Matt的DN是否能够为Barbara的记录写入新的`userPassword`。以下是`slapacl`命令的结果：
- en: '[PRE55]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: That's the result we would expect. Because of this ACL, Matt cannot write to
    Barbara's `userPassword` attribute.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们预期的结果。由于这个ACL，Matt不能写入Barbara的`userPassword`属性。
- en: slapauth
  id: totrans-505
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: slapauth
- en: 'The `slapauth` tool is used to test SASL authentication to the directory. When
    an application attempts to bind using SASL, instead of specifying a complete DN
    (like `uid=matt,ou=Users,dc=example,dc=com`), the application passes in a user
    ID (`u: matt`) along with a few other bits of information, such as a realm identifier
    and an authentication mechanism.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**`slapauth`**工具用于测试SASL身份验证到目录。当一个应用程序尝试使用SASL进行绑定时，它并不指定一个完整的DN（例如`uid=matt,ou=Users,dc=example,dc=com`），而是传递一个用户ID（`u:
    matt`）以及其他一些信息，如领域标识符和认证机制。'
- en: We will cover SASL authentication in Chapter 4\. If you do not already have
    experience with SASL you may want to read on, and come back to this section after
    reading Chapter 4.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第4章中讲解SASL身份验证。如果你还没有SASL的经验，建议先阅读下文，并在阅读完第4章后再回到这一节。
- en: OpenLDAP can then take that information and use a regular expression to guess
    what DN that user belongs to. But it can be difficult to figure out what the regular
    expressions will look like. The slapauth tool is useful in testing what one particular
    SASL request will look like when OpenLDAP receives it.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP可以利用这些信息，并使用正则表达式猜测用户所属的DN。但理解正则表达式的具体形式可能比较困难。`slapauth`工具在测试特定的SASL请求在OpenLDAP接收到时的表现时非常有用。
- en: 'For example, we could add the following SASL configuration directives to our
    `slapd.conf` file:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将以下SASL配置指令添加到我们的`slapd.conf`文件中：
- en: '[PRE56]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The regular expression in `authz-regexp` should convert from a SASL authzID
    format to an LDAP DN:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '`authz-regexp`中的正则表达式应该将SASL authzID格式转换为LDAP DN：'
- en: '[PRE57]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The first parameter, `-U matt`, sends a test request with the SASL authcID
    of `matt`. The `-X "u: matt"` parameter sends a test request with the authzID
    `u: matt`. These should then output a correctly formatted DN, according the the
    regular expression in `authz-regexp`.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个参数`-U matt`发送一个包含SASL authcID为`matt`的测试请求。`-X "u: matt"`参数则发送一个包含authzID为`u:
    matt`的测试请求。根据`authz-regexp`中的正则表达式，它们应该输出一个正确格式的DN。'
- en: We will use `slapauth` more in Chapter 4 when we set up SASL authentication.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第4章中更多地使用`slapauth`，当我们设置SASL身份验证时。
- en: slapdn
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: slapdn
- en: The **`slapdn`** tool is used to test whether a given DN is valid for this directory
    server. Specifically, it tests a DN against the defined schemas to make sure that
    the DN is valid.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '**`slapdn`**工具用于测试给定的DN是否对这个目录服务器有效。具体来说，它将DN与已定义的模式进行匹配，确保DN是有效的。'
- en: 'Here are a few examples of `slapdn` in action:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些`slapdn`实际应用的示例：
- en: '[PRE58]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In these two examples, the DNs checked out. `slapdn` tested the DNs, and then
    printed out the normalized version (all lowercase, extra spaces removed) and the
    pretty (originally formated) version.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个示例中，DN是有效的。`slapdn`测试了这些DN，然后打印出标准化版本（所有小写，去除多余的空格）和原始格式版本。
- en: 'Here''s an example of a failure:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个失败的示例：
- en: '[PRE59]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In this case no schema was found that had the attribute `fakeAttr`. Here''s
    another failed case:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，没有找到包含 `fakeAttr` 属性的模式。这里是另一个失败的例子：
- en: '[PRE60]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: While `documentSeries` is defined in a schema it is an object class, not an
    attribute, and object class names cannot be used in constructing DNs.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `documentSeries` 在模式中被定义为对象类，但它是一个对象类，而不是属性，且对象类名称不能用于构造 DN。
- en: The usefulness of the `slapdn` program is limited to only rare cases where you
    need to test a DN against a directory without being able to look at the `slapd.conf`
    file to find out what schemas are loaded (or, alternately, search the schemas
    using the `ldapsearch` program).
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`slapdn` 程序的实用性仅限于那些你需要在不查看 `slapd.conf` 文件来确定加载了哪些模式的情况下，测试 DN 与目录的匹配的罕见情况（或者，交替使用
    `ldapsearch` 程序搜索模式）。'
- en: slappasswd
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: slappasswd
- en: The `slappasswd` utility is a tool for encrypting passwords according to schemes
    supported by OpenLDAP, such as the one described in RFC 2307 ([http://rfc-editor.org/rfc/rfc2307.txt](http://rfc-editor.org/rfc/rfc2307.txt)).
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '`slappasswd` 实用工具是一个根据 OpenLDAP 支持的模式加密密码的工具，例如 RFC 2307 中描述的模式（[http://rfc-editor.org/rfc/rfc2307.txt](http://rfc-editor.org/rfc/rfc2307.txt)）。'
- en: Storing and Using Passwords in OpenLDAP
  id: totrans-528
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 OpenLDAP 中存储和使用密码
- en: 'When we created our basic LDIF file, we used the `userPassword` attribute for
    storing passwords. For example, our authentication account record looked like
    this:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建基础的 LDIF 文件时，我们使用了 `userPassword` 属性来存储密码。例如，我们的身份验证账户记录如下所示：
- en: '[PRE61]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `userPassword` field has the password in plain text. When the value is
    loaded into the directory `userPassword` is encoded with base-64, and looks like
    this:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`userPassword` 字段中存储的是明文密码。当该值被加载到目录中时，`userPassword` 会使用 base64 编码，看起来像这样：'
- en: '[PRE62]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: But this is not encrypted—just encoded in an easily reversible way. While it
    might prevent the directory administrator from accidentally seeing the user's
    password, base-64 encoding will do nothing to prevent an attacker from figuring
    out the password.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这并不是加密的——只是以一种容易反转的方式进行了编码。虽然它可能防止目录管理员无意中看到用户的密码，但 base64 编码并不会防止攻击者从中猜出密码。
- en: Note
  id: totrans-534
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using the Python scripting language, you can easily encode and decode strings
    with the built-in `base64.b64encode()` and `base64.b64decode()` functions.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 脚本语言，你可以轻松地通过内置的 `base64.b64encode()` 和 `base64.b64decode()` 函数进行字符串的编码和解码。
- en: But OpenLDAP does not require you to store passwords in unencrypted text. In
    fact, it is best if you do not. OpenLDAP supports a number of one-way hashing
    algorithms that can be used to store the passwords in a way in which they cannot
    be decrypted.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，OpenLDAP 并不要求你以未加密的文本形式存储密码。事实上，最好不要这么做。OpenLDAP 支持多种单向哈希算法，可以用来以无法解密的方式存储密码。
- en: The `slappasswd` program provides the tools to create a hashed value of a password.
    That hashed value can then be used in the `userPassword` field of an LDIF file.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '`slappasswd` 程序提供了创建密码哈希值的工具。然后，可以在 LDIF 文件的 `userPassword` 字段中使用该哈希值。'
- en: 'OpenLDAP supports five different password hashing schemes: Crypt (`CRYPT`),
    Message Digest 5 (`MD5`), salted MD5 (`SMD5`), Secure Hashing Algorithm, the SHA-1
    version (`SHA`), and Salted SHA (`SSHA`). By default, OpenLDAP uses the most secure
    of the available hashing algorithms: `SSHA`.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP 支持五种不同的密码哈希方案：Crypt（`CRYPT`）、消息摘要算法 5（`MD5`）、加盐 MD5（`SMD5`）、安全哈希算法
    SHA-1 版本（`SHA`）和加盐 SHA（`SSHA`）。默认情况下，OpenLDAP 使用最安全的哈希算法：`SSHA`。
- en: 'Passwords are stored in the `userPassword` field in a format according to section
    5.3 of RFC 2307 ([http://rfc-editor.org/rfc/rfc2307.txt](http://rfc-editor.org/rfc/rfc2307.txt)).
    An encrypted password looks like this:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 密码存储在 `userPassword` 字段中，格式遵循 RFC 2307 第 5.3 节的规定（[http://rfc-editor.org/rfc/rfc2307.txt](http://rfc-editor.org/rfc/rfc2307.txt)）。加密后的密码如下所示：
- en: '[PRE63]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: At the beginning of the password, the section in curly braces (`{}`) indicates
    which of the five password schemes was used. In this case it is the default SSHA
    algorithm. The remainder of the field is the digested hash of the password.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码的开头，花括号中的部分（`{}`）表示使用了哪种密码方案。在这种情况下，它是默认的 SSHA 算法。字段的其余部分是密码的摘要哈希值。
- en: While the hashed password cannot be decrypted, when a user tries to bind to
    the server, OpenLDAP takes the password the user supplies and encrypts it using
    the same algorithm as the value (and same salt) of the value of `userPassword`.
    If the two hashed passwords match, then OpenLDAP logs the user on. If the two
    do not match, OpenLDAP responds with an error message indicating that authentication
    failed.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管哈希后的密码无法被解密，但当用户尝试绑定到服务器时，OpenLDAP会使用与`userPassword`值（以及相同的盐值）相同的算法对用户提供的密码进行加密。如果两个哈希后的密码匹配，则OpenLDAP会让用户登录。如果不匹配，OpenLDAP会返回一个错误消息，提示身份验证失败。
- en: Generating a Password with slappasswd
  id: totrans-543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用slappasswd生成密码
- en: 'Armed with this basic understanding of how passwords are used and stored, we
    can now look at the `slappasswd` program. This program can be used to encrypt
    a password and format it for insertion into an LDIF file. The command can be called
    with no arguments:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 基于对密码如何使用和存储的基本理解，我们现在可以看看`slappasswd`程序。这个程序可以用来加密密码并将其格式化以便插入到LDIF文件中。该命令可以在没有任何参数的情况下调用：
- en: '[PRE64]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In this case, since no parameters were specified on the command line, `slappasswd`
    prompts for a password, and then prompts for verification of the password. Then,
    it prints out the encrypted value of the password. We can use this value in an
    LDIF record:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于命令行上没有指定任何参数，`slappasswd`会提示输入密码，然后再提示验证密码。接着，它会输出密码的加密值。我们可以在LDIF记录中使用这个值：
- en: '[PRE65]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In some cases, typing and retyping passwords may be too tedious, and a faster
    method of encrypting a number of passwords is preferred. You can either use the
    `-T` flag to point to a file containing a list of clear-text passwords to be hashed,
    or you can specify the password on the command line with the `-s` flag:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，输入和重新输入密码可能过于繁琐，因此更喜欢一种更快速的加密多个密码的方法。你可以使用`-T`标志来指定一个包含待哈希明文密码列表的文件，或者可以使用`-s`标志在命令行中指定密码：
- en: '[PRE66]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this shell command, each of the three clear-text passwords, `foo`, `bar`,
    and `baz`, are encrypted by `slappasswd`.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Shell命令中，三个明文密码`foo`、`bar`和`baz`都被`slappasswd`加密。
- en: Note
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On a multi-user system, other users may have access to your command history,
    and thus would be able to see these passwords in cleartext. Caution should be
    used when specifying passwords (or other sensitive information) on the command
    line.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在多用户系统上，其他用户可能能够访问你的命令历史记录，从而能够看到这些明文密码。在命令行中指定密码（或其他敏感信息）时应小心。
- en: 'By using the `-h` flag, you can specify which hashing algorithm `slappasswd`
    should use:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`-h`标志，你可以指定`slappasswd`应使用的哈希算法：
- en: '[PRE67]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In the above commands, the same password, `test`, is encrypted using three different
    hashing schemes.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，使用三种不同的哈希算法对相同的密码`test`进行加密。
- en: Next we will turn to the last OpenLDAP utility—`slaptest`.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将转向最后一个OpenLDAP工具——`slaptest`。
- en: slaptest
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: slaptest
- en: The `slaptest` utility is used for checking the format and directives used in
    the `slapd.conf` file (and any files included by `slapd.conf`).
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`slaptest`工具用于检查`slapd.conf`文件（及其包含的任何文件）中使用的格式和指令。'
- en: 'Running `slaptest` is simple:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`slaptest`非常简单：
- en: '[PRE68]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `-v` flag turns on verbose output, and the `-f` flag, which takes one argument,
    specifies which configuration file to check. If `-f` is omitted, then the default
    `slapd.conf` file (usually `/etc/ldap/slapd.conf`) is checked.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v`标志打开详细输出，而`-f`标志（它需要一个参数）指定要检查的配置文件。如果省略`-f`，则会检查默认的`slapd.conf`文件（通常是`/etc/ldap/slapd.conf`）。'
- en: Note
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As noted in the previous chapter, the version of `slaptest` provided by Ubuntu
    Linux does not print warnings if a directive in `slapd` is unknown. This is non-standard
    behavior. Most of the time OpenLDAP is compiled with such warnings enabled.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，Ubuntu Linux提供的`slaptest`版本在`slapd`中的指令未知时不会打印警告。这是一种非标准行为。大多数时候，OpenLDAP都是在启用这些警告的情况下进行编译的。
- en: 'If the configuration file is correctly formatted and the directives are all
    valid and operational, then `slaptest` will print out a basic success message:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配置文件格式正确且所有指令有效且可操作，那么`slaptest`会打印出基本的成功消息：
- en: '[PRE69]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If anything goes wrong however, `slaptest` will print out diagnostic information.
    For example, if I add an include directive to `slapd.conf` that points to a file
    that does not exist, `slaptest` will print an error:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果出现任何问题，`slaptest`会打印出诊断信息。例如，如果我在`slapd.conf`中添加一个指向不存在文件的include指令，`slaptest`会打印出错误：
- en: '[PRE70]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This output should be helpful for tracking down the problem in the configuration
    files. In this case it was caused by a line that looks like this:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出应该有助于追踪配置文件中的问题。在这种情况下，问题是由一个看起来像这样的行引起的：
- en: '[PRE71]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This is the last of the OpenLDAP utilities. Now we will turn to the client applications
    that are included with the OpenLDAP suite.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 OpenLDAP 实用程序的最后一部分。现在我们将转向包含在 OpenLDAP 套件中的客户端应用程序。
- en: Performing Directory Operations Using the Clients
  id: totrans-571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用客户端执行目录操作
- en: There are a host of OpenLDAP clients, all stored at `/usr/bin` (or `/usr/local/bin`
    if you compiled according to [Appendix A](apa.html "Appendix A. Building OpenLDAP
    from Source")). The OpenLDAP clients communicate over the LDAP protocol. They
    are all standards-compliant, and follow the LDAPv3 protocol (which was last updated
    in June 2006).
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 OpenLDAP 客户端，全部存储在 `/usr/bin`（或者如果您根据 [附录 A](apa.html "附录 A. 从源代码构建 OpenLDAP")
    进行编译，则存储在 `/usr/local/bin`）。OpenLDAP 客户端通过 LDAP 协议进行通信。它们都符合标准，并遵循 LDAPv3 协议（该协议最后更新于
    2006 年 6 月）。
- en: While some of the clients provide the basic standardized LDAP operations, such
    as search, add, and delete, others implement one or more of the LDAP extensions.
    But since the suite of tools does follow the standards, these tools should work
    against any standards-compliant LDAP directory server.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些客户端提供基本的标准化 LDAP 操作，如搜索、添加和删除，但其他客户端实现了一个或多个 LDAP 扩展。但由于这套工具遵循标准，这些工具应该可以与任何符合标准的
    LDAP 目录服务器一起工作。
- en: In this part of the chapter we will take a brief look at each of the OpenLDAP
    clients and see how they can be used to interact with an LDAP server. We do not
    have the space to cover all of the details of each client, so we will focus on
    the most useful and common features of each client. The OpenLDAP man pages (which
    are installed with OpenLDAP) are detailed and informative, and they provide a
    good source of further information for these clients.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的这一部分我们将简要介绍每个 OpenLDAP 客户端，并看看它们如何与 LDAP 服务器交互。我们没有足够的空间来详细介绍每个客户端的所有细节，所以我们将重点介绍每个客户端最有用和最常见的功能。OpenLDAP
    的手册页（与 OpenLDAP 一起安装）详尽而且信息丰富，它们为这些客户端提供了良好的进一步信息来源。
- en: Note
  id: totrans-575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most of the utilities in the last part required that the SLAPD server must not
    not be running. All of the tools in this section, however, connect to a SLAPD
    server. So make sure your server is running before trying the examples in this
    part.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分中，大多数实用程序要求 SLAPD 服务器必须不在运行。然而，本节中的所有工具都连接到 SLAPD 服务器。因此，请确保在尝试本部分示例之前，您的服务器正在运行。
- en: Common Command-Line Flags
  id: totrans-577
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见命令行标志
- en: All of the OpenLDAP clients are command-line applications that use UNIX-style
    flags to pass parameters to the program. For the sake of continuity common flags
    (like `-D`, `-b`, and `-H`) are used consistently across all of the clients.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 OpenLDAP 客户端都是使用 UNIX 风格标志将参数传递给程序的命令行应用程序。为了保持连贯性，通用标志（如 `-D`、`-b` 和 `-H`）在所有客户端中都一致使用。
- en: In Chapter 2 we configured our directory server to handle basic directory operations.
    However, we did not configure it to use SASL authentication (which is covered
    in Chapter 4). To authenticate to the server we will be using what is called **simple
    binding**. In simple binding the client authenticates by sending a full DN and
    password to the server.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们配置了我们的目录服务器来处理基本的目录操作。然而，我们没有配置它来使用 SASL 认证（这在第四章中介绍）。为了对服务器进行认证，我们将使用所谓的**简单绑定**。在简单绑定中，客户端通过向服务器发送完整的
    DN 和密码来进行认证。
- en: The clients require different command-line flags depending on whether they do
    a simple bind or a **SASL bind**. Now we will see those necessary for simple binding.
    Those flags needed for SASL binding are covered in Chapter 4.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 根据是否进行简单绑定或**SASL 绑定**，客户端需要不同的命令行标志。现在我们将看到简单绑定所需的那些标志。关于 SASL 绑定所需的标志将在第四章中介绍。
- en: Common Flags
  id: totrans-581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见标志
- en: 'There are command-line flags for the simple binding process. Some of the common
    flags are as follows:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 有关简单绑定过程的命令行标志。以下是一些常见标志：
- en: '`-D`: The `-D` flag is used to specify the full DN of the user who will bind
    to the directory server (this is used for simple binding).'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-D`：`-D` 标志用于指定将绑定到目录服务器的用户的完整 DN（这用于简单绑定）。'
- en: '`-W`, `-w`, `-y`: Each of these flags indicates a different source for the
    password. Let''s see them one by one:'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-W`、`-w`、`-y`：每个标志表示密码的不同来源。我们逐个来看它们：'
- en: The `-W` flag indicates that the user should be interactively prompted to enter
    a password.
  id: totrans-585
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-W` 标志指示用户应与服务器交互式提示输入密码。'
- en: The `-w` flag takes the password string for a value. We can use it to specify
    the password on the command line.
  id: totrans-586
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-w`：此标志接受一个密码字符串作为值。我们可以用它在命令行中指定密码。'
- en: The `-y` flag takes a file name as an argument. It will use the contents of
    the file as a password. These flags are mutually exclusive—you can only use one
    of these per command.
  id: totrans-587
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-y`：此标志接受文件名作为参数。它将使用文件的内容作为密码。这些标志是互斥的——每个命令中只能使用一个。'
- en: Note
  id: totrans-588
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `-y` flag uses the entire contents of a file for the password. This means
    that if there is a line break in the file, it will be treated like part of the
    password. To create a password file, you can use the `echo` command with the `-n`
    flag: `$ echo -n "secret" > my_pw`.'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`-y` 标志使用文件的整个内容作为密码。这意味着如果文件中有换行符，它将被视为密码的一部分。要创建密码文件，可以使用带 `-n` 标志的 `echo`
    命令：`$ echo -n "secret" > my_pw`。'
- en: '`-x`: The `-x` flag specifies that the client will use a simple bind. If this
    is not specified, the client will try a SASL bind.'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-x`：`-x` 标志指定客户端将使用简单绑定。如果未指定，则客户端将尝试使用 SASL 绑定。'
- en: '`-H`, `-h`: These two flags provide different ways of specifying which host
    to connect to. `-H` takes an LDAP URL (`-H ''ldap://example.com:389''`). `-h`
    simply takes the host name (`-h example.com`), and can be used with `-p` to specify
    a port. Unless you do not have a choice, use `-H`. The `-h` flag is provided only
    for backward compatibility, and may disappear in future versions.'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-H`，`-h`：这两个标志提供了指定连接主机的不同方式。`-H` 接受一个 LDAP URL（`-H ''ldap://example.com:389''`）。`-h`
    仅接受主机名（`-h example.com`），并可以与 `-p` 一起指定端口。除非没有选择，否则使用 `-H`。`-h` 标志仅为向后兼容而提供，未来版本中可能会删除。'
- en: '`-Z`: This flag is used to indicate that the client should issue a **Start
    TLS** command to the server, so that traffic is encrypted according to the TLS
    standard. But if TLS negotiation fails, the client will still continue to operate.
    Using two Z''s (`-ZZ`) will make it mandatory that the traffic be encrypted. If
    negotiation fails, then the client will disconnect. TLS is covered in more detail
    in the next chapter.'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Z`：此标志用于指示客户端应向服务器发出**启动 TLS**命令，以便根据 TLS 标准加密流量。但是，如果 TLS 协商失败，客户端仍将继续操作。使用两个
    Z（`-ZZ`）将强制流量加密。如果协商失败，则客户端将断开连接。TLS 相关内容将在下一章中详细介绍。'
- en: '`-b`: This is used to specify a base DN (`-b ''dc=example,dc=com''`).'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-b`：用于指定基本 DN（`-b ''dc=example,dc=com''`）。'
- en: '`-f`: The `-f` flag takes a filename as a parameter. The client will then read
    the contents of the file and build requests based on the contents of the file.'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`：`-f` 标志接受文件名作为参数。客户端将读取该文件的内容，并根据文件内容构建请求。'
- en: '`-v`: This flag will turn on verbose output. It is useful when troubleshooting.'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v`：此标志将开启详细输出。在故障排除时非常有用。'
- en: These are the common flags used by the clients in the OpenLDAP suite. But these
    represent only a subset of the flags used by each client, as each client implements
    the flags needed to accomplish its task.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 OpenLDAP 套件中客户端常用的标志。但这些仅代表每个客户端使用的标志的一个子集，因为每个客户端都实现了完成其任务所需的标志。
- en: Setting Defaults in ldap.conf
  id: totrans-597
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 ldap.conf 中设置默认值
- en: 'In Chapter 2, in the section entitled *Configuring the LDAP Clients*, we looked
    at the `ldap.conf` file. In that file, we set some useful defaults. In particular
    we set these three:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章的 *配置 LDAP 客户端* 部分，我们查看了 `ldap.conf` 文件。在该文件中，我们设置了一些有用的默认值。特别是我们设置了以下三项：
- en: '[PRE72]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If you omit host settings (`-H`, `-h`), then the value of `URI` will be used.
    If the client needs a base DN, and none is set with the `-b` flag, then the value
    of `BASE` is used. Likewise, if the client uses simple binding (with `-x`), and
    doesn't specify a DN with `-D`, then the value of `BINDDN` will be used.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了主机设置（`-H`，`-h`），则将使用 `URI` 的值。如果客户端需要基本 DN，并且没有使用 `-b` 标志进行设置，则将使用 `BASE`
    的值。同样，如果客户端使用简单绑定（`-x`）且未使用 `-D` 指定 DN，则将使用 `BINDDN` 的值。
- en: Since we have an `ldap.conf` file created already, many of the examples will
    omit the `-H` and `-b` flags.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经创建了一个 `ldap.conf` 文件，因此许多示例将省略 `-H` 和 `-b` 标志。
- en: While `ldap.conf` is shared by all clients, you can create a user-specific LDAP
    configuration file in your home directory. The LDAP clients will look for user-specific
    configuration files named `ldaprc` and `.ldaprc` in your home directory (`$HOME`).
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `ldap.conf` 是所有客户端共享的，但你可以在你的主目录中创建一个特定于用户的 LDAP 配置文件。LDAP 客户端将在你的主目录（`$HOME`）中查找名为
    `ldaprc` 和 `.ldaprc` 的用户特定配置文件。
- en: Now we are ready to look at the client commands.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好查看客户端命令。
- en: ldapsearch
  id: totrans-604
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ldapsearch
- en: 'The first client we will look at is also the most often used tool: `ldapsearch`.
    As the name suggests, this is a tool for searching the directory information tree.'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要看的客户端是最常用的工具：`ldapsearch`。顾名思义，这是一个用于搜索目录信息树的工具。
- en: The `ldapsearch` client connects to the server, authenticates a user, and then
    (as that user) runs one or more **search operations**, returning the results in
    LDIF format. When it is done performing searches, it closes the connection and
    exits. Since `ldapsearch` is a network client it can be used to search both local
    directories or a remote directory server.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldapsearch` 客户端连接到服务器，验证用户身份，然后（以该用户身份）执行一个或多个**搜索操作**，并以 LDIF 格式返回结果。当完成搜索后，它会关闭连接并退出。由于
    `ldapsearch` 是一个网络客户端，因此可以用于搜索本地目录或远程目录服务器。'
- en: A Simple Search
  id: totrans-607
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个简单的搜索
- en: 'Let''s take a look at a simple search command. In this command we will log
    in as the directory manager and request the record for the entry with the user
    ID *barbara*:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的搜索命令。在这个命令中，我们将以目录管理员身份登录，并请求获取用户 ID *barbara* 的记录：
- en: '[PRE73]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Here is the result:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '[PRE74]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In this example we ran the `ldapsearch` command with four flags: `-x`, `-W`,
    `-D`, and `-b`. For a description of these flags see the *Common Command-Line
    Flags* section. In a nutshell though, `-x`, `-W`, and `-D` are all parameters
    used for authenticating to the directory. They instruct the client to bind to
    the directory with simple authentication (`-x`) as the DN specified by `-D` (the
    directory manager in this case), then prompt the user to enter a password interactively
    (`-W`).'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们运行了带有四个标志的 `ldapsearch` 命令：`-x`、`-W`、`-D` 和 `-b`。有关这些标志的描述，请参阅《*常用命令行标志*》部分。不过，简而言之，`-x`、`-W`
    和 `-D` 都是用于目录认证的参数。它们指示客户端使用简单认证（`-x`）以 `-D` 指定的 DN（此例中为目录管理员）进行绑定，然后交互式地提示用户输入密码（`-W`）。
- en: The `-b` flag sets the base DN for the search. This is set to `ou=Users,dc=example,dc=com`.
    Given this, `ldapsearch` will start searching in the `Users` OU.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '`-b` 标志设置搜索的基础 DN。它被设置为 `ou=Users,dc=example,dc=com`。根据这一设置，`ldapsearch` 将从
    `Users` 组织单位（OU）开始搜索。'
- en: Note
  id: totrans-614
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we had omitted the `-b` flag, the value of BASE in `ldap.conf` would have
    been used, which would have set the base DN to `dc=example,dc=com`.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略了 `-b` 标志，则会使用 `ldap.conf` 中的 BASE 值，这会将基础 DN 设置为 `dc=example,dc=com`。
- en: 'After all of the command-line flags and their arguments, we specified an LDAP
    filter:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有命令行标志及其参数之后，我们指定了一个 LDAP 过滤器：
- en: '[PRE75]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This is the filter that the server will use for searching. We covered search
    filters in more detail earlier in this chapter, in the section entitled *The*
    *Search* *Operation*. In this case though, the search filter is straightforward:
    it matches only records that have the attribute named `uid` with the attribute
    value of `barbara`.'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 这是服务器用于搜索的过滤器。我们在本章的《*搜索操作*》部分更详细地讨论了搜索过滤器。不过，在这种情况下，搜索过滤器很简单：它仅匹配属性名为 `uid`
    且属性值为 `barbara` 的记录。
- en: Note
  id: totrans-619
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Many attributes have more than one name (these are properly called **attribute
    descriptions**). For example, the attribute that labels user IDs has the attribute
    descriptions `uid` and `userID`. In the case above, a search for `(uid=barbara)`
    will also match directory entries with and attribute of the form `userID: barbara`.'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '许多属性有多个名称（这些被称为**属性描述**）。例如，标记用户 ID 的属性有属性描述 `uid` 和 `userID`。在上面的例子中，搜索 `(uid=barbara)`
    也会匹配具有形式为 `userID: barbara` 的目录条目。'
- en: When this command is run, it will first prompt the user to enter a password
    (because of the `-W` flag), and then connect to the server and attempt to bind
    as the specified DN (`cn=Manager,dc=example,dc=com`). Then, if the bind is successful,
    it will request all records that match the filter, `(uid=barbara)`. As the example
    illustrates, the server will return the entire record of the user, or as much
    of it as the ACLs allow, in the case of a non-manager user.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行该命令时，系统首先会提示用户输入密码（因为使用了 `-W` 标志），然后连接到服务器并尝试以指定的 DN（`cn=Manager,dc=example,dc=com`）进行绑定。接着，如果绑定成功，它会请求所有符合过滤器
    `(uid=barbara)` 的记录。如示例所示，服务器将返回用户的整个记录，或者在非管理员用户的情况下返回 ACLs 允许的部分记录。
- en: 'The results are returned in LDIF format, with comments sprinkled throughout.
    The first set of comments provides basic information about the search:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 结果以 LDIF 格式返回，其中夹杂着注释。第一组注释提供了有关搜索的基本信息：
- en: '[PRE76]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The first line indicates that this record is in extended LDIF format. This
    is LDIF version 1.0, plus some comments. Beneath that, we get a summary of the
    search, including the following:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行表示该记录是扩展的 LDIF 格式。这是 LDIF 版本 1.0，并包含一些注释。下面是搜索的摘要，包含以下内容：
- en: Version of LDAP used (v3)
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的 LDAP 版本（v3）
- en: What the base DN is (`ou=Users,dc=example,dc=com`).
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本 DN 是什么（`ou=Users,dc=example,dc=com`）。
- en: What type of search will be performed. In this case, it is a **subtree search**,
    which means the server will look in all records beneath the base DN.
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将执行什么类型的搜索。在此案例中，这是一个**子树搜索**，意味着服务器会查找基本 DN 下所有记录。
- en: What the operating search filter is (`(userid=barbara)`).
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作搜索过滤器是什么（`(userid=barbara)`）。
- en: What attributes the client wants returned. `ALL` indicates that the client wants
    all available attributes returned.
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端希望返回的属性。`ALL` 表示客户端希望返回所有可用的属性。
- en: 'The central part of the file contains the full record for Barbara. Beneath
    the record is a brief summary of the results:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的中央部分包含 Barbara 的完整记录。记录下方是结果的简要总结：
- en: '[PRE77]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The first line, `search`, indicates that we performed two search operations
    (one for binding and one to execute the filtered search).
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行 `search` 表示我们执行了两个搜索操作（一个用于绑定，一个用于执行过滤搜索）。
- en: The second, `result`, inidcates the result code that the server sent back. `0
    Success` indicates that our search ran without encountering any errors.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行 `result` 表示服务器返回的结果代码。`0 Success` 表示我们的搜索没有遇到任何错误。
- en: The extended (and thus commented) results add some additional information. `numResponses`
    indicates that the server sent two responses back to the client (one for the bind,
    one for the search). And `numEntries` indicates how many entries were returned
    by the search. In this case there was only one—Barbara's record.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展（因此带有注释的）结果增加了一些附加信息。`numResponses` 表示服务器向客户端发送了两个响应（一个用于绑定，另一个用于搜索）。而 `numEntries`
    表示搜索返回了多少条记录。在此例中，只有一条——Barbara 的记录。
- en: Restricting Returned Fields
  id: totrans-635
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制返回字段
- en: 'Sometimes we don''t want to get a DN''s entire record back. Instead, we just
    want a couple of attributes. This can be accomplished by specifying a list of
    attributes at the end of the command:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不想获取整个 DN 的记录。相反，我们只希望获取一些特定的属性。这可以通过在命令的末尾指定属性列表来实现：
- en: '[PRE78]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here is the result:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是结果：
- en: '[PRE79]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note that in this example we used the `-w secret` flag to specify the password
    on the command line. We also used the `-LLL` flag to suppress all of the extraneous
    comments printed in the LDIF output.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个例子中，我们使用了 `-w secret` 标志在命令行中指定密码。我们还使用了 `-LLL` 标志来抑制 LDIF 输出中的所有冗余注释。
- en: Tip
  id: totrans-641
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Specifying the password on the command line can be a security risk. Other users
    on the system may be able to access this information through command-line histories
    (like the Bash shell's history feature) and operating system constructs (like
    the `/proc` file system in Linux).
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中指定密码可能会存在安全风险。系统上的其他用户可能通过命令行历史记录（如 Bash shell 的历史功能）和操作系统构造（如 Linux 中的
    `/proc` 文件系统）访问这些信息。
- en: 'In addition to the filter, `(userID=matt)`, I also added a list of attributes
    that I wanted returned: `cn` and `mail`. The returned record contained four lines:
    the `dn`, the two `mail` attributes, and the `cn` attribute. The DN is always
    returned.'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 除了过滤器`(userID=matt)`，我还添加了一个我希望返回的属性列表：`cn` 和 `mail`。返回的记录包含四行：`dn`、两个 `mail`
    属性和 `cn` 属性。DN 总是会被返回。
- en: Requesting Operational Attributes
  id: totrans-644
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求操作属性
- en: You may have noticed that the record returned for Barbara by `ldapsearch` is
    quite a bit different than the record returned by `slapcat`.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，通过 `ldapsearch` 返回的 Barbara 记录与通过 `slapcat` 返回的记录有所不同。
- en: Note
  id: totrans-646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We covered `slapcat` in the part of this chapter entitled *Using the Utilities
    to Prepare the Directory*.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章名为 *使用工具准备目录* 的部分中讲解了 `slapcat`。
- en: 'Let''s compare the two. First, here''s the `ldapsearch` output:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对比一下这两者。首先，这是 `ldapsearch` 的输出：
- en: '[PRE80]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, here''s the `slapcat` output:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是 `slapcat` 的输出：
- en: '[PRE81]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The output of `slapcat` has a host of additional attributes—namely the special
    operational attributes that the directory maintains internally. We can retrieve
    the operational attributes with `ldapsearch` either by specifying them by name
    along with the list of desired attributes, or by using the special plus sign (`+`)
    attribute list specifier at the end of the `ldapsearch` command:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '`slapcat` 的输出包含许多额外的属性——即目录内部维护的特殊操作属性。我们可以通过 `ldapsearch` 获取这些操作属性，方法是指定属性名称并与所需属性列表一起使用，或者在
    `ldapsearch` 命令末尾使用特殊的加号（`+`）属性列表说明符：'
- en: '[PRE82]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'And, this is what we get:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们得到的结果：
- en: '[PRE83]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Specifying the `+` list does not return all attributes—only the operational
    attributes. To get all of the regular attributes and all of the operational attributes,
    you will need both the `+` specifier and the `*` (asterisk) specifier. The `*`
    specifier indicates that we want all of the standard attributes. This is the output:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 指定 `+` 列表并不会返回所有属性——仅返回操作属性。要获取所有常规属性和所有操作属性，您需要同时使用 `+` 说明符和 `*`（星号）说明符。`*`
    说明符表示我们想要所有标准属性。以下是输出：
- en: '[PRE84]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Now we have the complete list of attributes. Using this combination of arguments,
    we can generate LDIF files suitable for making backups (assuming the ACLs are
    not preventing access to something). While `slapcat` will outperform `ldapsearch`
    for this task, the fact that `ldapsearch` can run remotely over the network is
    attractive in many cases.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了完整的属性列表。使用这些参数的组合，我们可以生成适合备份的 LDIF 文件（假设 ACL 不会阻止访问某些内容）。虽然 `slapcat`
    在这个任务上会比 `ldapsearch` 更高效，但 `ldapsearch` 可以远程通过网络运行，这在许多情况下非常有吸引力。
- en: Note
  id: totrans-659
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that in the given record, `ldapsearch` has returned three operational
    attributes that do not show up with `slapcat`: `entryDN`, `subschemaSubentry`,
    and `hasSubordinates`. These values are generated dynamically at runtime and do
    not exist in the LDAP backend. For that reason they are not exported with `slapcat`.
    Since they are generated dynamically, they are not useful values to back up.'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在给定的记录中，`ldapsearch` 返回了三个 `slapcat` 未显示的操作属性：`entryDN`、`subschemaSubentry`
    和 `hasSubordinates`。这些值是在运行时动态生成的，并不存在于 LDAP 后端。因此，它们不会与 `slapcat` 一起导出。由于它们是动态生成的，它们并不是备份的有用值。
- en: It is also possible to run multiple queries in sequence using `ldapsearch`.
    This is done by using an external file to store filter information for multiple
    searches.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用 `ldapsearch` 按顺序运行多个查询。这是通过使用外部文件来存储多个搜索的过滤器信息来实现的。
- en: Searching Using a File
  id: totrans-662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用文件进行搜索
- en: 'The `ldapsearch` client can use a file to build and execute multiple queries.
    Let''s say we have a plain text list of user IDs, and we want to get the last
    name for each user ID. The file, `userIDs.txt`, looks like this:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldapsearch` 客户端可以使用文件来构建并执行多个查询。假设我们有一个包含用户 ID 的纯文本列表，并且我们想获取每个用户 ID 的姓氏。文件
    `userIDs.txt` 看起来是这样的：'
- en: '[PRE85]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We can use `ldapsearch` to dynamically build a filter and run a search for
    each user''s surname. To do this, we use the `-f` flag, and point to the `userIDs.txt`
    file, and then we build a special filter. Here is the command line to be executed:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `ldapsearch` 动态构建过滤器并为每个用户的姓氏运行搜索。为此，我们使用 `-f` 标志，指向 `userIDs.txt` 文件，然后构建一个特殊的过滤器。以下是要执行的命令行：
- en: '[PRE86]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Most of this should look familiar, by now. But notice the filter: `''(uid=%s)''`.
    This filter uses the special `%s` placeholder to indicate where the values from
    the file ought to be placed. As `ldapsearch` runs, it will read through the `userIDs.txt`
    file line by line, and with each line, it will execute a search, substituting
    the value of the line for `%s` in the filter. The results look like this:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，大部分内容应该已经很熟悉了。但请注意过滤器：`'(uid=%s)'`。这个过滤器使用特殊的 `%s` 占位符来指示文件中的值应该放置的位置。每当
    `ldapsearch` 运行时，它会逐行读取 `userIDs.txt` 文件，并在每行中执行一个搜索，将该行的值替换为过滤器中的 `%s`。结果如下：
- en: '[PRE87]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In this example the `ldapsearch` client actually ran two different search operations.
    It first expanded `(uid=%s)` to `(uid=matt)` and ran a search; then, it expanded
    `(uid=%s)` to `(uid=barbara)`, and ran another search. In each case, it returned
    only the `dn` (which is always returned for a match) and the requested `sn` attribute.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`ldapsearch` 客户端实际上运行了两个不同的搜索操作。它首先将 `(uid=%s)` 扩展为 `(uid=matt)` 并运行一个搜索；然后，它将
    `(uid=%s)` 扩展为 `(uid=barbara)`，并运行另一个搜索。在每种情况下，它只返回 `dn`（这是匹配时总会返回的）和请求的 `sn`
    属性。
- en: 'You can also create filters in a file, and have multiple search filters run.
    For example, we could create a file named `filters.txt` with the following lines:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在文件中创建过滤器，并运行多个搜索过滤器。例如，我们可以创建一个名为 `filters.txt` 的文件，其中包含以下几行：
- en: '[PRE88]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Since each line will be inserted into a filter, we do not need the outer set
    of parentheses. Now we can use these lines to dynamically build filters with `ldapsearch`:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每一行将被插入到一个过滤器中，因此不需要外部的括号。现在我们可以使用这些行通过 `ldapsearch` 动态构建过滤器：
- en: '[PRE89]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We will get this output:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE90]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In this case the filter `(%s)` was expanded in the first case to `(&(ou=System)(objectClass=account))`,
    and in the second case to `(&(uid=b*)(ou=Users))`.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，过滤器 `(%s)` 在第一个案例中被展开为 `(&(ou=System)(objectClass=account))`，在第二个案例中则展开为
    `(&(uid=b*)(ou=Users))`。
- en: Using techniques like this it becomes possible to execute a number of complex
    searches with one command.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，就可以通过一个命令执行多个复杂的搜索。
- en: We will continue using the `ldapsearch` client throughout this book. Now that
    we have a basic idea as to how it works, we will move on to the next client in
    the OpenLDAP suite.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们将继续使用 `ldapsearch` 客户端。现在我们对它的基本工作方式有了了解，接下来我们将继续介绍 OpenLDAP 套件中的下一个客户端。
- en: ldapadd
  id: totrans-679
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ldapadd
- en: This is a command-line program used for adding new entries to an LDAP directory.
    The `ldapadd` command is not actually a stand-alone client. It is just a link
    to the `ldapmodify` program. When `ldapmodify` sees that it has been called as
    `ldapadd`, it will assume that it should request that the server perform an **add
    operation**, instead of requesting a modify operation.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于向 LDAP 目录添加新条目的命令行程序。`ldapadd` 命令实际上并不是一个独立的客户端，它只是 `ldapmodify` 程序的一个链接。当
    `ldapmodify` 看到它是作为 `ldapadd` 被调用时，它会假定应该请求服务器执行**添加操作**，而不是请求修改操作。
- en: 'In the most simple case, `ldapadd` can be used to enter a new record from the
    command line:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，`ldapadd` 可以用来从命令行输入一个新记录：
- en: '[PRE91]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Once we have been successfully authenticated, the cursor will move to the next
    line and wait for the input. We can directly enter a record. As soon as we hit
    *Enter* twice (creating a blank line, which indicates the end of a record), `ldapadd`
    will send the record to the server:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们成功通过身份验证，光标将移到下一行并等待输入。我们可以直接输入记录。只要我们按下 *Enter* 两次（创建一个空白行，表示记录结束），`ldapadd`
    就会将记录发送到服务器：
- en: '[PRE92]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The highlighted portion is the text that we entered. It specifies one entire
    record (a record for a user named Adam Smith).
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮部分是我们输入的文本。它指定了一个完整的记录（一个名为 Adam Smith 的用户记录）。
- en: 'After we pressed the return key twice, inserting a blank line, the record was
    sent to the server. The client indicated that it was adding the record: `adding
    new entry "uid=adam,ou=Users,dc=example,dc=com"`. No error message followed. This
    means that the add was successful.'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按下回车键两次，插入一个空白行时，记录被发送到服务器。客户端显示正在添加记录：`adding new entry "uid=adam,ou=Users,dc=example,dc=com"`。没有错误信息出现。这意味着添加成功。
- en: Once a record is added the cursor will move to a blank line, waiting for the
    `dn` attribute of the next record.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦记录被添加，光标将移至空白行，等待下一个记录的 `dn` 属性。
- en: '[PRE93]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In this example the record that we entered (again, highlighted) contained an
    undefined attribute, and the server balked with the same error message. In cases
    where the server sends an error message, the `ldapadd` client prints the error
    message and exits. To re-enter the record you will have to re-run `ldapadd`.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们输入的记录（再次突出显示）包含一个未定义的属性，服务器因而显示相同的错误信息。当服务器发送错误信息时，`ldapadd` 客户端会打印错误信息并退出。要重新输入记录，您必须重新运行
    `ldapadd`。
- en: But as long as new records are valid and the server does not report an error,
    `ldapadd` will continue prompting (or rather listening) for new records. When
    finished, use the *CTRL*-*C* key combination to exit the program.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 但只要新记录有效，并且服务器没有报告错误，`ldapadd` 将继续提示（或者说是监听）新记录。当完成时，使用 *CTRL*-*C* 键组合退出程序。
- en: Adding Records from a File
  id: totrans-691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从文件添加记录
- en: While typing a record directly into the client may be useful on occasion, in
    most cases it is far more convenient (and less error prone) to create the records
    in a plain text file, and then load them all at once with the `ldapadd` program.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有时直接在客户端输入记录可能很有用，但在大多数情况下，创建纯文本文件中的记录并使用 `ldapadd` 程序一次性加载它们要更方便（且更不容易出错）。
- en: 'As usual, the records in the text file should be formated in LDIF. Here, for
    example, are the contents of the file `user_records.ldif`:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，文本文件中的记录应该采用 LDIF 格式。例如，以下是文件 `user_records.ldif` 的内容：
- en: '[PRE94]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We can add all of the records in a file:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加文件中的所有记录：
- en: '[PRE95]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Just as when we added records interactively, here the absence of an error message
    indicates that the record was successfully added.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们交互式地添加记录时一样，这里没有错误信息表示记录已成功添加。
- en: Next we will look at modifying records that already exist in the directory.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下如何修改目录中已经存在的记录。
- en: ldapmodify
  id: totrans-699
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ldapmodify
- en: The `ldapmodify` program is used to modify an existing entry. It can add, change,
    and delete the attributes of a entries in the directory. It can also be used to
    add new entries (together with attributes for the entry).
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldapmodify` 程序用于修改现有条目。它可以添加、更改和删除目录中的条目属性。它还可以用来添加新条目（以及条目的属性）。'
- en: Like `ldapadd`, `ldapmodify` can be run interactively. It can be used to add,
    modify, and remove records.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `ldapadd` 类似，`ldapmodify` 也可以交互式运行。它可以用来添加、修改和删除记录。
- en: Adding a Record with ldapmodify
  id: totrans-702
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `ldapmodify` 添加记录
- en: 'The syntax for adding a record is almost identical in `ldapmodify` to that
    of `ldapadd`:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 添加记录的语法在 `ldapmodify` 中与 `ldapadd` 几乎相同：
- en: '[PRE96]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Here is the result:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE97]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The only difference is the addition of the `changetype` instruction after the
    `dn`. This tells `ldapmodify` what sort of LDAP operation should be performed
    on this record.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是，在 `dn` 后添加了 `changetype` 指令。这告诉 `ldapmodify` 应对该记录执行哪种 LDAP 操作。
- en: Note
  id: totrans-708
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `changetype` instruction is not an attribute, though it looks like one.
    It is not part of the record, but rather an instruction (in LDIF format) to tell
    the server what operation it should use.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '`changetype` 指令并不是一个属性，尽管它看起来像是。它不是记录的一部分，而是告诉服务器应使用哪种操作的指令（以 LDIF 格式）。'
- en: 'There are four possible values for `changetype`:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '`changetype` 有四个可能的值：'
- en: '`add`'
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add`'
- en: '`modify`'
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modify`'
- en: '`modrdn`'
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modrdn`'
- en: '`delete`'
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`'
- en: Each of these corresponds to an LDAP operation. The `add` change-type is used
    to add a new record (essentially performing the same add operation as `ldapadd`).
    The `modify` change-type takes an existing record and modifies it in some way
    (for example, by adding, replacing, or removing attributes). The `modrdn` change-type
    changes the relative DN (or RDN) of a record. The `delete` change-type deletes
    the entire record from the directory server.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个操作都对应一个 LDAP 操作。`add` 更改类型用于添加新记录（本质上执行与 `ldapadd` 相同的添加操作）。`modify` 更改类型用于修改现有记录（例如，通过添加、替换或删除属性）。`modrdn`
    更改类型用于修改记录的相对 DN（或 RDN）。`delete` 更改类型用于从目录服务器中删除整个记录。
- en: Modifying Existing Records
  id: totrans-716
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改现有记录
- en: Usually it is easier to add records with `ldapadd`. Where the `ldapmodify` client
    really shines is in its ability to modify existing records, adding, removing,
    or replacing attributes within a record.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用 `ldapadd` 添加记录更为简便。而 `ldapmodify` 客户端的真正亮点在于它能修改现有记录，添加、删除或替换记录中的属性。
- en: 'Let''s add a `givenName` field to one of the records we added in the last section:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为上一节中添加的一个记录增加一个 `givenName` 字段：
- en: '[PRE98]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This gives the following output:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '[PRE99]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Just as with `ldapadd`, once the authentication phase has been done, `ldapmodify`
    waits for a DN to be given. After the `dn` attribute is specified, the `changetype`
    should follow.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `ldapadd` 一样，一旦认证阶段完成，`ldapmodify` 会等待提供一个 DN。在指定 `dn` 属性后，应紧跟 `changetype`。
- en: 'When using a `modify` change-type, as we do here, we must also specify exactly
    what attributes we are going to change, and how we will change them. The modify
    change-type is the only type that requires this further specification. Here is
    the figure displaying the several change-types:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `modify` 更改类型时，如我们在此所做的，必须明确指定我们将要更改哪些属性，以及如何更改它们。`modify` 更改类型是唯一需要进一步指定的类型。以下是显示几个更改类型的图示：
- en: '![Modifying Existing Records](img/1021_03_11.jpg)'
  id: totrans-724
  prefs: []
  type: TYPE_IMG
  zh: '![修改现有记录](img/1021_03_11.jpg)'
- en: 'In this case, we want to add a new attribute to the the `uid=david`, `ou=Users`,
    `dc=example`, `dc=com` record. And the attribute we want to add is `givenName`.
    So, the line that specifies that we will add a `givenName` attribute reads `add:
    givenName`.'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，我们想要为 `uid=david`、`ou=Users`、`dc=example`、`dc=com` 记录添加一个新属性。我们要添加的属性是
    `givenName`。因此，指定要添加 `givenName` 属性的行是 `add: givenName`。'
- en: 'Next, we want to specify the attribute and attribute value:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要指定属性和属性值：
- en: '[PRE100]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Then, by hitting *Enter* twice, we indicate that the record is complete. Just
    as with `ldapadd`, `ldapmodify` indicates which record it is modifying. If the
    server does not return an error, `ldapmodify` will wait for another modify record.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按*Enter*两次表示记录已完成。就像使用`ldapadd`一样，`ldapmodify`会指示它正在修改哪个记录。如果服务器没有返回错误，`ldapmodify`将等待另一个修改记录。
- en: 'The `add` modification type is one of three that `ldapmodify` supports. Operations
    can only be specified if the change-type is set to modify. The three modification
    types are:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`修改类型是`ldapmodify`支持的三种类型之一。只有当更改类型设置为修改时，才能指定操作。三种修改类型分别是：'
- en: '`add`: Adds new attributes to an existing record'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add`：向现有记录中添加新属性'
- en: '`replace`: Replaces existing attribute values with new attribute values'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace`：用新属性值替换现有属性值'
- en: '`delete`: Removes attributes from the record'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`：从记录中删除属性'
- en: 'More than one of these operations can be done in a single transaction:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作中的多个可以在一个事务中进行：
- en: '[PRE101]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In this example we first add `givenName`, and then replace the existing `cn`
    value with a new one. Between the two modification requests we use a dash (`-`)
    to indicate that we are still working on the same record. Remember, a blank line
    indicates that we are done with the record. Now, if we look up the record with
    `ldapsearch`, it looks like this:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先添加`givenName`，然后用新的值替换现有的`cn`。在两个修改请求之间，我们使用连字符（`-`）表示我们仍在处理同一记录。记住，空行表示我们已完成该记录。现在，如果我们使用`ldapsearch`查找该记录，它将如下所示：
- en: '[PRE102]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The `cn` has been replaced, and the `givenName` attribute has been added.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '`cn`已被替换，并且`givenName`属性已被添加。'
- en: 'If the modification is adding several attributes, rather than splitting the
    additions up using dashes, you can group them together:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 如果修改是添加多个属性，您可以将它们分组，而不是使用连字符分开添加：
- en: '[PRE103]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Note that, in this case, the `add` line has two attribute names (`description`
    and `title`), followed by both attributes. And just as with `ldapadd`, we can
    put these change records into a plain text file, and then use the `-f` flag, which
    takes the path to a file, to have `ldapmodify` read the commands from the file
    instead of from the interactive prompt:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，`add`行包含两个属性名称（`description`和`title`），后跟这两个属性。就像使用`ldapadd`一样，我们可以将这些变更记录放入一个纯文本文件中，然后使用`-f`标志（后接文件路径），让`ldapmodify`从文件中读取命令，而不是从交互式提示符中读取：
- en: '[PRE104]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Using the `modify` change-type we can delete an attribute:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`modify`更改类型，我们可以删除一个属性：
- en: '[PRE105]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Deleting an attribute from the record has the result of deleting all of the
    attribute values from the record. For example, if Nicholas had two titles specified,
    the above would remove them both.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 从记录中删除一个属性会导致该属性的所有值从记录中被删除。例如，如果Nicholas有两个指定的头衔，上面的操作会将它们全部删除。
- en: 'To delete just one specific attribute, the request must also name the attribute
    value to be deleted:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个特定的属性，请求中必须指定要删除的属性值：
- en: '[PRE106]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: That will delete any `title` attribute values that contain the exact string
    "Cartesian philosopher", leaving any other attribute values intact.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除任何包含精确字符串"Cartesian philosopher"的`title`属性值，保留任何其他属性值不变。
- en: Modifying the Relative DN
  id: totrans-748
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改相对DN
- en: The third change type is for modifying relative DNs—the portion of the DN that
    identifies the current record (see the discussion at the beginning of this chapter).
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种更改类型用于修改相对DN——即标识当前记录的DN部分（参见本章开头的讨论）。
- en: 'For example, we can change the RDN portion of the DN for our user `uid=immanuel,ou=Users,dc=example,dc=com`:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以更改用户`uid=immanuel,ou=Users,dc=example,dc=com`的DN的RDN部分：
- en: '[PRE107]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: In this example, we use the `modrdn` change-type to instruct SLAPD to change
    the RDN portion of the user's DN. The `newrdn` instruction supplies the new RDN
    portion, and the `deleteoldrdn` instruction determines whether the old attribute
    value (`uid=immanuel`) will be deleted or retained. Setting `0` indicates that
    the old attribute value should not be deleted, while `1` will result in the old
    attribute value's removal.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用`modrdn`更改类型来指示SLAPD更改用户DN的RDN部分。`newrdn`指令提供新的RDN部分，而`deleteoldrdn`指令决定是否删除或保留旧的属性值（`uid=immanuel`）。设置`0`表示不删除旧的属性值，而设置`1`则会删除旧的属性值。
- en: 'Now, if we search for that user, we can observe the modification:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们搜索该用户，我们可以观察到修改：
- en: '[PRE108]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'In some cases we don''t want the old RDN attribute value to be kept. In such
    cases, setting the `deleteoldrdn` value to `1` will remove the old RDN attribute
    values:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们不希望保留旧的RDN属性值。在这种情况下，将`deleteoldrdn`值设置为`1`将删除旧的RDN属性值：
- en: '[PRE109]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This changes the RDN back to `uid=immanuel`, and since `deleteoldrdn` is set
    to `1`, the old UID value (`manny`) should be deleted. We can verify this with
    `ldapsearch`:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 这将RDN更改回`uid=immanuel`，并且由于`deleteoldrdn`设置为`1`，旧的UID值（`manny`）应该被删除。我们可以通过`ldapsearch`验证这一点：
- en: '[PRE110]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Note that, in addition to the changed DN, the old `uid` attribute value (`manny`)
    is no longer present in the record. It has been replaced.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除了更改后的DN，旧的`uid`属性值（`manny`）不再出现在记录中，它已被替换。
- en: We will take another look at modifying relative DNs when we examine the `ldapmodrdn`
    client.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查`ldapmodrdn`客户端时，我们将再次查看相对DN的修改。
- en: Moving a Record with modrdn
  id: totrans-761
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用modrdn移动记录
- en: The `modrdn` change-type can be used for more than just changing the RDN. It
    can be used for changing a record's superior entry, essentially relocating a record
    within the directory information tree.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '`modrdn`变更类型不仅可以用于更改RDN，还可以用于更改记录的上级条目，实际上是将记录在目录信息树中重新定位。'
- en: For this operation to work however, the backend database type must support this
    sort of modification. Currently, the only storage database that supports this
    is HDB. In Chapter 2, we set up `slapd.conf` to store the `dc=example,dc=com`
    tree in an HDB backend.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了使此操作有效，后端数据库类型必须支持这种修改。目前，唯一支持这种修改的存储数据库是HDB。在第二章中，我们设置了`slapd.conf`以在HDB后端存储`dc=example,dc=com`树。
- en: 'Now, we can issue a compound ModRDN operation, in which we change the record''s
    RDN, and move the record to a different OU:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以执行一个复合ModRDN操作，在此操作中，我们更改记录的RDN，并将记录移动到另一个OU：
- en: '[PRE111]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: In this example, we change the user's UID from `manny` back to `immanuel`. Since
    `deleteoldrdn` is `1`, the old RDN (`uid=manny`) will be removed from the record.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将用户的UID从`manny`更改回`immanuel`。由于`deleteoldrdn`为`1`，旧的RDN（`uid=manny`）将从记录中删除。
- en: The `newsuperior` instruction tells SLAPD what the new base portion of the DN
    ought to be. This will effectively move the record from the `ou=users` branch
    to the `ou=system` branch of our directory information tree.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '`newsuperior`指令告诉SLAPD DN的新基础部分应该是什么。这将有效地把记录从`ou=users`分支移动到我们目录信息树中的`ou=system`分支。'
- en: Note
  id: totrans-768
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike modifying a user's RDN, changing a record's superior will not modify
    any of the fields in the record. Thus, our record above would still have the `ou=Users`
    attribute.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 与修改用户的RDN不同，更改记录的上级不会修改记录中的任何字段。因此，我们上面的记录仍然会保留`ou=Users`属性。
- en: 'Again, we can use `ldapsearch` to see the newly modified record:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以使用`ldapsearch`查看已修改的记录：
- en: '[PRE112]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'And, we get:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们得到：
- en: '[PRE113]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Notice that not only has the `uid` changed, but also the `ou` in the DN.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不仅`uid`已更改，DN中的`ou`也发生了变化。
- en: In order to use the `newsuperior` instruction, you must first specify a `modrdn`.
    Thus, if we wanted to move the record for this user back to the users OU, we would
    still have to specify the user's new RDN.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`newsuperior`指令，必须首先指定`modrdn`。因此，如果我们想将该用户的记录移动回用户OU，我们仍然需要指定该用户的新RDN。
- en: So how do you move a record without changing the RDN?
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何在不更改RDN的情况下移动记录呢？
- en: 'Since the `modrdn` change-type does not require that the new RDN be different
    from the old one, a record can be moved with `modrdn` simply by setting the `newrdn`
    to be the same as the old RDN:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`modrdn`变更类型不要求新RDN与旧RDN不同，因此只需将`newrdn`设置为与旧RDN相同，即可使用`modrdn`移动记录：
- en: '[PRE114]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'In this case, `newrdn: uid=immanuel` does not actually change the RDN of the
    user. But this is necessary in order to change the superior.'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '在此情况下，`newrdn: uid=immanuel`实际上并没有更改用户的RDN。但这是为了更改上级所必须的。'
- en: 'The `newsuperior` instruction indicates that the record should be moved (back)
    to the `ou=users,dc=example,dc=com` tree. One last `ldapsearch` of this record
    shows us the results of that change:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '`newsuperior`指令表示记录应该被移动（回到）`ou=users,dc=example,dc=com`树。对该记录进行最后一次`ldapsearch`，我们可以看到该变更的结果：'
- en: '[PRE115]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Once again, the record is back in the `Users` OU.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，记录回到了`Users` OU。
- en: Deleting Entire Records
  id: totrans-783
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除整个记录
- en: 'Finally, using the `delete` change-type, we can delete an entire record with
    `ldapmodify`:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`delete`变更类型，我们可以通过`ldapmodify`删除整个记录：
- en: '[PRE116]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: When deleting a record all we need to specify are the DN and the change-type.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 删除记录时，我们只需指定DN和变更类型。
- en: Essentially, using the delete change-type performs the same task as is done
    using the `ldapdelete` client.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，使用删除更改类型执行的任务与使用`ldapdelete`客户端执行的任务相同。
- en: ldapdelete
  id: totrans-788
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ldapdelete
- en: The `ldapdelete` tool is used to delete one or more records from the directory.
    It performs the same operation as the `delete` change-type used in `ldapmodify`.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldapdelete`工具用于从目录中删除一个或多个记录。它执行与`ldapmodify`中使用的`delete`更改类型相同的操作。'
- en: If you want to delete a record with `ldapdelete`, you must know its DN. This
    tool will not search for, say, all records that have a specified address, and
    then delete them all.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用`ldapdelete`删除一条记录，必须知道它的DN。此工具不会搜索，例如，所有具有指定地址的记录，然后删除它们。
- en: 'The syntax of the `ldapdelete` command is simple:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldapdelete`命令的语法很简单：'
- en: '[PRE117]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: After the usual flags (`-x`, `-w`, `-D`), `ldapdelete` takes the DN that is
    to be deleted (this is the DN for `uid=nicholas` on the second line of the command).
    Upon execution it will request that the server delete the record. Assuming that
    the record exists and the user is allowed (by the server's ACLs) to delete the
    record, then the record will be removed from the directory.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 在常见的标志（`-x`、`-w`、`-D`）之后，`ldapdelete`接受要删除的DN（这是命令第二行中的`uid=nicholas`的DN）。执行时，它将请求服务器删除该记录。如果记录存在且用户（根据服务器的ACL）被允许删除记录，那么该记录将从目录中移除。
- en: ldapcompare
  id: totrans-794
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ldapcompare
- en: This tool is used to ask the server whether a particular entry (identified by
    a DN) has a particular attribute that matches the attribute specified. If the
    entry does have a matching attribute, then `ldapcompare` returns `TRUE`. Otherwise,
    it returns `FALSE`.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具用于询问服务器某个特定条目（通过DN标识）是否具有与指定属性匹配的属性。如果该条目确实具有匹配的属性，则`ldapcompare`返回`TRUE`。否则，返回`FALSE`。
- en: 'Here is a pair of examples:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一对示例：
- en: '[PRE118]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'In the first example `ldapcompare` requested that the server examine the record
    for `uid=david,ou=Users,dc=example,dc=com` to see if it had the attribute `givenName`
    with the value `David`. The record did have an attribute `givenName: David`, and
    so the return value is `TRUE`.'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '在第一个示例中，`ldapcompare`请求服务器检查`uid=david,ou=Users,dc=example,dc=com`的记录，查看它是否具有值为`David`的`givenName`属性。记录确实具有`givenName:
    David`属性，因此返回值为`TRUE`。'
- en: The second example performed a similar compare on the same record; it looked
    for the attribute `cn` with the value `Dave Hume`. While the record does have
    a `cn` attribute, the value of that attribute is `David Hume`, not `Dave Hume`.
    So the server returned `FALSE`.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例对相同的记录执行了类似的比较；它查找值为`Dave Hume`的`cn`属性。虽然该记录具有`cn`属性，但该属性的值为`David Hume`，而不是`Dave
    Hume`。因此，服务器返回了`FALSE`。
- en: Tip
  id: totrans-800
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Base-64 Encoding with ldapcompare**'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用ldapcompare进行Base-64编码**'
- en: 'In cases where the value to compare is not an ASCII string, you should base-64
    encode the value and use the double colon syntax (`::`) that we used in our LDIF
    files. Example: `givenName::RGF2aWQ=`'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 在值进行比较时，如果该值不是ASCII字符串，应该将该值进行Base-64编码，并使用我们在LDIF文件中使用的双冒号语法（`::`）。例如：`givenName::RGF2aWQ=`
- en: An LDAP compare operation is often much faster than a search operation. In cases
    where the same task can be accomplished with `ldapsearch` and `ldapcompare`, it
    is often more efficient to use `ldapcompare`.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP比较操作通常比搜索操作要快得多。在可以通过`ldapsearch`和`ldapcompare`完成相同任务的情况下，通常使用`ldapcompare`更高效。
- en: ldapmodrdn
  id: totrans-804
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ldapmodrdn
- en: 'The `ldapmodrdn` client is used to change the Relative DN (RDN) portion of
    a DN. This client requests a ModifyDN operation. `ldapmodrdn` takes the full DN
    of an existing record, and the relative DN that should replace the existing RDN
    for the record:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldapmodrdn`客户端用于更改DN的相对DN（RDN）部分。该客户端请求一个ModifyDN操作。`ldapmodrdn`接受一个现有记录的完整DN和应该替换现有RDN的相对DN：'
- en: '[PRE119]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This example requests that the RDN for `uid=immanual,ou=Users,dc=example,dc=com`
    be changed from `uid=immanuel` to `uid=manny`.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例请求将`uid=immanual,ou=Users,dc=example,dc=com`的RDN从`uid=immanuel`更改为`uid=manny`。
- en: 'Now let''s take a look at the record after the change. We will search by the
    `sn` field:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们查看更改后的记录。我们将通过`sn`字段进行搜索：
- en: '[PRE120]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Here, the filter is looking for records with the surname `Kant` and requesting
    that only the `uid` attribute be returned. Recall that we did not ever add a `uid`
    attribute with the value `manny`—we only had `uid: immanuel`.'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，过滤器正在查找姓氏为`Kant`的记录，并请求仅返回`uid`属性。回想一下，我们从未添加过`uid`属性值为`manny`的记录——我们只有`uid:
    immanuel`。'
- en: But looking at the results, we can see that not only has the DN been modified,
    but a new user ID attribute has been added for us. In some cases it is fine that
    the modification of the RDN results in adding (rather than replacing) an attribute
    value. But in other cases this is inconvenient or even illegal (because of the
    schema).
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 但是从结果来看，我们可以看到不仅DN已被修改，而且一个新的用户ID属性也被添加了。在某些情况下，修改RDN导致添加（而不是替换）属性值是可以的。但在其他情况下，这样做会很不方便，甚至是非法的（因为架构的原因）。
- en: 'For example, we might have a record in the directory that describes a subtree
    of records that have to do with the company website. Such a record might look
    like this:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能在目录中有一个描述与公司网站相关的记录子树的条目。这样的记录可能如下所示：
- en: '[PRE121]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Now, say we wanted to change the RDN to point not to `www`, but to `web`. Using
    `ldapmodrdn` the way we did earlier would generate an error:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想将RDN从`www`更改为`web`。像之前那样使用`ldapmodrdn`会导致错误：
- en: '[PRE122]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The reason for this error is that the schema definition for `dc` specifies that
    there can be only one `dc` attribute value per record.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 出现此错误的原因是`dc`的架构定义指定每个记录中只能有一个`dc`属性值。
- en: Note
  id: totrans-817
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `dc` (or `domainComponent`) attribute is defined in `core.schema`.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '`dc`（或`domainComponent`）属性在`core.schema`中有定义。'
- en: The solution to this problem is to use the `-r` flag for `ldapmodrdn`.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的方法是为`ldapmodrdn`使用`-r`标志。
- en: '[PRE123]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The `-r` flag causes `ldapmodrdn` to replace, rather than add, the existing
    attribute value. Now the resulting record looks like this:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '`-r`标志使得`ldapmodrdn`替换现有的属性值，而不是添加它。现在结果记录看起来是这样的：'
- en: '[PRE124]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: There is only one `dc` attribute listed, and it has the newly set value, `web`.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的只有一个`dc`属性，并且它具有新设置的值`web`。
- en: Modifying the Superior DN with ldapmodrdn
  id: totrans-824
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`ldapmodrdn`修改上级DN
- en: Just as we saw earlier with the `modrdn` change-type for ldapmodify, we can
    change the superior DN (the base portion of a record's DN) with `ldapmodrdn`.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前看到的`ldapmodify`的`modrdn`类型变更一样，我们也可以使用`ldapmodrdn`来更改上级DN（记录DN的基础部分）。
- en: Tip
  id: totrans-826
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The Right Backend**'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '**正确的后端**'
- en: Not all backends support this type of renaming. Currently, the HDB backend is
    the only storage backend to support changing the superior reference in a DN. Other
    non-storage backends (like `ldap`) may pass on these operations to the underlying
    storage mechanism, which in turn may or may not support this degree of renaming.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有的后端都支持这种类型的重命名。目前，只有HDB后端支持更改DN中的上级引用。其他非存储后端（如`ldap`）可能会将这些操作传递给底层存储机制，而该机制可能会或可能不会支持这种程度的重命名。
- en: Also, as with the `modrdn` change type, `ldapmodrdn` must specify a replacement
    RDN even if that RDN is the same as the current one. In other words, an RDN is
    required, even if the RDN is not a new RDN. We will see an example of this below.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，与`modrdn`类型变更一样，`ldapmodrdn`必须指定一个替换的RDN，即使这个RDN与当前的RDN相同。换句话说，即使RDN不是新的，仍然需要指定RDN。我们将在下面看到一个例子。
- en: 'The `-s` flag for `ldapmodrdn` specifies the new superior DN. Thus, to move
    the entry `uid=barbara,ou=users,dc=example,dc=com` to the `ou=system` branch of
    the directory, we can use a command like this:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldapmodrdn`的`-s`标志指定了新的上级DN。因此，要将条目`uid=barbara,ou=users,dc=example,dc=com`移动到目录中的`ou=system`分支，我们可以使用如下命令：'
- en: '[PRE125]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'This is a long command, and it is thus broken up into three lines:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个较长的命令，因此分成了三行：
- en: The first line contains the flags that handle binding to the directory, and
    these should be familiar by now.
  id: totrans-833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行包含了用于绑定到目录的标志，这些标志现在应该已经很熟悉了。
- en: The second line begins with the `-s` flag, which takes a DN for a parameter.
    This is the flag that specifies what the new superior DN will be. In this case,
    it is `ou=system,dc=example,dc=com`.
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行以`-s`标志开始，后面跟着一个DN作为参数。这个标志指定了新的上级DN是什么。在这个例子中，它是`ou=system,dc=example,dc=com`。
- en: The `-r` flag, as we have seen before, instructs SLAPD to replace the old RDN
    with the new one.
  id: totrans-835
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们之前所见，`-r`标志指示SLAPD用新的RDN替换旧的RDN。
- en: On the third line is the DN for the entry we want to modify, `uid=barbar,ou=users,dc=example,dc=com`,
    and the new RDN. Since we want to keep the same RDN (but move the record to a
    new subtree), we set this last value to `uid=barbara`, which is the RDN that the
    existing record has.
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行是我们要修改的条目的DN，`uid=barbar,ou=users,dc=example,dc=com`，以及新的RDN。由于我们希望保持相同的RDN（但将记录移动到新的子树），因此我们将最后一个值设置为`uid=barbara`，这是现有记录的RDN。
- en: 'After we run this command we can see the results with `ldapsearch`:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，我们可以使用`ldapsearch`查看结果：
- en: '[PRE126]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The base portion of Barbara's new record is now `ou=system,dc=example,dc=com`.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: Barbara的新记录的基本部分现在是`ou=system,dc=example,dc=com`。
- en: 'Just as with the `modrdn` changetype for `ldapmodify`, changing a superior
    entry will not change any attributes in the record. Thus, even though this record
    is now in the sytem OU, it still has the attribute `ou: Users`.'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '就像在`ldapmodify`的`modrdn`变更类型中一样，修改上级条目不会改变记录中的任何属性。因此，即使这个记录现在位于系统OU中，它仍然具有`ou:
    Users`属性。'
- en: 'It is possible to construct Relative DNs that have more than one attribute
    value. For example, I can use a combination of `uid` and `l` (for location) in
    the RDN portion:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 构建具有多个属性值的相对DN是可能的。例如，我可以在RDN部分中使用`uid`和`l`（用于位置）的组合：
- en: '[PRE127]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: In such cases, the plus sign (`+`) is used to indicate that both the attribute
    are to be considered part of the RDN.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用加号（`+`）表示这两个属性都应该被视为RDN的一部分。
- en: '`ldapmodrdn` is smart enough to handle these cases. It will add (or replace)
    all of the attributes used in the RDN.'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldapmodrdn`足够智能，能够处理这些情况。它将添加（或替换）RDN中使用的所有属性。'
- en: 'In the case where the `-r` flag is specified, there are some things to be aware
    of. First, `ldapmodrdn` will replace all of the fields used in the new RDN. Second,
    if there is a value in the initial RDN that is removed from the RDN, then the
    attribute value will be removed from the record as well. For example, here is
    our starting record:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定了`-r`标志的情况下，有一些需要注意的事项。首先，`ldapmodrdn`将替换新RDN中使用的所有字段。其次，如果初始RDN中有被从RDN中移除的值，那么该属性值也将从记录中移除。例如，以下是我们的起始记录：
- en: '[PRE128]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Notice that the DN uses both the `cn` and the `l` attributes, both of which
    are present in the body of the record. Now, if we use `ldapmodrdn` with the `-r`
    flag and replace `cn=Matt Butcher+l=Chicago` with `cn=Matt Butcher`, the `l: Chicago`
    attribute will be removed from the record:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，DN使用了`cn`和`l`两个属性，这两个属性都出现在记录的主体中。现在，如果我们使用`ldapmodrdn`并加上`-r`标志，将`cn=Matt
    Butcher+l=Chicago`替换为`cn=Matt Butcher`，`l: Chicago`属性将从记录中删除：'
- en: '[PRE129]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: So, when using `ldapmodrdn` with multi-attribute RDNs, be judicious when using
    the `-r` flag.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在使用带有多属性RDN的`ldapmodrdn`时，应谨慎使用`-r`标志。
- en: ldappasswd
  id: totrans-850
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ldappasswd
- en: In the utilities section we looked at encrypting passwords with `slappasswd`.
    That tool was used to generate encrypted values for inclusion in LDIF files. The
    `ldappasswd` client, in contrast, connects to the server and changes a password
    value in the directory. If needed it can be used to automatically generate a password,
    as well.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 在实用工具部分，我们查看了如何使用`slappasswd`加密密码。该工具用于生成加密的值，以便包含在LDIF文件中。与此不同，`ldappasswd`客户端连接到服务器并在目录中更改密码值。如果需要，它还可以用来自动生成密码。
- en: Unlike `ldapadd` and `ldapmodify`, which use the LDAP v.3 standard Add and Modify
    operations, the `ldappasswd` client uses an extension operation—the **LDAP Password
    Modify Extended Operation** as defined in RFC 3062 ([http://rfc-editor.org/rfc/rfc3062.txt](http://rfc-editor.org/rfc/rfc3062.txt)).
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用LDAP v.3标准的Add和Modify操作的`ldapadd`和`ldapmodify`不同，`ldappasswd`客户端使用的是扩展操作——**LDAP密码修改扩展操作**，该操作在RFC
    3062中有定义（[http://rfc-editor.org/rfc/rfc3062.txt](http://rfc-editor.org/rfc/rfc3062.txt)）。
- en: Note
  id: totrans-853
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When loading passwords from an LDIF file, or from `ldapadd` or `ldapmodify`,
    if you send the server a cleartext password, the password will be stored in the
    directory in an unencrypted string. This is not safe. You should either use `slappasswd`
    to generate an encrypted password for inclusion in an LDIF, or you should use
    `ldappasswd` to set the password.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 当从LDIF文件加载密码，或通过`ldapadd`或`ldapmodify`时，如果你发送给服务器的是明文密码，该密码将以未加密的字符串形式存储在目录中。这是不安全的。你应该使用`slappasswd`生成加密密码并将其包含在LDIF文件中，或者使用`ldappasswd`来设置密码。
- en: 'As long as the ACLs permit, a user can change her or his password with the
    `ldappasswd` client:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 只要ACL允许，用户就可以使用`ldappasswd`客户端更改她或他的密码：
- en: '[PRE130]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The `-S` flag is the only new flag used here. It indicates that `ldappasswd`
    should prompt the user to enter (and re-enter) a new password. The `-W` flag,
    as you may recall, prompts the user to enter a current password interactively.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '`-S`标志是这里唯一使用的新标志。它表示`ldappasswd`应该提示用户输入（并重新输入）新密码。如你所记得，`-W`标志则提示用户交互式地输入当前密码。'
- en: The order in which the user enters the passwords differs from the norm. The
    user is prompted to first enter and re-enter a new password, and then to enter
    the current password.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入密码的顺序与常规不同。用户首先被提示输入并重新输入新密码，然后再输入当前密码。
- en: 'It is also possible for an administrator (or one with write permissions to
    the `userPassword` attribute of a given record) to change a password for another
    user:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员（或具有`userPassword`属性写入权限的用户）也可以更改其他用户的密码：
- en: '[PRE131]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'In this case the directory manager is changing the value of the `userPassword`
    attribute for `uid=barbara,ou=Users,dc=example,dc=com`. Rather than using `-S`
    and entering the password at an interactive prompt, the password has been specified
    on the command line: `-s secret`.'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，目录管理员正在更改`uid=barbara,ou=Users,dc=example,dc=com`的`userPassword`属性值。与使用`-S`并在交互提示符下输入密码不同，密码已在命令行中指定：`-s
    secret`。
- en: 'The password, when changed through `ldappasswd`, is automatically encrypted
    by the server before it is stored in the record:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ldappasswd`更改密码时，密码会在存储到记录中之前由服务器自动加密：
- en: '[PRE132]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'If we decode the `userPassword` value, it reads: `{SSHA}S1SRt5nI/pvF8kwRIUSrwNDGdqRKxNCV`.
    The password is stored in an irreversible SSHA hash.'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们解码`userPassword`值，结果是：`{SSHA}S1SRt5nI/pvF8kwRIUSrwNDGdqRKxNCV`。该密码以不可逆的
    SSHA 哈希格式存储。
- en: Tip
  id: totrans-865
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Setting the Default Encryption Scheme**'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置默认加密方案**'
- en: 'You can specify which encryption scheme the server should choose when encrypting
    passwords. To specify the algorithm, use the `password-hash` directive in `slapd.conf`.
    Example: `password-hash {SMD5}`'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定服务器在加密密码时选择哪种加密方案。要指定算法，请在`slapd.conf`中使用`password-hash`指令。例如：`password-hash
    {SMD5}`
- en: 'Finally, `ldappasswd` can request that the server generate a strong password
    for that DN. If no flag is set that indicates, the source of the password (for
    example `-s`, `-S`, or `-T`), then `ldappasswd` requests that one be generated.
    Here is the request:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`ldappasswd`可以请求服务器为该 DN 生成一个强密码。如果没有设置标志来指示密码的来源（例如`-s`、`-S`或`-T`），那么`ldappasswd`将请求生成一个密码。以下是请求：
- en: '[PRE133]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The server responded to this request with a generated password, `New password:
    dS9R4Kvc`, which has already been encrypted and stored in the `userPassword` attribute
    on the server.'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '服务器响应了这个请求，并生成了一个密码`New password: dS9R4Kvc`，该密码已被加密并存储在服务器的`userPassword`属性中。'
- en: ldapwhoami
  id: totrans-871
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ldapwhoami
- en: The last client in the OpenLDAP suite is `ldapwhoami`. This client provides
    a client implementation of the **"Who am I?" Extended Operation**. This operation
    provides information about the DN who is currently bound to the directory.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP 套件中的最后一个客户端是`ldapwhoami`。该客户端提供了**“我是谁？”扩展操作**的客户端实现。该操作提供了当前与目录绑定的
    DN 的信息。
- en: 'The `ldapwhoami` command simply requires enough information to authenticate
    to the directory server:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldapwhoami`命令仅需要足够的信息来验证目录服务器：'
- en: '[PRE134]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: As you can see from this example, all this client does is reply with the DN
    of the user we connected with. This tool comes in useful when debugging SASL authentication,
    which does not require a DN to connect. We will look at SASL configuration in
    the next chapter.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从这个例子中可以看出，这个客户端只会返回我们连接的用户的 DN。这个工具在调试不需要 DN 来连接的 SASL 身份验证时非常有用。我们将在下一章讨论
    SASL 配置。
- en: Summary
  id: totrans-876
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we have taken a closer look at the tools in the OpenLDAP suite.
    We began by looking at the SLAPD and SLURPD servers. In particular, we looked
    at the major LDAP operations, such as bind, search, add, modify, and delete.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了 OpenLDAP 套件中的工具。我们首先查看了 SLAPD 和 SLURPD 服务器。特别是，我们了解了主要的 LDAP 操作，如绑定（bind）、搜索（search）、添加（add）、修改（modify）和删除（delete）。
- en: Next we created a basic directory information tree in an LDIF file. In doing
    this, we familiarized ourselves with LDIF—the text format for representing LDAP
    directory data.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在一个 LDIF 文件中创建了一个基本的目录信息树。在此过程中，我们熟悉了 LDIF——用于表示 LDAP 目录数据的文本格式。
- en: From there we looked at the utilities and clients in the OpenLDAP suite. Along
    the way, we loaded our directory information tree from LDIF into the directory,
    and then added to and modified that data.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们查看了 OpenLDAP 套件中的实用工具和客户端。在此过程中，我们将目录信息树从 LDIF 加载到目录中，然后添加和修改了这些数据。
- en: At this point you should be comfortable working with the tools included in OpenLDAP.
    In the next chapter we are going to return to the SLAPD server and take a close
    look at LDAP security.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你应该已经能够熟练使用 OpenLDAP 中包含的工具。在下一章中，我们将回到 SLAPD 服务器，并深入了解 LDAP 安全。
