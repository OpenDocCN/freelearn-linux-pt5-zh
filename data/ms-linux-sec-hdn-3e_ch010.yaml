- en: 9 Access Control Lists and Shared Directory Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 访问控制列表与共享目录管理
- en: Join our book community on Discord
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的书籍社区，在Discord上与我们互动
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/file59.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file59.png)'
- en: In the previous chapter, we reviewed the basics of **Discretionary Access Control**
    (**DAC**). Normal Linux file and directory permissions settings aren't very granular.
    With an **access control list** (**ACL**), we can fine-tune things to get the
    exact set of permissions that we really want. We can also use this capability
    to control access to files in shared directories.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们回顾了**自主访问控制**（**DAC**）的基础知识。正常的Linux文件和目录权限设置不够细粒度。使用**访问控制列表**（**ACL**），我们可以精细调整权限，以获得我们真正需要的权限集。我们还可以利用这一能力来控制对共享目录中文件的访问。
- en: 'The topics in this chapter include the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题包括以下内容：
- en: Creating an ACL for either a user or a group
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户或组创建ACL
- en: Creating an inherited ACL for a directory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为目录创建继承的ACL
- en: Removing a specific permission by using an ACL mask
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ACL掩码移除特定权限
- en: Using the `tar --acls` option to prevent loss of ACLs during a backup
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tar --acls`选项来防止备份过程中丢失ACL
- en: Creating a user group and adding members to it
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个用户组并添加成员
- en: Creating a shared directory for a group, and setting the proper permissions
    on it
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为组创建共享目录，并设置适当的权限
- en: Setting the SGID bit and the sticky bit on the shared directory
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置共享目录上的SGID位和粘滞位
- en: Using ACLs to allow only certain members of the group to access a file in the
    shared directory
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ACL仅允许小组中的特定成员访问共享目录中的文件
- en: Creating an ACL for either a user or a group
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为用户或组创建ACL
- en: The normal Linux file and directory permissions settings are okay, but they're
    not very granular. With an ACL, we can allow only a certain person to access a
    file or directory, or we can allow multiple people to access a file or directory
    with different permissions for each person. If we have a file or a directory that's
    wide open for everyone, we can use an ACL to allow different levels of access
    for either a group or an individual. Toward the end of the chapter, we'll put
    what we've learned all together in order to manage a shared directory for a group.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的Linux文件和目录权限设置是可以的，但它们不够细粒度。使用ACL，我们可以仅允许某个人访问文件或目录，或者允许多个不同的人访问文件或目录，并为每个人设置不同的权限。如果我们有一个对所有人开放的文件或目录，我们可以使用ACL为某个组或个人设置不同级别的访问权限。在本章的最后，我们将把所学的知识结合起来，以管理一个小组共享目录。
- en: 'You would use `getfacl` to view an ACL for a file or directory. (Note that
    you can''t use them to view all files in a directory at once.) To begin, let''s
    use `getfacl` to see if we have any ACLs already set on the `acl_demo.txt` file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`getfacl`查看文件或目录的ACL。（注意，你不能用它一次性查看目录中的所有文件。）首先，我们使用`getfacl`查看是否已经在`acl_demo.txt`文件上设置了ACL：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All we see here are just the normal permissions settings, so there's no ACL.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们看到的只是正常的权限设置，因此没有ACL。
- en: 'The first step for setting an ACL is to remove all permissions from everyone
    except for the user of the file. That''s because the default permissions settings
    allow members of the group to have read/write access, and others to have read
    access. So, setting an ACL without removing those permissions would be rather
    senseless:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 设置ACL的第一步是将文件所有者以外的所有人权限移除。这是因为默认的权限设置允许组成员具有读/写权限，其他人具有读权限。所以，如果不移除这些权限，直接设置ACL是没有意义的：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When using `setfacl` to set an ACL, you can allow a user or a group to have
    any combination of read, write, or execute privileges. In our case, let''s say
    that I want to let Maggie read the file and to prevent her from having write or
    execute privileges:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setfacl`设置ACL时，你可以为用户或组设置任意组合的读、写或执行权限。以我们的例子为例，假设我想让Maggie读取文件，但不允许她具有写或执行权限：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `-m` option of `setfacl` means that we're about to modify the ACL. (Well,
    to *create* one in this case, but that's okay.) `u:` means that we're setting
    an ACL for a user. We then list the user's name, followed by another colon, and
    the list of permissions that we want to grant to this user. In this case, we're
    only allowing Maggie read access. We complete the command by listing the file
    to which we want to apply this ACL. The `getfacl` output shows that Maggie does
    indeed have read access. Finally, we see in the `ls -l` output that the group
    is listed as having read access, even though we've set the `600` permissions settings
    on this file. But, there's also a `+` sign, which tells us that the file has an
    ACL. When we set an ACL, the permissions for the ACL show up as group permissions
    in `ls -l`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`setfacl`的`-m`选项意味着我们即将修改ACL。（好吧，在这种情况下是*创建*一个，但没关系。）`u:`表示我们正在为用户设置ACL。然后列出该用户的名字，后跟冒号，以及我们想要授予该用户的权限列表。在此案例中，我们只允许Maggie读取权限。通过列出我们要应用此ACL的文件来完成该命令。`getfacl`的输出显示Maggie确实具有读取权限。最后，我们在`ls
    -l`的输出中看到，尽管我们已为该文件设置了`600`权限，但组仍然被列为具有读权限。但也有一个`+`符号，表示该文件有ACL。当我们设置ACL时，ACL的权限会作为组权限出现在`ls
    -l`中。'
- en: 'To take this a step further, let''s say that I want Frank to have read/write
    access to this file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明，假设我想让Frank对这个文件具有读/写访问权限：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, we can have two or more different ACLs assigned to the same file. In the
    `ls -l` output, we see that we have `rw` permissions set for the group, which
    is really just a summary of permissions that we've set in the two ACLs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们可以将两个或更多不同的ACL分配给同一个文件。在`ls -l`输出中，我们看到为组设置了`rw`权限，这实际上只是我们在两个ACL中设置的权限的汇总。
- en: 'We can set an ACL for group access by replacing `u:` with a `g:`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`u:`替换为`g:`来为组访问设置ACL：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Members of the `accounting` group now have read access to this file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`accounting`组的成员现在可以读取这个文件。'
- en: Creating an inherited ACL for a directory
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为目录创建继承的ACL
- en: There may be times when you'll want all files that get created in a shared directory
    to have the same ACL. We can do that by applying an inherited ACL to the directory.
    Although, understand that even though this sounds like a cool idea, creating files
    in the normal way will cause files to have the read/write permissions set for
    the group, and the read permission set for others. So, if you're setting this
    up for a directory where users just create files normally, the best that you can
    hope to do is to create an ACL that adds either the write or execute permissions
    for someone. Either that or ensure that users set the `600` permissions settings
    on all files that they create, assuming that users really do need to restrict
    access to their files.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能希望所有在共享目录中创建的文件都拥有相同的ACL。我们可以通过对目录应用继承的ACL来实现这一点。不过，需要理解的是，尽管这听起来像个不错的主意，但以正常方式创建的文件将使文件对组设置读/写权限，并为其他人设置读权限。所以，如果你为一个用户通常创建文件的目录进行设置，最好的情况是创建一个ACL，给某些人添加写或执行权限。或者，确保用户在创建文件时设置`600`权限，前提是用户确实需要限制对他们文件的访问。
- en: On the other hand, if you're creating a shell script that creates files in a
    specific directory, you can include `chmod` commands to ensure that the files
    get created with the restrictive permissions that are necessary to make your ACL
    work as intended.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你正在创建一个在特定目录中创建文件的shell脚本，你可以包含`chmod`命令，以确保文件在创建时拥有必要的限制性权限，从而使你的ACL按预期工作。
- en: 'To demo, let''s create the `new_perm_dir` directory, and set the inherited
    ACL on it. I want to have read/write access for files that my shell script creates
    in this directory, and for Frank to have only read access. I don''t want anyone
    else to be able to read any of these files:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们来创建`new_perm_dir`目录，并在其上设置继承的ACL。我希望我的shell脚本在这个目录中创建的文件拥有读/写访问权限，并且Frank仅具有读权限。我不希望其他任何人能够读取这些文件：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'All I had to do to make this an inherited ACL was to add `d:` before `u:frank`.
    I left the default permissions settings on the directory, which allows everyone
    read access to the directory. Next, I''ll create the `donnie_script.sh` shell
    script, which will create a file within that directory, and that will set read/write
    permissions for only the user of the new files:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我所需要做的只是通过在`u:frank`前添加`d:`，使其成为继承的ACL。我保留了目录的默认权限设置，这允许每个人读取目录。接下来，我将创建`donnie_script.sh`
    shell脚本，该脚本将在该目录中创建一个文件，并为新文件的用户设置读/写权限：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After making the script executable, I''ll run it and view the results:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使脚本可执行后，我将运行它并查看结果：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, `new_file.txt` got created with the correct permissions settings, and with
    an ACL that allows Frank to read it. (I know that this is a really simplified
    example, but you get the idea.)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`new_file.txt`已经创建，且权限设置正确，并且为Frank提供了读取权限。（我知道这是一个非常简化的例子，但你明白我的意思。）
- en: Removing a specific permission by using an ACL mask
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过使用ACL掩码删除特定权限
- en: 'You can remove an ACL from a file or directory with the `-x` option. Let''s
    go back to the `acl_demo.txt` file that I created earlier, and remove the ACL
    for Maggie:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`-x`选项从文件或目录中删除ACL。让我们回到之前创建的`acl_demo.txt`文件，并删除Maggie的ACL：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So, Maggie''s ACL is gone. But, the `-x` option removes the entire ACL, even
    if that''s not what you really want. If you have an ACL with multiple permissions
    set, you might just want to remove one permission, leaving the others. Here, we
    see that Frank still has his ACL that grants him read/write access. Let''s now
    say that we want to remove the write permission, while still allowing him the
    read permission. For that, we''ll need to apply a mask:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，Maggie的ACL消失了。但`-x`选项会删除整个ACL，即使这不是你真正想要的。如果你有一个具有多个权限设置的ACL，你可能只想删除其中一个权限，保留其他权限。在这里，我们看到Frank仍然拥有他的ACL，允许他读写访问。现在，假设我们想要删除写权限，同时仍然允许他保留读权限。为此，我们需要应用一个掩码：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`m::r` sets a read-only mask on the ACL. Running `getfacl` shows that Frank
    still has a read/write ACL, but the comment to the side shows his effective permissions
    to be read-only. So, Frank''s write permission for the file is now gone. And,
    if we had ACLs set for other users, this mask would affect them the same way.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`m::r`在ACL上设置了只读掩码。运行`getfacl`显示，Frank仍然拥有读写ACL，但旁边的注释显示他的有效权限是只读。因此，Frank的写权限现在已被删除。而且，如果我们为其他用户设置了ACL，这个掩码也会以相同的方式影响他们。'
- en: Using the tar --acls option to prevent the loss of ACLs during a backup
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用tar的`--acls`选项来防止在备份过程中丢失ACL
- en: 'If you ever need to use `tar` to create a backup of either a file or a last
    two files:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用`tar`来备份一个文件或最后两个文件：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, I''ll do the backup without `--acls`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将不使用`--acls`进行备份：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It looks good, right? Ah, but looks can be deceiving. Watch what happens when
    I delete the directory, and then restore it from the backup:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，对吧？啊，但外表可能会欺骗你。看看当我删除目录，然后从备份中恢复时会发生什么：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I don''t even have to use `getfacl` to see that the ACLs are gone from the
    `perm_demo_dir` directory and all of its files, because the `+` signs are now
    gone from them. Now, let''s see what happens when I include the `--acls` option.
    First, I''ll show you that an ACL is set for this directory and its only file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至不需要使用`getfacl`来查看ACL已经从`perm_demo_dir`目录及其所有文件中消失，因为它们的`+`符号现在都没有了。现在，让我们看看当我使用`--acls`选项时会发生什么。首先，我将向你展示该目录及其唯一文件的ACL已设置：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, I''ll use the `tar` command with the `--acls` option:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将使用带有`--acls`选项的`tar`命令：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'I''ll now delete the `new_perm_dir` directory and restore it from backup. As
    we did before, we’ll use the `--acls` option:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在将删除`new_perm_dir`目录并从备份中恢复它。就像我们之前做的那样，我们将使用`--acls`选项：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The presence of the `+` signs indicates that the ACLs did survive the backup-and-restore
    procedure. The one slightly tricky part about this is that you must use `--acls`
    for both the backup and the restoration. If you omit the option either time, you
    will lose your ACLs.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`符号的存在表明ACL在备份和恢复过程中保留了下来。唯一稍微有点棘手的是，你必须在备份和恢复时都使用`--acls`选项。如果你在其中任何一个过程中省略了此选项，你将丢失ACL。'
- en: Creating a user group and adding members to it
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户组并向其中添加成员
- en: So far, I've been doing all of the demos inside my own home directory, just
    for the sake of showing the basic concepts. But the eventual goal is to show you
    how to use this knowledge to do something more practical, such as controlling
    file
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我一直在自己的家目录中做演示，仅仅是为了展示基本概念。但最终的目标是向你展示如何利用这些知识做一些更实际的事情，比如控制文件
- en: 'Let''s say that we want to create a `marketing` group for members of—you guessed
    it—the marketing department:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想为—你猜对了—市场部门的成员创建一个`marketing`组：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s now add some members. We can do that in three different ways:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加一些成员。我们可以通过三种不同的方式来实现：
- en: Add members as we create their user accounts.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建用户账户时添加成员。
- en: Use `usermod` to add members that already have user accounts.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`usermod`来添加已有用户账户的成员。
- en: Edit the `/etc/group` file.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑`/etc/group`文件。
- en: Adding members as we create their user accounts
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在创建用户账户时添加成员
- en: 'First, we can add members to the group as we create their user accounts, using
    the `-G` option of `useradd`. On Red Hat, AlmaLinux, or CentOS, the command would
    look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以在创建用户帐户时通过 `useradd` 的 `-G` 选项将成员添加到组中。在 Red Hat、AlmaLinux 或 CentOS 上，命令应该是这样的：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On Debian/Ubuntu, the command would look like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Debian/Ubuntu 上，命令应该是这样的：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And, of course, I''ll need to assign Cleopatra a password in the normal manner:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我还需要按正常方式为 Cleopatra 设置密码：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using usermod to add an existing user to a group
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `usermod` 将现有用户添加到组中
- en: 'The good news is that this works the same on either Red Hat/CentOS/AlmaLinux
    or Debian/Ubuntu:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，这在 Red Hat/CentOS/AlmaLinux 或 Debian/Ubuntu 上的效果是一样的：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this case, the `-a` wasn't necessary, because Maggie wasn't a member of any
    other secondary group. But, if she had already belonged to another group, the
    `-a` would have been necessary to keep from overwriting any existing group information,
    thus removing her from the previous groups.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`-a` 选项并不是必需的，因为 Maggie 还不是其他任何二级组的成员。不过，如果她已经属于其他组，`-a` 选项是必要的，否则会覆盖任何现有的组信息，从而把她从之前的组中移除。
- en: This method is especially handy for use on Ubuntu systems, where it is necessary
    to use `adduser` in order to create encrypted home directories. (As we saw in
    a previous chapter, `adduser` doesn't give you the chance to add a user to a group
    as you create the account.)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在 Ubuntu 系统中尤其方便，因为在 Ubuntu 系统中创建加密的主目录时，必须使用 `adduser`。（正如我们在前一章节看到的，`adduser`
    在创建帐户时并没有给你机会将用户添加到组中。）
- en: Adding users to a group by editing the /etc/group file
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过编辑 `/etc/group` 文件将用户添加到组中
- en: 'This final method is a good way to cheat, to speed up the process of adding
    multiple existing users to a group. First, just open the `/etc/group` file in
    your favorite text editor, and look for the line that defines the group to which
    you want to add members:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最终的方法是一个很好的“作弊”方式，可以加快将多个现有用户添加到组中的过程。首先，只需用你喜欢的文本编辑器打开 `/etc/group` 文件，并查找定义你想要添加成员的组的那一行：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So, I''ve already added Cleopatra and Maggie to this group. Let''s edit this
    to add a couple more members:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我已经将 Cleopatra 和 Maggie 添加到这个组中了。接下来，我们编辑这个文件，添加几个新的成员：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When you're done, save the file and exit the editor.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，保存文件并退出编辑器。
- en: 'A `groups` command for each of them will show that our wee bit of cheating
    works just fine:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个用户运行 `groups` 命令将显示我们的“作弊”方式效果很好：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method is extremely handy for whenever you need to add lots of members
    to a group at the same time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在你需要一次性将许多成员添加到组时非常方便。
- en: Creating a shared directory
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建共享目录
- en: 'The next act in our scenario involves creating a shared directory that all
    the members of our marketing department can use. Now, this is another one of those
    areas that engenders a bit of controversy. Some people like to put shared directories
    in the root level of the filesystem, while others like to put shared directories
    in the `/home/` directory. Some people even have other preferences. But really,
    it''s a matter of personal preference and/or company policy. Other than that,
    it really doesn''t much matter where you put them. For our purposes, to make things
    simple, I''ll just create the directory in the root level of the filesystem:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，下一步是创建一个共享目录，供我们市场部门的所有成员使用。这个问题实际上会引发一些争议。有些人喜欢把共享目录放在文件系统的根目录下，而另一些人则喜欢把它放在
    `/home/` 目录下。还有一些人有其他的偏好。但实际上，这主要是个人喜好和/或公司政策的问题。除此之外，目录放在哪儿并不重要。为了简化问题，我会直接在文件系统的根目录下创建这个目录：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The new directory belongs to the root user. It has a permissions setting of
    `755`, which permits read and execute access to everybody, and write access only
    to the root user. What we really want is to allow only members of the marketing
    department to access this directory. We''ll first change ownership and group association,
    and then we''ll set the proper permissions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 新的目录属于 root 用户。它的权限设置为 `755`，允许所有人读取和执行，只有 root 用户拥有写入权限。我们真正想要的是仅允许市场部门的成员访问这个目录。我们将首先更改所有权和组关联，然后设置正确的权限：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this case, we don''t have any one particular user that we want to own the
    directory, and we don''t really want the root user to own it. So, assigning ownership
    to the `nobody` pseudo-user account gives us a way to deal with that. I then assigned
    the `770` permissions value to the directory, which allows read/write/execute
    access to all `marketing` group members, while keeping everyone else out. Now,
    let''s let one of our group members log in to see if she can create a file in
    this directory:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们并没有一个特定的用户希望拥有该目录，我们也不希望 root 用户拥有它。所以，将所有权分配给 `nobody` 伪用户账户为我们提供了解决方案。然后，我将
    `770` 权限值分配给该目录，这样所有 `marketing` 组成员可以读/写/执行，而其他人无法访问。现在，让我们让我们的一位组员登录，看看她能否在这个目录中创建文件：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Okay, it works, except for one minor problem. The file belongs to Vicky, as
    it should. But, it's also associated with Vicky's personal group. For the best
    access control of these shared files, we need them to be associated with the `marketing`
    group. Let’s take care of that next.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这样可以正常工作，除了一个小问题。文件属于 Vicky，这是应该的。但它也和 Vicky 的个人组关联。为了对这些共享文件进行最佳的访问控制，我们需要将它们与
    `marketing` 组关联。接下来我们来解决这个问题。
- en: Setting the SGID bit and the sticky bit on the shared directory
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在共享目录上设置 SGID 位和粘滞位
- en: I've told you before that it's a bit of a security risk to set either the SUID
    or SGID permissions on files, especially on executable files. But it is both completely
    safe and very useful to set SGID on a shared directory.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前告诉过你，将 SUID 或 SGID 权限设置在文件上，特别是可执行文件上，是有一定的安全风险的。但在共享目录上设置 SGID 是完全安全且非常有用的。
- en: 'SGID behavior on a directory is completely different from SGID behavior on
    a file. On a directory, SGID will cause any files that anybody creates to be associated
    with the same group with which the directory is associated. So, bearing in mind
    that the SGID permission value is `2000`, let''s set SGID on our `marketing` directory:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 目录上的 SGID 行为与文件上的 SGID 行为完全不同。在目录上，SGID 会使任何人创建的文件都与目录关联的组相关联。因此，考虑到 SGID 权限值是
    `2000`，让我们在我们的 `marketing` 目录上设置 SGID：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `s` in the executable position for the group indicates that the command
    was successful. Let''s now let Vicky log back in to create another file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 组的可执行位置上的 `s` 表示命令执行成功。现在让我们让 Vicky 重新登录以创建另一个文件：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Vicky''s second file is associated with the `marketing` group, which is just
    what we want. Just for fun, let''s let Charlie do the same:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Vicky 的第二个文件与 `marketing` 组关联，这正是我们希望的。为了好玩，让我们让 Charlie 也这么做：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Again, Charlie''s file is associated with the `marketing` group. But, for some
    strange reason that nobody understands, Charlie really doesn''t like Vicky and
    decides to delete her files, just out of pure spite:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Charlie 的文件与 `marketing` 组关联。但由于某种原因，大家都不理解，Charlie 非常不喜欢 Vicky，出于纯粹的恶意决定删除她的文件：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The system complains that Vicky's original file is write-protected since it's
    still associated with her personal group. But the system does still allow Charlie
    to delete it, even without `sudo` privileges. And, since Charlie has write access
    to the second file, due to its association with the `marketing` group, the system
    allows him to delete it without question.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 系统抱怨 Vicky 的原始文件是写保护的，因为它仍然与她的个人组关联。但系统仍然允许 Charlie 删除它，即使没有 `sudo` 权限。而且，由于第二个文件与
    `marketing` 组关联，Charlie 拥有写访问权限，因此系统允许他毫无阻碍地删除它。
- en: 'Okay. So, Vicky complains about this and tries to get Charlie fired. But our
    intrepid administrator has a better idea. He''ll just set the sticky bit in order
    to keep this from happening again. Since the SGID bit has a value of `2000`, and
    the sticky bit has a value of `1000`, we can just add the two together to get
    a value of `3000`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以，Vicky 抱怨这件事并试图让 Charlie 被解雇。但我们的勇敢管理员有了一个更好的主意。他决定设置粘滞位，防止这种情况再次发生。由于
    SGID 位的值为 `2000`，而粘滞位的值为 `1000`，我们可以将两者相加得到 `3000`：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `T` in the executable position for others indicates that the sticky bit
    has been set. Since the `T` is uppercase, we know that the executable permission
    for others has not been set. Having the sticky bit set will prevent group members
    from deleting anybody else''s files. Let''s let Vicky show us what happens when
    she tries to retaliate against Charlie:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件的其他用户位置上的 `T` 表示粘滞位已设置。由于 `T` 是大写的，我们知道其他用户的执行权限没有被设置。设置粘滞位会阻止组成员删除其他人的文件。让我们让
    Vicky 来展示她尝试报复 Charlie 时会发生什么：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Even with the `-f` option, Vicky still can't delete Charlie's file. Vicky doesn't
    have `sudo` privileges on this system, so it would be useless for her to try that.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用 `-f` 选项，Vicky 仍然无法删除 Charlie 的文件。Vicky 在此系统上没有 `sudo` 权限，因此尝试删除是无效的。
- en: Using ACLs to access files in the shared directory
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ACL 访问共享目录中的文件
- en: As things currently stand, all members of the `marketing` group have read/write
    access to all other group members' files. Restricting access to a file to only
    specific group members is the same two-step process that we've already covered.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 目前所有 `marketing` 组的成员都可以读/写其他组成员的文件。限制文件访问权限仅限于特定的组成员，是我们已经讨论过的两步过程。
- en: Setting the permissions and creating the ACL
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置权限并创建 ACL
- en: 'First, Vicky sets the normal permissions to only allow herself to have read/write
    permissions on the file. Then, she’ll create an ACL that will allow Cleopatra
    to read the file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Vicky 设置正常权限，只允许她自己对文件具有读/写权限。然后，她将创建一个 ACL，允许 Cleopatra 阅读该文件：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There''s nothing here that you haven''t already seen. Vicky just removed all
    permissions from the group and from others and set an ACL that only allows Cleopatra
    to read the file. Let''s see if Cleopatra actually can read it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么是你没有见过的。Vicky 只是撤销了组和其他人的所有权限，并设置了一个只允许 Cleopatra 阅读文件的 ACL。让我们看看 Cleopatra
    是否真的能读取该文件：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So far, so good. But, can Cleopatra write to it? Let''s take a look:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。但 Cleopatra 能写入该文件吗？让我们看看：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Cleopatra can't do that, since Vicky only allowed her the read privilege in
    the ACL.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Cleopatra 无法做到这一点，因为 Vicky 在 ACL 中只授予她读取权限。
- en: 'Now though, what about that sneaky Charlie, who wants to go snooping in other
    users'' files? Let''s see if Charlie can do it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，现在那个狡猾的 Charlie 怎么样？他想要窥探其他用户的文件。让我们看看 Charlie 能否做到：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So yes, it's really true that only Cleopatra can access Vicky's file, and even
    then only for reading.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，确实只有 Cleopatra 能访问 Vicky 的文件，而且只能读取。
- en: Hands-on lab – creating a shared group directory
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实践实验 – 创建一个共享组目录
- en: 'For this lab, you''ll just put together everything that you''ve learned in
    this chapter to create a shared directory for a group. You can do this on any
    of your virtual machines:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实验，你将整合本章所学的内容，创建一个用于小组的共享目录。你可以在任何虚拟机上执行此操作：
- en: 'On any virtual machine, create the `sales` group:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何虚拟机上，创建 `sales` 组：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Create the users `mimi`, `mrgray`, and `mommy`, adding them to the `sales` group
    as you create the accounts.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用户 `mimi`、`mrgray` 和 `mommy`，并在创建帐户时将他们添加到 `sales` 组中。
- en: 'On CentOS or AlamaLinux, do this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CentOS 或 AlamaLinux 上，执行以下操作：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'On Ubuntu, do this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 上，执行以下操作：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Assign each user a password.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个用户分配一个密码。
- en: 'Create the `sales` directory in the root level of the filesystem. Set proper
    ownership and permissions, including the SGID and sticky bits:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件系统的根目录下创建 `sales` 目录。设置适当的所有权和权限，包括 SGID 和粘滞位：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Log in as Mimi, and have her create a file:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 Mimi 的身份登录，并让她创建一个文件：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Have Mimi set an ACL on her file, allowing only Mr. Gray to read it. Then,
    have Mimi log back out:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让 Mimi 为她的文件设置 ACL，只允许 Gray 先生读取它。然后，让 Mimi 注销：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Have Mr. Gray log in to see what he can do with Mimi''s file. Then, have Mr.
    Gray create his own file and log back out:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让 Gray 先生登录，看看他能对 Mimi 的文件做什么。然后，让 Gray 先生创建自己的文件并注销：
- en: '[PRE43]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Mommy will now log in and try to wreak havoc by snooping in other users'' files
    and by trying to delete them:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，Mommy 将登录并试图通过窥探其他用户的文件以及尝试删除它们来制造混乱：
- en: '[PRE44]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: End of lab.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实验结束。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how to take DAC to the proverbial next level. We first
    saw how to create and manage ACLs to provide more fine-grained access control
    over files and directories. We then saw how to create a user group for a specific
    purpose, and how to add members to it. Then, we saw how we can use the SGID bit,
    the sticky bit, and ACLs to manage a shared group directory.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们看到如何将 DAC 提升到更高的水平。我们首先了解了如何创建和管理 ACL，以对文件和目录提供更细粒度的访问控制。接着，我们了解了如何为特定目的创建用户组，并将成员添加到其中。然后，我们学习了如何使用
    SGID 位、粘滞位和 ACL 来管理共享组目录。
- en: But sometimes, DAC might not be enough to do the job. For those times, we also
    have mandatory access control, which we'll cover in the next chapter. I'll see
    you there.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，DAC 可能不足以完成任务。对于这种情况，我们还可以使用强制访问控制（MAC），这一部分内容将在下一章讨论。到时候见。
- en: Questions
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: When creating an ACL for a file in a shared directory, what must you first do
    to make the ACL effective?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在为共享目录中的文件创建 ACL 时，必须首先做什么才能使 ACL 生效？
- en: A. Remove all normal permissions from the file for everyone except for the user.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: A. 删除文件对所有人（除了用户）的所有普通权限。
- en: B. Ensure that the file has the permissions value of `644` set.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: B. 确保文件的权限值为`644`。
- en: C. Ensure that everyone in the group has read/write permissions for the file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: C. 确保组内的每个人对文件具有读/写权限。
- en: D. Ensure that the SUID permission is set for the file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: D. 确保为文件设置SUID权限。
- en: What is the benefit of setting the SGID permission on a shared group directory?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置SGID权限在共享组目录中的好处是什么？
- en: A. None. It's a security risk and should never be done.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: A. 无。它是一个安全风险，永远不应执行。
- en: B. It prevents members of the group from deleting each others' files.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: B. 它防止组成员删除彼此的文件。
- en: C. It makes it so that each file that gets created within the directory will
    be associated with the group that's also associated with the directory.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: C. 这样，每个在该目录中创建的文件都会与目录关联的组相关联。
- en: D. It gives anyone who accesses the directory the same privileges as the user
    of the directory.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: D. 它赋予任何访问该目录的人与目录用户相同的权限。
- en: Which of the following commands would set the proper permissions for the `marketing`
    shared group directory, with the SGID and sticky bit set?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪条命令会为`marketing`共享组目录设置正确的权限，且设置了SGID和粘滞位？
- en: A. **sudo chmod 6770 marketing**
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: A. **sudo chmod 6770 marketing**
- en: B. **sudo chmod 3770 marketing**
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: B. **sudo chmod 3770 marketing**
- en: C. **sudo chmod 2770 marketing**
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: C. **sudo chmod 2770 marketing**
- en: D. **sudo chmod 1770 marketing**
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: D. **sudo chmod 1770 marketing**
- en: Which of the following `setfacl` options would you use to just remove one specific
    permission from an ACL?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种`setfacl`选项可以用来从ACL中仅删除一个特定权限？
- en: A. `-xB. -r`
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: A. `-xB. -r`
- en: C. `-w`
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: C. `-w`
- en: 'D. `m: :`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 'D. `m: :`'
- en: E. `-m`
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: E. `-m`
- en: 'F. `x: :`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'F. `x: :`'
- en: Which of the following statements is true?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项陈述是正确的？
- en: A. When using `tar`, you must use the `--acls` option for both archive creation
    and extraction, in order to preserve the ACLs on the archived files.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: A. 使用`tar`时，必须在归档创建和提取时都使用`--acls`选项，以便保留归档文件中的ACL。
- en: B. When using `tar`, you need to use the `--acls` option only for archive creation
    in order to preserve the ACLs on the archived files.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: B. 使用`tar`时，只需在归档创建时使用`--acls`选项即可保留归档文件中的ACL。
- en: C. When using `tar`, ACLs are automatically preserved on archived files.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: C. 使用`tar`时，ACL会在归档文件中自动保留。
- en: D. When using `tar`, it's not possible to preserve ACLs on archived files.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: D. 使用`tar`时，无法保留归档文件中的ACL。
- en: Which two of the following are *not* a valid method for adding the user Lionel
    to the `sales` group?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪两种方法*不是*将用户Lionel添加到`sales`组的有效方法？
- en: A. **sudo useradd -g sales lionel**
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: A. **sudo useradd -g sales lionel**
- en: B. **sudo useradd -G sales lionel**
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: B. **sudo useradd -G sales lionel**
- en: C. **sudo usermod -g sales lionel**
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: C. **sudo usermod -g sales lionel**
- en: D. **sudo usermod -G sales lionel**
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: D. **sudo usermod -G sales lionel**
- en: E. By hand-editing the `/etc/group` file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: E. 通过手动编辑`/etc/group`文件。
- en: What happens when you create an inherited ACL?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建继承的ACL时会发生什么？
- en: A. Every file that gets created in the directory with that inherited ACL will
    be associated with the group that's associated with that directory.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: A. 使用该继承的ACL创建的目录中的每个文件都会与该目录相关联的组相同。
- en: B. Every file that gets created in the directory with that inherited ACL will
    inherit that ACL.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: B. 使用该继承的ACL创建的目录中的每个文件都会继承该ACL。
- en: C. Every file that gets created in that directory with that inherited ACL will
    have the same permissions settings as the directory.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: C. 使用该继承ACL创建的每个文件都会与目录具有相同的权限设置。
- en: D. Every file that gets created in that directory will have the sticky bit set.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: D. 在该目录中创建的每个文件都会设置粘滞位。
- en: Which of the following commands would you use to grant read-only privilege on
    a file to the user Frank?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪条命令可用于授予用户Frank只读权限？
- en: A. **chattr -m u:frank:r somefile.txt**
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: A. **chattr -m u:frank:r somefile.txt**
- en: B. **aclmod -m u:frank:r somefile.txt**
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: B. **aclmod -m u:frank:r somefile.txt**
- en: C. **getfacl -m u:frank:r somefile.txt**
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: C. **getfacl -m u:frank:r somefile.txt**
- en: D. **setfacl -m u:frank:r somefile.txt**
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: D. **setfacl -m u:frank:r somefile.txt**
- en: You've just done an `ls -l` command in a shared group directory. How can you
    tell from that whether an ACL has been set for any of the files?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你刚刚在共享组目录中执行了`ls -l`命令。如何从中判断是否为文件设置了ACL？
- en: A. Files with an ACL set will have `+` at the beginning of the permissions settings.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: A. 设置ACL的文件会在权限设置的开头显示`+`。
- en: B. Files with an ACL set will have `-` at the beginning of the permissions settings.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: B. 设置了 ACL 的文件，其权限设置的开头会有`-`符号。
- en: C. Files with an ACL set will have `+` at the end of the permissions settings.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: C. 设置了 ACL 的文件，其权限设置的末尾会有`+`符号。
- en: D. Files with an ACL set will have `-` at the end of the permissions settings.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了 ACL 的文件，其权限设置的末尾会有`-`符号。
- en: E. The `ls -l` command will show the ACL for that file.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: E. `ls -l` 命令会显示该文件的 ACL。
- en: Which of the following would you use to view the ACL on the `somefile.txt` file?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪一项可以用来查看`somefile.txt`文件的 ACL？
- en: A. **getfacl somefile.txt**
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: A. **getfacl somefile.txt**
- en: B. **ls -l somefile.txt**
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: B. **ls -l somefile.txt**
- en: C. **ls -a somefile.txt**
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: C. **ls -a somefile.txt**
- en: D. **viewacl somefile.txt**
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: D. **viewacl somefile.txt**
- en: Further reading
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'How to create users and groups from the Linux command line: [https://www.techrepublic.com/article/how-to-create-users-and-groups-in-linux-from-the-command-line/](https://www.techrepublic.com/article/how-to-create-users-and-groups-in-linux-from-the-command-line/)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从 Linux 命令行创建用户和组：[https://www.techrepublic.com/article/how-to-create-users-and-groups-in-linux-from-the-command-line/](https://www.techrepublic.com/article/how-to-create-users-and-groups-in-linux-from-the-command-line/)
- en: 'Add a user to a group: [https://www.howtogeek.com/50787/add-a-user-to-a-group-or-second-group-on-linux/](https://www.howtogeek.com/50787/add-a-user-to-a-group-or-second-group-on-linux/)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户添加到组：[https://www.howtogeek.com/50787/add-a-user-to-a-group-or-second-group-on-linux/](https://www.howtogeek.com/50787/add-a-user-to-a-group-or-second-group-on-linux/)
- en: 'SGID on directories: [https://www.toptip.ca/2010/03/linux-setgid-on-directory.html](https://www.toptip.ca/2010/03/linux-setgid-on-directory.html)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录上的 SGID：[https://www.toptip.ca/2010/03/linux-setgid-on-directory.html](https://www.toptip.ca/2010/03/linux-setgid-on-directory.html)
- en: 'What a sticky bit is and how to set it in Linux: [https://www.linuxnix.com/sticky-bit-set-linux/](https://www.linuxnix.com/sticky-bit-set-linux/)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是粘滞位，以及如何在 Linux 中设置：[https://www.linuxnix.com/sticky-bit-set-linux/](https://www.linuxnix.com/sticky-bit-set-linux/)
- en: Answers
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: A
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: C
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: B
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: D
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: D
- en: A
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: A, C
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A, C
- en: B
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: D
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: D
- en: C
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: A
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
