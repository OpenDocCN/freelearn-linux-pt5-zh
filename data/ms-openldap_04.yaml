- en: Chapter 4. Securing OpenLDAP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。保护 OpenLDAP
- en: 'In Chapter 2 we installed OpenLDAP and created a basic configuration file for
    the SLAPD server. Then, in the last chapter, we turned our attention to LDAP operations
    and LDAP clients. Now we will return to the SLAPD server, but with a specific
    focus: **security**. We will take a look at three major security considerations
    with OpenLDAP: securing connections between the server and client connections,
    authenticating users of the directory, and specifying what data particular users
    can access (and in what capacity they can access it). We will look at these security
    considerations on a practical level and, in doing so, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们安装了 OpenLDAP 并创建了 SLAPD 服务器的基本配置文件。然后，在上一章中，我们将注意力转向了 LDAP 操作和 LDAP
    客户端。现在，我们将返回到 SLAPD 服务器，但重点将有所不同：**安全性**。我们将重点关注 OpenLDAP 的三个主要安全考虑因素：保护服务器和客户端之间的连接、验证目录用户的身份，以及指定特定用户可以访问哪些数据（以及他们可以以何种方式访问）。我们将从实际角度来审视这些安全考虑因素，并在此过程中涵盖以下内容：
- en: Configuring SSL and TLS to protect network data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 SSL 和 TLS 以保护网络数据
- en: Using simple binding to authenticate DNS (Domain Name System) for using the
    directory
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简单绑定来验证 DNS（域名系统）以使用目录
- en: Using SASL to provide more robust authentication services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SASL 提供更强大的身份验证服务
- en: Integrating SASL and client SSL/TLS certificates for authentication
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 SASL 和客户端 SSL/TLS 证书进行身份验证
- en: Configuring Access Control Lists (ACLs) to establish rules about what data users
    can access
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置访问控制列表（ACL）以建立有关用户可以访问哪些数据的规则
- en: 'LDAP Security: The Three Aspects'
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LDAP 安全性：三大方面
- en: As we have seen already, the directory contains sensitive information. One example
    of such sensitive information is the `userPassword` attribute. But other information
    that may be considered sensitive, such as personal information or confidential
    information about the organization, may exist in the directory. Such information
    needs to be protected.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，目录包含敏感信息。一个例子就是 `userPassword` 属性。但目录中也可能包含其他被认为是敏感的信息，如个人信息或关于组织的机密信息。这些信息需要得到保护。
- en: We might ask what is meant by *protection* in this case. For it is certainly
    not the case that we want to prevent *all* clients from seeing *everything*. What
    we want rather, is to allow people to get at specific pieces of the directory
    information. But, on the other hand, there are cases where we want to deny certain
    users the ability to get at certain pieces of directory information. So protecting
    our data becomes a matter of providing information in some cases, while denying
    it in other cases.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会问，这里所说的*保护*是什么意思。因为我们显然并不是要阻止*所有*客户端查看*所有*内容。我们真正想要的，是允许人们访问特定的目录信息。然而，另一方面，也有些情况是我们希望拒绝某些用户访问特定的目录信息。所以，保护我们的数据成为在某些情况下提供信息，而在其他情况下拒绝信息的一个问题。
- en: 'While it is possible to draw finer-grained distinctions, here we are going
    to consider three broad aspects of security where we want to make sure that we
    are protecting the directory and its information. These three aspects are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以进行更精细的区分，但在这里我们将考虑保护目录及其信息的三个广泛安全方面。这三个方面如下：
- en: '**Connection Security**: This is the process of protecting directory information
    (and client information) as it is passed between a client and the directory server.
    We will talk about this in the context of network security with SSL and TLS.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接安全性**：这是保护目录信息（以及客户端信息）在客户端和目录服务器之间传递过程的过程。我们将在网络安全的背景下讨论这一点，涉及 SSL 和 TLS。'
- en: '**Authentication**: This is the process of ensuring that the user who tries
    to access the information in the directory is who he/she/it claims to be. In this
    chapter we will look at two types of authentication: simple and SASL Binding.
    SASL stands for **Simple Authentication and Security Layer****.**'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：这是确保尝试访问目录信息的用户确实是其声称身份的过程。在本章中，我们将介绍两种身份验证类型：简单绑定和 SASL 绑定。SASL 代表**简单身份验证和安全层**。'
- en: '**Authorization**: This is the process of ensuring that an identified or authenticated
    user is allowed to access pieces of information within the directory. OpenLDAP
    ACLs are used to specify rules for authorization.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：这是确保已识别或已验证的用户被允许访问目录中某些信息的过程。OpenLDAP 的 ACL 用于指定授权规则。'
- en: In this chapter we will look at each of these three aspects of security. By
    combining all three we will be able to provide suitably fine-grained protection
    for our directory information.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨这三个安全方面。通过将这三者结合起来，我们可以为我们的目录信息提供适当细粒度的保护。
- en: Securing Network-Based Directory Connections with SSL/TLS
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SSL/TLS 保护基于网络的目录连接
- en: The first element of security that we will examine is network security. Most
    clients connect to OpenLDAP over a network interface, and client requests, as
    well as the server's responses, are transferred over a network.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要研究的第一个安全要素是网络安全。大多数客户端通过网络接口连接到 OpenLDAP，客户端请求和服务器响应都通过网络传输。
- en: 'The LDAP protocol, by default, sends and receives messages in clear text. In
    this case no attempt is made to obscure the data as it is being transmitted across
    the network. Sending in clear text has a few advantages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP 协议默认情况下以明文形式发送和接收消息。在这种情况下，数据在通过网络传输时不会进行任何隐藏处理。明文传输有几个优点：
- en: It is easier to configure and maintain.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它更容易配置和维护。
- en: LDAP services can function faster. The process of encrypting and decrypting
    messages can be processor-intensive, and eliminating that processing can serve
    to speed things up.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LDAP 服务可以更快速地运行。加密和解密消息的过程可能会占用大量处理器资源，去除这些处理过程可以加速操作。
- en: But these advantages come at the cost of security. Other devices on the network
    may be able to intercept these unencrypted transmissions and read their contents
    and in doing so, they may obtain sensitive information. On a small Local Area
    Network (LAN) the risks may be smaller (though still present). On a large scale
    network, such as the Internet, the dangers are much greater.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些优点是以安全性为代价的。网络上的其他设备可能能够拦截这些未加密的传输并读取其内容，从而可能获取敏感信息。在小型局域网（LAN）中，风险可能较小（尽管依然存在）。而在大规模网络中，例如互联网，风险则要大得多。
- en: In this section we will walk through the process of configuring **Secure Sockets
    Layer** (**SSL**) and **Transport Layer Security (TLS)** encryption to protect
    data as it is transmitted over a network. SSL and TLS are very similar, to the
    point where the terms are often used (acceptably) as synonyms. TLS though, is
    a refinement of SSL, and has been implemented in ways that are more flexible than
    the typical SSL implementation. The StartTLS method of securing a connection is
    an example.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍配置**安全套接字层**（**SSL**）和**传输层安全性**（**TLS**）加密的过程，以保护数据在网络上传输时的安全。SSL
    和 TLS 非常相似，以至于这两个术语经常被作为同义词使用（通常是可以接受的）。不过，TLS 是 SSL 的改进版本，实施方式比典型的 SSL 实现更加灵活。StartTLS
    方法就是一种保护连接的例子。
- en: The Basics of SSL and TLS
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSL 和 TLS 的基础
- en: OpenLDAP provides two methods for encrypting network traffic. The first is to
    have OpenLDAP listen on a special port for requests (port 636, the LDAPS port,
    is used by default). Transmissions on this port will automatically be encrypted.
    This method is older, introduced as an addition to LDAP v2, but it is no longer
    the preferred method.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP 提供了两种加密网络流量的方法。第一种是让 OpenLDAP 在一个特殊端口上监听请求（默认使用端口 636，即 LDAPS 端口）。这个端口上的传输会自动进行加密。这种方法较旧，是作为
    LDAP v2 的一个附加功能引入的，但现在已不再是首选方法。
- en: The second method, which is part of the LDAP v3 standard, is to allow clients
    connecting over the standard port (usually port 389) to request to switch from
    clear text transmissions to encrypted transmissions. I will cover both configurations
    here.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是 LDAP v3 标准的一部分，允许客户端在标准端口（通常是端口 389）上连接时，申请从明文传输切换到加密传输。我将在这里介绍这两种配置。
- en: '**Secure Sockets Layer** (**SSL**) is a security process, originally developed
    by Netscape Communications for their web browser, designed to provide a safe way
    of exchanging trusted information between a server and any client on the network.
    There are two major features of the SSL process: establishing authenticity and
    conducting securely encrypted transactions.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全套接字层**（**SSL**）是一种安全过程，最初由 Netscape 通信公司为其网页浏览器开发，旨在提供一种安全的方式，在服务器和任何客户端之间交换可信的信息。SSL
    过程的两个主要特性是：建立身份验证和进行安全加密交易。'
- en: As SSL developed and evolved it was handed over to a standard body, the **Internet
    Engineering Task Force (IETF)**, for standardization and continued development.
    IETF renamed it **Transport Layer Security (TLS)** and released version 1.0 (as
    RFC 2246). SSL 3.0 and TLS 1.0 do not have any notable differences, and most servers
    that support one also support the other. Because of their similarity and shared
    heritage, I refer to them jointly as SSL/TLS.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着SSL的发展和演变，它被移交给了一个标准化组织——**互联网工程任务组（IETF）**，进行标准化和持续开发。IETF将其重新命名为**传输层安全（TLS）**，并发布了1.0版本（作为RFC
    2246）。SSL 3.0和TLS 1.0没有显著差异，大多数支持其中一种的服务器也支持另一种。由于它们的相似性和共同的历史，我通常将它们合并称为SSL/TLS。
- en: Authenticity
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真实性
- en: Proving authenticity and providing encryption are the two major features of
    SSL/TLS. In regards to the first, SSL/TLS provides a way to establish the authenticity
    of the server (and, if desired, the client too). What this means is that SSL/TLS
    makes it possible for the client to be reasonably sure that the server belongs
    to whom it claims to belong.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 证明真实性和提供加密是SSL/TLS的两个主要特性。关于第一个，SSL/TLS提供了一种建立服务器真实性的方法（如果需要，也可以验证客户端的真实性）。这意味着SSL/TLS使客户端能够合理地确认服务器确实属于它声称的所有者。
- en: 'Consider the case of online banking. If I use my browser to log on to my bank''s
    website and conduct a few transactions, I want to be sure that the website I am
    connected to really is my bank''s website, and not some other website masquerading
    as my bank. SSL/TLS provides tools to establish the authenticity of the server
    using **X.509 certificates**. An X.509 certificate has three important pieces
    of information:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下在线银行的情况。如果我使用浏览器登录到银行的网站并进行一些交易，我希望确保我连接到的网站确实是我的银行网站，而不是一个冒充我银行的网站。SSL/TLS提供了使用**X.509证书**来验证服务器真实性的工具。X.509证书包含三个重要信息：
- en: Information about the individual or organization that owns the certificate
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关证书所有者的个人或组织的信息
- en: A public encryption key (which we will discuss in the next section)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个公钥（我们将在下一部分讨论）
- en: The **digital signature** of a certificate authority (CA)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字签名**由证书颁发机构（CA）提供'
- en: A certificate is designed as a sort of assurance that a server is associated
    with a particular individual or organization. When I contact a server that I believe
    to be my bank's, I want some assurance that it is, in fact, my bank's server.
    So one piece of information contained in the certificate is information about
    who owns the certificate. We can inspect this information ourselves, but since
    the certificate has a digital signature, it is also possible for software to computationally
    verify this—in a way much more reliable than reading the certificate and simply
    trusting that the certificate is accurate.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 证书被设计为一种保证，确保某个服务器与特定的个人或组织相关联。当我联系我认为是我的银行的服务器时，我希望得到一些保证，确认它确实是我银行的服务器。因此，证书中包含的一项信息是关于谁拥有该证书的信息。我们可以自己检查这些信息，但由于证书包含数字签名，软件也可以以一种比简单读取证书并信任证书更可靠的方式来验证这些信息。
- en: The digital signature is an encrypted bit of information. It is encrypted with
    a special "private" key that is owned by a Certificate Authority. The CA can then
    issue a public key that client software can use to verify that the certificate
    was in fact signed by the CA. The CA then, plays a very important role in establishing
    trust. We will discuss public and private keys in the *Encryption* section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名是加密的信息块。它使用证书颁发机构（CA）拥有的特殊“私钥”进行加密。然后，CA可以发布一个公钥，客户端软件可以使用它来验证证书确实是由CA签署的。CA在建立信任方面起着非常重要的作用。我们将在*加密*部分讨论公钥和私钥。
- en: Certificate Authorities are responsible for issuing certificates. Ideally, a
    CA is a trusted source that can verify the authenticity of the certificate, and
    provide assurance that the certificate is really owned by the organization or
    individual that claims to own it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 证书颁发机构（CA）负责颁发证书。理想情况下，CA是一个受信任的来源，可以验证证书的真实性，并提供保证，确保证书确实由声明拥有该证书的组织或个人所有。
- en: There are a number of commercial CAs that provide certificate generation services
    for a price. To obtain a certificate through these services, an organization or
    individual must provide a certain amount of information that can be used to verify
    that the person or organization signing up for the certificate is legitimate.
    Once investigation of this material has been done, and the person or organization
    has paid the requisite fee, the CA issues a digitally-signed certificate.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多商业 CA 提供收费的证书生成服务。为了通过这些服务获取证书，组织或个人必须提供一些信息，用以验证申请证书的人或组织是否合法。一旦对这些信息进行了调查，并且申请人或组织支付了相应的费用，CA
    就会签发一个数字签名的证书。
- en: The certificates of large CAs are included by default in most SSL-aware applications,
    such as popular web browsers (like Mozilla Firefox) and SSL libraries (like OpenSSL).
    These certificates include the public keys necessary for verifying digital signatures.
    Thus, when a client gets an X.509 certificate that is signed by one of these CAs,
    it has all of the tools it needs to verify the certificate's authenticity.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大型 CA 的证书默认包含在大多数支持 SSL 的应用程序中，如流行的网页浏览器（如 Mozilla Firefox）和 SSL 库（如 OpenSSL）。这些证书包含了验证数字签名所需的公钥。因此，当客户端获取到由这些
    CA 签名的 X.509 证书时，它就具备了验证证书真实性所需的所有工具。
- en: But it is possible, and often useful, for an organization or individual to simply
    create a locally used CA, and then use that CA to generate certificates for in-house
    applications. This is what we will do when we create a certificate for OpenLDAP.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于一个组织或个人来说，创建一个本地使用的证书颁发机构（CA）并使用该 CA 为内部应用生成证书是可行的，而且通常是有用的。这就是我们在为 OpenLDAP
    创建证书时所做的事情。
- en: Of course, certificates generated this way may not be considered reliable to
    users outside of your organization, but hosting an individual or organization-wide
    CA can be an effective way to add security to your own network, without having
    to purchase certificates from a commercial vendor.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种方式生成的证书可能不会被组织外的用户认为是可靠的，但托管一个个人或组织级别的 CA 可以有效地为自己的网络增加安全性，而无需购买来自商业供应商的证书。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Not all CAs use the same form of authoritative signing (and not all CAs charge
    for certificates). Some CAs, such as Cacert.org, use what is called a **web of
    trust** technique for establishing authenticity. In the web of trust the authenticity
    of a certificate is established by peers who can play the role of assuring that
    the certificate is owned by the person or organization that it claims to be owned
    by. For more information visit [http://www.cacert.org/](http://www.cacert.org/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有 CA 都采用相同形式的权威签名（也并非所有 CA 都收取证书费用）。有些 CA，如 Cacert.org，采用一种称为 **信任网** 的技术来建立身份认证。在信任网中，证书的真实性由同伴验证，他们可以担任确保证书归属所声明的个人或组织的角色。欲了解更多信息，请访问
    [http://www.cacert.org/](http://www.cacert.org/)。
- en: We have discussed the first role of SSL/TLS, establishing authenticity. Next
    we will turn to the second role of SSL/TLS; providing encryption services.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 SSL/TLS 的第一个功能：建立身份认证。接下来，我们将讨论 SSL/TLS 的第二个功能：提供加密服务。
- en: Encryption
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加密
- en: 'SSL/TLS provides the features required for sending encrypted messages back
    and forth between the client and the server. In a nutshell the process goes like
    this: the server sends the client its certificate, and inside the certificate
    (among other things) is the server''s **public key**. The public key is the first
    half of a pair of keys. A public key can be used for encrypting a message, but
    not decrypting it. A second key, the **private key**, is then used for decrypting
    a message. The server keeps its private key to itself, but gives out its public
    key to any client that requests it. Clients can then send messages to the server
    that only the server can decrypt and interpret.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: SSL/TLS 提供了客户端和服务器之间发送加密消息所需的功能。简而言之，过程如下：服务器将证书发送给客户端，在证书中（以及其他内容中）包含了服务器的**公钥**。公钥是一对密钥中的第一部分。公钥可用于加密消息，但不能解密消息。第二个密钥，**私钥**，则用于解密消息。服务器将私钥保密，但会将公钥提供给任何请求的客户端。客户端可以将消息发送给服务器，只有服务器可以解密并解读这些消息。
- en: Depending on the configuration the client also sends the server its public key,
    which the server can use to send messages that only the client can decrypt. At
    this point, each can transmit encrypted messages to the other.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 根据配置，客户端还会向服务器发送其公钥，服务器可以利用这个公钥发送只有客户端能够解密的消息。此时，双方可以互相发送加密消息。
- en: 'But there is a drawback to using public/private keys: they are slow and resource-intensive.
    Rather than trading all information through these public/private key combos, the
    client and server then negotiate a set of temporary symmetric encryption keys
    (which use the same key to encrypt and decrypt messages) that they will both use
    for the duration of the session. All traffic between the two clients is encrypted
    using these keys. Once the session is complete, both the client and server discard
    the temporary keys.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公钥/私钥的缺点是：它们速度较慢且资源消耗大。与其通过这些公钥/私钥组合交换所有信息，客户端和服务器会协商一组临时对称加密密钥（使用相同的密钥来加密和解密消息），它们将在会话期间共同使用。客户端之间的所有流量都使用这些密钥进行加密。一旦会话完成，客户端和服务器都会丢弃临时密钥。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For a more detailed introduction to SSL and TLS, as well as pointers to further
    sources of information, see the Wikipedia entry for Transport Layer Security:
    [http://en.wikipedia.org/wiki/Transport_Layer_Security](http://en.wikipedia.org/wiki/     Transport_Layer_Security).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 关于SSL和TLS的更详细介绍，以及进一步信息的链接，请参阅维基百科上的传输层安全条目：[http://en.wikipedia.org/wiki/Transport_Layer_Security](http://en.wikipedia.org/wiki/Transport_Layer_Security)。
- en: StartTLS
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: StartTLS
- en: As it is typically implemented, SSL requires that the server listen for encrypted
    traffic on a port separate from the one it uses for unencrypted traffic. All traffic
    that comes over the SSL port is assumed to be SSL-encrypted traffic. This means
    that every server that needs to provide both cleartext and encrypted services
    must listen on at least two different ports.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 按照通常的实现方式，SSL要求服务器在与非加密流量不同的端口上监听加密流量。所有通过SSL端口的流量都被认为是SSL加密的流量。这意味着，任何需要同时提供明文和加密服务的服务器都必须至少在两个不同的端口上监听。
- en: The multi-port requirement seemed to some to be unnecessary, inelegant, and
    wasteful. There is no reason why the client should not be able to request on a
    cleartext (non-SSL) connection that further communication between the client and
    server be encrypted. The client and server could then perform all of the SSL/TLS
    negotiation over the same connection, and not have to switch to another SSL/TLS-only
    port. This suggestion was standardized in RFC2487 as **StartTLS**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 多端口的需求对一些人来说似乎是多余的、不优雅的且浪费资源。没有理由客户端不能在明文（非SSL）连接上请求客户端和服务器之间的进一步通信加密。然后，客户端和服务器可以在同一连接上完成所有SSL/TLS协商，而不必切换到另一个仅支持SSL/TLS的端口。这个建议在RFC2487中被标准化为**StartTLS**。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Which to Pick: StartTLS or LDAPS?**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择哪个：StartTLS还是LDAPS？**'
- en: The standardized way of implementing SSL/TLS in LDAP v.3 is to use the StartTLS
    method. This method should be implemented whenever possible. However, external
    considerations (such as network firewalling or clients without StartTLS support)
    may require that you use LDAPS and a dedicated SSL/TLS-protected port. LDAPS support
    is now listed as deprecated, though it is not yet slated for removal from OpenLDAP.
    Both options can be used on the same server.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在LDAP v.3中实现SSL/TLS的标准方法是使用StartTLS方法。此方法应该尽可能实现。然而，外部因素（例如网络防火墙或不支持StartTLS的客户端）可能要求您使用LDAPS和专用的SSL/TLS保护端口。目前，LDAPS支持已被列为过时，但尚未从OpenLDAP中移除。两种方法可以在同一服务器上同时使用。
- en: In a StartTLS-supporting server, if the client sends the server the command
    `STARTTLS` then the server will begin the TLS encryption process. Assuming the
    TLS negotiation is successful, the client and server will then continue their
    transactions using encrypted traffic.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持StartTLS的服务器中，如果客户端向服务器发送命令`STARTTLS`，则服务器将开始TLS加密过程。如果TLS协商成功，客户端和服务器将继续使用加密流量进行通信。
- en: StartTLS has the obvious advantage of requiring only one listening port per
    server. And, it makes it possible for clients and servers to communicate in cleartext
    for unimportant data, and then switch over to TLS when security becomes important.
    Since encryption is resource intensive, requiring extra processing power to encrypt
    and decrypt messages, streamlining services the StartTLS way can improve performance
    and free up resources for other tasks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: StartTLS显然的优势是每个服务器只需要一个监听端口。而且，它使得客户端和服务器可以在处理不重要数据时进行明文通信，当安全性变得重要时再切换到TLS。由于加密是资源密集型的，需要额外的处理能力来加密和解密消息，通过StartTLS方式简化服务可以提高性能，并释放资源用于其他任务。
- en: There is a drawback for StartTLS though. Since both encrypted and cleartext
    traffic are sent over the same port, the method of simply blocking a port to prevent
    insecure data transmissions (by using a firewall for instance) is not effective
    with StartTLS. Security measures must be capable of inspecting transmissions at
    the protocol level.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，StartTLS 有一个缺点。由于加密流量和明文流量通过同一个端口发送，单纯通过阻止端口来防止不安全的数据传输（例如使用防火墙）在 StartTLS
    中并不有效。安全措施必须能够在协议级别检查传输。
- en: In order to improve security services in such cases, OpenLDAP provides methods
    of testing the **security strength factor (SSF)** of a connection to see if it
    is encrypted (and if so, if the encryption scheme is strong enough). We will look
    at SSF in more detail later in this chapter in the section on *Using* *Security*
    *Strength* *Factors*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高此类情况下的安全服务，OpenLDAP 提供了测试连接**安全强度因子（SSF）**的方法，以检查连接是否加密（如果是，加密方案是否足够强大）。我们将在本章后面的*使用*
    *安全* *强度* *因子*部分更详细地讨论 SSF。
- en: At this point, you should have a fairly good idea of how SSL and TLS function.
    Now we will move on to more practical matters. We will create our own CA, and
    our own certificate, and then configure OpenLDAP to support SSL/TLS and StartTLS.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该对 SSL 和 TLS 的工作原理有了相当清晰的理解。现在我们将进入更实际的部分。我们将创建我们自己的证书颁发机构（CA），并生成我们自己的证书，然后配置
    OpenLDAP 以支持 SSL/TLS 和 StartTLS。
- en: Creating an SSL/TLS CA
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 SSL/TLS 证书颁发机构（CA）
- en: In order to create a Certificate Authority and generate certificates, you will
    need to have OpenSSL installed. Since many Ubuntu packages, including the OpenLDAP
    packages, require OpenSSL, it should be installed already.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建证书颁发机构并生成证书，你需要安装 OpenSSL。由于许多 Ubuntu 包（包括 OpenLDAP 包）都需要 OpenSSL，它应该已经安装好了。
- en: If you build from source, as detailed in [Appendix A](apa.html "Appendix A. Building
    OpenLDAP from Source"), you may also enable support for SSL/TLS using the OpenSSL
    libraries.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是从源代码构建的，如[附录 A](apa.html "附录 A. 从源代码构建 OpenLDAP")中详细描述的那样，你也可以通过 OpenSSL
    库启用 SSL/TLS 支持。
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you have a certificate already, you can skip this section and move to the
    *Configuring* *StartTLS* section. OpenLDAP uses certificates in the PEM format.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有了证书，可以跳过本节并转到*配置* *StartTLS* 部分。OpenLDAP 使用 PEM 格式的证书。
- en: The first thing we will need to do is create our new CA.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建新的证书颁发机构（CA）。
- en: While it is possible to manually configure your CA using the `openssl` command
    line tool, it is much simpler to use the `CA.pl` Perl script that is included
    with OpenSSL. This script streamlines many of the configuration options for OpenSSL,
    and the first thing that we will use it for is creating the environment for our
    new CA.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用 `openssl` 命令行工具手动配置 CA，但使用随 OpenSSL 附带的 `CA.pl` Perl 脚本要简单得多。这个脚本简化了
    OpenSSL 的许多配置选项，我们首先使用它来创建我们新的 CA 环境。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ubuntu maintains documentation on creating a new Certificate Authority the "long
    way" (creating all of the files by hand). This documentation is detailed and well
    worth reading. While I will follow the conventions established there, I will be
    using the `CA.pl` script to do most of the heavy lifting ([https://help.ubuntu.com/community/OpenSSL](https://help.ubuntu.com/community/OpenSSL)).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu 维护了关于以“长方式”创建新的证书颁发机构（手动创建所有文件）的文档。这份文档详细且值得阅读。虽然我会遵循那里建立的惯例，但我将使用 `CA.pl`
    脚本来完成大部分繁重的工作（[https://help.ubuntu.com/community/OpenSSL](https://help.ubuntu.com/community/OpenSSL)）。
- en: 'You can put the CA environment anywhere on your system. Some prefer to keep
    CA files with the rest of the SSL configuration at `/etc/ssl/`. Others prefer
    keeping the certificate authority in a user directory so that it does not get
    overwritten during system upgrades (an unlikely, but possible, event). In keeping
    with the Ubuntu suggestion to keep CA info in a user''s home directory, I will
    just put mine in my home directory, `/home/mbutcher/`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 CA 环境放在系统的任何位置。有些人喜欢将 CA 文件与其他 SSL 配置一起保存在 `/etc/ssl/` 目录下。也有一些人喜欢将证书颁发机构保存在用户目录中，以避免在系统升级时被覆盖（虽然这不太可能，但也有这种可能）。根据
    Ubuntu 的建议，我将把它保存在我的用户主目录下，路径为 `/home/mbutcher/`：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the `CA.pl` script is not in `$PATH`, so you will need to type in
    the entire path to the script.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`CA.pl` 脚本不在 `$PATH` 中，因此你需要输入脚本的完整路径。
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Finding CA.pl**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找 CA.pl**'
- en: Different operating system distributions will put `CA.pl` in different places.
    If running `which CA.pl` does not return any results, you may want to consult
    the man pages for SSL (`man config` or `man CA.pl`), or use the `find` or `slocate`
    utilities to find the `CA.pl` file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的操作系统发行版会将 `CA.pl` 放在不同的位置。如果运行 `which CA.pl` 没有返回任何结果，你可能需要查阅 SSL 的手册页（`man
    config` 或 `man CA.pl`），或者使用 `find` 或 `slocate` 工具来查找 `CA.pl` 文件。
- en: The argument `-newca` instructs `CA.pl` to set up a new certificate authority
    environment. This will generate a directory structure along with a number of files.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 `-newca` 指示 `CA.pl` 设置一个新的证书颁发机构环境。这将生成一个目录结构，并包含多个文件。
- en: 'The first thing that `CA.pl` will do is prompt you to enter a CA file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`CA.pl` 首先会提示你输入一个 CA 文件：'
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Hit *Enter* to create a new CA certificate. `CA.pl` will then generate a new
    key and then prompt you for a password:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 *Enter* 创建一个新的 CA 证书。然后，`CA.pl` 会生成一个新的密钥，并提示你输入密码：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once you have entered and re-entered your password, `CA.pl` will collect some
    information from you about your organization:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你输入并重新输入了密码，`CA.pl` 将收集一些关于你所在组织的信息：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`CA.pl` walks you through the process of creating a main certificate. The highlighted
    lines in the code listing are those where you will have to provide information
    at an interactive prompt. After setting the country, state, and city name for
    my locale, we set the **Organization Name** to **Example.Com**. While we left
    the **Organizational Unit** field blank, you can use that to further specify what
    part of the organization this CA is a member of.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`CA.pl` 会引导你完成创建主证书的过程。代码列表中高亮的行是你在交互式提示中需要提供信息的地方。设置好国家、州和城市名称后，我们将 **组织名称**
    设置为 **Example.Com**。虽然我们将 **组织单位** 字段留空，但你可以利用这个字段进一步指定这个 CA 属于组织的哪个部分。'
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You should consider using the same fields in your certificate that you used
    for your root DN when you set up your directory information tree in the previous
    two chapters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该考虑在证书中使用与你在前两章设置目录信息树时使用的根 DN 相同的字段。
- en: Usually the **Common Name** and **Email Address** fields should contain information
    about the organization. Sometimes **Common Name** is used for the server name
    (as will be the case when we create our certificate). Sometimes, it is used for
    contact information. In the case that follows, we used my name and email. If the
    CA is to be the "official" CA for your organization, you should set this to the
    official contact person for certificate inquiries.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，**公共名称** 和 **电子邮件地址** 字段应包含有关组织的信息。有时，**公共名称** 用于服务器名称（如我们创建证书时）。有时，它也用于联系信息。在接下来的例子中，我们使用了我的名字和电子邮件。如果
    CA 是你组织的“官方” CA，你应该将其设置为证书查询的官方联系人。
- en: 'Next, `CA.pl` will begin the process of generating a certificate request for
    the CA certificate. In other words, `CA.pl` will create a new certificate that
    will be the CA''s own certificate. The first step in doing this is to create a
    certificate request. We will need to set a challenging password for the certificate
    request. We can also set a company name too. With the above information, `CA.pl`
    will continue the process of generating a new certificate:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`CA.pl` 将开始生成 CA 证书的证书请求。换句话说，`CA.pl` 将创建一个新的证书，作为 CA 自己的证书。第一步是创建证书请求。我们需要为证书请求设置一个复杂的密码，也可以设置公司名称。有了上述信息，`CA.pl`
    将继续生成新证书的过程：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will be prompted to enter a pass phrase. This is the pass phrase we created
    first (when prompted to **Enter PEM pass phrase**). If we enter the pass phrase
    correctly, `CA.pl` will generate our new certificate and display its contents
    on the screen.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将被提示输入密码短语。这是我们首先创建的密码短语（当提示输入 **PEM 密码短语** 时）。如果我们正确输入密码短语，`CA.pl` 将生成新的证书，并在屏幕上显示其内容。
- en: We have now created a Certificate Authority. Now we are ready to start generating
    a certificate to be used by SLAPD.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个证书颁发机构。现在，我们准备开始生成一个供 SLAPD 使用的证书。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Due to a bug in some versions of `CA.pl`, you may have to `cd` into the `./demoCA`
    directory (the directory that `CA.pl -newca` created) and add a symbolic link
    to itself: `ln -s ./demoCA`. This is because `CA.pl` occasionally expects to find
    files in the current directory (`./`), which it assumes to be `demoCA/`, and sometimes
    it expects to find files in `./demoCA` (which, of course, is equivalent to `demoCA/demoCA/`).
    You can also fix this simply by editing the `dir=` line under `[CA_default]` in
    the `/etc/ssl/openssl.cnf` file, and setting it to an absolute path.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某些版本的`CA.pl`存在bug，您可能需要`cd`进入`./demoCA`目录（`CA.pl -newca`创建的目录），并为其添加一个符号链接：`ln
    -s ./demoCA`。这是因为`CA.pl`有时会期望在当前目录（`./`）中找到文件，它假设该目录是`demoCA/`，有时它期望在`./demoCA`中找到文件（这当然等同于`demoCA/demoCA/`）。您也可以通过简单地编辑`/etc/ssl/openssl.cnf`文件中`[CA_default]`下的`dir=`行，并将其设置为绝对路径来解决此问题。
- en: Creating a Certificate
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建证书
- en: 'Creating a certificate is a two-step process:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建证书是一个两步过程：
- en: We need to generate the Certificate Request.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要生成证书请求。
- en: We need to sign the request with the CA's signature.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要用CA的签名来签署请求。
- en: Let's see these steps in detail.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些步骤。
- en: Creating a New Certificate Request
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新的证书请求
- en: The first step in creating a valid SSL certificate is to create a Certificate
    Request. In the process, we will specify what information we want to show up on
    the certificate.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建有效的SSL证书的第一步是创建证书请求。在这个过程中，我们将指定我们希望在证书上显示的信息。
- en: There are a few ways to generate Certificate Requests. For example, you can
    use the `openssl` command line tool and specifying a number of command line parameters.
    But, following our previous example, we will use `CA.pl` and let the application
    prompt us for information as is necessary.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以生成证书请求。例如，您可以使用`openssl`命令行工具并指定一系列命令行参数。但是，按照我们之前的示例，我们将使用`CA.pl`并让应用程序在需要时提示我们输入信息。
- en: 'To generate a new request we will run `CA.pl -newreq`. In the next example
    the highlighted lines are lines that require us to enter information:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成新的请求，我们将运行`CA.pl -newreq`。在下一个示例中，突出显示的行是需要我们输入信息的行：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This should look familiar. It is similar in most respects to the process of
    generating a Certificate Authority.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该看起来很熟悉。在大多数方面，它与生成证书颁发机构的过程相似。
- en: First, we will be prompted to enter a pass phrase. We will use this pass phrase
    in a few moments.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将被提示输入一个密码短语。我们将在稍后使用这个密码短语。
- en: Next, we will be asked to supply information about the organization that this
    certificate will represent. As before the fields are Country Name, State/Province
    Name, Locality, Organization Name, Organizational Unit, Common Name (of the contact
    person), and the Email for the contact person. Again, as before, we entered the
    information for Example.Com.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要提供有关该证书所代表的组织的信息。和之前一样，字段包括国家名、州/省名、城市、组织名、组织单位、联系人常用名和联系人的电子邮件地址。同样，像之前一样，我们输入了Example.Com的相关信息。
- en: This time, however, we set the Common Name field to be the domain name of the
    server that the certificate is for—`example.com`. It is very important that you
    use the correct domain name for the server. During the certificate negotiation
    process clients will check the Common Name field to see if it matches the domain
    name of the server. If the names do not match the user may get an error message,
    or the client application may simply terminate the connection.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这次我们将“常用名称”字段设置为证书所对应的服务器域名——`example.com`。正确使用服务器的域名非常重要。在证书协商过程中，客户端会检查“常用名称”字段，看它是否与服务器的域名匹配。如果域名不匹配，用户可能会收到错误信息，或者客户端应用程序可能会直接终止连接。
- en: The extra *password* and *optional* *company* *name* are sometimes used in the
    certificate request process. Since we are doing the requesting and the signing
    ourselves we don't need to complete either of these fields.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的*密码*和*可选* *公司* *名称*有时会在证书请求过程中使用。由于我们自己在请求和签署过程中进行操作，因此不需要填写这些字段。
- en: 'Now we should have two files in the CA directory:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该在CA目录中有两个文件：
- en: One called `newreq.pem`, which contains a base-64 encoded representation of
    our certificate request
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一步是创建名为`newreq.pem`的文件，里面包含我们证书请求的base-64编码表示。
- en: One called `newkey.pem`, which contains the base-64 encoded private key
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二步是创建名为`newkey.pem`的文件，里面包含base-64编码的私钥。
- en: We are now ready to move on to the second step.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续进行第二步了。
- en: Signing the Certificate Request
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 签署证书请求
- en: 'The Certificate Request has all of the information required for a certificate,
    but it still lacks the digital signature of the CA. The next step, then, will
    be to use the CA we created previously to sign this new certificate. To do this,
    we will run `CA.pl -signreq`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 证书请求包含了证书所需的所有信息，但仍然缺少 CA 的数字签名。那么，下一步就是使用我们之前创建的 CA 来签署这个新证书。为此，我们将运行 `CA.pl
    -signreq`：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `CA.pl -signcert` command looks for `newreq.pem` and then begins the signing
    process. First, we need to enter the pass phrase for the CA. If that is correct,
    then `CA.pl` will display the certificate in `newreq.pem` and ask if we want to
    sign it. Finally, it will ask us to commit these changes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`CA.pl -signcert` 命令会查找 `newreq.pem` 文件，然后开始签名过程。首先，我们需要输入 CA 的密码短语。如果密码正确，`CA.pl`
    会显示 `newreq.pem` 中的证书，并询问是否要签署它。最后，它会要求我们提交这些更改。'
- en: Once the changes are committed a new file will be created, named `newcert.pem`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更改被提交，将会创建一个名为 `newcert.pem` 的新文件。
- en: 'There are two important files that we now have:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两个重要的文件：
- en: '`newkey.pem`, which contains the private key'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newkey.pem`，它包含私钥。'
- en: '`newcert.pem`, which contains the signed certificate.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newcert.pem`，它包含签名后的证书。'
- en: We've just got a few loose ends to tie up, and then we can move on to configuring
    SLAPD to use SSL/TLS.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要处理几个小问题，然后就可以继续配置 SLAPD 以使用 SSL/TLS。
- en: Configuring and Installing the Certificates
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置和安装证书
- en: We have only three more steps to do, here. The first one has to do with the
    pass phrase we set on our certificate.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要完成剩下的三个步骤。第一个步骤与我们在证书中设置的密码短语有关。
- en: Remove the Pass Phrase from the Key
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 移除密钥的密码短语
- en: Be very careful here! When generating our certificate request, we set a pass
    phrase on the certificate. This encrypted the `newkey.pem` file with a pass phrase.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要非常小心！在生成证书请求时，我们为证书设置了一个密码短语。这使得 `newkey.pem` 文件使用密码短语进行了加密。
- en: If you use a key file that is encrypted with a pass phrase, then every time
    you use this certificate, you will have to enter a password. This means, in our
    case, that every time we start OpenLDAP, we will have to enter a pass phrase.
    Unless we have stringent security requirements (and are willing to put up with
    the hassle of typing the pass phrase every time we start or restart the server),
    we probably do not want the key file to be encrypted.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是带有密码短语加密的密钥文件，那么每次使用这个证书时，你都必须输入密码。这意味着，在我们的例子中，每次启动 OpenLDAP 时，我们都需要输入密码短语。除非我们有严格的安全要求（并且愿意忍受每次启动或重启服务器时输入密码短语的麻烦），否则我们可能不希望密钥文件被加密。
- en: 'So, we will need to create an unencrypted version of the key file using the
    `openssl` command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要使用 `openssl` 命令创建一个未加密版本的密钥文件：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is what we get:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们得到的结果：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example the command `openssl rsa` executes the OpenSSL RSA tool, which
    will decrypt the key. Using `< newkey.pem`, we sent the file contents of `newkey.pem`
    into `openssl` to be decrypted. Then, using `> clearkey.pem` we directed `openssl`
    to write the cleartext key file to the `clearkey.pem` file. In order to complete
    this operation, `openssl` prompts for the pass phrase. Now `clearkey.pem` has
    the unencrypted private key for our certificate.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，命令 `openssl rsa` 执行了 OpenSSL RSA 工具，它将解密密钥。通过 `< newkey.pem`，我们将 `newkey.pem`
    文件的内容传递给 `openssl` 进行解密。然后，通过 `> clearkey.pem`，我们指示 `openssl` 将明文密钥文件写入 `clearkey.pem`
    文件。为了完成此操作，`openssl` 会提示输入密码短语。现在，`clearkey.pem` 文件包含了我们证书的未加密私钥。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `clearkey.pem` file now contains an unencrypted private key. This file should
    be protected from misuse. You should set strict permissions on this file so that
    other users of the system cannot access it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`clearkey.pem` 文件现在包含了一个未加密的私钥。此文件应该受到保护，以防止滥用。你应该为此文件设置严格的权限，以确保系统中的其他用户无法访问它。'
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The openssl Program**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenSSL 程序**'
- en: 'The `openssl` program performs dozens of SSL-related functions, from generating
    certificates to emulating a network-based SSL client. Its syntax is notoriously
    difficult though. That is why we have been using the `CA.pl` wrapper script to
    perform common tasks. But some tasks can only be done with the `openssl` command.
    Should you need them though, `openssl` has excellent man pages: `man openssl`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`openssl` 程序执行了几十个与 SSL 相关的功能，从生成证书到模拟基于网络的 SSL 客户端。其语法通常比较复杂。这也是为什么我们使用 `CA.pl`
    包装脚本来执行常见任务的原因。但有些任务只能通过 `openssl` 命令来完成。如果需要，`openssl` 有非常出色的手册页面：`man openssl`。'
- en: Relocate the Certificates
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 移动证书
- en: The second task is to move our new certificate and key to a useful location
    on the server, and give the PEM files useful names as well. If this certificate
    is to be used by lots of different services, it might make sense to locate it
    in the shared directory. But for our cases we will only be using the SSL certificate
    for LDAP, so we can put the files in `/etc/ldap/` (or `/usr/local/etc/openldap/`
    if you built from source).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个任务是将我们的新证书和密钥移动到服务器上的一个有用位置，并给PEM文件命名。如果这个证书需要被多个不同的服务使用，可能可以考虑将其放在共享目录中。但在我们的情况下，我们只会将SSL证书用于LDAP，所以我们可以将文件放在`/etc/ldap/`（如果您是从源代码构建的，可以放在`/usr/local/etc/openldap/`）。
- en: 'The two files with which we are concerned are `newcert.pem` and `clearkey.pem`.
    We need to rename and move those two keys:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注的两个文件是`newcert.pem`和`clearkey.pem`。我们需要重命名并移动这两个密钥：
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we need to set permissions and ownership on the certificate files. Since
    we did not add a pass phrase to the key, we should also make sure that only the
    OpenLDAP user can read the key file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为证书文件设置权限和所有权。由于我们没有给密钥添加密码短语，我们还应确保只有OpenLDAP用户能够读取该密钥文件：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first line changes the owner and group of the two PEM files to the `root`
    user and the `root` group. The second line sets the mode so that only the owner
    can read the file, and no one else has any access.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将两个PEM文件的所有者和组更改为`root`用户和`root`组。第二行设置权限，使得只有文件所有者能够读取该文件，其他人无法访问。
- en: If you are running OpenLDAP as a user other than root (and it is a good idea
    to do so), then the files should be owned by that user instead of root; for example
    `chown oenldap example.com.*.pem`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以非root用户运行OpenLDAP（这样做是个好主意），那么这些文件应该由该用户而非root用户拥有；例如`chown oenldap example.com.*.pem`。
- en: Install the CA Certificate
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装CA证书
- en: 'The third task is to install the CA''s public certificate so that other applications
    on the system can use that certificate to verify the authenticity of the certificate
    we just generated. First, we need to copy the CA certificate to the local certificate
    database for Ubuntu. In the process we will give it a user-friendly name:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个任务是安装CA的公用证书，以便系统上的其他应用程序可以使用该证书来验证我们刚生成的证书的真实性。首先，我们需要将CA证书复制到Ubuntu本地的证书数据库。在此过程中，我们将为它提供一个用户友好的名称：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then, edit the `/etc/ca-certificates.conf` file, and add `Example.Com.crt` at
    the end of the file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编辑`/etc/ca-certificates.conf`文件，并在文件末尾添加`Example.Com.crt`。
- en: 'Finally, run `update-ca-certificates`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行`update-ca-certificates`：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The CA certificate has now been installed. The `/etc/ssl/certs` directory is
    now the authoritative source for CA certificates.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: CA证书现在已经安装。`/etc/ssl/certs`目录现在是CA证书的权威来源。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: UNIX and Linux systems other than Ubuntu and Debian may not have the `update-ca-certificates`
    script. Consult the system documentation to find out how to update the certificate
    database on such systems.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Ubuntu和Debian之外的UNIX和Linux系统可能没有`update-ca-certificates`脚本。请查阅系统文档，了解如何在这些系统中更新证书数据库。
- en: 'Optional: Clean Up'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可选：清理
- en: 'If you want, you can do a little clean-up in the CA directory. Delete the encrypted
    key file and the certificate request file, both of which are in the `demoCA/`
    directory:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您可以在CA目录中做一些清理。删除加密的密钥文件和证书请求文件，这两个文件都位于`demoCA/`目录中：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Also, make sure `clearkey.pem` is no longer present in the `demoCA/` directory.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，确保`clearkey.pem`不再出现在`demoCA/`目录中。
- en: Now we are ready to configure OpenLDAP to use our new certificates. First, we
    will configure StartTLS support, which is the easiest, then we will configure
    SSL/TLS support on the LDAPS port, port 636.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好配置OpenLDAP以使用我们的新证书了。首先，我们将配置StartTLS支持，这是最简单的，然后我们将在LDAPS端口636上配置SSL/TLS支持。
- en: Configuring StartTLS
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置StartTLS
- en: In the previous sections we created our new certificate and key, and placed
    the two files in the `/etc/ldap` directory. In this section we will set up StartTLS
    (which we introduced earlier in this chapter in the StartTLS section). Setting
    up StartTLS requires only a few extra lines in the `slapd.conf` file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们创建了新证书和密钥，并将这两个文件放置在`/etc/ldap`目录中。在本节中，我们将设置StartTLS（我们在本章的StartTLS部分已经介绍过）。配置StartTLS只需要在`slapd.conf`文件中增加几行。
- en: Again, StartTLS is the standard way (according to RFC 4511) of providing SSL/TLS
    security to OpenLDAP. For security reasons support for StartTLS should be provided
    whenever practical.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，StartTLS是为OpenLDAP提供SSL/TLS安全性的一种标准方式（根据RFC 4511）。出于安全原因，应在实际操作中提供对StartTLS的支持。
- en: 'In the `slapd.conf` file, just before the `BDB Database Configuration` section,
    insert the SSL/TLS options:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `slapd.conf` 文件中，在 `BDB 数据库配置` 部分之前，插入 SSL/TLS 选项：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Basically, there are only three directives we need to specify to get StartTLS
    working:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们只需要指定三个指令就可以使 StartTLS 工作：
- en: The first directive, `TLSCACertificatePath`, tells SLAPD where to find all of
    the CA certificates that it will need for verifying certificates. The definitive
    location is, as we saw before, the `/etc/ssl/certs/` directory.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个指令 `TLSCACertificatePath` 告诉 SLAPD 在哪里找到所有它需要用于验证证书的 CA 证书。绝对位置是，正如我们之前看到的，`/etc/ssl/certs/`
    目录。
- en: The second directive, `TLSCertificateFile`, specifies the location of the signed
    certificate.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个指令 `TLSCertificateFile` 指定了已签名证书的位置。
- en: The third directive, `TLSCertificateKeyFile`, specifies the location of the
    corresponding key file, which has the private encryption key for the certificate.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个指令 `TLSCertificateKeyFile` 指定了相应密钥文件的位置，该文件具有证书的私有加密密钥。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are a handful of other TLS-specific directives that allow you to provide
    detailed constraints on TLS connections (such as which suites of ciphers can be
    used, and whether the client needs to provide a certificate to the server). Complete
    documentation on these can be found in the TLS section of the `slapd.conf` man
    page: `man slapd.conf`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他特定于 TLS 的指令，允许您对 TLS 连接提供详细的约束（例如可以使用哪些密码套件，以及是否需要客户端向服务器提供证书）。关于这些的完整文档可以在
    `slapd.conf` 手册的 TLS 部分找到：`man slapd.conf`。
- en: That's all we need to get SLAPD to perform StartTLS. Restart SLAPD so that the
    changes take effect.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们使 SLAPD 执行 StartTLS 所需的所有内容。重新启动 SLAPD 以使更改生效。
- en: Configuring Client TLS
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置客户端 TLS
- en: We do need to add a directive or two to `ldap.conf`—the configuration file that
    the OpenLDAP clients use. As with SLAPD, we need to direct the clients to the
    correct location of the new CA certificate so that they can verify the server
    certificate.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实需要在 `ldap.conf` 中添加一两个指令——这是 OpenLDAP 客户端使用的配置文件。与 SLAPD 类似，我们需要将客户端指向新的
    CA 证书的正确位置，以便它们可以验证服务器证书。
- en: 'At the bottom of the `ldap.conf` file we can add the appropriate directive:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ldap.conf` 文件的底部，我们可以添加适当的指令：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Clients will use this directive to locate the CA certificates for checking digital
    signatures on the certificates they get from servers. If you know that you are
    only going to use certificates signed by a specific CA, you can use the `TLS_CACERT`
    directive to point to a specific CA certificate file, instead of a directory containing
    one or more certificates.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将使用此指令来定位 CA 证书，以便检查从服务器获取的证书的数字签名。如果您知道您只会使用由特定 CA 签名的证书，可以使用 `TLS_CACERT`
    指令指向特定的 CA 证书文件，而不是包含一个或多个证书的目录。
- en: By default, OpenLDAP clients always perform a check on the digital signatures.
    If a server sends a certificate that was signed by a CA other than those at `/etc/ssl/certs/`
    (or whatever directory `TLS_CACERTDIR` points to), then the client will close
    the connection and print an error message to the screen.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，OpenLDAP 客户端始终对数字签名进行检查。如果服务器发送的证书由 `/etc/ssl/certs/`（或 `TLS_CACERTDIR`
    指向的任何目录）之外的 CA 签名，那么客户端将关闭连接并在屏幕上打印错误消息。
- en: Sometimes though, the correct CA certificate is not available, and it is worthwhile
    to get the encryption support of TLS even if it is not possible to verify the
    identity of the server.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，即使无法验证服务器的身份，也值得获得 TLS 的加密支持，因此正确的 CA 证书不可用。
- en: 'In such cases you may find it necessary to change the way OpenLDAP clients
    perform identification checks. For example, it might be desirable to try to verify
    the certificate, but to continue with the connection even if there is no appropriate
    CA locally. To accomplish this, use the following directive in `slapd.conf`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可能需要更改 OpenLDAP 客户端执行身份验证检查的方式。例如，可能希望尝试验证证书，但即使没有适当的本地 CA，也希望继续连接。为此，在
    `slapd.conf` 中使用以下指令：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, if there is no CA certificate or if the certificate sent cannot
    be verified, the session will continue, rather than exiting with an error message.
    `TLS_REQCERT` has a few different levels of checking, ranging from `strict` (always
    verify) to `never` (do not even bother trying to verify certificates).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果没有 CA 证书或者发送的证书无法验证，会话将继续，而不会显示错误消息。`TLS_REQCERT` 有几个不同的检查级别，从 `strict`（始终验证）到
    `never`（甚至不尝试验证证书）不等。
- en: 'At this point, we can use `ldapsearch` to test a connection. To instruct a
    client to use StartTLS, we need to use the `-Z` flag. But if just `-Z` is specified,
    if the client fails TLS negotiation with the server, it will continue with the
    transaction in clear text. In other words, with `-Z`, TLS is preferred, but not
    required. To make TLS required, we will add an extra z to the flag, making it
    `-ZZ`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以使用 `ldapsearch` 来测试连接。要指示客户端使用 StartTLS，我们需要使用 `-Z` 标志。但是，如果仅指定 `-Z`，当客户端与服务器的
    TLS 协商失败时，它将继续以明文进行事务。换句话说，使用 `-Z` 时，TLS 是优先的，但不是强制的。要使 TLS 成为必需，我们将向标志中添加一个额外的
    z，使其变为 `-ZZ`：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This should prompt for a password and then return one result:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会提示输入密码，然后返回一个结果：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the result comes back like this, then TLS was successfully configured. But
    TLS can be difficult to get configured because it is strict by design. Small errors
    in configuration (like using a domain name that differs from the one in the CN
    field of the certificate) can prevent TLS from working. Consider this example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果返回如下，则表示 TLS 配置成功。但由于 TLS 在设计上是严格的，配置可能会很困难。配置中的小错误（例如使用与证书中的 CN 字段不同的域名）可能会导致
    TLS 无法正常工作。考虑以下示例：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, the host name specified on the command line (`localhost`) differed
    from the one in the CN field of the certificate (`example.com`). Even though,
    in this case, the two domain names are hosted on the same system, TLS will not
    accept the mismatch.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，命令行中指定的主机名（`localhost`）与证书中的 CN 字段（`example.com`）中的主机名不同。尽管在此情况下，这两个域名托管在同一系统上，TLS
    仍然不接受不匹配。
- en: 'Other common errors in TLS are:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 中的其他常见错误包括：
- en: Reversing the values of the `TLSCertificateFile` and the `TLSCertificateKeyFile`
    directives
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转 `TLSCertificateFile` 和 `TLSCertificateKeyFile` 指令的值
- en: Forgetting to install the CA certificate (which results in an error indicating
    that the server certificate cannot be verified)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忘记安装 CA 证书（导致出现错误，表示无法验证服务器证书）
- en: Forgetting to set the client CA path correctly in `ldap.conf`
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忘记在 `ldap.conf` 中正确设置客户端 CA 路径
- en: Setting the read/write permissions (or the ownership) on the key file (or the
    certificate file) in such a way that the SLAPD server cannot read it
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在密钥文件（或证书文件）上设置读/写权限（或所有权），使得 SLAPD 服务器无法读取它
- en: While OpenLDAP can be forgiving in many areas, TLS configuration is not one
    of them. It pays to take extra care when configuring TLS and SSL.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 OpenLDAP 在许多方面可以宽容，但 TLS 配置并不是其中之一。在配置 TLS 和 SSL 时需要特别小心。
- en: Configuring LDAPS
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 LDAPS
- en: Now that we have configured TLS, we need to take only a few additional steps
    to enable SSL/TLS on its own port. The traditional port for running dedicated
    TLS/SSL-protected LDAP traffic is port 636, the LDAPS port.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了 TLS，接下来只需执行几个额外的步骤，以便在其专用端口上启用 SSL/TLS。运行专用的 TLS/SSL 保护的 LDAP 流量的传统端口是
    636，LDAPS 端口。
- en: Most of the time it is better to use StartTLS. However, network considerations
    (like clients that do not support StartTLS or policies dictating mandatory blocking
    on ports that allow non-encrypted text) might warrant using LDAPS.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，使用 StartTLS 更好。然而，网络因素（如不支持 StartTLS 的客户端或要求强制阻塞允许非加密文本的端口的政策）可能需要使用 LDAPS。
- en: Keep in mind that LDAPS and StartTLS can both be used for the same server. SLAPD
    can accept LDAPS traffic on a dedicated port, and continue to provide the StartTLS
    feature on an LDAP port.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，LDAPS 和 StartTLS 都可以用于同一服务器。SLAPD 可以在专用端口上接受 LDAPS 流量，并继续在 LDAP 端口提供 StartTLS
    功能。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Like the StartTLS configuration, this configuration requires that the `slapd.conf`
    file have the `TLSCertificateFile`, `TLSCertificateKeyFile`, and `TLSCACertificateDir`
    directives set.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与 StartTLS 配置类似，此配置要求 `slapd.conf` 文件中设置 `TLSCertificateFile`、`TLSCertificateKeyFile`
    和 `TLSCACertificateDir` 指令。
- en: Getting SLAPD to listen on this port requires passing an additional parameter
    when starting `slapd`. In Ubuntu, as with other Debian-based distributions, configuration
    parameters can be set in the `/etc/defaults/slapd` file. In that file we just
    need to set `SLAPD_SERVICES`. When the start script is executed, SLAPD will start
    all of the services listed here.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 SLAPD 监听此端口，需要在启动 `slapd` 时传递一个额外的参数。在 Ubuntu 中，与其他基于 Debian 的发行版一样，配置参数可以在
    `/etc/defaults/slapd` 文件中设置。在该文件中，我们只需要设置 `SLAPD_SERVICES`。当启动脚本执行时，SLAPD 会启动此处列出的所有服务。
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The given code tells SLAPD to listen on all available IP addresses on both
    the default LDAP (port 389) and the default LDAPS (port 636). If we wanted SLAPD
    to only listen on one address for LDAP traffic, but all addresses for LDAPS traffic,
    we could replace the above with:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的代码指示 SLAPD 在所有可用的 IP 地址上监听默认的 LDAP（端口 389）和默认的 LDAPS（端口 636）。如果我们希望 SLAPD
    只在一个地址上监听 LDAP 流量，但在所有地址上监听 LDAPS 流量，可以将上面的配置替换为：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, the `ldap://127.0.0.1/` tells SLAPD to only listen on the loopback address
    for LDAP traffic, while `ldaps:///` indicates that SLAPD should listen for LDAPS
    traffic on all of the IP addresses configured for this host. You will need to
    restart SLAPD in order for these changes to take effect.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ldap://127.0.0.1/` 告诉 SLAPD 仅在回环地址上监听 LDAP 流量，而 `ldaps:///` 则表示 SLAPD 应该在为该主机配置的所有
    IP 地址上监听 LDAPS 流量。你需要重启 SLAPD，才能使这些更改生效。
- en: 'Similarly, if you built from source and want to start `slapd` directly, the
    `-h` command line flag lets you specify which services to start:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果你是从源代码构建并且想直接启动 `slapd`，`-h` 命令行参数可以让你指定启动哪些服务：
- en: '[PRE22]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That is all there is to configuring LDAPS. We can now test it with `ldapsearch`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 LDAPS 就这么简单。我们现在可以用 `ldapsearch` 来测试它：
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are two crucial differences between this `ldapsearch` and the ones we
    used when testing StartTLS:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `ldapsearch` 和我们在测试 StartTLS 时使用的有两个关键区别：
- en: The protocol for the URL specified after the `-H` flag is `ldaps://` rather
    than `ldap://`.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-H` 参数后指定的 URL 协议是 `ldaps://`，而不是 `ldap://`。'
- en: There is no `-Z` or `-ZZ` flag here. Those flags tell the client to send the
    StartTLS command, and SSL/TLS over a dedicated port do not recognize the StartTLS
    command.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里没有 `-Z` 或 `-ZZ` 参数。这些参数告诉客户端发送 StartTLS 命令，而 SSL/TLS 通过专用端口时，不会识别 StartTLS
    命令。
- en: If you get an error doing the given search, but StartTLS is working properly,
    the first place to look is at the firewall settings. Typically, firewalls allow
    traffic on port 389, but block 636\. It is also useful to make sure that the server
    is actually listening on port 636\. You can check this from a shell prompt using
    `netstat –tcp -l`, which will print out a list of what ports are being used. If
    LDAPS (636) does not show up, then check `/etc/defaults/slapd` again to make sure
    that the `SLAPD_SERVICES` directive is set correctly.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在进行给定的搜索时遇到错误，但 StartTLS 工作正常，首先要检查的是防火墙设置。通常，防火墙会允许通过 389 端口的流量，但会阻塞 636
    端口。还可以确保服务器确实在监听 636 端口。你可以通过命令行使用 `netstat –tcp -l` 来检查，这会显示正在使用的端口列表。如果 LDAPS（636）没有出现，检查
    `/etc/defaults/slapd` 配置，确保 `SLAPD_SERVICES` 指令设置正确。
- en: Debugging with the OpenSSL Client
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 OpenSSL 客户端调试
- en: 'In some cases it is useful to be able to connect to SLAPD over LDAPS and watch
    the certificate processing. The `openssl` program can do this with its built-in
    `s_client` client application:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，能够通过 LDAPS 连接到 SLAPD 并观察证书处理过程是有用的。`openssl` 程序可以通过其内置的 `s_client` 客户端应用程序实现这一点：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `-connect` parameter takes a host name followed by a colon and a port number.
    When this command is run, `openssl` will connect to a remote server using SSL,
    and perform the certificate negotiation. The entire negotiation process is written
    to the screen. If certificate negotiation succeeds, then `openssl` leaves the
    connection open, and you can type in raw protocol commands at the command line.
    To exit, just hit *CTRL*+*C*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`-connect` 参数接受主机名，后面跟一个冒号和端口号。当运行此命令时，`openssl` 将通过 SSL 连接到远程服务器，并执行证书协商。整个协商过程将显示在屏幕上。如果证书协商成功，`openssl`
    将保持连接打开，你可以在命令行输入原始协议命令。要退出，只需按 *CTRL*+*C*。'
- en: Now we have both StartTLS and TLS/SSL working. We have one more short item to
    cover in this section, and then we will move on to authentication.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使 StartTLS 和 TLS/SSL 都能正常工作。我们在这一节中只剩下一个简短的内容要讲解，之后我们将进入认证部分。
- en: Using Security Strength Factors
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用安全强度因子
- en: There are advantages to running StartTLS. It is simpler to configure, it is
    easier (in many respects) to debug, and complex transactions can switch back and
    forth from cleartext to encryption as needed.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 StartTLS 有其优势。它更容易配置，在许多方面更容易调试，且复杂的事务可以根据需要在明文和加密之间切换。
- en: 'But there is one clear drawback: we can use a standard firewall to block non-encrypted
    traffic when all clear text goes over one port and all encrypted traffic goes
    over another. But when both go over the same port, many firewalls can''t do much
    to verify that the traffic is secure.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个明显的缺点：当所有明文流量通过一个端口而所有加密流量通过另一个端口时，我们可以使用标准防火墙来阻止未加密的流量。但当两者都通过同一端口时，许多防火墙无法验证流量是否安全。
- en: But OpenLDAP does provide some tools for implementing this sort of security
    in SLAPD, instead of in a firewall.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 但OpenLDAP确实提供了一些工具来在SLAPD中实现这种安全性，而不是在防火墙中实现。
- en: OpenLDAP can examine the integrity and encryption state of a connection and,
    based on those features, assign a **Security Strength Factor (SSF)** to that connection.
    An SSF is a numeric representation of the strength of the protective measures
    used.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP可以检查连接的完整性和加密状态，并根据这些特性为该连接分配一个**安全强度因子（SSF）**。SSF是用于表示保护措施强度的数字表示。
- en: Most of the SSF numbers simply reflect the key length of the encryption cipher.
    For example, since the maximum key length for **DES** is 56, when a connection
    is protected using DES, the SSF is 56\. **Triple-DES (3DES)**, which is the cipher
    used by default in Ubuntu's OpenSSL configuration, has a key length of 112\. Hence,
    its SSF is also 112\. The **AES** cipher, which is strong and can be computed
    quickly, can use different key sizes. AES-128 uses a 128-bit key, while AES-256
    uses a 256-bit key. In the case of AES then, the SSF will reflect the key size.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数SSF数字只是反映了加密算法的密钥长度。例如，由于**DES**的最大密钥长度为56，当使用DES保护连接时，SSF为56。**Triple-DES
    (3DES)**，这是Ubuntu的OpenSSL配置中默认使用的加密算法，密钥长度为112。因此，它的SSF也是112。**AES**加密算法既强大又能快速计算，可以使用不同的密钥大小。AES-128使用128位密钥，而AES-256使用256位密钥。因此，AES的SSF将反映密钥大小。
- en: 'There are two special SSF numbers: 0 and 1\. An SSF of 0 indicates (as might
    be expected) that no security measures have been implemented. An SSF of 1 indicates
    that only integrity checking on the connection is being done.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个特殊的SSF数字：0和1。SSF为0表示（正如预期的那样）没有实施任何安全措施。SSF为1表示仅对连接进行完整性检查。
- en: OpenLDAP can use SSF information to determine whether a client is allowed to
    connect to the directory. SSF information can also be used in ACLs and in SASL
    configuration, effectively allowing complex rules to be built as to what conditions
    a client connection must satisfy before getting access to perform certain operations
    on the directory.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP可以使用SSF信息来确定客户端是否可以连接到目录。SSF信息还可以在ACL和SASL配置中使用，有效地允许构建复杂的规则，以确定客户端连接必须满足哪些条件，才能在目录上执行某些操作。
- en: We will look at SASL authentication and ACLs later in this chapter, but right
    now we will look at using SSFs in the `security` directive in `slapd.conf` as
    a way of specifying how secure a connection must be in order to access the database.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论SASL身份验证和ACL，但现在我们将看看如何在`slapd.conf`中的`security`指令中使用SSF，作为指定连接必须多安全才能访问数据库的一种方式。
- en: The security Directive
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全性指令
- en: 'The `security` directive can be used in two different contexts in `slapd.conf`.
    If it is put near the top of the file, before any backend databases are defined,
    then it is placed in the *global* context and will apply to all connections. On
    the other hand, if the security directive is placed within a backend definition,
    then it will only be applied to that particular database. For example, consider
    a case where there are two backends:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`security`指令可以在`slapd.conf`中以两种不同的方式使用。如果它放在文件的顶部，在任何后端数据库定义之前，则它被放置在*全局*上下文中，并将应用于所有连接。另一方面，如果`security`指令放在某个后端定义内，则它只会应用于该特定数据库。例如，考虑一个有两个后端的情况：'
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This partial example of a `slapd.conf` file defines two directory backends.
    Now, if the `security` directive is used before the first database is defined
    (namely before the line that says `database hdb`), then it will be applied globally
    to all connections.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`slapd.conf`文件的部分示例定义了两个目录后端。现在，如果`security`指令在第一个数据库定义之前使用（即在`database hdb`那行之前），则它将全局应用于所有连接。
- en: 'But if we wanted to allow non-encrypted connections to DB 2, but allow only
    well-encrypted connections to DB 1 (which houses all of our user entries), we
    could use separate `security` directives:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想允许对数据库2的未加密连接，但只允许对数据库1（它包含所有用户条目）进行加密连接，我们可以使用不同的`security`指令：
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note the addition of the two highlighted lines—two separate `security` directives,
    one for each database backend.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意两个突出显示的行的添加——两个单独的 `security` 指令，每个后端数据库一个。
- en: 'Now, restarting the directory (note that the `loglevel` is set to `stats`),
    we can test out the security parameters with `ldapsearch`. First, we will try
    to search the `Users` OU with a non-TLS connection:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新启动目录（请注意 `loglevel` 设置为 `stats`），我们可以使用 `ldapsearch` 测试安全参数。首先，我们将尝试使用非
    TLS 连接搜索 `Users` OU：
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the log we see entries like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志中，我们看到如下条目：
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The third line indicates that the server returned error number 13: `confidentiality
    required`. This is because we did not do anything to protect the connection. Using
    simple authentication (which is not encrypted) and failing to use TLS/SSL resulted
    in the client connection having an effective SSF of 0.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行指示服务器返回错误编号 13：`confidentiality required`。这是因为我们没有采取任何措施来保护连接。使用简单的认证（未加密）并未使用
    TLS/SSL 导致客户端连接的有效 SSF 为 0。
- en: 'Next, let''s do the same search with TLS turned on:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用启用 TLS 的相同搜索：
- en: '[PRE29]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note that in this example, the `-Z` flag is included to send the StartTLS command.
    Now, the server log says:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此示例中，包含 `-Z` 标志以发送 StartTLS 命令。现在，服务器日志显示：
- en: '[PRE30]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There are a few things to note about this result. On the second line, OpenLDAP
    reports that it is doing StartTLS. Two lines later it reports: `TLS established
    tls_ssf=256 ssf=256`. This line indicates that the TLS connection has an SSF of
    256 (since the connection is using AES-256), and that the total SSF of the connection
    is 256.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此结果有几点需要注意。在第二行，OpenLDAP 报告正在执行 StartTLS。两行后，它报告：`TLS established tls_ssf=256
    ssf=256`。此行指示 TLS 连接的 SSF 为 256（因为连接正在使用 AES-256），连接的总 SSF 为 256。
- en: 'If you look a few lines lower, on the second line that begins `BIND`, you will
    notice that there another SSF is reported: `ssf=0`. Why?'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向下看几行，可以看到开始 `BIND` 的第二行，您会注意到另一个报告的 SSF：`ssf=0`。为什么呢？
- en: OpenLDAP measures SSF on various aspects of the connection. First, as we can
    see above, it checks the SSF of the network connection. TLS/SSL connections are
    assigned an SSF based on their cipher strength.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP 在连接的各个方面上测量 SSF。首先，正如我们上面所看到的，它检查网络连接的 SSF。基于它们的密码强度，TLS/SSL 连接被分配一个
    SSF。
- en: But during the bind phase when the client authenticates to the directory, OpenLDAP
    also measures the SSF of the authentication mechanism. The simple (`mech=SIMPLE`)
    authentication mechanism does not encrypt the password, and so it is always given
    an SSF of 0.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 但在客户端对目录进行身份验证的绑定阶段期间，OpenLDAP 也测量认证机制的 SSF。简单（`mech=SIMPLE`）认证机制不会加密密码，因此始终给予
    SSF 为 0。
- en: The total SSF for the connection, however, remains at 256, with the TLS SSF
    being 256 and the SASL SSF at 0.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，连接的总 SSF 仍为 256，其中 TLS SSF 为 256，SASL SSF 为 0。
- en: A Fine-Grained security Directive
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个精细化的安全指令
- en: The `security` directive that we have looked at so far is basic. It simply requires
    that the overall SSF be 112 (3DES encryption) or greater, but we can make it more
    specific.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们查看的 `security` 指令很基础。它只要求总 SSF 至少为 112（3DES 加密），但我们可以使其更具体。
- en: 'For example, we can simply require that any TLS connection have at least a
    128 bit key:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以简单地要求任何 TLS 连接至少有一个 128 位的密钥：
- en: '[PRE31]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will require that all incoming connections use TLS with a strong (128 bit
    or greater) cipher.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这将要求所有传入的连接使用具有强大（128 位或更高）的 TLS 密码。
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In some cases it is desirable to define which TLS/SSL ciphers or cipher families
    will be used. This cannot be done with the `security` directive. Instead, you
    will need to use the `TLSCipherSuite` directive, which will allow you to give
    a detailed specification for which ciphers are acceptable for TLS/SSL connections.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，定义将使用哪些 TLS/SSL 密码或密码族是可取的。这不能通过 `security` 指令完成。相反，您将需要使用 `TLSCipherSuite`
    指令，允许您为 TLS/SSL 连接指定可接受的密码详细规范。
- en: 'Or, if we only wanted to define a strong SSF for connections that try to perform
    a simple bind (as opposed to an SASL bind), then we can specify an SSF just for
    simple binding:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们只想为试图执行简单绑定（而不是 SASL 绑定）的连接定义一个强 SSF，那么我们可以为简单绑定指定一个 SSF：
- en: '[PRE32]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will require that some strong TLS cipher be used to protect the authentication
    information.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这将要求使用一些强大的 TLS 密码来保护认证信息。
- en: Tip
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you plan to allow simple binding, and you are running on a non-secure network,
    you are strongly advised to configure TLS/SSL and require TLS encryption during
    the bind operation using the `security` directive.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划允许简单绑定，并且你正在一个不安全的网络上运行，强烈建议你配置 TLS/SSL 并在绑定操作期间通过 `security` 指令要求 TLS
    加密。
- en: 'You can also use the `update_ssf` keyword in the `security` directive to set
    the SSF necessary for updating operations. Thus you could specify that only low-grade
    encryption is needed for reading the directory, but high-grade encryption must
    be used for performing updates to directory information:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 `security` 指令中使用 `update_ssf` 关键字来设置更新操作所需的 SSF。因此，你可以指定对于读取目录只需要低级加密，但在执行目录信息更新时必须使用高级加密：
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the coming section, we will look at SASL configuration. You can use the `security`
    directive to set SSF for SASL binding as well using the `sasl=` and `update_sasl=`
    phrases.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论 SASL 配置。你也可以使用 `security` 指令通过 `sasl=` 和 `update_sasl=` 关键字来为
    SASL 绑定设置 SSF。
- en: Finally, in rare cases where OpenLDAP is listening on a local socket (that is,
    `ldapi://`), you can use `security transport=112` (or whatever cipher strength
    you desire) to ensure that traffic coming over that socket is encrypted.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在极少数情况下，当 OpenLDAP 监听本地套接字（即 `ldapi://`）时，你可以使用 `security transport=112`（或任何你需要的加密强度）来确保通过该套接字传输的流量是加密的。
- en: 'At this point, we have completed our examination of SSL and TLS. Next, we will
    move on to the second of our three aspects of security: authentication.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已完成对 SSL 和 TLS 的讨论。接下来，我们将继续研究安全性三大方面中的第二个：认证。
- en: Authenticating Users to the Directory
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将用户认证到目录
- en: As we have seen earlier in the book, OpenLDAP supports two different methods
    of binding (or authenticating) to the directory. The first is to use simple binding.
    The second is to use SASL binding. In this part we will look at each of these
    two methods of authentication.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书前面看到的，OpenLDAP 支持两种不同的绑定（或认证）方式。第一种是使用简单绑定。第二种是使用 SASL 绑定。在本部分中，我们将分别介绍这两种认证方法。
- en: It is not necessary to choose one or the other. OpenLDAP can be configured to
    do both, at which point it is up to the client as to which method will be used.
    Simple binding is easier to configure (there is very little configuration that
    must be done). But SASL is more secure and more flexible, though these benefits
    come at the cost of added complexity.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 并不需要选择其中一个。OpenLDAP 可以配置同时支持这两种方式，这时由客户端决定使用哪种方法。简单绑定更容易配置（需要的配置非常少）。但 SASL
    更安全且更灵活，尽管这些优点伴随着额外的复杂性。
- en: The basics of the bind operation and the authentication process are covered
    early in Chapter 3\. While we will review some of that materials here, you may
    find it useful to glance back at that section.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定操作和认证过程的基础知识已在第 3 章的早期部分介绍。虽然我们将在这里回顾一些相关内容，但你可能会觉得回头看看该部分的内容很有帮助。
- en: Simple Binding
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单绑定
- en: The first form of authentication we will look at is simple binding. It is simple
    not necessarily from the user's perspective, but it is definitely easier to configure,
    and the process of binding is easier on the server, too, since less processing
    is needed.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看看的认证形式是简单绑定。从用户的角度来看，它不一定简单，但它肯定更容易配置，而且绑定过程对服务器来说也更简单，因为需要的处理较少。
- en: 'To perform a simple bind the server requires two pieces of information: a DN
    and a password. If both the DN and the password fields are empty then the server
    attempts to bind as the Anonymous user.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行简单绑定，服务器需要两个信息：一个 DN 和一个密码。如果 DN 和密码字段都为空，则服务器会尝试以匿名用户身份绑定。
- en: During a simple bind the client connects to the server and sends the DN and
    password information to the server, without adding any additional security. The
    password, for example, is not specially encrypted.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单绑定过程中，客户端连接到服务器并将 DN 和密码信息发送给服务器，而不会添加任何额外的安全措施。例如，密码并没有特别加密。
- en: If the client is communicating over TLS/SSL, then the whole transaction will
    be encrypted, and so the password will be safe. If the client is not using TLS/SSL
    then the password will be sent over the network in cleartext. This, of course,
    is a security issue, and should be avoided (perhaps by using the `security` directive
    discussed in the previous section, or by using an SASL bind instead of a simple
    bind).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端通过 TLS/SSL 进行通信，那么整个事务将被加密，密码也会因此得到保护。如果客户端没有使用 TLS/SSL，则密码将以明文形式通过网络发送。这当然是一个安全问题，应该避免（可以通过使用上一节中讨论的
    `security` 指令，或者使用 SASL 绑定代替简单绑定）。
- en: There are two common ways in which client applications attempt to perform a
    simple bind. The first is sometimes called **Fast Bind**. In a Fast Bind, the
    client supplies a full DN (`uid=matt,ou=users,dc=example,dc=com`) and also a password
    (`myPassword`). It is faster than the common alternative (binding as anonymous
    and searching for the desired DN).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序执行简单绑定有两种常见方法。第一种方法有时被称为 **快速绑定**。在快速绑定中，客户端提供完整的 DN（`uid=matt,ou=users,dc=example,dc=com`）以及密码（`myPassword`）。它比常见的替代方法（以匿名身份绑定并搜索所需的
    DN）更快。
- en: Note
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: '**Cyrus SASLAuthd**, which provides SASL authentication services to other applications,
    is the application in which the term "Fast Bind" was first used. SASLAuthd is
    a useful tool for providing SASL authentication services. We will look at it again
    in the next section. Nowhere in the OpenLDAP documentation, is the term "Fast
    Bind" used.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cyrus SASLAuthd** 提供给其他应用程序 SASL 认证服务，它是第一个使用“快速绑定”术语的应用程序。SASLAuthd 是一个为应用程序提供
    SASL 认证服务的有用工具。我们将在下一节中再次讨论它。在 OpenLDAP 文档中，根本没有使用“快速绑定”这一术语。'
- en: The directory first performs, as the anonymous user, an **auth** access on the
    `userPassword` attribute of the DN that the client supplies. In an auth access
    the server compares the value of the supplied password to the value of the `userPassword`
    stored in the directory. If the `userPassword` value is hashed (with, for example,
    SSHA or SMD5), then SLAPD hashes the password that the user supplies, and then
    compares the hashes. If the values match, OpenLDAP binds the user and allows it
    to perform other LDAP operations.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 目录首先作为匿名用户，对客户端提供的 DN 的 `userPassword` 属性执行 **auth** 访问。在 auth 访问中，服务器会将提供的密码值与存储在目录中的
    `userPassword` 值进行比较。如果 `userPassword` 值已加密（例如，使用 SSHA 或 SMD5），那么 SLAPD 会将用户提供的密码进行哈希处理，然后比较哈希值。如果值匹配，OpenLDAP
    将绑定用户并允许其执行其他 LDAP 操作。
- en: Note
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: The OpenLDAP command-line clients, when used with the `-x` option, perform simple
    binding. The clients require that you specify the entire user DN and a password,
    and they then perform a Fast Bind.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `-x` 选项时，OpenLDAP 命令行客户端执行简单绑定。客户端要求你指定完整的用户 DN 和密码，然后它们会执行快速绑定。
- en: That's a Fast Bind. But there is a second common method of doing a simple bind—a
    method designed to eliminate the requirement that the user know an entire DN.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是快速绑定。但是，还有第二种常见的简单绑定方法——一种旨在消除用户需要知道完整 DN 的要求的方法。
- en: In this second method (which is not, incidentally, called a "slow bind"), the
    client application requires that the user only know some particular unique identifier—usually
    the value of `uid` or `cn`. The client application then binds to the server as
    anonymous (or another pre-configured user) and performs a search for a DN that
    contains the matching attribute value. If it finds one (and only one) matching
    DN, then it re-binds, using the retrieved DN and the user-supplied password.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种方法中（顺便说一下，这并不叫“慢绑定”），客户端应用程序要求用户只知道某个特定的唯一标识符——通常是 `uid` 或 `cn` 的值。客户端应用程序然后作为匿名用户（或另一个预配置的用户）绑定到服务器，并执行搜索，寻找包含匹配属性值的
    DN。如果找到一个（且只有一个）匹配的 DN，它就会重新绑定，使用检索到的 DN 和用户提供的密码。
- en: 'Usually, client applications that use simple bind will need a base DN. The
    second method of performing a simple bind requires one additional piece of information
    not required in a Fast Bind: a search filter. The filter is usually something
    like `(&(uid=?)(objectclass=inetOrgPerson))`, where the question mark (`?`) is
    replaced by the user-supplied value.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用简单绑定的客户端应用程序需要一个基础 DN。执行简单绑定的第二种方法需要一个附加信息，这在快速绑定中是不需要的：一个搜索过滤器。过滤器通常像这样
    `(&(uid=?)(objectclass=inetOrgPerson))`，其中问号（`?`）由用户提供的值替换。
- en: Using an Authentication User for Simple Binding
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用认证用户进行简单绑定
- en: 'While it is more convenient for the user when only a user ID or a CN is required,
    the second method we have seen may raise an additional concern: the Anonymous
    user, in order to perform the search, must have *read* access to all user records
    in the directory. This means that anyone can connect to the directory (remember,
    Anonymous has no password) and perform searches.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然当只需要用户 ID 或 CN 时用户更为便捷，但我们所看到的第二种方法可能会引发一个额外的担忧：为了执行搜索，匿名用户必须具有*读取*目录中所有用户记录的权限。这意味着任何人都可以连接到目录（记住，匿名用户没有密码）并执行搜索。
- en: In many cases this isn't a problem. Allowing someone to see a list of all the
    users in the directory may not be a security concern at all. But in other cases,
    such access would not be acceptable.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，这并不是问题。允许某人查看目录中所有用户的列表可能根本不会构成安全隐患。但在其他情况下，这种访问是不可接受的。
- en: 'One way to work around this problem is to use a different user (rather than
    Anonymous) to perform the search for the user''s DN. In the last chapter, we created
    just such an account. Here is the LDIF record we used:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是使用不同的用户（而不是匿名用户）来执行用户 DN 的查找。在上一章中，我们创建了这样一个账户。以下是我们使用的 LDIF 记录：
- en: '[PRE34]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The purpose of this account is to log into the server and perform searches for
    DNs. In other words, it conducts the same job as the Anonymous user, but it adds
    a little more security, since clients that use the `uid=authenticate` account
    will have to have the appropriate password, too.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个账户的目的是登录到服务器并执行 DN 查找。换句话说，它执行与匿名用户相同的工作，但它增加了一些安全性，因为使用`uid=authenticate`账户的客户端也必须具有相应的密码。
- en: To make this clear let's look at the case where a client, configured to use
    the Authenticate account, binds a user that identifies himself as `matt` with
    the password `myPassword`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确这一点，我们来看一个案例：一个配置为使用 Authenticate 账户的客户端，将一个自我标识为`matt`，密码为`myPassword`的用户进行绑定。
- en: 'Here''s a step-by-step breakdown of what happens when doing a bind operation
    this way:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是逐步分析当以这种方式执行绑定操作时发生的情况：
- en: Client connects to the server and starts a bind operation with the DN `uid=autenticate,ou=system,dc=example,dc=com`
    and the password `secret`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端连接到服务器，并开始使用 DN `uid=authenticate,ou=system,dc=example,dc=com`和密码`secret`执行绑定操作。
- en: The server, as Anonymous, compares the Authenticate password, `secret`, with
    the value of the `userPassword` attribute for the `uid=autenticate,ou=system,dc=example,dc=com`
    record.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器作为匿名用户，将 Authenticate 密码`secret`与`uid=authenticate,ou=system,dc=example,dc=com`记录中的`userPassword`属性值进行比较。
- en: 'If the above succeeds, then the client (now logged in as the Authenticate user)
    performs a search with the filter: `(&(uid=matt)(objectclass=inetOrgPerson))`.
    Since `uid` is unique, the search should return either 0 or 1 record.'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果上述步骤成功，那么客户端（现在已登录为 Authenticate 用户）将使用过滤器`(&(uid=matt)(objectclass=inetOrgPerson))`执行搜索。由于`uid`是唯一的，搜索应该返回0或1条记录。
- en: If one matching DN is found (in our case, it would be `uid=matt,ou=user,dc=example,dc=com`),
    then the client tries to re-bind as this DN, and using the password the user initially
    supplies to the client (`myPassword`).
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到匹配的 DN（在我们这个例子中是`uid=matt,ou=user,dc=example,dc=com`），那么客户端将尝试以该 DN 重新绑定，并使用用户最初提供给客户端的密码（`myPassword`）。
- en: The server, as Anonymous, compares the user-supplied password, `myPassword`,
    with the value of the `userPassword` attribute of `uid=matt,ou=user,dc=example,dc=com`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器作为匿名用户，将用户提供的密码`myPassword`与`uid=matt,ou=user,dc=example,dc=com`的`userPassword`属性值进行比较。
- en: If the password comparison succeeds then the client application can continue
    performing LDAP operations as `uid=matt,ou=user,dc=example,dc=com`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果密码比较成功，那么客户端应用程序可以继续以`uid=matt,ou=user,dc=example,dc=com`身份执行 LDAP 操作。
- en: The process is lengthy and it requires that the client application be configured
    with bind DN and password information for the Authenticate user, but it adds an
    additional layer of security to an Anonymous bind and search.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程较为繁琐，并且要求客户端应用程序配置绑定 DN 和 Authenticate 用户的密码信息，但它为匿名绑定和搜索增加了额外的安全层。
- en: In this section, we have looked at three different ways of performing a simple
    bind. Each of these methods is useful in particular circumstances, and when used
    in conjunction with SSL/TLS, simple binding does not pose a significant security
    threat when the password is transmitted across the network.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了三种执行简单绑定的不同方式。这些方法在特定情况下各有其用，且当与 SSL/TLS 一起使用时，简单绑定在密码通过网络传输时不会构成显著的安全威胁。
- en: Tip
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Simple Binding Directives in slapd.conf**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**slapd.conf 中的简单绑定指令**'
- en: There are only a few directives in `slapd.conf` that have any bearing on simple
    binding. Simple binding is allowed by default. To prevent SLAPD from accepting
    simple bind operations, you can use the `require SASL` directive which will require
    that all bind operations are SASL bind operations. Additionally, the `security`
    directive provides the `simple_bind=` SSF check, which can be used to require
    a minimum SSF for simple bind operations. This is covered in more detail in the
    section entitled *The* *security* *Directive*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `slapd.conf` 中只有少数指令与简单绑定相关。默认情况下允许简单绑定。为了防止 SLAPD 接受简单绑定操作，你可以使用 `require
    SASL` 指令，这将要求所有绑定操作都为 SASL 绑定操作。此外，`security` 指令提供了 `simple_bind=` SSF 检查，可用于要求对简单绑定操作设置最小的
    SSF。这在 *安全* *指令* 部分有更详细的说明。
- en: Later in this book we will examine several third party applications that use
    simple binding when connecting to the directory.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 本书后续章节将介绍几个使用简单绑定连接到目录的第三方应用程序。
- en: But there are times when it is desirable to have an even more secure authentication
    process, or when the bind-search-rebind method of simple binding is too much for
    the client to do. In such cases using SASL binding may be even better.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时我们需要更安全的认证过程，或者简单绑定的绑定-查询-重新绑定方法对客户端来说过于复杂。在这种情况下，使用 SASL 绑定可能更好。
- en: SASL Binding
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SASL 绑定
- en: SASL provides a second method of authenticating to the OpenLDAP directory. SASL
    works by supplanting the simple bind method outlined above with a more robust
    authentication process.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: SASL 提供了第二种认证 OpenLDAP 目录的方法。SASL 通过用更强大的认证过程取代上述简单绑定方法来工作。
- en: Note
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The SASL standard is defined in RFC 2222 ( [http://www.rfc-editor.org/rfc/rfc2222.txt](http://www.rfc-editor.org/rfc/rfc2222.txt)).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: SASL 标准在 RFC 2222 中定义（[http://www.rfc-editor.org/rfc/rfc2222.txt](http://www.rfc-editor.org/rfc/rfc2222.txt)）。
- en: SASL supports a number of different kinds of underlying authentication mechanisms,
    ranging from login/password combinations to more complex configurations like **One-Time
    Passwords (OTP)** and even **Kerberos** ticket-based authentication.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: SASL 支持多种不同的底层认证机制，从登录/密码组合到更复杂的配置，如**一次性密码（OTP）**，甚至**Kerberos**票证认证。
- en: While SASL provides dozens of different configuration options, we will cover
    only one. We will configure SASL for doing **DIGEST-MD5** authentication. It is
    slightly more difficult to set up than some SASL mechanisms, but does not require
    the detailed configuration involved in **GSSAPI** or Kerberos.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SASL 提供了几十种不同的配置选项，但我们只介绍其中的一种。我们将配置 SASL 来进行 **DIGEST-MD5** 认证。它的设置稍微比某些
    SASL 机制复杂，但不需要像 **GSSAPI** 或 Kerberos 那样详细的配置。
- en: Later in this chapter, we will integrate our SASL work with our SSL/TLS work,
    and use the **SASL EXTERNAL mechanism** for authenticating to the directory with
    client SSL certificates.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面我们将把 SASL 工作与 SSL/TLS 工作结合起来，并使用**SASL EXTERNAL 机制**通过客户端 SSL 证书进行目录认证。
- en: Note
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Cyrus SASL documentation (at `/usr/share/doc/libsasl2` or available online
    at [http://asg.web.cmu.edu/sasl/](http://asg.web.cmu.edu/sasl/)) provides information
    on implementing other mechanisms.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Cyrus SASL 文档（位于 `/usr/share/doc/libsasl2` 或在线查看 [http://asg.web.cmu.edu/sasl/](http://asg.web.cmu.edu/sasl/)）提供了实现其他机制的信息。
- en: In DIGEST-MD5 authentication, the user's password will be encrypted by the SASL
    client, sent across the network in its encrypted form only, then decrypted by
    the server and compared to a cleartext version of the password.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DIGEST-MD5 认证中，用户的密码将由 SASL 客户端加密，只有加密后的密码会通过网络传输，然后由服务器解密并与明文密码进行比较。
- en: The advantage to using DIGEST-MD5 is that the password is protected when transmitted
    over the network. The disadvantage, however, is that the passwords must be stored
    on the server in cleartext.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DIGEST-MD5 的优点是密码在网络上传输时得到保护。然而，缺点是密码必须以明文形式存储在服务器上。
- en: Contrast this with the way simple bind works. In a simple bind the password
    itself is not encrypted when crossing the network, but the copy of the password
    stored in the database is stored in an encrypted format (unless you configure
    OpenLDAP otherwise).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 与简单绑定的工作方式对比。在简单绑定中，密码本身在网络上传输时并未加密，但存储在数据库中的密码副本是以加密格式存储的（除非你对 OpenLDAP 进行了其他配置）。
- en: Keep in mind that when SSL/TLS is used, all data transmitted over the connection
    is encrypted, including passwords.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当使用 SSL/TLS 时，所有通过连接传输的数据都将被加密，包括密码。
- en: 'Configuring SASL is more complex than configuring simple bind operations. There
    are two parts to configuring SASL support:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 SASL 比配置简单的绑定操作要复杂。配置 SASL 支持有两个部分：
- en: Configuration of Cyrus SASL
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cyrus SASL 配置
- en: Configuration of OpenLDAP
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 OpenLDAP
- en: Configuring Cyrus SASL
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Cyrus SASL
- en: 'When we installed OpenLDAP in Chapter 2, one of the packages we installed was
    Cyrus SASL (the library was named `libsasl2`). We will also need the SASL command-line
    tools, which are included in the `sasl2-bin` package:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第 2 章安装 OpenLDAP 时，我们安装的其中一个软件包是 Cyrus SASL（该库名为 `libsasl2`）。我们还需要 SASL
    命令行工具，这些工具包含在 `sasl2-bin` 软件包中：
- en: '[PRE35]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Included in this package are the `saslpasswd2` program and the SASL testing
    client and server applications.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 本软件包中包含了 `saslpasswd2` 程序以及 SASL 测试客户端和服务器应用程序。
- en: Now we are ready to start configuring.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备开始配置了。
- en: The SASL Configuration File
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SASL 配置文件
- en: 'The SASL library can be used by numerous applications, and each application
    can have its own SASL configuration file. SASL configuration files are stored
    in the `/usr/lib/sasl2` directory. In that directory, we will create a configuration
    file for OpenLDAP. The file, `slapd.conf`, looks like this:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: SASL 库可以被多个应用程序使用，每个应用程序都可以拥有自己的 SASL 配置文件。SASL 配置文件存储在 `/usr/lib/sasl2` 目录中。在该目录下，我们将为
    OpenLDAP 创建一个配置文件。文件 `slapd.conf` 看起来是这样的：
- en: '[PRE36]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not confuse this `slapd.conf`, located at `/usr/lib/sasl2` with the main
    `slapd.conf` file at `/etc/ldap/`. These are two different files.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将位于 `/usr/lib/sasl2` 的 `slapd.conf` 与位于 `/etc/ldap/` 的主 `slapd.conf` 文件混淆。这是两个不同的文件。
- en: As usual, lines that begin with the `pound sign (#)` are comments. The second
    line determines how SASL will try to check passwords. For example, SASL comes
    with a stand-alone server, **saslauthd**, which will handle password checking.
    In our case though, we want to use the `auxprop` plugin, which does the password
    checking itself, rather than querying the `saslauthd` server.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，所有以 `#` 开头的行都是注释。第二行决定了 SASL 如何检查密码。例如，SASL 配备了一个独立的服务器 **saslauthd**，它将处理密码检查。然而，在我们的情况下，我们希望使用
    `auxprop` 插件，它自己进行密码检查，而不是查询 `saslauthd` 服务器。
- en: The last line tells SASL where the password database (which stores a cleartext
    version of all of the passwords) is located. The standard location for this database
    is `/etc/sasldb2`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行告诉 SASL 密码数据库的位置（该数据库存储所有密码的明文版本）。此数据库的标准位置是 `/etc/sasldb2`。
- en: Setting a User Password
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置用户密码
- en: 'As we get started, we will store the SASL password in the `/etc/sasldb2` database.
    To add a password to the database we use the `saslpasswd2` program:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，我们将把 SASL 密码存储在 `/etc/sasldb2` 数据库中。要向数据库添加密码，我们使用 `saslpasswd2` 程序：
- en: '[PRE37]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that we have to run the above using `sudo` because the password file is
    owned by root. Both `sudo` and `saslpasswd2` will prompt you to enter a password.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须使用 `sudo` 来运行上述命令，因为密码文件属于 root 用户。`sudo` 和 `saslpasswd2` 都会提示你输入密码。
- en: 'The `-c` argument for `saslpasswd2` indicates that we want the user ID to be
    created if it does not already exist. `-u example.com` sets the **SASL realm**.
    SASL uses realms as a way to partition the authentication name space. Client applications
    typically provide SASL with three pieces of information: the username, the password,
    and the realm. By default, clients will send their domain name as the realm.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`saslpasswd2` 的 `-c` 参数表示如果用户 ID 尚未存在，则希望创建该用户 ID。`-u example.com` 设置 **SASL
    域**。SASL 使用域作为划分认证名称空间的一种方式。客户端应用程序通常会向 SASL 提供三项信息：用户名、密码和域。默认情况下，客户端将发送它们的域名作为域。'
- en: Using realms, it is possible to give the same user name different passwords
    for different applications or application contexts. For example, `matt` in realm
    `example.com` can have one password, while `matt` in realm `testing.example.com`
    can have a different password.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用域，可以为不同的应用程序或应用程序上下文提供相同用户名的不同密码。例如，`example.com` 域中的 `matt` 可以有一个密码，而 `testing.example.com`
    域中的 `matt` 可以有不同的密码。
- en: For our purposes we need only one realm, and we will name it `example.com`.
    When the given command is run it will prompt for a password for user `matt`, and
    then prompt for a password confirmation. If the passwords match, it will store
    the password in clear text in the SASL password database.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们只需要一个域，并将其命名为 `example.com`。运行给定的命令时，它将提示输入用户 `matt` 的密码，然后提示输入密码确认。如果密码匹配，它将把密码以明文形式存储在
    SASL 密码数据库中。
- en: Now we are ready to configure OpenLDAP.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备配置 OpenLDAP。
- en: Configuring SLAPD for SASL Support
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为 SASL 支持配置 SLAPD
- en: The OpenLDAP side of SASL configuration is done in the `slapd.conf` file for
    the server, and the `ldap.conf` file for the client. In this section, we will
    focus on the SLAPD server.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP 的 SASL 配置在服务器的 `slapd.conf` 文件中完成，在客户端的 `ldap.conf` 文件中完成。 本节中，我们将重点关注
    SLAPD 服务器。
- en: 'When OpenLDAP receives a SASL authentication request it receives four pieces
    of information from the client. The four fields of information it gets are:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当 OpenLDAP 接收到 SASL 认证请求时，它会从客户端接收四个信息字段。这四个信息字段是：
- en: 'Username: This field contains the ID that the user supplied when authenticating.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名：此字段包含用户在认证时提供的 ID。
- en: 'Realm: This field contains the SASL realm in which the user is authenticated.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域：此字段包含用户进行身份验证时使用的 SASL 领域。
- en: 'SASL Mechanism: This field indicates which authentication system (mechanism)
    was used. Given our SASL configuration, this should be DIGEST-MD5.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SASL 机制：此字段指示使用了哪种认证系统（机制）。根据我们的 SASL 配置，应该是 DIGEST-MD5。
- en: 'Authentication Information: This field is always set to `auth` to indicate
    that the user needs authentication.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证信息：此字段始终设置为 `auth`，表示用户需要认证。
- en: 'All of this information is compacted into one DN-like string that looks like
    this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息都被压缩成一个类似 DN 的字符串，看起来像这样：
- en: '[PRE38]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The order of the fields above is the same as the order of the bulleted list:
    User-name, realm, SASL mechanism, and authentication information. Note however,
    that the realm is not required and might not always be present. If SASL does not
    use any realm information, the realm field will be omitted.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 上面字段的顺序与项目符号列表中的顺序相同：用户名、领域、SASL 机制和认证信息。但请注意，领域字段不是必须的，可能并不总是存在。如果 SASL 不使用任何领域信息，领域字段将被省略。
- en: 'Of course, we do not have any records in our LDAP with DNs like the SASL string
    above. So, in order to correlate the authenticated SASL user with a user in the
    LDAP, we need to set up some method of converting the above DN-like string into
    a DN that is structured like the DNs in the directory. So we want to make the
    given string into something like this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的 LDAP 中没有像上面的 SASL 字符串那样的 DN 记录。因此，为了将经过身份验证的 SASL 用户与 LDAP 中的用户关联起来，我们需要设置一种方法，将上述类似
    DN 的字符串转换为像目录中那些 DN 一样的结构化 DN。因此，我们希望将给定的字符串变成类似下面这样的格式：
- en: '[PRE39]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There are two ways of doing this mapping. We can either configure a simple string
    replacement rule to convert the SASL information string to a DN like the last
    one, or we could perform a search of the directory for an entry with a `uid` that
    is `matt`, and then, if a match is found, use that matching entry's DN.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 进行映射有两种方式。我们可以配置一个简单的字符串替换规则，将 SASL 信息字符串转换为像最后一个那样的 DN，或者我们可以在目录中查找一个 `uid`
    为 `matt` 的条目，然后如果找到匹配项，使用该匹配条目的 DN。
- en: Each of these two methods has its advantages and disadvantages. Using string
    replacement is faster, but it is less flexible, and it may not be sufficient for
    complex directory information trees. Using string replacement it may be necessary
    to use several `authz-regexp` directives in a row, each one with a different regular
    expression and replacement string.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法各有优缺点。使用字符串替换更快，但不够灵活，可能不足以应对复杂的目录信息树。使用字符串替换时，可能需要连续使用多个 `authz-regexp`
    指令，每个指令有不同的正则表达式和替换字符串。
- en: Searching for the user on the other hand, can be much more flexible in a directory
    with lots of subtrees. But it will incur the overhead of doing an additional search
    of the LDAP tree, and it may require tweaking ACLs to allow pre-authentication
    searches.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在一个拥有大量子树的目录中，查找用户可以更加灵活。但这会增加额外的 LDAP 树搜索开销，并且可能需要调整 ACL 以允许进行预认证搜索。
- en: 'Both methods use the same directive in `slapd.conf`: the `authz-regexp` directive.
    Let''s look at an example of each method, beginning with the string replacement
    method.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都使用 `slapd.conf` 中的相同指令：`authz-regexp` 指令。让我们从字符串替换方法开始，查看每种方法的示例。
- en: Using a Replacement String in authz-regexp
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 `authz-regexp` 中使用替换字符串
- en: 'The `authz-regexp` directive takes two parameters: a regular expression for
    getting information out of the SASL DN-like string, and a replacement function
    (which is different depending on whether we do string replacement or a search).'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`authz-regexp` 指令接受两个参数：一个正则表达式，用于从 SASL DN 类似字符串中提取信息，和一个替换函数（根据我们是使用字符串替换还是搜索而有所不同）。'
- en: 'For our regular expression we want to take the username from the SASL information
    and map it to the `uid` field in a DN. We don''t really need any of the information
    in the other three SASL fields, so our regular expression is fairly simple:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的正则表达式，我们想从 SASL 信息中提取用户名，并将其映射到 DN 中的 `uid` 字段。我们不需要其他三个 SASL 字段中的任何信息，因此我们的正则表达式非常简单：
- en: '[PRE40]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This rule starts at the beginning of the line (`^`) and looks for an entry that
    starts with `uid=`. The next part, `([^,]+)`, stores characters after `uid=` and
    before a comma (`,`) in a special variable called `$1`. The rule reads "match
    as many characters as possible (but at least one character) that are not commas
    and store them in the first variable (`$1`)."
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则从行的开头 (`^`) 开始，查找以 `uid=` 开头的条目。接下来的部分 `([^,]+)` 会将 `uid=` 后和逗号（`,`）前的字符存储在一个名为
    `$1` 的特殊变量中。这个规则的意思是“匹配尽可能多的字符（至少一个字符），这些字符不是逗号，并将它们存储在第一个变量（`$1`）中。”
- en: 'After that, the rule (using `.*` to match anything) skips over the realm (if
    there is one) and the mechanism, and then looks for a match at the end of the
    line: `cn=auth$` (where the dollar sign (`$`) indicates a line ending).'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，规则（使用 `.*` 匹配任何字符）跳过领域（如果有的话）和机制，然后寻找行尾的匹配项：`cn=auth$`（其中美元符号 (`$`) 表示行结束）。
- en: 'Once the regular expression is run we should have a variable, `$1`, which contains
    the user''s name. Now we can use that value in a replacement rule, setting the
    `uid` value to the value of `$1`. The entire `authz-regexp` line looks like this:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦正则表达式执行完成，我们应该有一个变量 `$1`，它包含用户的名称。现在，我们可以在替换规则中使用该值，将 `uid` 的值设置为 `$1` 的值。整个
    `authz-regexp` 行如下所示：
- en: '[PRE41]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: After the `authz-regexp` directive, I have inserted the regular expression we
    just looked at. After the regular expression comes the replacement rule, which
    instructs SLAPD to insert the value of `$1` in the `uid` field of this template
    DN.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `authz-regexp` 指令之后，我插入了我们刚才查看的正则表达式。正则表达式之后是替换规则，指示 SLAPD 在该模板 DN 的 `uid`
    字段中插入 `$1` 的值。
- en: The `authz-regexp` directive can go anywhere in the `slapd.conf` file before
    the first `database` directive.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`authz-regexp` 指令可以放在 `slapd.conf` 文件中任何位置，只要它出现在第一个 `database` 指令之前。'
- en: 'Since `authz-regexp` is the only necessary directive for configuring SASL,
    we can now test SLAPD from the command line, without making any additional changes
    to `slapd.conf`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `authz-regexp` 是配置 SASL 所需的唯一指令，现在我们可以在命令行上测试 SLAPD，而不需要对 `slapd.conf` 做任何其他更改：
- en: '[PRE42]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Previously, we have used the `-x` flag, combined with `-W` and `-D`, to do a
    simple bind with a full DN and a password.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们已经使用了 `-x` 标志，结合 `-W` 和 `-D`，执行了一个简单的绑定操作，使用了完整的 DN 和密码。
- en: With SASL however, we don't need the full DN. All we need is a shortened connection
    string. So, instead of using the `-x`, `-W`, and `-D` flags, we just use `-U matt@example.com`.
    The `-U` flag takes a SASL username and (optionally) a realm. The realm is appended
    to the username, separated by the *at* sign (`@`). So, in the given example, we
    are connecting with username `matt` and realm `example.com`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 SASL 时，我们不需要完整的 DN。我们只需要一个简化的连接字符串。因此，我们不再使用 `-x`、`-W` 和 `-D` 标志，而是使用
    `-U matt@example.com`。`-U` 标志接受一个 SASL 用户名和（可选的）领域。领域与用户名通过 *@* 符号连接。所以，在给定的示例中，我们使用用户名
    `matt` 和领域 `example.com` 进行连接。
- en: Next, `ldapsearch` prompts for a password (see the highlighted line in the example).
    This is not our LDAP password, but our SASL password—the one in the account we
    created when we ran `saslpasswd2`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`ldapsearch` 会提示输入密码（请参见示例中的高亮行）。这不是我们的 LDAP 密码，而是我们的 SASL 密码——也就是在运行 `saslpasswd2`
    时创建的账户密码。
- en: 'To review, what is happening in the previous command is this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，之前命令中发生的事情如下：
- en: The client is connecting to SLAPD requesting an SASL bind.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端正在连接到 SLAPD，请求进行 SASL 绑定。
- en: SLAPD uses the SASL subsystem (which checks the `/usr/lib/sasl/slapd.conf` file
    for settings) to tell the client how to authenticate. In this case, it tells the
    client to use DIGEST-MD5.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SLAPD 使用 SASL 子系统（该子系统检查 `/usr/lib/sasl/slapd.conf` 文件中的设置）来告知客户端如何进行身份验证。在此案例中，它告诉客户端使用
    DIGEST-MD5。
- en: The client sends the authentication information to SLAPD.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端将身份验证信息发送到 SLAPD。
- en: SLAPD performs the translation specified in `authz-regexp`.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SLAPD 执行 `authz-regexp` 中指定的转换。
- en: SLAPD then checks the client's response (using the SASL subsystem) against the
    information in `/etc/sasldb2`.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，SLAPD 使用 SASL 子系统检查客户端的响应，并与 `/etc/sasldb2` 中的信息进行匹配。
- en: When the client authentication succeeds, OpenLDAP runs the search and returns
    the results to the client.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当客户端身份验证成功时，OpenLDAP 执行搜索并将结果返回给客户端。
- en: Now we are ready to look at using `authz-regexp` to search the directory with
    a specific filter.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好使用 `authz-regexp` 来用特定的过滤器搜索目录了。
- en: Using a Search Filter in authz-regexp
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 authz-regexp 中使用搜索过滤器
- en: 'In this case, we want to search the directory for an entry that matches the
    username (`uid`) received during the SASL bind. Recall that the SASL authentication
    information comes in a string that looks like this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望搜索目录中与 SASL 绑定期间接收到的用户名（`uid`）匹配的条目。回想一下，SASL 认证信息是以如下字符串的形式传入的：
- en: '[PRE43]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the last case, we mapped the given directly on to a DN of the form:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们直接将给定的映射到如下形式的 DN：
- en: '[PRE44]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: But what do we do if we don't know, for example, if the user `matt` is in the
    Users OU or the System OU? A simple mapping function will not work. We need to
    search the directory. We will do this by changing the last argument in our `authz-regexp`
    directive.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们不知道，比如说，用户 `matt` 是否在 Users OU 或 System OU 中，该怎么办？一个简单的映射函数是行不通的。我们需要搜索目录。我们将通过修改
    `authz-regexp` 指令中的最后一个参数来实现这一点。
- en: 'Our new `authz-regexp` directive looks like this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的 `authz-regexp` 指令如下所示：
- en: '[PRE45]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This regular expression is the same as the one in the previous example. But
    the second argument to `authz-regexp` is an LDAP URL.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式与前一个示例中的相同。但是 `authz-regexp` 的第二个参数是一个 LDAP URL。
- en: Note
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For an overview of writing and using LDAP URLs see [Appendix B](apb.html "Appendix B. LDAP
    URLs").
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 有关编写和使用 LDAP URL 的概述，请参见[附录 B](apb.html "附录 B. LDAP URL")。
- en: 'This LDAP URL instructs SLAPD to search in the base `dc=example,dc=com` (using
    a subtree (`sub`) search) for an entry whose `uid` equals the value of `$1`, which
    gets replaced by the value retrieved from the regular expression in the first
    argument to `authz-regexp`. If the user `matt` attempts to authenticate, for example,
    the URL will look like this:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 LDAP URL 指示 SLAPD 在 `dc=example,dc=com` 基础上进行搜索（使用子树（`sub`）搜索），查找 `uid` 等于
    `$1` 的条目，`$1` 被替换为从正则表达式第一参数中获取的值。如果用户 `matt` 尝试进行身份验证，例如，URL 将如下所示：
- en: '[PRE46]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When SLAPD performs that search against our directory information tree, it will
    get a single record back—the record with the DN `uid=matt,ou=Users,dc=example,dc=com`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SLAPD 对我们的目录信息树进行搜索时，它将返回一个记录——即 DN 为 `uid=matt,ou=Users,dc=example,dc=com`
    的记录。
- en: 'Here''s an example using `ldapsearch`. It is the same example used in the previous
    section, and it should have the same results even though we are using the LDAP
    search method:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `ldapsearch` 的一个示例。它与前一节中使用的示例相同，即使我们使用 LDAP 搜索方法，它应该也会得到相同的结果：
- en: '[PRE47]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: A Note on ACLs and Search Filters
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关于 ACL 和搜索过滤器的说明
- en: When SLAPD reads the search filter, it performs a search of the directory. But
    the search is done as the Anonymous user. What this means is that we will need
    to make sure that the Anonymous user will need to have the requisite permissions
    to search the directory using the filter.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SLAPD 读取搜索过滤器时，它会执行对目录的搜索。但搜索是以匿名用户的身份进行的。这意味着我们需要确保匿名用户拥有使用该过滤器进行目录搜索所需的权限。
- en: 'Given our last example, the Anonymous user will need to be able to search the
    `dc=example,dc=com` subtree for `uid` values. The ACLs that we created in Chapter
    2 do not grant the Anonymous user any such permission. We will need to add one
    rule to our ACLs in order to allow the search to operate successfully:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前的示例，匿名用户需要能够在 `dc=example,dc=com` 子树中搜索 `uid` 值。我们在第二章中创建的 ACL 并未授予匿名用户此类权限。为了使搜索操作成功，我们需要向
    ACL 中添加一条规则：
- en: '[PRE48]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This rule, which should appear at the top of the list of ACLs, grants read access
    to the `uid` attribute to `anonymous` and to any authenticated users on the system.
    The important part, in this example, is that Anonymous gets read access.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则应该出现在 ACL 列表的顶部，它授予 `anonymous` 以及系统中任何已认证用户对 `uid` 属性的读取访问权限。在这个示例中，重要的是匿名用户获得了读取权限。
- en: Keep in mind that by adding this rule, we are making it possible for unauthenticated
    users to see what user IDs exist in the database. Depending on the nature of your
    directory data, this may be a security issue. If this is a problem you can either
    use the string replacement method (remember, you can use several `authz-regexp`
    expressions in a row to handle more complex pattern matching), or you can try
    to reduce exposure to the `uid` field by building more restrictive ACLs
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，通过添加这条规则，我们使得未经身份验证的用户能够看到数据库中存在的用户 ID。根据目录数据的性质，这可能会带来安全问题。如果这是一个问题，您可以使用字符串替换方法（记住，您可以连续使用多个
    `authz-regexp` 表达式来处理更复杂的模式匹配），或者通过构建更严格的 ACL 来减少 `uid` 字段的暴露。
- en: Later in this chapter, we will take a more detailed look at ACLs.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后续部分，我们将更详细地讨论ACL。
- en: Failure of Mapping
  id: totrans-400
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 映射失败
- en: In some cases the mapping done by `authz-regexp` will fail. That is, SLAPD will
    search the directory (using the search filter) and not find any matches. The user,
    however, is authenticated, and SLAPD will not fail to bind.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，`authz-regexp`的映射可能会失败。也就是说，SLAPD会使用搜索过滤器在目录中查找，但没有找到匹配项。然而，用户已通过身份验证，SLAPD不会失败并停止绑定。
- en: 'Instead, what will happen is that the user will bind as the SASL DN. Thus,
    the effective DN may be something like:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，发生的情况是用户将以SASL DN进行绑定。因此，有效的DN可能类似于：
- en: '[PRE49]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It makes no difference that there is no actual record in the directory with
    that username. The client will still be able to access the directory.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 即使目录中没有与该用户名对应的实际记录，也没有关系。客户端仍然可以访问该目录。
- en: But this DN is also subject to ACLs, so you can write access controls targeted
    at users who have authenticated through SASL but who do not have a DN corresponding
    to a record in the directory.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个DN也受到ACL的控制，因此你可以针对那些通过SASL认证但没有相应目录记录的用户编写访问控制。
- en: Removing the Need to Specify the Realm
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 去除指定领域的需要
- en: 'In our configuration all of the users are in the same realm, `example.com`.
    Rather than typing that the username and the realm be typed in every time, we
    can configure a default realm in `slapd.conf` by adding the following directive:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配置中，所有用户都位于相同的领域`example.com`。为了避免每次都输入用户名和领域，我们可以通过在`slapd.conf`中添加以下指令来配置默认领域：
- en: '[PRE50]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If we restart the server with this new modification, we can now run an `ldapsearch`
    without having to specify the realm:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用这个新的修改重启服务器，我们现在可以运行`ldapsearch`而不需要指定领域：
- en: '[PRE51]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This time, passing `-U matt` was sufficient for authentication. SLAPD automatically
    inserted the default realm into the SASL information.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，传递`-U matt`就足以进行身份验证。SLAPD自动将默认领域插入到SASL信息中。
- en: Debugging the SASL Configuration
  id: totrans-412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调试SASL配置
- en: 'Getting the correct SASL configuration can be frustrating. One way of improving
    your ability to debug is to configure logging in such a way that you can see what
    is going on during a SASL transaction. The `trace` debugging level (`1`) can be
    used to watch what is happening in SASL. You can either set the debug level in
    `slapd.conf` to trace (or just the digit `1`), or you can run `slapd` in the foreground
    on the command line:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 获取正确的SASL配置可能令人沮丧。提高调试能力的一种方法是配置日志记录，以便你可以看到SASL事务期间发生的情况。`trace`调试级别（`1`）可以用来观察SASL中的活动。你可以在`slapd.conf`中设置调试级别为trace（或直接设置为数字`1`），或者你可以在命令行上将`slapd`运行在前台：
- en: '[PRE52]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Following this log, we can see the initial SASL string, `uid=matt,cn=DIGEST-MD5,cn=auth`,
    and watch as it is normalized, run through the regular expression, and converted
    to `uid=matt,ou=users,dc=example,dc=com`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个日志，我们可以看到初始的SASL字符串`uid=matt,cn=DIGEST-MD5,cn=auth`，并观察它是如何被标准化、运行正则表达式并转换为`uid=matt,ou=users,dc=example,dc=com`的。
- en: The `ldapwhoami` client and the `slapauth` utility are also useful when attempting
    to debug SASL. An example of using `ldapwhoami` to evaluate the results of `authz-regexp`
    is given in the next section.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldapwhoami`客户端和`slapauth`工具在调试SASL时也非常有用。下一节将给出使用`ldapwhoami`评估`authz-regexp`结果的示例。'
- en: Using Client SSL/TLS Certificates to Authenticate
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用客户端SSL/TLS证书进行身份验证
- en: SASL and SSL/TLS can be used in combination to perform **SASL EXTERNAL authentication**.
    In SASL EXTERNAL authentication the SASL module relies upon an external source,
    in this case a client's X.509 certificate, as a source of identity.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: SASL和SSL/TLS可以结合使用来执行**SASL EXTERNAL认证**。在SASL EXTERNAL认证中，SASL模块依赖于外部来源，在这种情况下是客户端的X.509证书，作为身份来源。
- en: Using this configuration a client with an appropriately signed certificate can
    bind to SLAPD without having to enter a username and password, but in a way that
    is still secure.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，拥有适当签名证书的客户端可以绑定到SLAPD，而无需输入用户名和密码，但这种方式仍然是安全的。
- en: How does this work? Just as it is possible to issue a server a certificate for
    SSL/TLS communication, it is also possible to issue one to a user or client. We
    have discussed already how a certificate provides, in a secure way, identity information
    about a server. A client certificate can serve the same purpose.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？就像可以为服务器颁发SSL/TLS通信证书一样，也可以为用户或客户端颁发证书。我们已经讨论过，证书可以以安全的方式提供关于服务器的身份信息。客户端证书也可以发挥相同的作用。
- en: 'Authentication, using SASL EXTERNAL works like this:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 认证，使用SASL EXTERNAL工作方式如下：
- en: The client and server communicate with SSL/TLS protection, either using LDAPS
    or using StartTLS
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端和服务器使用SSL/TLS保护进行通信，可以使用LDAPS或使用StartTLS
- en: When the server sends its certificate, it requests that the client also provide
    a certificate
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当服务器发送其证书时，请求客户端也提供一个证书
- en: The client sends its own certificate, which includes the following
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端发送自己的证书，其中包括以下内容
- en: Identity information
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份信息
- en: A public key
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个公钥
- en: The signature of a certificate authority that the server will recognize
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器将识别的证书颁发机构签名
- en: The server, after verifying the certificate, passes the identity information
    on to SLAPD through the SASL subsystem
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器在验证证书后，通过SASL子系统将身份信息传递给SLAPD
- en: SLAPD then uses that information to bind
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SLAPD然后使用该信息进行绑定
- en: Since the certificate sent by the client contains all of the information needed
    to verify the client's identity, no login/password combination is needed.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 由于客户端发送的证书包含了验证客户端身份所需的所有信息，因此不需要登录/密码组合。
- en: 'Configuring the SASL EXTERNAL mechanism requires the following steps:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 配置SASL EXTERNAL机制需要以下步骤：
- en: Create a new client certificate
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的客户端证书
- en: Configure the client to send the certificate
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置客户端以发送证书
- en: Configure SLAPD to correctly handle client certificates
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置SLAPD以正确处理客户端证书
- en: Configure SLAPD to correctly translate the identity information provided in
    the client certificate
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置SLAPD以正确转换客户端证书中提供的身份信息
- en: Creating a New Client Certificate
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个新的客户端证书
- en: Creating a new client certificate is not significantly different from creating
    a server certificate. We will use the same certificate authority that we created
    earlier in this chapter.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的客户端证书与创建服务器证书没有显著区别。我们将使用本章早期创建的同一证书颁发机构。
- en: 'First, we need to create a new certificate request:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个新的证书请求：
- en: '[PRE53]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This process is just like the one before, though the fields are completed specifically
    for the user who is represented by this certificate. For example, if we were generating
    this certificate for Barbara, we would complete the **Common Name** and **Email
    Address** fields with her information.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程就像之前的过程一样，只是字段是专门为代表此证书的用户填写的。例如，如果我们为芭芭拉生成这个证书，我们会用她的信息填写**通用名称**和**电子邮件地址**字段。
- en: Tip
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**What should go in the Common Name field?**'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用名称字段应填写什么？**'
- en: Earlier we used the CN field to store a domain name. What should go in an individual's
    CN field? One option is to use the user's full name. A more pragmatic option is
    to use an identifier that is used in the user's LDAP DN (such as the value of
    the user's `uid` attribute). This makes mapping from a certificate to an LDAP
    record easier.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们使用CN字段存储域名。个人的CN字段应填写什么？一个选择是使用用户的全名。更实用的选择是使用用户LDAP DN中使用的标识符（如用户的`uid`属性的值）。这样做可以更轻松地从证书映射到LDAP记录。
- en: 'Now, we have the new request (`newreq.pem`) and key (`newkey.pem`). The next
    thing to do is sign the certificate with our CA''s digital signature:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了新请求（`newreq.pem`）和密钥（`newkey.pem`）。接下来要做的是使用我们CA的数字签名对证书进行签名：
- en: '[PRE54]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, we have the signed certificate stored in the file `newcert.pem`.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将签名的证书存储在文件`newcert.pem`中。
- en: 'The next thing to do is to move these files to a location that will be convenient
    for the user. In this case, we will make a new directory in the user''s home directory
    and move the files into that directory:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的是将这些文件移动到用户方便的位置。在这种情况下，我们将在用户的主目录中创建一个新目录，并将文件移动到该目录中：
- en: '[PRE55]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In these three lines, we make a new directory for the certs. In this case, the
    new `certs/` directory is in the user's home directory.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三行中，我们为证书创建一个新目录。在这种情况下，新的`certs/`目录位于用户的主目录中。
- en: Then we move the newly-created certificate files into the new directory. We
    could rename these files but for now the generic name will suffice.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将新创建的证书文件移动到新目录中。我们可以重命名这些文件，但目前使用通用名称即可。
- en: Finally, we need to make sure that the user has access to his or her certificates.
    This is done with the `chown` command.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要确保用户能够访问自己的证书。这可以通过`chown`命令来完成。
- en: The certificates are ready to use.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 证书已准备就绪。
- en: Configuring the Client
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置客户端
- en: The next thing we need to do is configure the client to use the certificate
    and key. This is done by creating `.ldaprc` file in the user's home directory.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要做的是配置客户端使用证书和密钥。这通过在用户的主目录下创建`.ldaprc`文件来完成。
- en: Note
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A **.ldaprc file** is a "personal" version of an `ldap.conf` file. It supports
    all of the directives normally included in `ldap.conf`, plus a couple of special
    directives, like the `TLS_CERT` and `TLS_KEY` directives.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '**.ldaprc文件**是`ldap.conf`文件的“个人”版本。它支持`ldap.conf`中通常包含的所有指令，此外还有几个特殊指令，比如`TLS_CERT`和`TLS_KEY`指令。'
- en: 'Since I am the user `mbutcher`, I will create this file in my own home directory:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我是用户`mbutcher`，我将在自己的主目录下创建这个文件：
- en: '[PRE56]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now we can edit the `.ldaprc` file. This file needs to indicate that the client
    is using the SASL EXTERNAL mechanism. Also, it must contain directives about the
    certificate and key files that we want to use. Additionally, it is not a bad idea
    to specify the location of the CA certificates (or even to the specific certificate
    for the CA that signed the server's certificate), though this is usually done
    at a global level with the `ldap.conf` file.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编辑`.ldaprc`文件。这个文件需要指明客户端正在使用SASL EXTERNAL机制。同时，它必须包含关于证书和密钥文件的指令。此外，指定CA证书的位置（甚至指定签署服务器证书的CA的特定证书）也是一个好主意，尽管通常这在全局层面通过`ldap.conf`文件来完成。
- en: 'The `.ldaprc` file then, looks like this:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`.ldaprc`文件如下所示：'
- en: '[PRE57]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The first directive, `SASL_MECH`, indicates what SASL mechanism the client is
    using. In our case the client is using the `EXTERNAL` SASL mechanism.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个指令`SASL_MECH`指示客户端使用的SASL机制。在我们的例子中，客户端使用的是`EXTERNAL` SASL机制。
- en: The `TLS_CERT` directive points to the location of the client's signed X.509
    certificate, and the `TLS_KEY` directive indicates the location of the client's
    private key file.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`TLS_CERT`指令指向客户端签名的X.509证书的位置，`TLS_KEY`指令指示客户端私钥文件的位置。'
- en: The `TLS_CACERT` directive points to the specific certificate used for signing
    the server's certificate. This will be used by the client libraries to verify
    the identity of the server during SSL/TLS negotiation.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`TLS_CACERT`指令指向用于签署服务器证书的特定证书。客户端库将使用该证书在SSL/TLS协商期间验证服务器的身份。'
- en: At this point the client is ready. Now we need to configure SLAPD.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 目前客户端已经准备好。接下来我们需要配置SLAPD。
- en: Configuring the Server
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置服务器
- en: 'SLAPD needs to do a few things in order to make the SASL EXTERNAL mechanism
    work:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: SLAPD需要做一些工作，才能使SASL EXTERNAL机制生效：
- en: It must request a certificate from the client (otherwise the client will not
    present one)
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须请求客户端的证书（否则客户端将不会提供证书）
- en: It needs to translate the identity information given in the client certificate
    into a DN that is meaningful in our environment
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要将客户端证书中给出的身份信息转换为在我们环境中有意义的DN。
- en: 'To set the server to request a client certificate is a matter of adding one
    directive. In the global section of the `slapd.conf` file, before any database
    directive is specified, the `TLSVerifyClient` directive should be added:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 要让服务器请求客户端证书，只需要添加一条指令。在`slapd.conf`文件的全局部分，在任何数据库指令指定之前，应添加`TLSVerifyClient`指令：
- en: '[PRE58]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Only the highlighted line is new. The other lines we added earlier in the chapter.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 只有高亮的那一行是新的。其他的行是我们在本章早些时候添加的。
- en: '`TLSVerifyClient` determines whether SLAPD will take steps to request and verify
    client certificates. There are four possible values:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`TLSVerifyClient`决定SLAPD是否采取步骤请求和验证客户端证书。它有四个可能的值：'
- en: '`never`: Never request a client certificate. This is the *default*. If no certificate
    is requested the client will not provide one. Hence SASL EXTERNAL authentication
    cannot be used when the `TLSVerifyClient` is set to `never`.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`never`：永远不请求客户端证书。这是*默认*设置。如果没有请求证书，客户端就不会提供证书。因此，当`TLSVerifyClient`设置为`never`时，无法使用SASL
    EXTERNAL认证。'
- en: '`allow`: This will cause SLAPD to request a certificate from the client but
    if the client does not provide one, or if the provided one is not good (for example
    if the signature cannot be verified), the session will continue.'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allow`：这将导致SLAPD请求客户端证书，但如果客户端没有提供证书，或者提供的证书无效（例如，无法验证签名），会话将继续进行。'
- en: '`try`: In this case SLAPD will request a certificate from the client. If the
    client does not provide a certificate the session will continue. However, if the
    client provides a certificate that is bad, the session will terminate.'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`：在这种情况下，SLAPD将请求客户端提供证书。如果客户端未提供证书，连接将继续。然而，如果客户端提供的证书无效，连接将终止。'
- en: '`demand`: This will cause SLAPD to require a certificate from the client. If
    the client does not provide one, or if the provided one is not good, the session
    will terminate.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`demand`：这将导致SLAPD要求客户端提供证书。如果客户端没有提供证书，或者提供的证书无效，连接会终止。'
- en: In the last example we set `TLSVerifyClient` to `try`. This simply means that
    if the client submits a certificate, it must be a valid certificate (with a known
    CA signature) before SLAPD will allow the connection. But it will also allow clients
    to connect without supplying a certificate (though such clients will not be able
    to use SASL EXTERNAL authentication).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的示例中，我们将`TLSVerifyClient`设置为`try`。这意味着，如果客户端提交了证书，它必须是有效的证书（并且有一个已知的CA签名），否则SLAPD将不允许连接。但它也允许客户端在没有证书的情况下连接（尽管这些客户端无法使用SASL
    EXTERNAL认证）。
- en: If we wanted to force clients to provide a certificate then we would use the
    `demand` keyword instead of `try`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望强制客户端提供证书，那么我们应该使用`demand`关键字而不是`try`。
- en: 'At this point, we have SSL/TLS configured correctly. Now, we need to add one
    additional step: we need to map the identity provided by the certificate (which
    happens to be a DN) onto a DN for a directory user.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经正确配置了SSL/TLS。接下来，我们需要添加一个额外的步骤：我们需要将证书提供的身份（即DN）映射到目录用户的DN。
- en: Note
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Translating the certificate DN into another DN is not strictly necessary. A
    user can bind using a certificate DN even if it is not in the directory. ACLs
    can be written to target such DNs too.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 将证书DN转换为另一个DN不是严格必要的。用户可以使用证书DN进行绑定，即使它不在目录中。ACL可以写成目标这些DN。
- en: 'The DN in the client certificate we create looks like this:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的客户端证书中的DN看起来像这样：
- en: '[PRE59]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that this is one long line.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是一个长行。
- en: 'The DN contains the information we entered when running `CA.pl -newreq`. What
    we want to do is translate this DN into the DN of the corresponding LDAP record:
    `uid=matt,ou=users,dc=example,dc=com`.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 证书中的DN包含我们在运行`CA.pl -newreq`时输入的信息。我们要做的是将这个DN转换为对应的LDAP记录的DN：`uid=matt,ou=users,dc=example,dc=com`。
- en: How is this translation done? Using the `authz-regexp` directive that we examined
    earlier in the section on SASL authentication.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 这个翻译是如何完成的？使用我们在SASL认证部分中研究过的`authz-regexp`指令。
- en: 'There are two fields in the certificate''s identity string that are particularly
    helpful in identifying the user: `email` and `cn`. Thus, a simple regular expression
    can capture these two fields:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 证书的身份字符串中有两个特别有用的字段来识别用户：`email`和`cn`。因此，简单的正则表达式可以捕获这两个字段：
- en: '[PRE60]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This will assign the email address to `$1`, and the CN to `$2`.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把电子邮件地址分配给`$1`，将CN分配给`$2`。
- en: From here we could either specify an LDAP URL with a filter for looking up DNs
    by email address, or we could substitute the CN for the UID field used in the
    LDAP DN (since the CN maps cleanly onto UID).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们可以指定一个LDAP URL，使用邮箱地址过滤器来查找DN，或者可以将CN替换为LDAP DN中使用的UID字段（因为CN可以干净地映射到UID）。
- en: 'We will use this second method, and create `authz-regexp` that looks like this:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用第二种方法，并创建如下的`authz-regexp`：
- en: '[PRE61]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This directive maps the CN value of the certificate DN to the UID attribute
    in the LDAP authorization DN. Thus, when a client connects with a certificate
    with the DN `dn:email=matt@example.com,cn=matt,o=example.com,l=chicago,st=illinois,c=us`,
    SLAPD will translate that into the DN `uid=matt,ou=users,dc=example,dc=com`.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令将证书DN的CN值映射到LDAP授权DN中的UID属性。因此，当客户端连接并提供一个证书，证书的DN是`dn:email=matt@example.com,cn=matt,o=example.com,l=chicago,st=illinois,c=us`时，SLAPD会将其转换为DN
    `uid=matt,ou=users,dc=example,dc=com`。
- en: Now we are ready to test things out.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好测试了。
- en: Testing with ldapwhoami
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ldapwhoami进行测试
- en: The ideal client for testing this process is `ldapwhoami`. This will allow us
    to connect and bind with SASL EXTERNAL. In addition it will indicate whether or
    not `authz-regexp` mapped the certificate DN to our LDAP DN.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 测试此过程的理想客户端是`ldapwhoami`。它将允许我们使用SASL EXTERNAL连接和绑定。此外，它将指示`authz-regexp`是否将证书DN映射到我们的LDAP
    DN。
- en: 'After restarting SLAPD to load the changes, we can test the server:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 重启SLAPD以加载更改后，我们可以测试服务器：
- en: '[PRE62]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'First, let''s take a closer look at the command entered:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们仔细看看输入的命令：
- en: '[PRE63]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `-ZZ` flag requires that StartTLS negotiation be done successfully. Using
    only one `Z` will attempt StartTLS, but not close the connect if the negotiations
    fail. Using `-ZZ` is always a good idea when attempting authentication with the
    SASL EXTERNAL mechanism.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '`-ZZ`标志要求StartTLS协商必须成功完成。仅使用一个`Z`将尝试StartTLS，但如果协商失败不会关闭连接。使用`-ZZ`在尝试使用SASL
    EXTERNAL机制进行身份验证时总是一个好主意。'
- en: Next, the `-H 'ldap://example.com'` parameter provides the URL of the SLAPD
    server. Remember that for StartTLS negotiation to work, here, the domain in the
    LDAP URL must match the domain in the server's certificate.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`-H 'ldap://example.com'`参数提供了SLAPD服务器的URL。记住，StartTLS协商要正常工作，这里LDAP URL中的域名必须与服务器证书中的域名匹配。
- en: 'What happens when this command is executed? First, the user is prompted for
    a pass phrase:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行这个命令时会发生什么呢？首先，系统会提示用户输入密码短语：
- en: '[PRE64]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This prompt is actually generated by the SSL/TLS subsystem (OpenSSL). Recall
    that the key that we generated is protected by a pass phrase. In order to read
    the key file, the OpenSSL subsystem requires the pass phrase.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提示实际上是由SSL/TLS子系统（OpenSSL）生成的。回想一下，我们生成的密钥是由密码短语保护的。为了读取密钥文件，OpenSSL子系统需要密码短语。
- en: 'But didn''t I say that the SASL EXTERNAL method can obviate the need for entering
    a password? Yes, it can—but to do so, we would need to remove the passphrase from
    the key as we did when generating the server certificate:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 但我不是说过SASL EXTERNAL方法可以避免输入密码吗？是的，的确可以——但要实现这一点，我们需要像生成服务器证书时那样移除密钥中的密码短语：
- en: '[PRE65]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Then the `TLS_KEY` directive in `.ldaprc` would need to be adjusted to point
    to the `clearkey.pem` file.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`.ldaprc`中的`TLS_KEY`指令需要调整，指向`clearkey.pem`文件。
- en: Removing the pass phrase may be desirable in some circumstances, and undesirable
    in others. Keep in mind that removing the pass phrase from the key will make it
    easier for the certificate to be hijacked by someone else. A key without a pass
    phrase should be carefully protected by permissions and other means.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，移除密码短语可能是需要的，而在其他情况下则不推荐。请记住，移除密钥中的密码短语将使证书更容易被他人劫持。没有密码短语的密钥应该通过权限和其他手段进行严格保护。
- en: 'Once the user''s pass phrase has been entered, SASL authentication begins:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户输入了密码短语，SASL身份验证开始：
- en: '[PRE66]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As can be seen here, the SASL EXTERNAL mechanism is used, and the SASL username
    is set to `emailAddress=matt@example.com,CN=Matt,O=Example.Com,L=Chicago,ST=Illinois,C=US`.
    Finally, the SASL security strength factor is set to 0 because no SASL security
    mechanism has been used. Instead, the security mechanisms are *external* to SASL.
    Since we are using SSL/TLS with an AES-256 encyrpted certificate, the overall
    SSF will still be 256.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 如这里所见，使用了SASL EXTERNAL机制，并且SASL用户名被设置为`emailAddress=matt@example.com,CN=Matt,O=Example.Com,L=Chicago,ST=Illinois,C=US`。最后，SASL安全强度因子被设置为0，因为没有使用SASL安全机制。相反，安全机制是*外部*的，位于SASL之外。由于我们使用带有AES-256加密证书的SSL/TLS，整体SSF仍然是256。
- en: 'One important detail to note is that SLAPD will normalize the DN. In normalized
    form the DN will look like this:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的细节是，SLAPD会标准化DN。在标准化形式下，DN看起来像这样：
- en: '[PRE67]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `emailAddress` attribute has been converted to `email`, and all uppercase
    strings have been converted to lowercase. The `authz-regexp` that we looked at
    above operates on this normalized version of the DN.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '`emailAddress`属性已经转换为`email`，所有大写字符串已经转换为小写。我们上面看到的`authz-regexp`在这个标准化的DN版本上进行操作。'
- en: 'Finally, the last few lines of output are the results of the LDAP Who Am I?
    operation:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，输出的最后几行是LDAP Who Am I?操作的结果：
- en: '[PRE68]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: According to SLAPD, the client is currently performing directory operations
    with an effective DN of `uid=matt,ou=users,dc=example,dc=com`. This means that
    our mapping was successful.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 根据SLAPD，客户端当前正在使用有效DN为`uid=matt,ou=users,dc=example,dc=com`执行目录操作。这意味着我们的映射成功。
- en: 'What would the output look like if the `authz-regexp` mapping was not successful?
    It would look something like this:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`authz-regexp`映射没有成功，输出会是什么样的呢？它可能看起来像这样：
- en: '[PRE69]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The highlighted portion shows the result of the Who Am I? operation. The DN
    returned is simply the normalized form of the certificate DN—not the desired LDAP
    DN.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮显示的部分展示了“我是谁？”操作的结果。返回的DN只是证书DN的标准化形式——而不是期望的LDAP DN。
- en: Going Further with SASL
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步了解SASL
- en: 'SASL is a flexible tool for handling authentication. Here we have looked at
    only two SASL mechanisms: DIGEST-MD5 and EXTERNAL. But there are many other possibilities.
    It can be used in conjunction with robust network authentication systems like
    Kerberos. It can take advantage of secure One Time Password systems, like Opiekeys.
    And it can be used as an interface to more standard password storage systems,
    like PAM (Pluggable Authentication Modules).'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: SASL 是一个灵活的身份验证处理工具。在这里我们只讨论了两种 SASL 机制：DIGEST-MD5 和 EXTERNAL。但还有许多其他的可能性。它可以与像
    Kerberos 这样的强大网络身份验证系统一起使用。它可以利用像 Opiekeys 这样的安全一次性密码系统。还可以作为与更标准的密码存储系统（如 PAM（可插拔身份验证模块））的接口。
- en: While such configurations are outside of the scope of this book, there are many
    resources available. The SASL documentation (installed locally on Ubuntu in `/usr/local/doc/libsasl/index.html`),
    and the OpenLDAP Administrator's Guide ([http://openldap.org](http://openldap.org)),
    both provide more information about different SASL configurations.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种配置超出了本书的范围，但有很多可用资源。SASL 文档（在 Ubuntu 上本地安装在 `/usr/local/doc/libsasl/index.html`），以及
    OpenLDAP 管理员指南（[http://openldap.org](http://openldap.org)），都提供了有关不同 SASL 配置的更多信息。
- en: Now we will move on from authentication to authorization, and turn our attention
    to ACLs.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将从身份验证转向授权，并关注 ACL（访问控制列表）。
- en: Controlling Authorization with ACLs
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ACL 控制授权
- en: 'We''ve looked at connection security and authentication. Now we are ready to
    look at the last aspect of security: authorization. What we are specifically interested
    in is controlling access to information in our directory tree. Who should be able
    to access a record? Under what conditions? And how much of that record should
    they be able to see? These are the sorts of questions that we will address in
    this section.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了连接安全性和身份验证。现在我们准备讨论安全性的最后一个方面：授权。我们特别感兴趣的是控制对目录树中信息的访问。谁应该能够访问记录？在什么条件下？他们应该能看到该记录的多少内容？这些就是我们将在本节中解决的问题。
- en: The Basics of ACLs
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ACL 基础知识
- en: The primary way that OpenLDAP controls access to directory data is through Access
    Control Lists (ACLs). When the SLAPD server processes a request from a client,
    it evaluates whether the client has permissions to access the information it has
    requested. To do this evaluation SLAPD sequentially evaluates each of the ACLs
    in the configuration files, applying the appropriate rules to the incoming request.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP 控制目录数据访问的主要方式是通过访问控制列表（ACL）。当 SLAPD 服务器处理来自客户端的请求时，它会评估客户端是否具有访问所请求信息的权限。为进行此评估，SLAPD
    会顺序评估配置文件中的每个 ACL，按照适当的规则应用到传入的请求。
- en: Note
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Previously in this chapter, we have looked at *authentication* using simple
    and SASL binding. ACLs provide *authorization* services, which determine what
    information a given DN has access to.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之前，我们已经讨论了使用简单绑定和 SASL 绑定的*身份验证*。ACL 提供*授权*服务，决定给定 DN 可以访问哪些信息。
- en: ACLs were introduced in Chapter 2 in the section entitled *ACLs*. This section
    will develop the basic examples discussed there.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章的*ACLs*部分中介绍了 ACL。本节将扩展那里讨论的基本示例。
- en: An ACL is just a fancy configuration directive (the `access` directive) for
    SLAPD. Like certain other directives, the `access` directive can be used multiple
    times. There are two different places in the SLAPD configuration where ACLs can
    be placed. Firstly, they can be placed in the global configuration outside of
    a database section (that is, near the top of the configuration file). Rules that
    are placed at this level will apply globally to all backends. In the next chapter
    we will look at the case where a single directory has multiple backends.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: ACL 只是 SLAPD 的一个特殊配置指令（`access` 指令）。像某些其他指令一样，`access` 指令可以多次使用。SLAPD 配置中有两个不同的地方可以放置
    ACL。首先，它们可以放置在数据库部分之外的全局配置中（即，配置文件的顶部附近）。放置在此级别的规则将全局应用于所有后端。在下一章中，我们将讨论一个目录有多个后端的情况。
- en: Secondly, ACLs may be placed within a backend section (somewhere beneath a `database`
    directive). In this case, the ACLs will only be used when handling requests for
    information within database. In Chapter 2, we put our ACLs within the backend
    section, and we did not create any global `access` directives.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，ACL 可以放置在后端部分（`database` 指令下的某个位置）。在这种情况下，ACL 仅在处理数据库内的信息请求时使用。在第 2 章中，我们将
    ACL 放在了后端部分，并且没有创建任何全局 `access` 指令。
- en: How does all of this work out in practice? When are global rules used, and when
    are backend-specific rules used? If a backend has no specific ACLs, then the global
    rules will apply. If a backend does have ACLs, then the global rules will only
    be applied if none of the backend-specific rules apply. If the request is for
    a record which is not stored in any backend, such as the Root DSE or the `cn=subschema`
    entry, then only the global rules will be applied.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切在实践中是如何运作的？何时使用全局规则，何时使用特定后端规则？如果一个后端没有特定的 ACL，则将应用全局规则。如果后端确实有 ACL，则只有在没有任何后端特定规则应用的情况下，才会应用全局规则。如果请求是针对存储在任何后端中的记录（例如根
    DSE 或 `cn=subschema` 条目）时，则仅会应用全局规则。
- en: Within their context ACLs are evaluated top-down, from the first directive in
    the configuration file to the last. So, when backend-specific rules are tested,
    SLAPD begins testing with the first rule on the list and continues sequentially
    until either a stopping rule matches or SLAPD reaches the end of the list.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在其上下文中，ACLs 是自上而下进行评估的，从配置文件中的第一条指令开始，直到最后一条。所以，当测试特定后端规则时，SLAPD 会从列表中的第一条规则开始测试，并按顺序继续，直到找到匹配的停止规则，或者
    SLAPD 到达列表的末尾。
- en: In Chapter 2 we put the ACLs directly in the `slapd.conf` configuration file.
    In this section we will put them in their own file and use the `include` directive
    in `slapd.conf` to direct SLAPD to load the ACL file. This will allow us to separate
    the potentially lengthy ACLs from the rest of the configuration file.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章中，我们将 ACL 直接放入 `slapd.conf` 配置文件中。在本节中，我们将把它们放在自己的文件中，并在 `slapd.conf`
    中使用 `include` 指令，指示 SLAPD 加载 ACL 文件。这将允许我们将可能很长的 ACL 与配置文件的其他部分分开。
- en: Let's take a quick look at the format of an ACL, and then we will move on to
    some examples which will help clarify the intricacies of the ACL method.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下 ACL 的格式，然后我们将继续一些示例，帮助澄清 ACL 方法的复杂性。
- en: 'An access directive looks like this:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 一个访问指令如下所示：
- en: '`access to` [*resources*]'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '`访问` [*资源*]'
- en: '`by` [*who*] [*type* *of* *access* *granted*] [*control*]'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '`by` [*谁*] [*授予的* *访问类型*] [*控制*]'
- en: '`by` [*who*] [*type* *of* *access* *granted*] [*control*]'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '`by` [*谁*] [*授予的* *访问类型*] [*控制*]'
- en: '[PRE70]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: An `access` directive can have one `to` phrase, and any number of `by` phrases.
    We will take a look at the `access to` phrase first, then the `by` phrase.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `访问` 指令可以有一个 `to` 短语，并且可以有任意数量的 `by` 短语。我们将首先查看 `访问` 部分，然后是 `by` 部分。
- en: Access to [resources]
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问 [资源]
- en: In the `access to` part, an ACL specifies what is to be restricted in the directory
    tree by this rule. In the given rule we used `[resources]` as a placeholder for
    this section. An ACL can restrict by DN, by attribute, by filter, or by a combination
    of these. We will first look at restricting by DN.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `访问` 部分，ACL 指定了此规则在目录树中要限制的内容。在给定的规则中，我们使用了 `[resources]` 作为此部分的占位符。ACL 可以通过
    DN、属性、过滤器或它们的组合来进行限制。我们将首先查看如何通过 DN 限制访问。
- en: Access using DN
  id: totrans-548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 DN 的访问
- en: 'To restrict access to a particular DN, we would use something like this:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 要限制对特定 DN 的访问，我们可以使用如下内容：
- en: '[PRE71]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `by * none` phrase simply rejects access to anyone. We will cover this and
    other rules when we discuss the `by` phrase later in this chapter.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '`by * none` 短语简单地拒绝任何人的访问权限。我们将在本章稍后讨论 `by` 短语时详细介绍这一点及其他规则。'
- en: The rule would restrict access to that specific DN. Any time a request is received
    that needs access to the DN `uid=matt,ou=Users,dc=example,dc=com`, SLAPD would
    evaluate this rule to determine whether that request is authorized to access this
    record.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则将限制对特定 DN 的访问。每当收到需要访问 DN `uid=matt,ou=Users,dc=example,dc=com` 的请求时，SLAPD
    会评估此规则，以确定该请求是否被授权访问该记录。
- en: Restricting access to a specific DN can be useful at times, but there are several
    other supported options to the DN access specifier that come in useful for more
    general rule-making.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 限制对特定 DN 的访问有时是有用的，但除了 DN 访问限定符外，还有其他几个支持的选项对于更通用的规则制定非常有用。
- en: 'It is possible to restrict access to subtrees of a DN, or even by DN patterns.
    For example, if we wanted to write a rule that restricted access to entries beneath
    the Users OU, we could use an `access` clause like this:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 可以限制对 DN 子树的访问，甚至通过 DN 模式进行限制。例如，如果我们想编写一个规则，限制对 Users OU 下条目的访问，我们可以使用如下的 `访问`
    子句：
- en: '[PRE72]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In this example the rule restricts access to the OU and any records subordinate
    to it. This is accomplished by using `dn.subtree` (or the synonym `dn.sub`). In
    our directory information tree there are a number of user records in the Users
    OU subtree. These records are children of the Users OU. The DN `uid=matt,ou=Users,dc=example,dc=com`,
    for example, is in the subtree, and an attempt to access the record would trigger
    this rule.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，规则限制了对OU及其下属记录的访问。这是通过使用`dn.subtree`（或同义词`dn.sub`）来实现的。在我们的目录信息树中，Users
    OU子树下有多个用户记录。这些记录是Users OU的子级。例如，`uid=matt,ou=Users,dc=example,dc=com`的DN就在子树中，尝试访问该记录将触发此规则。
- en: 'Along with `dn.subtree`, there are three other keywords for adding structural
    restrictions to the DN access specifier:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`dn.subtree`，还有三个其他关键字，用于为DN访问修饰符添加结构性限制：
- en: '`dn.base`: Restrict access to this particular DN. This is the default, and
    `dn.exact` and `dn.baselevel` are synonyms of `dn.base`.'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dn.base`：限制对此特定DN的访问。这是默认值，`dn.exact`和`dn.baselevel`是`dn.base`的同义词。'
- en: '`dn.one`: Restrict access to any entries immediately below this DN. `dn.onelevel`
    is a synonym.'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dn.one`：限制对此DN下方的任何条目的访问。`dn.onelevel`是其同义词。'
- en: '`dn.children`: Restrict access to the children (subordinate) entries of this
    DN. This is similar to subtree, except that the given DN itself is not restricted
    by the rule.'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dn.children`：限制对此DN的子级（下属）条目的访问。这与子树相似，唯一不同的是，规则不限制给定的DN本身。'
- en: 'The `dn` clause accepts one other modifier that can be used to do sophisticated
    pattern matching: `dn.regex`. The `dn.regex` access specifier can process POSIX
    extended regular expressions. Here is an example of a simple regular expression
    in `dn.regex`:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '`dn`子句接受另一个修饰符，可以用于进行复杂的模式匹配：`dn.regex`。`dn.regex`访问修饰符可以处理POSIX扩展正则表达式。以下是一个`dn.regex`中简单正则表达式的示例：'
- en: '[PRE73]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This example would restrict access to any DN with the pattern `uid=SOMETHING,ou=Users,dc=example,dc=com`,
    where `SOMETHING` can be any string that is at least one character long and has
    no commas (`,`) in it. Regular expressions are a powerful tool for writing ACLs.
    We will discuss them more in the section *Getting* *More* *from* *Regular* *Expressions*
    after we look at the `by` phrase.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将限制对具有`uid=SOMETHING,ou=Users,dc=example,dc=com`模式的任何DN的访问，其中`SOMETHING`可以是任何至少有一个字符长且不包含逗号（`,`）的字符串。正则表达式是编写ACL的强大工具。在我们讨论`by`短语之后，我们将在*获取*
    *更多* *正则表达式*一节中深入讨论它们。
- en: Access using attrs
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用attrs访问
- en: In addition to restricting access to records by DN, we can also restrict access
    to one or more attributes within records. This is done using the `attrs` access
    specifier.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过DN限制对记录的访问，我们还可以限制对记录中一个或多个属性的访问。这是通过使用`attrs`访问修饰符来实现的。
- en: 'In the examples we''ve seen, when we restricted access we were restricting
    access at a record level. The `attrs` restriction works at a finer-grained level:
    it restricts access to particular attributes within records.'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看到的示例中，当我们限制访问时，我们是在限制记录级别的访问。`attrs`限制作用于更细粒度的级别：它限制对记录中特定属性的访问。
- en: 'For example, consider a case where we want to limit access to the `homePhone`
    attribute of all records in our directory information tree. This can be done with
    the following access phrase:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们希望限制对目录信息树中所有记录的`homePhone`属性的访问。可以使用以下访问短语来实现：
- en: '[PRE74]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `attrs` specifier takes a list of one or more attributes. In the given
    example, we just restricted access to the `homePhone` attribute. If we wanted
    to block access to `homePostalAddress` as well, we could modify the `attrs` list
    accordingly:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '`attrs`修饰符接受一个或多个属性的列表。在给定的示例中，我们仅限制了对`homePhone`属性的访问。如果我们还想阻止对`homePostalAddress`的访问，可以相应地修改`attrs`列表：'
- en: '[PRE75]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Let''s say that we wanted to restrict access to all of the attributes in the
    `organizationalPerson` object class. One way of doing this would be to create
    one long list: `attrs`=`title`, `x121Address`, `registeredAddress`, `destinationIndicator`,....
    But such a method would be time-consuming, difficult to read, and clumsy.'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要限制对`organizationalPerson`对象类中所有属性的访问。一种方法是创建一个长长的列表：`attrs`=`title`，`x121Address`，`registeredAddress`，`destinationIndicator`，....但这种方法既费时、难以阅读，又显得笨重。
- en: 'Instead, there is a convenient shorthand notation for this:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，有一种方便的简写符号表示法：
- en: '[PRE76]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This notation should be used carefully, however. This code does not just restrict
    access to the attributes explicitly defined in `organizationalPerson`, but also
    all of the attributes already defined in the `person` object class. Why? Because
    the `organizationalPerson` object class is a subclass of `person`. Therefore,
    all of the attributes of `person` are attributes of `organizationalPerson`.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，应该小心使用这种符号。此代码不仅限制对`organizationalPerson`中明确定义的属性的访问，还限制对`person`对象类中已经定义的所有属性的访问。为什么？因为`organizationalPerson`对象类是`person`的子类。因此，`person`的所有属性都是`organizationalPerson`的属性。
- en: 'Sometimes it useful to restrict access to all attributes *not* required or
    allowed by a particular object class. For example, consider the case where the
    only attributes we want to restrict are those that are not specified in the `organizationalPerson`
    object class. We can do that by replacing the *at* sign (`@`) with an exclamation
    point (`!`):'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，限制对所有*未*被特定对象类要求或允许的属性的访问是有用的。例如，考虑一个情况，我们只想限制那些在`organizationalPerson`对象类中未指定的属性。我们可以通过将*at*符号（`@`）替换为感叹号（`!`）来实现：
- en: '[PRE77]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This will restrict access to any attributes unless they are allowed or required
    by the `organizationalPerson` object class.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 这将限制对任何属性的访问，除非它们被`organizationalPerson`对象类允许或要求。
- en: 'There are two special names that can be specified in the attributes list but
    that do not actually match an attribute. These two names are `entry` and `children`.
    So we have two cases:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个特殊的名称可以在属性列表中指定，但它们并不真正匹配任何属性。这两个名称是`entry`和`children`。所以我们有两种情况：
- en: If `attrs=entry` is specified, then the record itself is restricted.
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果指定了`attrs=entry`，则限制该记录本身。
- en: If `attrs=children`, then the records that are children of this record are restricted.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`attrs=children`，则限制此记录的子记录。
- en: These two key words are not particularly useful in cases where only an `attrs`
    specifier is used, but they can be much more useful when `attrs` and `dn` specifiers
    are used in conjunction.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 当只使用`attrs`指定符时，这两个关键字并不特别有用，但当`attrs`和`dn`指定符一起使用时，它们会变得更加有用。
- en: 'Sometimes it is useful to restrict by the value of an attribute (rather than
    by an attribute name). For example, we may want to restrict access to any `givenName`
    attribute that has the value `Matt`. This sort of thing can be accomplished using
    the `val` (value) specifier:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，通过属性的值（而不是属性名）来限制访问会很有用。例如，我们可能希望限制对任何`givenName`属性值为`Matt`的访问。可以通过使用`val`（值）指定符来实现：
- en: '[PRE78]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Like the `dn` specifier, the `val` specifier has `regex`, `subtree`, `base`,
    `one`, `exact`, and `children` styles.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 和`dn`指定符一样，`val`指定符也具有`regex`、`subtree`、`base`、`one`、`exact`和`children`风格。
- en: Note
  id: totrans-586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When using the `val` specifier you can have no more than one attribute in the
    `attrs` list. The `val` specifier will not work on object class lists either.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`val`指定符时，`attrs`列表中最多只能有一个属性。`val`指定符也无法对对象类列表起作用。
- en: 'With `val.regex` you can use regular expressions for matching. We can modify
    the last example to restrict access to any `givenName` that starts with the letter
    `M`:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`val.regex`，你可以使用正则表达式进行匹配。我们可以修改最后一个例子，限制对任何以字母`M`开头的`givenName`的访问：
- en: '[PRE79]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In cases where the attribute value is a DN (like the `member` attribute for
    a `groupOfNames` object), the `regex`, `subtree`, `base`, `one`, and `children`
    styles can be used to restrict access based on the DN in the attribute value.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性值是DN（例如`groupOfNames`对象的`member`属性）时，可以使用`regex`、`subtree`、`base`、`one`、`exact`和`children`风格，根据属性值中的DN来限制访问。
- en: '[PRE80]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Tip
  id: totrans-592
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Specifying an Alternate Matching Rule**'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '**指定替代匹配规则**'
- en: By default, the `val` comparison uses the equality matching rule. You can select
    a different matching rule however, by inserting a slash (`/`) after `val`, and
    then entering the name or OID of the matching rule:`access to attrs=givenName
    val/caseIgnoreMatch="matt"`.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`val`比较使用的是相等匹配规则。然而，你可以选择不同的匹配规则，通过在`val`后插入斜杠（`/`），然后输入匹配规则的名称或OID：`access
    to attrs=givenName val/caseIgnoreMatch="matt"`。
- en: Access using Filters
  id: totrans-595
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用过滤器进行访问
- en: One of the lesser used but surprisingly powerful features of the `access` phrase
    is support for LDAP search filters as a means of restricting access to records.
    We looked at the LDAP filter syntax at the beginning of Chapter 3 when we discussed
    the search operation. Here we will use filters to restrict access to parts of
    a record.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '`access` 短语的一个较少使用但非常强大的功能是支持使用 LDAP 搜索筛选器来限制对记录的访问。我们在第 3 章开始时讨论搜索操作时已经看过
    LDAP 筛选器的语法。在这里，我们将使用筛选器来限制对记录部分的访问。'
- en: 'Filters provide a way to support value matching for entire records (instead
    of just attribute values, as is done with `attrs`). For example, using filters
    we can restrict access to all records that contain the object class `simpleSecurityObject`:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 筛选器提供了一种支持对整个记录进行值匹配的方法（而不仅仅是像 `attrs` 中那样匹配属性值）。例如，使用筛选器，我们可以限制访问所有包含 `simpleSecurityObject`
    对象类的记录：
- en: '[PRE81]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This will restrict access to any record in the directory information tree that
    has the object class `simpleSecurityObject`. Any legal LDAP filter can be used
    in a filter specifier. For example, we could restrict access to all records that
    have the given name Matt, the given name Barbara, or the surname Kant:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 这将限制对目录信息树中所有具有 `simpleSecurityObject` 对象类的记录的访问。可以在筛选器指定符中使用任何合法的 LDAP 筛选器。例如，我们可以限制对所有具有名字
    Matt、Barbara 或姓氏 Kant 的记录的访问：
- en: '[PRE82]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This code uses the "or" (disjunction) operator to indicate that if the request
    needs access to records that have given names with the values of Matt or Barbara,
    or if the request needs access to a record with the surname Kant, this rule should
    be applied.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了“或”（析取）操作符，表示如果请求需要访问名字为 Matt 或 Barbara 的记录，或者请求需要访问姓氏为 Kant 的记录，则应应用此规则。
- en: Combining Access Specifiers
  id: totrans-602
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合访问指定符
- en: 'We have looked at three different access specifiers: `dn`, `attrs`, and `filter`.
    And in the previous sections we have used each. Now we will combine them to create
    even more specific access rules.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过三种不同的访问指定符：`dn`、`attrs` 和 `filter`。在前面的章节中，我们已使用过每种指定符。现在，我们将它们组合起来创建更具体的访问规则。
- en: 'The order of combination is as follows:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 组合的顺序如下：
- en: '`access to` [*dn*] [*filter*] [*attrs*] [*val*]'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '`access to` [*dn*] [*filter*] [*attrs*] [*val*]'
- en: 'The `dn` and `filter` specifiers come first, as they both deal with records
    as a whole. Then `attrs` (and `val`), which function at the attribute level, come
    next. Let''s say that we want to restrict access to records in the Users OU just
    in the cases where the record has an `employeeNumber` attribute. To do this we
    can use a combination of a DN specifier and a filter:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '`dn` 和 `filter` 指定符排在前面，因为它们处理的是整个记录。接着是 `attrs`（和 `val`），它们在属性级别起作用。假设我们希望限制仅在记录具有
    `employeeNumber` 属性的情况下才能访问 Users 组织单位中的记录。为此，我们可以使用 DN 指定符和筛选器的组合：'
- en: '[PRE83]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This ACL will only restrict access when the request is for records in the `ou=Users,dc=example,dc=com`
    subtree and the `employeeNumber` field exists and has some value.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 此 ACL 仅在请求的是 `ou=Users,dc=example,dc=com` 子树中的记录，并且 `employeeNumber` 字段存在且有值时，才会限制访问。
- en: 'In a similar fashion, we can limit access to attributes for records in a certain
    subtree. For example, consider the case where we want to restrict access to the
    `description` attribute, but only for records that are in the the System OU. We
    can do this by combining the DN and attribute specifiers:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以限制对某个子树中记录的属性的访问。例如，假设我们希望限制对 `description` 属性的访问，但仅限于 System 组织单位中的记录。我们可以通过组合
    DN 和属性指定符来实现：
- en: '[PRE84]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: By this rule, a client could access the record with DN `uid=authenticate,ou=System,dc=example,dc=com`,
    but it would not be able to access the `description` attribute of that record.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 根据此规则，客户端可以访问 DN 为 `uid=authenticate,ou=System,dc=example,dc=com` 的记录，但无法访问该记录的
    `description` 属性。
- en: By carefully combining these access specifiers it is possible to articulate
    exact access restrictions. We will see some more in action as we continue on to
    the `by` phrase.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仔细组合这些访问指定符，可以精确地表述访问限制。我们将在继续研究 `by` 短语时看到更多应用实例。
- en: By [who] [type of access granted] [control]
  id: totrans-613
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 [who] [授予的访问类型] [控制]
- en: 'The `by` phrase contains three parts:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '`by` 短语包含三个部分：'
- en: The **who field** indicates what entities are allowed to access the resource
    identified in the access phrase
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**who 字段**表示允许访问访问短语中标识的资源的实体'
- en: The **access field** (type of access granted) indicates what can be done with
    the resource
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问字段**（授予的访问类型）表示可以对资源执行的操作'
- en: The third optional part, which is usually left off, is the **control field**
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个可选部分，通常被省略，是 **控制字段**。
- en: 'To get the gist of this distinction, consider the `by` phrase that we have
    been working with in the previous sections: `by * none`. In this `by` phrase,
    the `who` field is `*` (an asterisk character), and the access field is `none`.
    The control field is omitted in this example.'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这种区别，考虑一下我们在前面部分中使用的 `by` 子句：`by * none`。在这个 `by` 子句中，`who` 字段是 `*`（星号字符），访问字段是
    `none`。这个示例中省略了控制字段。
- en: The `*` is the universal wildcard. It matches any entity, including anonymous
    and all DNs. The `none` access type indicates that no permissions at all should
    be granted to the entity identified in the `who` specifier. In other words, `by
    * none` means that no access should be granted to anyone.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 是通用通配符。它匹配任何实体，包括匿名和所有 DN。`none` 访问类型表示不应授予任何权限给 `who` 指定的实体。换句话说，`by *
    none` 表示不应授予任何人访问权限。'
- en: Note
  id: totrans-620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The directory manager (`cn=Manager,dc=example,dc=com`), specified in the `slapd.conf`
    file with the `rootdn` directive, is an exception. It cannot be restricted by
    any access control. Thus, `by * none` does not apply to the manager.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `slapd.conf` 文件中通过 `rootdn` 指令指定的目录管理员（`cn=Manager,dc=example,dc=com`）是一个例外。它不能被任何访问控制限制。因此，`by
    * none` 不适用于管理员。
- en: We will explore the `who` field in detail, but before getting to that, let's
    examine the access field.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细探讨 `who` 字段，但在此之前，让我们先来看看访问字段。
- en: The Access Field
  id: totrans-623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问字段
- en: 'There are six distinct privileges that a client can have, in regards to an
    entry or attribute. There is also a seventh privilege specifier that equates to
    the removal of all privileges:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在访问某个条目或属性时，可以拥有六种不同的权限。此外，还有第七种权限，它表示移除所有权限：
- en: '`w`: Writes access to a record or attribute.'
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`w`：写入访问记录或属性。'
- en: '`r`: Reads access to a record or attribute.'
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`r`：读取记录或属性的访问权限。'
- en: '`s`: Searches access to a record or attribute.'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`s`：搜索记录或属性的访问权限。'
- en: '`c`: Accesses to run a comparison operation on a record or attribute.'
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`c`：访问以在记录或属性上执行比较操作。'
- en: '`x`: Accesses to perform a server-side authentication operation on a record
    or attribute.'
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x`：执行服务器端身份验证操作来访问记录或属性。'
- en: '`d`: Accesses to information about whether or not a record or attribute exists
    (''d'' stands for ''disclose'').'
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`d`：访问有关记录或属性是否存在的信息（''d'' 代表 ''disclose''）。'
- en: '`0`: Does not allow access to the record or attribute. This is equivalent to
    `-wrscxd`.'
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0`：不允许访问记录或属性。这相当于 `-wrscxd`。'
- en: These seven privileges can be specified in a `by` clause. To set one or more
    of these access privileges, use the `=` (equals) sign.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 这七种权限可以在 `by` 子句中指定。要设置一个或多个访问权限，可以使用 `=`（等号）。
- en: 'For example, to allow the server to compare a record''s `givenName` field to
    a `givenName` specified by a client, we could use the following ACL:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了让服务器将记录的 `givenName` 字段与客户端指定的 `givenName` 进行比较，我们可以使用以下 ACL：
- en: '[PRE85]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This will allow any client to attempt a compare operation. But that is the
    only operation it will allow. By this rule, no one can read from or write to this
    attribute. How does this work out in practice? When we use the `ldapsearch` client
    to attempt to read the value of the `givenName` attribute, we do not get any information
    about the `givenName`:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许任何客户端尝试执行比较操作。但这就是它唯一允许的操作。根据这个规则，没有人可以读取或写入此属性。实际操作中是怎样的呢？当我们使用 `ldapsearch`
    客户端尝试读取 `givenName` 属性的值时，无法获取任何有关 `givenName` 的信息：
- en: '[PRE86]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The only thing the server returns for our query is the DN of the record that
    matches the filter. No `givenName` attribute is returned.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器返回的唯一信息是与过滤器匹配的记录的 DN。不返回 `givenName` 属性。
- en: 'However, if we use the `ldapcompare` client, we can ask the server to tell
    us whether or not the DN has a `givenName` field with the value ''Matt'':'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用 `ldapcompare` 客户端，我们可以请求服务器告诉我们 DN 是否有一个值为 'Matt' 的 `givenName` 字段：
- en: '[PRE87]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The `ldapcompare` client sends a DN and an attribute/value pair to the server,
    and asks the server to compare the supplied attribute value with the server's
    copy of the attribute value for the record with the given DN.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldapcompare` 客户端将一个 DN 和一个属性/值对发送到服务器，并请求服务器将提供的属性值与服务器中该 DN 记录的属性值进行比较。'
- en: Here the `ldapcompare` client will request that the SLAPD server look up the
    record for `uid=matt,ou=Users,dc=example,dc=com` and check to see if the `givenName`
    attribute has the value 'Matt'. The server will answer `TRUE`, `FALSE`, or (if
    there is an error) `UNDEFINED`.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ldapcompare`客户端将请求SLAPD服务器查找`uid=matt,ou=Users,dc=example,dc=com`的记录，并检查`givenName`属性是否为'Matt'。服务器将返回`TRUE`、`FALSE`，或者（如果出现错误）`UNDEFINED`。
- en: 'In this case, the server responded `TRUE`. This indicates that the server performed
    the comparison, and the values matched. The combination of the `ldapsearch` and
    `ldapcompare` examples should illustrate how the ACL worked: while the server-side
    compare operation is permitted, the client does not have access to read the attribute
    value.'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，服务器回应了`TRUE`。这表明服务器执行了比较，并且值匹配。`ldapsearch`和`ldapcompare`的组合示例应当能够说明ACL的工作原理：虽然服务器端允许进行比较操作，但客户端没有权限读取属性值。
- en: 'Multiple access privileges can be granted in one `by` phrase. To modify in
    order to allow reading (`r`), comparing (`c`), and disclosing (`d`) on the `givenName`
    attribute, we can use the following ACL:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在一个`by`子句中授予多个访问权限。为了修改并允许对`givenName`属性进行读取（`r`）、比较（`c`）和披露（`d`），我们可以使用以下ACL：
- en: '[PRE88]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Now, both the `ldapsearch` and `ldapcompare` commands that we ran should succeed.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们之前运行的`ldapsearch`和`ldapcompare`命令应该成功。
- en: There are cases where permissions are inherited from other ACLs (we will look
    at some later). In such cases, we can selectively add or remove specific permissions
    by using `+` (plus sign) to add and `–` (minus sign) to remove.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，权限是从其他ACL继承的（我们稍后会讨论）。在这种情况下，我们可以通过使用`+`（加号）来添加，使用`–`（减号）来移除特定权限，进行有选择的添加或移除。
- en: 'For example, if we know that all the users already have compare (`c`) and disclose
    (`d`) on all the attributes, but we want to add *read* privileges just for the
    `givenName` attribute, we can use the following ACL:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们知道所有用户已经对所有属性拥有比较（`c`）和披露（`d`）权限，但我们只想为`givenName`属性添加*读取*权限，我们可以使用以下ACL：
- en: '[PRE89]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note
  id: totrans-649
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'An access control that grants compare and disclose, and then continues processing
    might look something like this: `access to attrs=givenName,sn by * =cd break`.
    This uses the `break` control to instruct SLAPD to continue processing ACLs. If
    this rule appeared in the SLAPD configuration above the rule `access to attrs=giveName
    by * +r`, then a request to the `givenName` attribute would have the effective
    permissions `=rcd`.'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 一个授予比较和披露权限，并继续处理的访问控制可能类似于这样：`access to attrs=givenName,sn by * =cd break`。这使用了`break`控制指令，告知SLAPD继续处理ACL。如果这个规则出现在SLAPD配置文件中，位于规则`access
    to attrs=giveName by * +r`之上，那么对`givenName`属性的请求将会有有效权限`=rcd`。
- en: Likewise, if we needed to remove the compare operation just for the `givenName`
    attribute, we could use a `by` clause like `by * -c`.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们需要仅为`givenName`属性移除比较操作，可以使用类似`by * -c`的`by`子句。
- en: 'The `0` access privilege removes all privileges. It cannot be used with the
    `+` or `–` operators, it can only be used with the `=` operator. The following
    ACL removes all privileges for all users to the `givenName` attribute:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '`0`访问权限移除所有权限。它不能与`+`或`–`操作符一起使用，只能与`=`操作符一起使用。以下ACL移除所有用户对`givenName`属性的所有权限：'
- en: '[PRE90]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This is the same as the `by` clause: `by * -wrscdx`.'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`by`子句相同：`by * -wrscdx`。
- en: 'These access controls are good for fine-grained control, but sometimes it is
    nice to have shortcuts. OpenLDAP has seven shortcuts that handle common configurations
    of access controls:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 这些访问控制适用于细粒度的权限控制，但有时使用快捷方式会更方便。OpenLDAP提供了七个快捷方式，用于处理常见的访问控制配置：
- en: '| Keyword | Privileges |'
  id: totrans-656
  prefs: []
  type: TYPE_TB
  zh: '| 关键字 | 权限 |'
- en: '| --- | --- |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `none` | `0` |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '| `none` | `0` |'
- en: '| `disclose` | `d` |'
  id: totrans-659
  prefs: []
  type: TYPE_TB
  zh: '| `disclose` | `d` |'
- en: '| `auth` | `xd` |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
  zh: '| `auth` | `xd` |'
- en: '| `compare` | `cxd` |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
  zh: '| `compare` | `cxd` |'
- en: '| `search` | `scxd` |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
  zh: '| `search` | `scxd` |'
- en: '| `read` | `rscxd` |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
  zh: '| `read` | `rscxd` |'
- en: '| `write` | `wrscxd` |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
  zh: '| `write` | `wrscxd` |'
- en: 'The `none` keyword we have seen before and it is the same as `=0`. Looking
    at the other keywords and their associated privilege, a pattern emerges: each
    keyword adds one new privilege, to the privileges of the previous keyword. Thus,
    `auth` has the `=d` privilege from `disclose`, plus the `x` privilege, and `compare`
    has `=xd` from `auth` and adds the `c` privilege. The `write` keyword at the bottom
    has all privileges.'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前见过的`none`关键字与`=0`相同。通过查看其他关键字及其相关权限，可以看出一种模式：每个关键字会在前一个关键字的权限基础上添加一个新权限。因此，`auth`拥有来自`disclose`的`=d`权限，加上`x`权限，而`compare`拥有来自`auth`的`=xd`权限，并添加了`c`权限。底部的`write`关键字具有所有权限。
- en: Because this general accumulation of privileges captures the usual use cases
    while remaining more readable, keywords are used more frequently than privilege
    strings. In most of our examples from here on, we will use the keyword unless
    there is a specific reason to use the privilege string instead.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这种通用的权限累积方式既能捕获常见的使用案例，又保持了较高的可读性，所以关键词比权限字符串更常用。在接下来的例子中，除非有特别的原因使用权限字符串，否则我们将使用关键词。
- en: Note
  id: totrans-667
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Of the seven keywords, `disclose`, `auth`, `compare`, `search`, `read`, and
    `write` can be prefixed with one of two prefixes: `self` and `realself`. The `self`
    prefix indicates that if the value in question refers to the user''s DN, then
    the user may have certain privileges. Thus `selfwrite` indicates that the user
    has `=wrscxd` permissions if and only if the value of the attribute in question
    is the user''s DN.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 在七个关键词中，`disclose`、`auth`、`compare`、`search`、`read` 和 `write` 可以加上两种前缀之一：`self`
    和 `realself`。`self` 前缀表示如果相关值指的是用户的 DN，那么用户可能会拥有某些权限。因此，`selfwrite` 表示只有当属性的值为用户的
    DN 时，用户才拥有 `=wrscxd` 权限。
- en: The `realself` prefix is similar, but it carries the additional stipulation
    that the DN not be proxied. These prefixes are particularly useful when dealing
    with groups and other membership-based records.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '`realself` 前缀与 `self` 类似，但它附带了额外的规定，即 DN 不能被代理。这些前缀在处理组和其他基于成员的记录时特别有用。'
- en: 'For example, the following ACL allows a user `write` access to the `uniqueMember`
    attribute only if the `uniqueMember` attribute contains that user''s DN: `access
    to attrs=uniqueMember by users selfwrite`.'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下 ACL 只允许用户在 `uniqueMember` 属性包含该用户的 DN 时对其进行 `write` 操作：`access to attrs=uniqueMember
    by users selfwrite`。
- en: Now that we have covered the access field we will move on to the `who` field.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讲解了访问字段，接下来我们将讨论 `who` 字段。
- en: The who Field
  id: totrans-672
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`who` 字段'
- en: We have always used `*` in the `who` field. However, the `who` field is the
    richest of the ACL fields, providing twenty-three distinct forms, most of which
    can be used in combinations. In order to efficiently cover ground, we will cover
    the major forms on their own, and then group similar forms together and treat
    them as units.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在 `who` 字段中使用 `*`。然而，`who` 字段是 ACL 字段中最丰富的，提供了二十三种不同的形式，其中大部分可以组合使用。为了高效覆盖这些内容，我们将单独讲解主要形式，然后将相似的形式组合在一起作为一个整体来处理。
- en: The five most frequently used forms are `*`, `anonymous`, `self`, `users`, and
    `dn`.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 五种最常用的形式是 `*`、`anonymous`、`self`、`users` 和 `dn`。
- en: The * and anonymous Specifiers
  id: totrans-675
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`*` 和 `anonymous` 修饰符'
- en: The `*` specifier, as we have already seen, is a global match. It matches any
    client, including the anonymous user.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 修饰符，如我们所见，是一个全局匹配符。它匹配任何客户端，包括匿名用户。'
- en: 'The `anonymous` specifier matches only clients that bind to the directory as
    the Anonymous user (see Chapter 3 for details on the Anonymous user). This refers,
    then, to clients that have not authenticated to the directory. Since the process
    of authentication requires that the client connect Anonymously, and then attempt
    to bind as a DN with a specific password, the anonymous user almost always needs
    permissions to perform an `auth` operation, in which the client sends the DN and
    password to the directory and asks the directory to verify that the information
    is correct. For that reason, you will likely need an ACL that looks like this:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '`anonymous` 修饰符只匹配那些以匿名用户身份绑定到目录的客户端（有关匿名用户的详细信息，请参见第 3 章）。这指的是那些没有对目录进行身份验证的客户端。由于认证过程要求客户端以匿名身份连接，然后尝试作为
    DN 绑定并使用特定密码，因此匿名用户几乎总是需要权限来执行 `auth` 操作，即客户端将 DN 和密码发送到目录，并要求目录验证这些信息是否正确。因此，你可能需要一个像这样的
    ACL：'
- en: '[PRE91]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This grants the Anonymous user the ability to do an auth operation. Note that
    every ACL ends with an implicit phrase: `by * none`. In other words, if permissions
    are not explicitly specified none are granted.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 这授予匿名用户执行认证操作的权限。请注意，每个 ACL 以隐式的短语结尾：`by * none`。换句话说，如果权限没有明确指定，则不授予任何权限。
- en: Note that the ACL above does not allow users to modify their own passwords.
    That's where the `self` specifier comes in.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述 ACL 不允许用户修改自己的密码。这正是 `self` 修饰符的作用所在。
- en: The self Specifier
  id: totrans-681
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`self` 修饰符'
- en: 'The `self` specifier is used to specify access controls for a DN on its own
    record. Thus, we can use the `self` specifier to allow a user to modify her or
    his own `userPassword` value:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '`self` 修饰符用于指定对一个 DN 自身记录的访问控制。因此，我们可以使用 `self` 修饰符来允许用户修改她或他的 `userPassword`
    值：'
- en: '[PRE92]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If we log in as `uid=matt,ou=Users,dc=example,dc=com` and try to modify the
    `userPassword` value of our own record (`dn: uid=matt,ou=Users,dc=example,dc=com`),
    SLAPD will allow us to change the password. But it will not (according to the
    rule above) allow us to modify anyone else''s `userPassword` value.'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们以 `uid=matt,ou=Users,dc=example,dc=com` 登录并尝试修改自己记录的 `userPassword` 值（`dn:
    uid=matt,ou=Users,dc=example,dc=com`），SLAPD 将允许我们更改密码。但它不会（根据上述规则）允许我们修改其他人的 `userPassword`
    值。'
- en: Note
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `self` specifier can be further modified with a `level` style. The `level`
    style indicates whether (and how many) parent records or child records are to
    be treated as if they were part of `self`. The `level` style takes an integer
    index. Positive integers refer to parents, while negative integers refer to children.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '`self` 指定符可以进一步使用 `level` 样式进行修饰。`level` 样式表示是否（以及多少个）父记录或子记录应被视为 `self` 的一部分。`level`
    样式采用整数索引。正整数表示父记录，而负整数表示子记录。'
- en: Thus `access to` `ou` `by` `self.level{1}` `write` indicates that the current
    DN has write permissions to the `ou` of its parent. Likewise, `access` `to` `ou`
    `by` `self.level{-1}` `write` indicates that the current DN has write permission
    to the `ou` of any of its immediate children.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`access to` `ou` `by` `self.level{1}` `write` 表示当前的 DN 对其父级的 `ou` 拥有写权限。同样，`access`
    `to` `ou` `by` `self.level{-1}` `write` 表示当前的 DN 对其任何直接子级的 `ou` 拥有写权限。
- en: The users Specifier
  id: totrans-688
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`users` 指定符'
- en: The `users` specifier refers to any authenticated client. The anonymous user
    is not included in `users` because it represents a client that has not authenticated.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '`users` 指定符表示任何已认证的客户端。匿名用户不包括在 `users` 中，因为它表示尚未进行身份验证的客户端。'
- en: 'This specifier comes in very handy when you need to allow anyone who has authenticated
    access to some resources. For example, in an enterprise directory we would likely
    want to allow all users the ability to see each other''s names, telephone numbers,
    and email addresses:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要允许任何已认证的用户访问某些资源时，dn 指定符非常有用。例如，在企业目录中，我们可能希望允许所有用户查看彼此的姓名、电话号码和电子邮件地址：
- en: '[PRE93]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The dn Specifier
  id: totrans-692
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: dn 指定符
- en: 'The `dn` specifier performs similarly in the `by` phrase to the role it plays
    in the `access` `to` phrase. It specifies one or more DNs. The `dn` has the `regex`,
    `base`, `one`, `subtree`, and `children` modifiers, all of which perform the same
    way here as they did in the `access` `to` phrase. Here''s an example using a few
    different DN patterns:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '`dn` 指定符在 `by` 语句中与其在 `access` `to` 语句中的作用类似。它指定一个或多个 DN。`dn` 拥有 `regex`、`base`、`one`、`subtree`
    和 `children` 修饰符，它们在这里的作用与在 `access` `to` 语句中的作用相同。以下是使用几个不同 DN 模式的示例：'
- en: '[PRE94]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This rule restricts access to the description attributes of anything in the
    System OU subtree. The user `uid=barbara,ou=Users,dc=example,dc=com` has write
    permissions to the description, while any child users of the System OU have *read*
    permissions. Users with DNs of the form `uid=SOMETHING,ou=Users,dc=example,dc=com`
    also have *read* access to the description.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则限制对系统 OU 子树中任何对象的描述属性的访问。用户 `uid=barbara,ou=Users,dc=example,dc=com` 拥有对描述的写权限，而系统
    OU 的任何子级用户则拥有*读取*权限。DN 形式为 `uid=SOMETHING,ou=Users,dc=example,dc=com` 的用户也拥有对描述的*读取*权限。
- en: In addition to the regular DN modifiers, a `dn` in the `by` clause can also
    have a `level` modifier. Level allows the ACL author to specify exactly how many
    levels down a `by` phrase should go. Recall that the `dn.one` specifier indicates
    that any record directly below the specified DN is to be granted the specified
    permissions. For example `by` `dn.one="ou=Users,dc=example,dc=com"` `read` grants
    any direct descendant of the Users OU read permissions. So `uid=matt,ou=Users,dc=example,dc=com`
    would be granted read access, but `uid=jake,ou=Temp,ou=Users,dc=example,dc=com`
    would not be granted such access because he is two levels down. The `dn.level`
    specifier lets us arbitrarily specify how many levels to descend. For example,
    `by` `dn.level{2}="ou=Users,dc=example,dc=com"` `read` would allow both `matt`
    and `jake` read access.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的 DN 修饰符外，`by` 语句中的 `dn` 还可以带有 `level` 修饰符。Level 允许 ACL 编写者精确指定 `by` 语句应该下降多少级。回想一下，`dn.one`
    指定符表示任何直接位于指定 DN 下的记录将获得指定权限。例如，`by` `dn.one="ou=Users,dc=example,dc=com"` `read`
    会授予 `Users` OU 的任何直接后代读取权限。因此，`uid=matt,ou=Users,dc=example,dc=com` 会被授予读取权限，但
    `uid=jake,ou=Temp,ou=Users,dc=example,dc=com` 不会被授予此权限，因为他位于第二级。`dn.level` 指定符让我们可以任意指定下降多少级。例如，`by`
    `dn.level{2}="ou=Users,dc=example,dc=com"` `read` 将允许 `matt` 和 `jake` 都获得读取权限。
- en: Note
  id: totrans-697
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Proxy Authentication and Real DNs**'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '**代理认证与真实 DN**'
- en: 'If SLAPD is set up to allow Proxy Authentication, in which case one DN is used
    for authentication, and then another DN is used for performing other directory
    operations, it is sometimes useful to write ACLs based on the DN used for authentication
    (the real DN). The `realdn` specifier can be used for this. It functions just
    like the `dn` specifier, except that it operates on the real DN. Also, `realanonymous`,
    `realusers`, `realdnattr`, and `realself` can be used to restrict based on the
    real DN. See the `slapd.access` man page for more: `man` `slapd.access`.'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SLAPD被设置为允许代理认证，其中一个DN用于认证，然后另一个DN用于执行其他目录操作，那么有时根据用于认证的DN（即真实的DN）编写ACL是很有用的。可以使用`realdn`指定符来实现这一点。它的功能与`dn`指定符相同，唯一的区别是它作用于真实的DN。此外，`realanonymous`、`realusers`、`realdnattr`和`realself`可以用来基于真实的DN进行限制。详情请参阅`slapd.access`手册页：`man`
    `slapd.access`。
- en: Groups and Members
  id: totrans-700
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 组和成员
- en: Sometimes it is useful to grant group members the access to an object. For example,
    if you have an Administrators group, you may wish to grant any member of that
    group write access to all of the records in the System OU.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，授权组成员访问某个对象是很有用的。例如，如果你有一个管理员组，你可能希望授予该组的任何成员对系统OU中所有记录的写访问权限。
- en: One might expect that the way to set permissions for group members is simply
    to use the group as the value of a `dn` specifier in an ACL. However, that is
    not the case since the `dn` specifier refers to the group record as a whole, and
    has nothing at all to do with the members of the group, each of which has its
    own record elsewhere in the directory.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有人认为，为组成员设置权限的方式就是在ACL中使用该组作为`dn`指定符的值。但事实并非如此，因为`dn`指定符是指整个组记录，且与组成员无关，每个组成员在目录中都有自己的记录。
- en: Instead, what we need is a way to search the member attributes of a particular
    group record, and then grant access to the DNs listed in the record. The group
    specifier provides exactly this sort of capability.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们真正需要的是一种方法，可以搜索特定组记录中的成员属性，然后授予记录中列出的DN访问权限。`group`指定符正好提供了这种能力。
- en: 'Group evaluation can be done with the `group` specifier. In its simplest form
    it is used like this:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 组评估可以使用`group`指定符来完成。其最简单的形式如下所示：
- en: '[PRE95]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This ACL will grant members of the `cn=Admins,ou=Groups,dc=example,dc=com` group
    write access to anything in the System OU, while giving all other users read-only
    permissions.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 此ACL将授予`cn=Admins,ou=Groups,dc=example,dc=com`组的成员对系统OU中任何内容的写权限，同时授予所有其他用户只读权限。
- en: Tip
  id: totrans-707
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Order Matters**'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '**顺序很重要**'
- en: ACL by phrase are evaluated sequentially, and by default SLAPD will stop processing
    `by` phrases when it hits a match. In other words, if the by phrases in the above
    rule were reversed, members of LDAP Admins would never be given write permission
    because they would always match the `by` `users` `read` phrase. Evaluation of
    the ACL would stop before group membership was checked.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 通过短语的ACL按顺序进行评估，默认情况下，当SLAPD找到匹配项时，它会停止处理`by`短语。换句话说，如果上述规则中的`by`短语被反转，LDAP管理员的成员将永远无法获得写权限，因为他们总是会匹配到`by`
    `users` `read`短语。在检查组成员资格之前，ACL的评估就会停止。
- en: But the ACL above will only work on groups whose object class is `groupOfNames`,
    and whose membership attribute is `member`. This is because groupOfNames is the
    default grouping object class, and member is the default membership attribute.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 但是上面的ACL只会对那些对象类为`groupOfNames`，并且成员属性为`member`的组起作用。这是因为`groupOfNames`是默认的分组对象类，而`member`是默认的成员属性。
- en: 'When we created our LDAP Admins group in Chapter 3, it was not `groupOfNames`,
    nor did it use the `member` attribute for membership. Our record looked like this:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第3章创建LDAP管理员组时，它不是`groupOfNames`，也没有使用`member`属性来表示成员关系。我们的记录如下所示：
- en: '[PRE96]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We used the `groupOfUniqueNames` object class and the `uniqueMember` membership
    attribute. In order to get the ACL to match these constraints we will need to
    specify the object class and membership attribute in the `group` specifier:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`groupOfUniqueNames`对象类和`uniqueMember`成员属性。为了让ACL匹配这些约束，我们需要在`group`指定符中指定对象类和成员属性：
- en: '[PRE97]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Note the change in the highlighted line. Using slashes (`/`) we have specified
    first the object class then the membership attribute that should be used to determine
    who what entries represent members. When this `by` phrase is evaluated, SLAPD
    will find the DN `cn=LDAP` `Admins,ou=Groups,dc=example,dc=com`, check to see
    if it has object class `groupOfUniqueMembers`, and then grant write permissions
    to a DN if it is specified in a uniqueMember attribute.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意高亮行中的更改。通过使用斜杠（`/`），我们首先指定了对象类，然后是应该用来确定条目代表哪些成员的成员属性。当评估此`by`短语时，SLAPD将找到DN
    `cn=LDAP` `Admins,ou=Groups,dc=example,dc=com`，检查它是否具有`groupOfUniqueMembers`对象类，然后如果在`uniqueMember`属性中指定了该DN，则授予写权限。
- en: Using this expanded notation, you can use other membership-based records as
    groups. For example, you can use the `organizationalRole` object class with the
    `roleOccupant` membership attribute.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种扩展的表示法，你可以将其他基于成员的记录作为组来使用。例如，你可以使用`organizationalRole`对象类和`roleOccupant`成员属性。
- en: 'Like many other specifiers, the group specifier also supports regular expressions
    with the `regex` style. Thus, we could create a rule that would allow members
    of any group in OU Groups write access to the System OU by expanding our last
    example:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他说明符一样，组说明符也支持`regex`样式的正则表达式。因此，我们可以创建一个规则，允许任何OU Groups组的成员对系统OU拥有写权限，方法是扩展我们最后的示例：
- en: '[PRE98]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The second and third lines should be combined into one long line in `slapd.conf`.
    The regular expression in the group specifier would match any DN with a CN component
    at the beginning. For all such entries, if the object class is `groupOfUniqueMembers`,
    then the SLAPD will grant membership to a user who is a `uniqueMember` of one
    of those groups.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行和第三行应该合并为`slapd.conf`中的一长行。组说明符中的正则表达式将匹配所有具有CN组件的DN。对于所有此类条目，如果对象类是`groupOfUniqueMembers`，则SLAPD将为该组中的`uniqueMember`用户授予成员资格。
- en: Member-Based Record Access
  id: totrans-720
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于成员的记录访问
- en: 'What if a group member needs to modify the record of the group to whom she
    or he belongs? One way to allow this is with the `dnattr` specifier. The `dnattr`
    specifier grants access to a record only if the client''s DN appears in a certain
    attribute of the record. For example, the following example allows a group member
    (`uniqueMember`) of a group (which is a `groupOfUniqueNames` object) access to
    the group record:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组成员需要修改他或她所属组的记录，该怎么办？允许这种操作的一种方法是使用`dnattr`说明符。`dnattr`说明符仅在客户端的DN出现在记录的某个属性中时授予访问权限。例如，以下示例允许一个组（`groupOfUniqueNames`对象）的组成员（`uniqueMember`）访问该组记录：
- en: '[PRE99]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The second line specifies that if the client's DN is in the list of values for
    the `uniqueMember` attribute, then that client should be given write access to
    the entire group record. Other users, according to the third line, will have read
    access.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行指定，如果客户端的DN出现在`uniqueMember`属性的值列表中，则该客户端应获得对整个组记录的写入权限。根据第三行，其他用户将只能读取访问权限。
- en: Network, Connections, and Security
  id: totrans-724
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网络、连接与安全
- en: SLAPD can use information about the client's connection (including network and
    security information) in access control lists. This feature provides an additional
    layer of network security that complements SSL/TLS and SASL.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: SLAPD可以在访问控制列表中使用客户端连接的信息（包括网络和安全信息）。该功能提供了一个额外的网络安全层，补充了SSL/TLS和SASL。
- en: 'The following are network or connection level specifiers:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是网络或连接级别的说明符：
- en: '`peername`: This is used to specify a range of IP addresses (for `ldap://`
    and `ldaps://`).'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peername`：用于指定IP地址范围（用于`ldap://`和`ldaps://`）。'
- en: '`sockname`: This is used to specify a socket file for an LDAPI listener (`ldapi://`).'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sockname`：用于指定LDAPI监听器（`ldapi://`）的套接字文件。'
- en: '`domain`: This is used to specify a domain name for `ldap://` and `ldaps://`
    listeners.'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domain`：用于指定`ldap://`和`ldaps://`监听器的域名。'
- en: '`sockurl`: This is used to specify a socket file in URL format (`ldapi://var/run/ldapi`)
    for an LDAPI listener.'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sockurl`：用于指定LDAPI监听器的套接字文件的URL格式（`ldapi://var/run/ldapi`）。'
- en: '`ssf`: The overall security strength factor (SSF) of the connection.'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssf`：连接的整体安全强度因子（SSF）。'
- en: '`transport_ssf`: The SSF for the underlying transport layer of the network.'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transport_ssf`：网络传输层的安全强度因子（SSF）。'
- en: '`tls_ssf`: The SSF for the SSL/TLS connection. This works with SSL/TLS connections
    on LDAPS listeners and Start TLS on LDAP listeners.'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tls_ssf`：SSL/TLS连接的安全强度因子（SSF）。它适用于LDAPS监听器上的SSL/TLS连接，以及LDAP监听器上的Start TLS。'
- en: '`sasl_ssf`: The SSF of the SASL connection.'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sasl_ssf`：SASL连接的安全强度因子（SSF）。'
- en: The SSF specifiers (`ssf`, `transport_ssf`, `tls_ssf`, and `sasl_ssf`) perform
    the same checks as the SSF parameters to the SLAPD `security` directive (discussed
    in the first part of this chapter). In this case, however, SSFs may be used to
    selectively restrict (or grant) access to portions of the directory information
    tree. SSF specifiers require an integer value for the level of security desired.
    For example, using `ssf=256` will require that the overall SSF of a connection
    be 256\. But `tls_ssf=56` will require that the SSF of the TLS/SSL layer be at
    least 56, regardless of what the SSF of the SASL configuration is. For more information
    on SSFs, see the section earlier in this chapter entitled *Using* *Security* *Strength*
    *Factors*.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: SSF 限定符（`ssf`，`transport_ssf`，`tls_ssf`，`sasl_ssf`）执行与 SSF 参数对 SLAPD `security`
    指令相同的检查（在本章的第一部分中讨论）。然而，在这种情况下，SSF 可用于有选择地限制（或授予）对目录信息树部分的访问。SSF 限定符需要一个整数值来指定所需的安全级别。例如，使用
    `ssf=256` 将要求连接的整体 SSF 为 256。 但 `tls_ssf=56` 将要求 TLS/SSL 层的 SSF 至少为 56，无论 SASL
    配置的 SSF 是多少。有关 SSF 的更多信息，请参阅本章前面的标题为 *使用* *安全* *强度* *因子* 的部分。
- en: 'For example, the following ACL will only grant *write* access to the specified
    DN when the client has connected with a strong SASL cipher:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下 ACL 仅在客户端使用强大的 SASL 密码连接时，才会授予指定 DN 的 *写入* 权限：
- en: '[PRE100]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This rule allows users to modify their own records only if they have authenticated
    with SASL using a security mechanism with a strength of 128 (DIGEST-MD5) or more.
    All other users would only get read access.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则仅允许用户在通过 SASL 认证并使用强度为 128（DIGEST-MD5）或更高的安全机制时修改自己的记录。所有其他用户只能获得读取权限。
- en: Tip
  id: totrans-739
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Combining Specifiers in a by Phrase**'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 by 短语中组合限定符**'
- en: As the rule above illustrates, multiple specifiers can be used in a single by
    phrase. When this happens all specifiers must be matched before the indicated
    rights will be granted (or denied).
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 如上规则所示，多个限定符可以在同一个 by 短语中使用。当这种情况发生时，所有限定符必须匹配，才能授予（或拒绝）指示的权限。
- en: The `peername` specifier is used for setting restrictions based on information
    about the IP connection. It can be used to complement other components in network
    security, like SSL/TLS. The `peername` specifier can take an IP address or a range
    of IP addresses (using subnet masks) and can also specify a source port.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '`peername` 限定符用于根据 IP 连接信息设置限制。它可以与网络安全中的其他组件（如 SSL/TLS）配合使用。`peername` 限定符可以接受一个
    IP 地址或一系列 IP 地址（使用子网掩码），还可以指定源端口。'
- en: The following rule grants write access to local connections, read access to
    connections on the local LAN (address from 10.40.0.0 through 10.40.0.255), and
    denies access to all other clients. Remember, every rule ends with an implicit
    `by` `*` `none`.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 以下规则授予本地连接写入权限，授予本地局域网（地址从 10.40.0.0 到 10.40.0.255）上的连接读取权限，并拒绝所有其他客户端的访问。请记住，每条规则以隐式的
    `by` `*` `none` 结尾。
- en: '[PRE101]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Note that the `peername` specifier requires the ip style for specifying an IP
    address. It also supports the `regex` style (`access` `to` `*` `by` `peername.regex="^IP=10\`.`40\`.`0\`.`[0-9]+:[0-9]+$"`
    `write`) and the `path` specifier to replicate the behavior of `sockname`.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`peername` 限定符要求使用 IP 风格来指定 IP 地址。它还支持 `regex` 风格（`access` `to` `*` `by`
    `peername.regex="^IP=10\`.`40\`.`0\`.`[0-9]+:[0-9]+$"` `write`）以及 `path` 限定符来复制
    `sockname` 的行为。
- en: Tip
  id: totrans-746
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Regular Expressions for IP Addresses**'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '**IP 地址的正则表达式**'
- en: 'For an IP address, the format of the string used in regular expression evaluation
    is this: `IP=<address>:<port>`. If you are creating a precise regular expression
    make sure to deal with the `IP=` prefix and the port information. A regular expression
    like this will fail: `peername.regex="^10.40.12[0-9]$"`. Why? Because it is missing
    the `IP=` and port information.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 IP 地址，在正则表达式评估中使用的字符串格式如下：`IP=<address>:<port>`。如果您正在创建精确的正则表达式，请确保处理 `IP=`
    前缀和端口信息。像这样的正则表达式会失败：`peername.regex="^10.40.12[0-9]$"`。为什么？因为它缺少 `IP=` 和端口信息。
- en: 'A more useful version of the rule above would deny access to anything in the
    directory if it was not in the particular ranges, but would leave further access
    controls to rules appearing later in the ACL list. This can be done using the
    special `break` control described in the next section. We could also added SSF
    information, so connections coming over non-local connections must also use strong
    SSL/TLS encryption. Here is the rule:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 上述规则的一个更有用的版本是，如果连接不在特定范围内，则拒绝访问目录中的所有内容，但会将进一步的访问控制留给ACL列表中后面的规则。这可以通过使用下节中描述的特殊`break`控制来实现。我们还可以添加SSF信息，这样通过非本地连接来的连接也必须使用强SSL/TLS加密。以下是规则：
- en: '[PRE102]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The above rule might appear difficult to read, but here is what it does:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 上述规则可能看起来难以阅读，但它的作用如下：
- en: If the connection is local (coming over 127.0.0.1 or `localhost`), then SLAPD
    allows further processing of the ACL list (that's what `break` does). Whether
    or not the user then gets access to resources is dependent on other rules.
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果连接是本地的（来自127.0.0.1或`localhost`），则SLAPD允许进一步处理ACL列表（这就是`break`的作用）。用户是否能够访问资源则依赖于其他规则。
- en: If the connection comes from an address on the LAN and it is using strong SSL/TLS
    encryption, then SLAPD will continue processing the ACL list.
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果连接来自局域网中的地址并且使用强SSL/TLS加密，那么SLAPD将继续处理ACL列表。
- en: Under any other connecting circumstances the connection is rejected. For example,
    if a connection comes from the LAN but does not use sufficiently strong SSL/TLS,
    the connection will be closed. This behavior is caused by the implicit `by` `*`
    `none` phrase.
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何其他连接情况下，连接都会被拒绝。例如，如果连接来自局域网，但未使用足够强的SSL/TLS加密，连接将被关闭。此行为是由隐式的`by` `*` `none`短语引起的。
- en: For more on the `break` control, see the section called *The* *Control* *Field*.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`break`控制的更多信息，请参见名为*控制字段*的章节。
- en: 'Sometimes it is more useful to be able to specify which domain names (rather
    than which IP addresses) should be granted access. This can be done with the `domain`
    specifier:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，能够指定哪些域名（而不是哪些IP地址）应被授予访问权限更加有用。这可以通过使用`domain`指定符来完成：
- en: '[PRE103]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: In the example above, the second line provides write access to any client connection
    coming from the domain name `main.example.com`. The third line grants read access
    to the domain `example.com`, and any subdomain of `example.com`. So, if a server
    with the domain name `test2.example.com` made a request, it would be granted access
    under the third rule. However, `testexample.com` would not match because it is
    not a subdomain of `example.com`—it is a different domain altogether.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，第二行为来自域名`main.example.com`的任何客户端连接提供写入权限。第三行为`example.com`及其任何子域名提供读取权限。所以，如果域名为`test2.example.com`的服务器发起请求，它将在第三条规则下获得访问权限。然而，`testexample.com`则不匹配，因为它不是`example.com`的子域名——它是一个完全不同的域名。
- en: When SLAPD encounters a domain specifier in an ACL, it takes the IP address
    of the client connection and does a reverse DNS lookup to get the host name. In
    light of this there are two things to keep in mind when using the domain specifier.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 当SLAPD在ACL中遇到域名指定符时，它会获取客户端连接的IP地址并进行反向DNS查找以获取主机名。鉴于此，在使用域名指定符时需要记住两点。
- en: First, the name returned by a reverse DNS lookup may not be what you expect
    based on a forward DNS lookup. For example, doing a DNS lookup on `ldap.example.com`
    returns the address 10.40.0.23\. However, doing a reverse DNS lookup on 10.40.0.23
    returns `mercury.example.com`. Why?
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，反向DNS查找返回的名称可能与正向DNS查找返回的结果不同。例如，对`ldap.example.com`进行DNS查找返回地址10.40.0.23，而对10.40.0.23进行反向DNS查找返回`mercury.example.com`。为什么会这样？
- en: 'It is because `ldap.example.com` is in DNS parlance, a **CNAME record**, and
    `mercury.example.com` is an **A record**. Practically speaking, what this means
    is that `ldap.example.com` is an alias to the server''s real (**canonical**) name,
    which is `mercury.example.com`. The practical consequence is this: when you write
    an ACL using the `domain` specifier, make sure you use the A record domain name,
    not the CNAME record name. Otherwise, SLAPD will apply the rule to the wrong domain
    name.'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`ldap.example.com`在DNS术语中是一个**CNAME记录**，而`mercury.example.com`是一个**A记录**。实际上，这意味着`ldap.example.com`是服务器真实（**规范**）名称`mercury.example.com`的别名。实际结果是：当你使用`domain`指定符编写ACL时，确保使用A记录域名，而不是CNAME记录名。否则，SLAPD会将规则应用到错误的域名。
- en: Tip
  id: totrans-762
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Looking up DNS Information**'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找DNS信息**'
- en: 'There are many tools for looking up DNS information. Most Linux distributions,
    including Ubuntu Linux, provide the `host` and `dig` commands for command-line
    DNS lookups. The `host` command gives brief sentence-like information like this:
    `ldap.example.com` `is` `an` `alias` `for` `mercury.example.com`. The `dig` command,
    in contrast, gives detailed technical information.'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以查找 DNS 信息。大多数 Linux 发行版，包括 Ubuntu Linux，都提供了用于命令行 DNS 查找的 `host` 和 `dig`
    命令。`host` 命令提供简短的类似句子的信息，例如：`ldap.example.com` `is` `an` `alias` `for` `mercury.example.com`。与此相对，`dig`
    命令提供详细的技术信息。
- en: The second thing to keep in mind when considering the domain specifier is that
    it is less reliable than using IP address information. DNS addresses can be spoofed,
    which means another server on the network can claim to be `ldap.example.com` and
    send traffic that looks, to SLAPD, like it is coming from the real `ldap.example.com`.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑域名指定符时，第二点需要记住的是，它的可靠性低于使用 IP 地址信息。DNS 地址可以被伪造，这意味着网络上的另一台服务器可能会假冒 `ldap.example.com`，并发送看起来像是来自真实
    `ldap.example.com` 的流量给 SLAPD。
- en: One way to diminish the risk of this is to use client-side SSL/TLS certificates
    and configure SLAPD to require that the client send a signed certificate to authenticate
    before it can perform any other directory operations. Unfortunately, client-side
    certificates cannot be selectively required through ACLs. Instead you will have
    to use the directive `TLSVerifyClient` `demand` in the `slapd.conf` file.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 降低这种风险的一种方法是使用客户端 SSL/TLS 证书，并配置 SLAPD 要求客户端发送签名证书进行身份验证，然后才能执行任何其他目录操作。不幸的是，客户端证书不能通过
    ACL 有选择地强制使用。相反，你需要在 `slapd.conf` 文件中使用 `TLSVerifyClient` `demand` 指令。
- en: The `sockname` and `sockurl` specifiers are used for servers that run with UNIX
    local socket Inter Process Communication (IPC) instead of network sockets. These
    directives can be used to restrict local connections that use the IPC layer instead
    of connecting through the IP network.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '`sockname` 和 `sockurl` 指定符用于使用 UNIX 本地套接字进程间通信（IPC）而不是网络套接字运行的服务器。这些指令可以用于限制使用
    IPC 层而非通过 IP 网络连接的本地连接。'
- en: Note
  id: totrans-768
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is uncommon to run LDAPI. Generally it is used only in situations where IP
    network connections cannot or should not be used. In typical cases, local clients
    connect to SLAPD over LDAP, using the URL `ldap://localhost/` rather than using
    LDAPI.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 LDAPI 并不常见。通常只在不能或不应使用 IP 网络连接的情况下使用。在典型情况下，本地客户端通过 LDAP 连接到 SLAPD，使用 `ldap://localhost/`
    URL，而不是使用 LDAPI。
- en: 'For example, we could use the following ACL to allow only local (LDAPI) connections
    to write to the record, while users who connected through a different mechanism
    could only read the record:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用以下 ACL 仅允许本地（LDAPI）连接写入记录，而通过其他机制连接的用户只能读取记录：
- en: '[PRE104]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The second line indicates that only LDAPI connections that connect through a
    particular LDAPI socket file should gain write access to the DN. All other clients
    (`users`) will get read permissions.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行表示只有通过特定 LDAPI 套接字文件连接的 LDAPI 连接才应获得对 DN 的写访问权限。所有其他客户端（`用户`）将获得读取权限。
- en: 'Advanced Step: Using the set Specifier'
  id: totrans-773
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 高级步骤：使用 set 指定符
- en: In addition to the syntax we have examined just now, there is an experimental
    type of `by` phrase—the **set** syntax. The `set` syntax can be used to create
    a compact and powerful set of conditions for access. Since it allows Boolean operators,
    and has a method for accessing attribute values, a single rule in the `set` syntax
    can accomplish what would otherwise take tremendously complex ACLs.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们刚才检查过的语法外，还有一种实验性的 `by` 短语类型——**set** 语法。`set` 语法可以用于创建一个简洁且强大的访问条件集。由于它允许使用布尔运算符，并且具有访问属性值的方法，单个
    `set` 语法规则可以完成原本需要非常复杂的 ACL 才能实现的任务。
- en: The basic idea behind the `set` syntax is this. By using a rule composed of
    conditions joined by operators, SLAPD creates a set of objects which have access
    to the record in question. If the result of an evaluation of a `set` specifier
    is a set that contains one or more members, then the `by` phrase is considered
    a match and permissions are applied. If, on the other hand, the set is empty,
    then SLAPD will continue evaluating the `by` phrases for that rule to see if it
    can find another match.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 语法的基本思想是这样的。通过使用由条件组成的规则，SLAPD 创建了一个对象集，这些对象可以访问相关记录。如果对 `set` 指定符的评估结果是一个包含一个或多个成员的集合，则
    `by` 短语被视为匹配，权限将被应用。另一方面，如果集合为空，SLAPD 将继续评估该规则的 `by` 短语，以查看是否能找到另一个匹配项。'
- en: Tip
  id: totrans-776
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `set` specifier uses operations of the sort used in set theory. When using
    the set specifier you may find it helpful to think in terms of set theory, with
    sets (lists of items) and set operations, such as union (`&`) and intersection
    (`|`).
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`指定符使用与集合论中类似的操作。当使用集合指定符时，您可能会发现以集合论的角度思考非常有帮助，思考集合（项目的列表）和集合操作，如并集（`&`）和交集（`|`）。'
- en: 'Here is a simple ACL using a `set` specifier to replicate the behavior of the
    `group` specifier. It provides write access to records in the System OU only to
    clients in the LDAP Admins group. All others get read access only:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 ACL，使用`set`指定符来复制`group`指定符的行为。它只为 LDAP Admins 组中的客户端提供对系统 OU 中记录的写访问权限，其他所有客户端只能获得读访问权限：
- en: '[PRE105]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The second line, highlighted above, contains the `set` specifier, which contains
    a `set` statement. The text in the square brackets specifies a DN, which is the
    DN of the LDAP Admins group. To access the values of the `uniqueMember` attribute
    we append `/uniqueMember` to the DN. When SLAPD expands this, it will contain
    the set of all `uniqueMembers` in the LDAP `Admins` `group`. In set-theoretic
    notation (which is not used by OpenLDAP, but which is helpful to understand what
    is happening), the set of group members would look like this:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 上面突出显示的第二行包含`set`指定符，其中包含`set`语句。方括号中的文本指定了一个 DN，即 LDAP Admins 组的 DN。为了访问`uniqueMember`属性的值，我们将`/uniqueMember`附加到
    DN 上。当 SLAPD 展开时，它将包含 LDAP `Admins` `group` 中所有`uniqueMembers`的集合。在集合论表示法中（OpenLDAP
    未使用此表示法，但有助于理解发生了什么），组成员的集合将如下所示：
- en: '[PRE106]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: There are two members (the two `uniqueMembers`) for the LDAP Admins group.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP Admins 组中有两个成员（两个`uniqueMembers`）。
- en: 'The `&` (ampersand) operator performs a union operation on two sets. The **user
    keyword** expands to the set that contains one member: the DN of the current client.
    So, if I perform a search, binding as `uid=matt,ou=users,dc=example,dc=com`, then
    the user set will contain one record:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`（与符号）运算符对两个集合执行并集操作。**user 关键字**展开为包含一个成员的集合：当前客户端的 DN。因此，如果我执行搜索，绑定为`uid=matt,ou=users,dc=example,dc=com`，那么用户集合将只包含一条记录：'
- en: '[PRE107]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'When the `&` operator is applied, it will generate the intersection of the
    two sets. That is, the resulting set will contain only members that are in both
    of the original sets. Since only the record for UID `matt` is in both, the resulting
    set will contain just the DN for `matt`:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 当`&`运算符被应用时，它将生成两个集合的交集。也就是说，结果集合只会包含同时出现在原始两个集合中的成员。由于只有 UID 为`matt`的记录同时存在于两个集合中，因此结果集合只会包含`matt`的
    DN：
- en: '[PRE108]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The resulting set is not empty so it is considered a match. The result of the
    set evaluation, then, is that the `uid=matt,ou=users,dc=example,dc=com` will be
    granted access based on the `set` specifier.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 结果集合非空，因此被视为匹配。集合评估的结果是，`uid=matt,ou=users,dc=example,dc=com`将基于`set`指定符获得访问权限。
- en: Note
  id: totrans-788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sets are case-sensitive, and always use the normalized DN form. What this means
    is that the DNs in sets should always be lowercase.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是区分大小写的，并且始终使用标准化的 DN 形式。这意味着集合中的 DN 应该始终是小写的。
- en: 'Consider a case though, when the user is not a member of the LDAP Admins group.
    If `uid=david,ou=users,dc=example,dc=com` binds, can he perform read and write
    operations? When the set specifier is run, the first of the two sets (group membership)
    will evaluate to the same thing it did above:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，考虑一个情况，假设用户不是 LDAP Admins 组的成员。如果`uid=david,ou=users,dc=example,dc=com`绑定，是否可以执行读写操作？当集合指定符运行时，第一个集合（组成员）将与上述相同：
- en: '[PRE109]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'But the user keyword will expand to this:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，user 关键字会展开为这个：
- en: '[PRE110]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'There are no items in the intersection of these two sets, so the resulting
    set, after the `&` operator is applied, is an empty set:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个集合的交集为空集，因此，在应用`&`运算符后，结果集合是一个空集：
- en: '[PRE111]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: There are no matches, so this `by` phrase fails to apply. The last line in our
    ACL (`by` `users` `none`) will then apply, and the `uid=david` will be given no
    access permissions.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 没有匹配项，因此这个`by`子句不会应用。我们 ACL 中的最后一行（`by` `users` `none`）将会应用，`uid=david`将不会获得任何访问权限。
- en: 'Let''s look at another example. We will use the set specifier to implement
    a rule where, when a client DN tries to access a record DN, it is given write
    access only if the two DNs are the same, or else it is given read access if they
    are in the same OU. Otherwise, the client DN is denied access to the record DN.
    Here''s the ACL:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看另一个例子。我们将使用集合指定符来实现一条规则，即当客户端 DN 尝试访问记录 DN 时，只有当两个 DN 相同，才赋予写访问权限；否则，如果它们在同一
    OU 中，则赋予读访问权限。否则，客户端 DN 将被拒绝访问记录 DN。以下是 ACL：
- en: '[PRE112]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The first line indicates that this rule will apply to the record `dc=example,dc=com`
    and everything under it.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行表明这条规则将应用于`dc=example,dc=com`的记录以及其下的所有内容。
- en: 'The second line takes the intersection of the sets generated by two keywords:
    `this` and `user`. The `this` keyword expands to the set containing the DN of
    the requested record. The `user` keyword, as we saw, expands to the DN of the
    client.'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行取自两个关键词生成的集合的交集：`this`和`user`。`this`关键词扩展为包含请求记录DN的集合。`user`关键词，如我们所见，扩展为客户端的DN。
- en: 'So, if the client `uid=david,ou=users,dc=example,dc=com` requests access to
    its own record, the resulting set operation will be as follows:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果客户端`uid=david,ou=users,dc=example,dc=com`请求访问其自己的记录，结果集合操作如下：
- en: '[PRE113]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Since both sets contain the same member, the resulting set (the intersection
    of the two) is `{` `uid=david,ou=users,dc=example,dc=com` `}`. The end set is
    not empty, so the user will be granted write access.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个集合包含相同的成员，结果集合（两者的交集）为`{` `uid=david,ou=users,dc=example,dc=com` `}`。最终集合非空，因此该用户将被授予写访问权限。
- en: Now let's look at the third line of the given ACL. This rule will return a non-empty
    set whenever the requested DN and the client DN both have the same value for the
    `ou` attribute. If `uid=david,ou=users,dc=example,dc=com` requests the record
    for `uid=matt,ou=users,dc=example,dc=com`, then SLAPD will check the values of
    their respective OU attributes.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下给定ACL的第三行。只要请求的DN和客户端的DN在`ou`属性上具有相同的值，这条规则就会返回一个非空集合。如果`uid=david,ou=users,dc=example,dc=com`请求`uid=matt,ou=users,dc=example,dc=com`的记录，SLAPD将检查它们各自的OU属性值。
- en: 'The set identified by `this/ou` will be expanded to contain the values of all
    of the OU attributes in the requested record (the record for `uid=matt,ou=users,dc=example,dc=com`).
    This set is:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '`this/ou`标识的集合将被扩展，包含请求记录中所有OU属性的值（`uid=matt,ou=users,dc=example,dc=com`的记录）。该集合为：'
- en: '[PRE114]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Note that in this case the value is not a DN, but a string. Sets can perform
    matching operations on strings as well as DNs.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，值不是DN，而是字符串。集合可以对字符串以及DN执行匹配操作。
- en: 'The set identified by `user/ou` will be expanded to contain the values of all
    of the OU attributes in the client''s record. The record for `uid=david,ou=users,dc=example,dc=com`
    contains one value for the `ou` attribute, and the resulting set will contain
    that one attribute value:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '`user/ou`标识的集合将被扩展，包含客户端记录中所有OU属性的值。`uid=david,ou=users,dc=example,dc=com`的记录包含一个`ou`属性值，结果集合将包含该一个属性值：'
- en: '[PRE115]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: SLAPD will compute the intersection of `{` `'Users'` `}` `&` `{` `'Users'` },
    which is `{` `'Users'` `}`. Since the set is not empty, `uid=david,ou=users,dc=example,dc=com`
    will be granted access to read the record of `uid=matt,ou=users,dc=example,dc=com`.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: SLAPD将计算`{` `'Users'` `}`与`{` `'Users'` `}`的交集，结果为`{` `'Users'` `}`。由于集合非空，`uid=david,ou=users,dc=example,dc=com`将被授予访问`uid=matt,ou=users,dc=example,dc=com`记录的权限。
- en: 'The `set` specifier provides one way of granting access to a record *only*
    in the case that a record contains a certain attribute. If we only want to grant
    write access to records with the title attribute, we can use the following rule:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`指定符提供了一种在记录包含特定属性时*仅*授予访问权限的方法。如果我们只想对具有title属性的记录授予写访问权限，可以使用以下规则：'
- en: '[PRE116]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: In this ACL, if the requested record has a single `title` attribute, then the
    result of the evaluation of the above rule will be a set containing one element.
    However, if the record attribute has no title attribute, then the resulting set
    will be empty, and write access will not be granted.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个ACL中，如果请求的记录具有一个`title`属性，那么上述规则的评估结果将是一个包含一个元素的集合。然而，如果记录没有title属性，那么结果集合将为空，写访问权限将不会被授予。
- en: 'In our directory the record of `uid=matt,ou=users,dc=example,dc=com` has the
    following title attribute:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的目录中，`uid=matt,ou=users,dc=example,dc=com`的记录有以下title属性：
- en: '[PRE117]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'But the record `uid=barbara,ou=users,dc=example,dc=com` does not have a title
    attribute at all. So if the record for `uid=matt` was requested, then the resulting
    set, based on the above ACL, would be:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 但`uid=barbara,ou=users,dc=example,dc=com`的记录根本没有title属性。因此，如果请求的是`uid=matt`的记录，基于上述ACL，结果集合将是：
- en: '[PRE118]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: So if an authenticated user attempted to access the record for `uid=matt`, SLAPD
    would grant access. In contrast, the set for `uid=barbara` would be `{}`, the
    empty set. So a user trying to access the record having `uid=barbara` would be
    denied access.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果一个经过认证的用户尝试访问`uid=matt`的记录，SLAPD将授予访问权限。相反，`uid=barbara`的集合将是`{}`，即空集合。因此，尝试访问`uid=barbara`记录的用户将被拒绝访问。
- en: 'Using a similar set specifier, we could grant access to a record depending
    not only on the existence of an attribute, but on its value too:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似的集合指定符，我们可以根据属性的存在性以及其值来授予对记录的访问权限：
- en: '[PRE119]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: According to the above rule, write access will be granted for anything in the
    Users OU only if the entry has an `objectclass` attribute with the value `person`.
    Note that in this case the square brackets are used to define a string literal.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述规则，只有当条目具有 `objectclass` 属性且其值为 `person` 时，才会授予对 Users OU 中任何内容的写访问权限。请注意，在这种情况下，方括号用于定义字符串文字。
- en: 'If a client were to access the record `uid=barbara,ou=users,dc=example,dc=com`,
    the first part of our `set` statement would evaluate to the following set:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端尝试访问记录 `uid=barbara,ou=users,dc=example,dc=com`，我们 `set` 语句的第一部分将计算出以下集合：
- en: '[PRE120]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Those are the three object classes for the `uid=barbara` record. The other
    part, `[person]`, would be expanded to this set:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 `uid=barbara` 记录的三个对象类。另一部分 `[person]` 将扩展为以下集合：
- en: '[PRE121]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: When the union is computed, the result would be the set `{'person'}` and so
    write access would be granted.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算联合时，结果将是集合 `{'person'}`，因此会授予写访问权限。
- en: 'These are just a few of the basic operations that can be done with the `set`
    specifier. Unfortunately, `set` is not documented in the `slapd.access` man page.
    However, there is a lengthy and informative article on using set in the OpenLDAP
    official FAQ-O-Matic: [http://www.openldap.org/faq/data/cache/1133.html](http://www.openldap.org/faq/data/cache/1133.html).'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是使用 `set` 指定符可以执行的一些基本操作。不幸的是，`set` 在 `slapd.access` 手册页中没有文档记录。然而，OpenLDAP
    官方 FAQ-O-Matic 上有一篇详细且内容丰富的文章介绍了如何使用 `set`：[http://www.openldap.org/faq/data/cache/1133.html](http://www.openldap.org/faq/data/cache/1133.html)。
- en: The control Field
  id: totrans-828
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制字段
- en: 'The last field in the `by` phrase is the control field. There are only three
    possible values for the control field: `stop`, `break`, and `continue`. If no
    control field is specified, `stop` is assumed. For example, `by` `*` `none` is
    the same as `by` `*` `none` `stop`.'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '`by` 短语中的最后一个字段是控制字段。控制字段只有三种可能的值：`stop`、`break` 和 `continue`。如果未指定控制字段，则默认为
    `stop`。例如，`by` `*` `none` 与 `by` `*` `none` `stop` 是相同的。'
- en: 'The first value, `stop`, indicates that if that particular by clause matches,
    no further checking of ACLs for matching should occur. Consider the following
    (admittedly contrived) case:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个值 `stop` 表示如果该特定的 `by` 条件匹配，则不应继续检查与之匹配的其他 ACL。考虑以下（虽然是人为构造的）情况：
- en: '[PRE122]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: If I bind as `uid=matt,ou=Users,dc=example,dc=com` and try to modify my `employeeNumber`,
    will I be allowed to? No, I will not.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我以 `uid=matt,ou=Users,dc=example,dc=com` 身份绑定并尝试修改我的 `employeeNumber`，我会被允许吗？不会，我不会被允许。
- en: 'The reason I will not be able to modify the record is because I will only have
    the permissions granted by the first `by` phrase: `by` `users` `=cd` (remember,
    `by` `users` `=cd` is the same as `by` `users=cd` `stop`). As soon as SLAPD sees
    that I match the first `by` phrase of the first ACL, it will stop testing ACLs.
    Thus it will never reach the rule that grants my DN `+r` access, nor will it reach
    the rule that grants all users `+w` to the `employeeNumber` attribute.'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法修改记录的原因是因为我只会拥有第一个 `by` 短语所授予的权限：`by` `users` `=cd`（记住，`by` `users` `=cd`
    与 `by` `users=cd` `stop` 是相同的）。一旦 SLAPD 看到我匹配第一个 ACL 的第一个 `by` 短语，它就会停止测试 ACL。因此，它永远不会执行授予我
    DN `+r` 访问权限的规则，也不会执行授予所有用户对 `employeeNumber` 属性 `+w` 权限的规则。
- en: This is an example of the `stop` control, which is used implicitly by all three
    rules.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `stop` 控制的一个例子，它被所有三个规则隐式使用。
- en: 'Now, if I wanted to make sure that after the first `by` phrase SLAPD continues
    to evaluate phrases within the ACL, I could re-write the ACLs using the `continue`
    control:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我想确保在第一个 `by` 短语之后，SLAPD 继续评估 ACL 内的短语，我可以使用 `continue` 控制重新编写 ACL：
- en: '[PRE123]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: After running the same test on these rules, the DN `uid=matt,ou=Users,dc=example,dc=com`
    would have the permissions `=cdr`.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 在对这些规则进行相同测试后，DN `uid=matt,ou=Users,dc=example,dc=com` 将拥有 `=cdr` 权限。
- en: The `continue` control instructs SLAPD to continue processing all of the `by`
    phrases in the *current* *ACL*. Once it is done evaluating that ACL though, it
    will not continue to look for matches in other ACLs.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 控制指示 SLAPD 继续处理 *当前* *ACL* 中的所有 `by` 短语。然而，一旦它完成了对该 ACL 的评估，它将不再继续查找其他
    ACL 中的匹配项。'
- en: In order to tell SLAPD to look at different rules for matches, we would have
    to use the `break` control. When SLAPD encounters an applicable clause that ends
    with a `break` control, it stops processing the current ACL but continues looking
    at other ACLs to see if they apply.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告诉SLAPD查看不同的规则来进行匹配，我们必须使用`break`控制。当SLAPD遇到以`break`控制结尾的适用子句时，它会停止处理当前的ACL，但会继续查看其他ACL，看看它们是否适用。
- en: 'Thus, to get write permissions with our ACL we would want the following ACLs:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了通过ACL获得写权限，我们希望使用以下ACL：
- en: '[PRE124]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Now what will happen when the user with UID `matt` attempts accesses an `employeeNumber`?
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当UID为`matt`的用户尝试访问`employeeNumber`时会发生什么呢？
- en: First, the `by` phrase of the first ACL will be evaluated, and `matt` will be
    granted `=cd`. Because of the `continue` control, SLAPD will then examine the
    second `by` clause, which will also match for the user `matt`. Thus, `matt` will
    have `=rcd` when the processing of the first ACL completes.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，第一条ACL的`by`短语将被评估，`matt`将被授予`=cd`权限。由于`continue`控制，SLAPD接着会检查第二个`by`子句，这个子句也会匹配到`matt`用户。因此，当第一条ACL处理完成时，`matt`将拥有`=rcd`权限。
- en: Due to the `break` control the second ACL will also be evaluated, and `matt`
    will be granted `+w` as well, bringing his final permissions up to `=wrcd`.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`break`控制，第二个ACL也会被评估，并且`matt`将被授予`+w`权限，因此他的最终权限将是`=wrcd`。
- en: Using the `continue` and `break` controls is one way to incrementally handle
    permissions. In complex configurations, judicious use of `continue` and `break`
    can make maintaining ACLs much easier, and can reduce the total number of ACLs.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`continue`和`break`控制语句是逐步处理权限的一种方法。在复杂的配置中，合理使用`continue`和`break`可以让维护ACL变得更加容易，并且减少ACL的总数。
- en: Getting More from Regular Expressions
  id: totrans-846
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从正则表达式中获取更多信息
- en: In the previous sections we have looked at using regular expressions in both
    the `access` `to` phrase and the `by` phrase. But we can use both in conjunction.
    We can store information about the matches identified in the `access` `to` phrase,
    and use that information later in the `by` phrases.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经看过了如何在`access` `to` 短语和`by` 短语中使用正则表达式。但我们也可以将它们结合使用。我们可以在`access`
    `to` 短语中存储匹配到的信息，然后在`by` 短语中使用这些信息。
- en: 'To temporarily store matching information in an `access` `to` phrase we can
    surround the regular expression with parentheses. Here''s an example:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 为了临时存储`access` `to`短语中的匹配信息，我们可以用括号将正则表达式包裹起来。以下是一个示例：
- en: '[PRE125]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This ACL grants a client the DN access to read a record DN only if both the
    client DN and the record DN are in the same part of the directory tree (that is,
    if both are in the same OU).
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ACL只会在客户端的DN和记录的DN位于同一个目录树部分（即它们位于同一个OU中）时，才授予客户端读取记录DN的权限。
- en: In the first line of the given ACL we used parentheses to capture the match
    from the regular expression `[^,]+`, which will be the value of the `ou=` component
    of the DN. Again, `[^,]+` says "match all charcters that are not '`,`'."
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的ACL的第一行中，我们使用括号捕获了正则表达式`[^,]+`的匹配结果，它将成为DN的`ou=`部分的值。再说一次，`[^,]+`的意思是“匹配所有不是`,`的字符”。
- en: 'In the second line we used the `dn.children` specifier but supplemented it
    with an extra keyword: `expand`. The `expand` keyword tells SLAPD to substitute
    matches from the `access` `to` clause into this phrase.'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行中，我们使用了`dn.children`指定符，但加上了一个额外的关键字：`expand`。`expand`关键字告诉SLAPD将`access`
    `to`子句中的匹配项替换到这个短语中。
- en: Because of the `expand` keyword, the variable `$1` is substituted with the value
    of the match in the first line. Everything captured between '`(`' and '`)`' in
    the regular expression will be stored in `$1`.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`expand`关键字，变量`$1`将被替换为第一行匹配的值。正则表达式中`(`和`)`之间捕获的所有内容将存储在`$1`中。
- en: Variable names are assigned in order. The first set of parenthesis in the regular
    `access` `to` phrase gets stored in `$1`. If a second set of parenthesis existed,
    the matching information inside of those would be stored in `$2` and so on for
    each additional set of parenthesis.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名称按顺序分配。正则`access` `to`短语中的第一组括号将存储在`$1`中。如果有第二组括号，里面的匹配信息将存储在`$2`中，以此类推，对于每一组括号都如此。
- en: 'For example, we might want an ACL like this:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能想要像这样的ACL：
- en: '[PRE126]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: This rule would grant a client DN access to read and write any entries subordinate
    to its own record but deny other uses the ability to even read those entries.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则将授予客户端DN读取和写入其自己记录下属条目的权限，但禁止其他用户读取这些条目。
- en: Note
  id: totrans-858
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Address books are sometimes implemented in OpenLDAP by storing a user''s addresses
    as subordinate entries to the user''s own entry in the directory. There is an
    example of this in the OpenLDAP FAQ-O-Matic: [http://www.openldap.org/faq/data/cache/1005.html](http://www.openldap.org/faq/data/cache/1005.html)'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 地址簿有时通过将用户的地址存储为用户条目下的从属条目来在 OpenLDAP 中实现。在 OpenLDAP FAQ-O-Matic 中有一个示例：[http://www.openldap.org/faq/data/cache/1005.html](http://www.openldap.org/faq/data/cache/1005.html)
- en: Notice that the first line stores two variables. The UID goes in `$1` and the
    OU goes in `$2`. These are expanded in the second line.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一行存储了两个变量。UID 存储在 `$1` 中，OU 存储在 `$2` 中。这些变量在第二行中被展开。
- en: 'It is also possible to use matches from the `access` `to` phrase in regular
    expressions in the `by` phrase:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在 `by` 短语中使用来自 `access` `to` 短语的匹配项，作为正则表达式的一部分：
- en: '[PRE127]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: In the first line only the results of the second regular expression are captured
    and stored in a variable. The second line also contains a regular expression,
    and it makes use of the `$1` variable to retrieve the value of the OU from the
    first line. Note that `dn.children,expand` was replaced with `dn.regex`. The `expand`
    keyword need not be added for regular expressions.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，仅捕获并存储第二个正则表达式的结果，并将其存储在变量中。第二行也包含一个正则表达式，并利用 `$1` 变量从第一行中获取 OU 的值。请注意，`dn.children,expand`
    已被 `dn.regex` 替代。正则表达式不需要添加 `expand` 关键字。
- en: The rule grants write access to a client DN for any user record that is in the
    same OU of that directory tree.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则授予客户端 DN 对目录树中同一 OU 下的任何用户记录的写入访问权限。
- en: We have looked at some simple, though useful, regular expressions in these ACLs.
    But much more complex regular expressions can be composed, making ACLs even more
    powerful. As you compose more advanced regular expressions you may find some other
    sources of information helpful. Along with the `slapd.access` man page, the POSIX
    extended regular expressions man page (`man` `regex`) may turn out to be useful
    as well.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在这些 ACL 中看了一些简单但有用的正则表达式。但还可以构建更复杂的正则表达式，使 ACL 更加强大。当你编写更高级的正则表达式时，你可能会发现一些其他的信息源很有帮助。除了
    `slapd.access` 手册页外，POSIX 扩展正则表达式手册页（`man` `regex`）也可能很有用。
- en: Debugging ACLs
  id: totrans-866
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试 ACL
- en: Debugging ACLs can be frustrating. They are complex, security sensitive, and
    require detailed testing. But there are three tools that make the debugging and
    testing process easier.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 调试 ACL 可能令人沮丧。它们复杂、安全敏感，并且需要详细的测试。但有三种工具可以使调试和测试过程变得更容易。
- en: The first is just the `ldapsearch` command-line client. It can be used to carefully
    craft filters designed to test the processing of ACLs. The `ldapcompare` tool
    also comes in handy when you need to test comparison operations.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个工具就是 `ldapsearch` 命令行客户端。它可以用于精心编写过滤器，专门用于测试 ACL 的处理。`ldapcompare` 工具在需要测试比较操作时也很有用。
- en: But it is also useful to make the most of LDAP's logging directives. The `trace`
    and `acl` debugging levels each provide detailed information about ACL processing.
    The `acl` level, for example, records each ACL evaluation. This can be very useful
    in determining what rules are run and when. We find the `trace` debugging level
    to be useful as well, as it provides information about how each evaluation was
    performed, including how regular expressions were expanded.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 但充分利用 LDAP 的日志指令也是很有帮助的。`trace` 和 `acl` 调试级别都提供有关 ACL 处理的详细信息。例如，`acl` 级别会记录每次
    ACL 评估。这对于确定哪些规则被执行以及何时执行非常有用。我们发现 `trace` 调试级别也很有用，因为它提供了每次评估是如何执行的的信息，包括正则表达式是如何展开的。
- en: Tip
  id: totrans-870
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Running SLAPD in the Foreground**'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '**在前台运行 SLAPD**'
- en: 'Sometimes it is easier to test ACLs by running SLAPD in the foreground, instead
    of as a daemon process, and printing debugging and logging information to standard
    out. For example, we can print ACL and trace debugging out this way: `slapd` `-d`
    `"acl,trace"`. Note that you will want to run this command as the appropriate
    user (such as `openldap`). To terminate the process use the *Ctrl*-*C* keyboard
    combination.'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 有时通过将 SLAPD 以前台模式运行，而不是作为守护进程运行，并将调试和日志信息打印到标准输出上来测试 ACL 会更容易。例如，我们可以通过这种方式打印
    ACL 和 trace 调试信息：`slapd` `-d` `"acl,trace"`。请注意，你需要以合适的用户身份（如 `openldap`）运行此命令。要终止该进程，可以使用
    *Ctrl*-*C* 键盘组合。
- en: Finally, the `slapacl` command line utility provides a detail-oriented tool
    for evaluating ACLs directly. Since it does not connect to the SLAPD server over
    the LDAP protocol it allows more direct testing of just the ACLs.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`slapacl`命令行工具提供了一个注重细节的工具，用于直接评估ACL。由于它不通过LDAP协议连接到SLAPD服务器，因此它允许直接测试ACL。
- en: 'For example, we can check whether or not a particular SASL user, `matt`, can
    access the record `cn=LDAP` `Admins,ou=Groups,dc=example,dc=com` and *read* the
    value of the `description` attribute:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以检查特定的SASL用户`matt`是否可以访问记录`cn=LDAP` `Admins,ou=Groups,dc=example,dc=com`并*读取*`description`属性的值：
- en: '[PRE128]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The `-U` `matt` param specifies the SASL user name. The `-b` `"cn=LDAP` `Admins,ou=Groups,`
    `dc=example,dc=com"` param indicates which record we want to test against, and
    the last field, `"description/read"` indicates the attribute and the access level.
    This will simply return `ALLOWED` if the ACLs allow read access, or `DENIED` otherwise.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '`-U` `matt` 参数指定了SASL用户名。`-b` `"cn=LDAP` `Admins,ou=Groups,` `dc=example,dc=com"`
    参数指示我们希望测试的记录，最后一个字段`"description/read"`指示属性和访问级别。如果ACL允许读取访问，它将返回`ALLOWED`，否则返回`DENIED`。'
- en: 'Likewise, we can test other LDAP operations. For example, we can test whether
    a user has permissions to `compare`:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以测试其他LDAP操作。例如，我们可以测试用户是否有权限进行`compare`操作：
- en: '[PRE129]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: In this example we have included the response. The first response line indicates
    how the SASL DN was resolved, and the second line indicates that compare access
    on `uid` was allowed.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们已经包含了响应内容。第一行响应显示了SASL DN是如何解析的，第二行显示了对`uid`的比较访问被允许。
- en: 'The `slapacl` program essentially runs its own SLAPD and as such, it can be
    set to print complete processing logs to the screen. For example, to turn on trace
    debugging we can just add the `-d` `trace` param to the given command:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '`slapacl`程序本质上运行自己的SLAPD，因此可以设置为将完整的处理日志打印到屏幕上。例如，要启用跟踪调试，我们只需将`-d` `trace`参数添加到给定命令中：'
- en: '[PRE130]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: As you can see`slapacl` provides detailed evaluation information in this case.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`slapacl`在这种情况下提供了详细的评估信息。
- en: Using the LDAP command-line clients, detailed logging, and the `slapacl` command,
    debugging and testing ACLs can be done effectively.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 使用LDAP命令行客户端、详细日志记录和`slapacl`命令，可以有效地调试和测试ACL。
- en: A Practical Example
  id: totrans-884
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个实际的例子
- en: In this part of the chapter, we have taken a low-level look at ACLs in OpenLDAP.
    We have covered many of the details of the ACL system. Now it is time to implement
    what we have covered so far to create a generic set of ACLs for our directory
    information tree.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们对OpenLDAP中的ACL进行了低级别的研究。我们已经覆盖了ACL系统的许多细节。现在是时候将我们所学的内容应用到实践中，为我们的目录信息树创建一组通用的ACL了。
- en: 'In Chapter 2 we created a bare-bones set of ACLs in our `slapd.conf` file.
    Here''s what we created then:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们在`slapd.conf`文件中创建了一组基础的ACL。以下是我们当时创建的内容：
- en: '[PRE131]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Now, we will create a new, more practical list of ACLs.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一组新的、更实际的ACL。
- en: 'The first thing we will do is move the ACLs out of `slapd.conf` and into a
    separate file: `acl.conf`. This will keep the lengthy list of ACLs separate from
    the rest of our configuration. To do this we will replace the ACLs above with
    an `include` directive:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是将ACL从`slapd.conf`中移出来，放到一个单独的文件`acl.conf`中。这将使得ACL的长列表与我们其余的配置分开。为此，我们将用`include`指令替换上面的ACL：
- en: '[PRE132]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: When SLAPD is started it will include the contents of `/etc/ldap/acl.conf` at
    the location where the `include` statement appears. Recall that ACLs are backend-specific.
    Each different database can have its own ACLs (and multiple databases can be defined
    in the same `slapd.conf` file). So it is important to put the `include` directive
    after the database `directive` in `slapd.conf`.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 当SLAPD启动时，它会在`include`语句出现的位置包含`/etc/ldap/acl.conf`的内容。请记住，ACL是与后端特定的。每个不同的数据库可以有自己的ACL（并且多个数据库可以在同一个`slapd.conf`文件中定义）。因此，将`include`指令放在`slapd.conf`文件中的数据库`directive`之后是很重要的。
- en: Now we will begin editing the `acl.conf` file. The rules that we will write
    will be simple, and designed for a directory where most of the directory users
    are allowed to view most of the information in the directory. A higher-security
    directory may have a far more complex list of ACLs.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将开始编辑`acl.conf`文件。我们将编写的规则将是简单的，适用于大多数目录用户都被允许查看目录中大多数信息的目录。一个更高安全性的目录可能会有一份更复杂的ACL列表。
- en: Since ACLs are evaluated in order from top to bottom we want to carefully craft
    our rules so that important restrictions are implemented right away.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ACL是按从上到下的顺序进行评估的，我们需要仔细制定规则，以确保重要的限制能够立即生效。
- en: 'If there are network-based access rules they should usually appear at the top
    of the ACL list so that they are evaluated first. For example, if we want to restrict
    access to the entire database if the host is not in our LAN, we would use the
    following rule:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在基于网络的访问规则，它们通常应该出现在ACL列表的顶部，以便首先评估。例如，如果我们希望限制当主机不在我们的局域网内时对整个数据库的访问，我们可以使用以下规则：
- en: '[PRE133]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: By this rule only access from the localhost (127.0.0.1) and from inside of our
    10.40.0.0 subnet will be allowed to access the directory. Since the `break` control
    is specified, later rules may modify the `none` permission, granting clients more
    permissions. All other connections will be closed immediately.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 根据此规则，只有来自本地主机（127.0.0.1）和我们10.40.0.0子网内部的访问将被允许访问目录。由于指定了`break`控制，后续规则可能会修改`none`权限，从而授予客户端更多权限。所有其他连接将立即关闭。
- en: 'Next, we want to grant members of the LDAP Admins group write access to everything
    in the `dc=example,dc=com` tree:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望授予LDAP管理员组成员对`dc=example,dc=com`树中所有内容的写访问权限：
- en: '[PRE134]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: This immediately grants write access to the members of the LDAP Admins group.
    For all other clients though, SLAPD will continue processing.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 这立即授予LDAP管理员组成员写访问权限。然而，对于所有其他客户端，SLAPD将继续处理。
- en: Note
  id: totrans-900
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: No ACLs need to be written for the directory manager, the DN specified in the
    `slapd.conf` directive `rootdn`. This DN always has full access to the directory
    information tree, and ACLs will have no effect on this user.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 目录管理器不需要编写ACL，`slapd.conf`指令`rootdn`中指定的DN始终具有对目录信息树的完全访问权限，ACL对该用户没有任何作用。
- en: Next, we want to make sure that the `userPassword` field is available to the
    anonymous user for authentication purposes. We also want to allow users to be
    able to modify their own passwords, but otherwise we want `userPassword` unavailable
    for reading and writing by others. Note that by the previous rule the LDAP Admins
    will also be able to modify passwords for users.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望确保`userPassword`字段对匿名用户可用，以便进行身份验证。我们还希望允许用户修改自己的密码，但除此之外，我们希望`userPassword`对其他人不可读写。请注意，根据前面的规则，LDAP管理员也能够修改用户的密码。
- en: '[PRE135]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: In some cases, other users may need `auth` access to the password as well, in
    which case you may need to add `by` `users` `auth` to the given list.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，其他用户可能也需要对密码进行`auth`访问，这时您可能需要将`by` `users` `auth`添加到给定的列表中。
- en: We also need to grant access to the `uid` attribute if we are using the `ldap://`
    URL form for SASL binding in the `authz-regexp` directive. This is because the
    filter in the LDAP URL is run as anonymous (see the discussion in the *Configuring*
    *SLAPD* *for* *SASL* *Support Subsection*).
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`authz-regexp`指令中使用`ldap://` URL形式进行SASL绑定，我们还需要授予`uid`属性的访问权限。这是因为LDAP
    URL中的过滤器是以匿名身份运行的（参见*为SASL支持配置SLAPD*小节的讨论）。
- en: 'Additionally, we don''t want to let users try to modify their own `uid`, since
    `uid` is used in the DN:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们不希望允许用户尝试修改他们自己的`uid`，因为`uid`在DN中被使用：
- en: '[PRE136]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Now Anonymous and all authenticated users will be able to access the `uid` attribute
    of any record in the directory to which they have access.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，匿名用户和所有经过身份验证的用户将能够访问他们有权限访问的目录中任何记录的`uid`属性。
- en: There are also a few other attributes we don't want users to be able to modify—even
    in their own records.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他属性，我们不希望用户能够修改——即使是在他们自己的记录中。
- en: 'We don''t want users to try to modify their OU attributes, since OU attributes
    are also used in DNs. We also don''t want them to be able to modify their `employeeNumber`
    or their `employeeType`:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望用户尝试修改他们的OU属性，因为OU属性也用于DN中。我们也不希望他们能够修改他们的`employeeNumber`或`employeeType`：
- en: '[PRE137]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'We have a special account, `uid=Authenticate,ou=System,dc=example,dc=com`,
    which will be used on occasion to help with bind requests. This user should not
    have access to anything else other than what we specified:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个特殊账户`uid=Authenticate,ou=System,dc=example,dc=com`，该账户偶尔用于帮助进行绑定请求。此用户不应有权访问除了我们指定的内容之外的任何其他内容：
- en: '[PRE138]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Again, the last line instructs SLAPD to continue processing ACLs for users who
    aren't having the authentication account. This line will also stop the anonymous
    user from browsing the rest of the tree since the implicit rule at the end, `by`
    `*` `none`, will catch the anonymous user.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，最后一行指示SLAPD继续处理没有认证账户的用户的ACL。这一行还将阻止匿名用户浏览树中的其他部分，因为末尾的隐式规则 `by` `*` `none`
    会拦截匿名用户。
- en: Note
  id: totrans-915
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `uid=Authenitcate` user was already granted, in an earlier rule, access
    to the `uid` attribute, which is the attribute that this account will use to search
    for user information needed to bind.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '`uid=Authenticate` 用户在之前的规则中已被授权访问 `uid` 属性，这个属性是该账户用于查找绑定所需的用户信息的。'
- en: 'Let''s say that we don''t want regular users (DNs in the Users OU) to be able
    to access records in the System OU of our directory (which is typically used for
    system accounts). We can implement this with the following rule:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们不希望普通用户（位于Users OU中的DNs）能够访问目录中的System OU记录（通常用于系统账户）。我们可以通过以下规则实现这一点：
- en: '[PRE139]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: This denies access to users in the Users OU, but allows other users (like System
    accounts) access to these records.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 这拒绝了用户OU中的用户访问权限，但允许其他用户（如系统账户）访问这些记录。
- en: 'We also want to give every user the ability to read and write records below
    its own, but restrict others from accessing those records. This makes it possible
    for users to store their own information (like address books) inside of the directory:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望给予每个用户读取和写入自己记录的权限，但限制其他人访问这些记录。这使得用户可以在目录中存储自己的信息（如通讯录）：
- en: '[PRE140]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Finally, the last rule we want is a default rule. This rule should answer the
    question, "What do we want to happen when no other rules are matched?" We want
    users to be able to modify their own records and see the records of others:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要的最后一条规则是默认规则。这个规则应该回答“当没有其他规则匹配时，我们希望发生什么？”的问题。我们希望用户能够修改自己的记录并查看他人的记录：
- en: '[PRE141]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Now our list of ACLs is complete. Altogether, this is what they look like:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的ACL列表已完整。总体来看，它们是这样的：
- en: '[PRE142]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: While they certainly won't meet all needs, these rules provide a good starting
    point for balancing security and usability of the directory. Furthermore, they
    set the stage for some of the things we will be doing later in this book.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些规则肯定无法满足所有需求，但它们为平衡目录的安全性和可用性提供了一个良好的起点。此外，它们为本书后续内容的操作奠定了基础。
- en: In later chapters of this book, the mentioned ACLs will be revisited and fine-tuned
    to allow additional features, like directory replication.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续章节中，我们将再次讨论并微调这些ACLs，以支持更多功能，如目录复制。
- en: Summary
  id: totrans-928
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The focus of this chapter has been OpenLDAP security, and we have covered a
    lot of ground. We began with connection-level security, where we configured SSL/TLS
    encryption for our directory server. We used StartTLS over the standard LDAP port,
    and also configured the older (LDAP v2) LDAPS protocol on port 636\. Next, we
    looked at the process of authenticating to the LDAP. In that part we covered both
    simple binding and SASL binding. Finally, we took a detailed look at access control
    lists (ACLs), finishing the chapter with a basic set of ACLs.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是OpenLDAP的安全性，我们已经覆盖了很多内容。我们从连接级别的安全性开始，配置了我们的目录服务器的SSL/TLS加密。我们使用了标准LDAP端口上的StartTLS，并且在端口636上配置了较旧的（LDAP
    v2）LDAPS协议。接着，我们探讨了LDAP身份验证的过程。在这一部分，我们讨论了简单绑定和SASL绑定。最后，我们详细审视了访问控制列表（ACLs），并以一组基本的ACLs结束了本章。
- en: In the next chapter we will look at advanced configuration of OpenLDAP's SLAPD
    server. We will configure our server to host multiple backend databases and we
    will use directory overlays to add powerful additional features to our SLAPD server.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨OpenLDAP的SLAPD服务器的高级配置。我们将配置服务器以托管多个后端数据库，并通过目录覆盖来为我们的SLAPD服务器添加强大的附加功能。
