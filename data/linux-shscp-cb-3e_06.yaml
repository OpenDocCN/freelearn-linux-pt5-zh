- en: Repository Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库管理
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下操作：
- en: Creating a new git repository
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的 git 仓库
- en: Cloning a remote git repository
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆一个远程 git 仓库
- en: Adding and committing changes with git
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 git 添加并提交更改
- en: Creating and merging branches with git
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 git 创建和合并分支
- en: Sharing your work
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分享你的工作
- en: Pushing a branch to a server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分支推送到服务器
- en: Retrieving the latest sources for the current branch
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前分支的最新源代码
- en: Checking the status of a git repository
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 git 仓库的状态
- en: Viewing git history
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看 git 历史
- en: Finding bugs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找 bugs
- en: Committing message ethics
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交信息的道德规范
- en: Using fossil
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 fossil
- en: Creating a new fossil repository
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的 fossil 仓库
- en: Cloning a remote fossil repository
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆一个远程 fossil 仓库
- en: Opening a fossil project
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个 fossil 项目
- en: Adding and Committing Changes with Fossil
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Fossil 添加并提交更改
- en: Using branches and forks with fossil
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 fossil 的分支和分叉
- en: Sharing your work with fossil
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 fossil 分享你的工作
- en: Updating your local fossil repository
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新本地 fossil 仓库
- en: Checking the status of a fossil repository
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 fossil 仓库的状态
- en: Viewing fossil history
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看 fossil 历史
- en: Introduction
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The more time you spend developing applications the more you come to appreciate
    software that tracks your revision history. A revision control system lets you
    create a sandbox for new approaches to problems, maintain multiple branches of
    released code, and provide a development history in the event of intellectual
    property disputes. Linux and Unix support many source code control systems ranging
    from the early and primitive SCCS and RCS to concurrent systems such as **CVS**
    and **SVN** and the modern distributed development systems such as **GIT** and
    **FOSSIL**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你花在开发应用程序上的时间越多，就越能理解那些能够追踪你版本历史的软件。版本控制系统可以让你为新的问题解决方法创建一个沙盒，维护多个发布代码的分支，并在知识产权争议发生时提供开发历史。Linux
    和 Unix 支持多种源代码控制系统，从早期的、原始的 SCCS 和 RCS，到并发系统如 **CVS** 和 **SVN**，以及现代的分布式开发系统如
    **GIT** 和 **FOSSIL**。
- en: The big advantage of Git and Fossil over older systems such as CVS and SVN is
    that a developer can use them without being connected to a network. Older systems
    such as CVS and RCS worked fine when you were at the office, but you could not
    check the new code or examine the old code while working remotely.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Git 和 Fossil 相对于早期的系统如 CVS 和 SVN 的一个重大优势是，开发者可以在不连接到网络的情况下使用它们。像 CVS 和 RCS 这样的旧系统在你在办公室时工作得很好，但在远程工作时你无法检查新代码或查看旧代码。
- en: Git and Fossil are two different revision control systems with some similarities
    and some differences. Both support the distributed development model of revision
    control. Git provides source code control and has a number of add-on applications
    for more information while Fossil is a single executable that provides revision
    control, trouble tickets, a Wiki, web pages and technical notes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Git 和 Fossil 是两种不同的版本控制系统，它们既有相似之处，也有不同之处。两者都支持分布式开发模型的版本控制。Git 提供源代码控制，并且有多个附加应用程序提供更多信息，而
    Fossil 是一个单一的可执行文件，提供版本控制、故障单、Wiki、网页和技术笔记。
- en: Git is used for the Linux kernel development and has been adopted by many open
    source developers. Fossil was designed for the SQLite development team and is
    also widely used in both the open source and closed source communities.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Git 被用于 Linux 内核开发，并且已被许多开源开发者采用。Fossil 是为 SQLite 开发团队设计的，也广泛应用于开源和闭源社区。
- en: Git is included with most Linux distributions. If it's not available on your
    system, you can install it with either yum (Redhat or SuSE) or apt-get (Debian
    or Ubuntu).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Git 已包含在大多数 Linux 发行版中。如果你的系统中没有，您可以通过 yum（Redhat 或 SuSE）或 apt-get（Debian 或
    Ubuntu）安装它。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Fossil is available as source or executable from [http://www.fossil-scm.org](http://www.fossil-scm.org).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Fossil 可从 [http://www.fossil-scm.org](http://www.fossil-scm.org) 作为源代码或可执行文件下载。
- en: '**Using Git**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 Git**'
- en: The git system uses the `git` command with many subcommands to perform individual
    actions. We'll discuss git clone, git commit, git branch, and others.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: git 系统使用 `git` 命令和多个子命令来执行单个操作。我们将讨论 git clone、git commit、git branch 等命令。
- en: To use git you need a code repository. You can either create one yourself (for
    your projects) or clone a remote repository.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 git，你需要一个代码仓库。你可以自己创建一个（用于你的项目），或者克隆一个远程仓库。
- en: Creating a new git repository
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的 git 仓库
- en: If you are working on your own project, you will want to create your own repository.
    You can create the repository on your local system, or on a remote site such as
    GitHub.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在自己的项目中工作，你将需要创建自己的仓库。你可以在本地系统上创建仓库，或者在远程站点上创建，例如 GitHub。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: All projects in git need a master folder that holds the rest of the project
    files.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 git 项目都需要一个主文件夹来存放其他项目文件。
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The `git init` command creates the `.git` subfolder within your current working
    directory and initializes the files that configure `git`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`git init` 命令在你当前的工作目录中创建 `.git` 子文件夹，并初始化配置 `git` 的文件。'
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `git init` command initializes a `git` repository for local use. If you
    want to allow remote users access this repository, you need to enable that with
    the `update-server-info` command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`git init` 命令为本地使用初始化一个 `git` 仓库。如果你希望允许远程用户访问这个仓库，你需要使用 `update-server-info`
    命令来启用它：'
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Cloning a remote git repository
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆一个远程 git 仓库
- en: If you intend to access someone else's project, either to contribute new code
    or just to use the project, you'll need to clone the code to your system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算访问他人的项目，无论是为了贡献新代码还是仅仅使用该项目，你都需要将代码克隆到你的系统中。
- en: You need to be online to clone a repository. Once you've copied the files to
    your system, you can commit new code, backtrack to older revisions, and so on.
    You can't send any new code changes upstream to the site you cloned from until
    you are online again.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆仓库时你需要保持在线。将文件复制到你的系统后，你可以提交新代码、回退到旧版本等等。你不能将任何新代码变更推送到你克隆的站点，直到你再次上线。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The `git clone` command copies files from the remote site to your local system.
    The remote site might be an anonymous repository such as GitHub, or a system where
    you need to log in with an account name and perhaps password.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`git clone` 命令将文件从远程站点复制到你的本地系统。远程站点可能是一个匿名仓库，例如 GitHub，或者是一个你需要使用帐户名和可能的密码进行登录的系统。'
- en: 'Clone from a known remote site such as GitHub:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个已知的远程站点克隆，例如 GitHub：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Clone from a login/password protected site (perhaps your own server):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从需要登录/密码保护的站点克隆（可能是你自己的服务器）：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Adding and committing changes with git
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 git 添加和提交更改
- en: With distributed version control systems such as git, you do most of your work
    with your local copy of the repository. You can add new code, change code, test,
    revise, and finally commit the fully tested code. This encourages frequent small
    commits on your local repository and one large commit when the code is stable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分布式版本控制系统，如 git，你大部分工作都是在本地复制的仓库中进行的。你可以添加新代码、修改代码、测试、修改，最后提交完全测试的代码。这鼓励你在本地仓库中进行频繁的小提交，代码稳定时再做一次大的提交。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The `git add` command adds a change in your working code to the staging area.
    It does not change the repository, it just marks this change as one to be included
    with the next commit:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`git add` 命令将你工作区的更改添加到暂存区。它不会改变仓库，只是将这个更改标记为下次提交时包含的内容：'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Doing a `git add` after every edit session is a good policy if you want to be
    certain you don't accidently leave out a change when you commit your changes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每次编辑会话后执行 `git add` 是一个好习惯，如果你希望确保不会在提交时遗漏任何更改。
- en: 'You can also add new files to your repository with the git add command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 git add 命令将新文件添加到仓库中：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, you can add multiple files:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以添加多个文件：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `git commit` command commits the changes to the repository:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`git commit` 命令将更改提交到仓库：'
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `git commit` command will open the editor defined in your **EDITOR** shell
    variable and pre-populate like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`git commit` 命令将打开你在 **EDITOR** shell 变量中定义的编辑器，并像这样预填充：'
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After you enter a comment your changes will be saved in your local copy of the
    repository.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入注释后，你的更改将保存在本地仓库的副本中。
- en: This does not push your changes to the main repository (perhaps `github`), but
    other developers can **pull** the new code from your repository if they have an
    account on your system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会将你的更改推送到主仓库（可能是 `github`），但其他开发者如果在你的系统上有账户，还是可以从你的仓库中 **拉取** 新的代码。
- en: 'You can shorten the add/commit events with the `-a` and `-m` arguments to commit:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `-a` 和 `-m` 参数来简化 add/commit 操作：
- en: '`-a`: This adds the new code before committing'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-a`：在提交前添加新的代码'
- en: '`-m`: This defines a message without going into the editor'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-m`：这是在不进入编辑器的情况下定义消息'
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating and merging branches with git
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 git 创建和合并分支
- en: If you are maintaining an application you may need to return to an earlier branch
    to test. For instance, the bug you're fixing may have been around, but unreported,
    for a long time. You'll want to find when the bug was introduced to track down
    the code that introduced it. (Refer to `git bisect` in the *Finding bugs* recipe
    in this chapter.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在维护一个应用程序，你可能需要返回到早期的分支进行测试。例如，你正在修复的bug可能已经存在，但没有被报告过很长时间。你会想要找出这个bug是何时引入的，以追踪导致问题的代码。（请参阅本章节中的*查找bug*食谱中的`git
    bisect`命令。）
- en: When you add new features, you should create a new branch to identify your changes.
    The project maintainer can then merge the new branch into the master branch after
    the new code is tested and validated. You can change and create new branches with
    the git's `checkout` subcommand.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当你添加新功能时，你应该创建一个新分支来标识你的更改。项目维护者可以在新代码经过测试和验证后，将新分支合并到主分支中。你可以使用git的`checkout`子命令来改变和创建新分支。
- en: Getting ready...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中...
- en: Use `git init` or `git clone` to create the project on your system.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`git init`或`git clone`来在你的系统中创建项目。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To change to a previously defined branch:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要切换到之前定义的分支：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The checkout subcommand examines the `.git` folder on your system and restores
    the snapshot associated with the desired branch.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: checkout子命令会检查系统上的`.git`文件夹，并恢复与所需分支关联的快照。
- en: Note that you cannot change to an existing branch if you have uncommitted changes
    in your current workspace.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你当前工作区中有未提交的更改，你无法切换到现有的分支。
- en: 'You can create a new branch when you have uncommitted changes in the current
    workspaces. To create a new branch, use git checkout''s `-b` option:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前工作区有未提交的更改时，你可以创建一个新分支。要创建新分支，可以使用`git checkout`的`-b`选项：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This defines your current working branch to be `MyBranchName`. It sets a pointer
    to match `MyBranchName` to the previous branch. As you add and commit changes,
    the pointer will diverge further from the initial branch.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将定义你的当前工作分支为`MyBranchName`。它设置一个指针，将`MyBranchName`与之前的分支匹配。随着你添加和提交更改，指针会进一步偏离初始分支。
- en: When you've tested the code in your new branch, you can merge the changes back
    into the branch you started from.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在新的分支中测试过代码后，可以将更改合并回你最初开始的分支。
- en: There's more...
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can view the branches with the `git branch` command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`git branch`命令查看分支：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The current branch is highlighted with an asterisk (`*`).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当前分支会用星号（`*`）标记。
- en: Merging branches
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并分支
- en: After you've edited, added, tested, and committed, you'll want to merge your
    changes back into the initial branch.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在你编辑、添加、测试并提交之后，你会想要将你的更改合并回初始分支。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'After you''ve created a new branch and added and committed your changes, change
    back to the original branch and use the `git merge` command to merge the changes
    in your new branch:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建了新分支并添加并提交了更改后，切换回原始分支，使用`git merge`命令将新分支中的更改合并：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The first `git checkout` command retrieves the snapshot for the starting branch.
    The second `git checkout` command marks your current working code as also being
    a new branch.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`git checkout`命令会检索起始分支的快照。第二个`git checkout`命令将你的当前工作代码标记为一个新的分支。
- en: The `git commit` command (or commands) move the snapshot pointer for the new
    branch further and further away from the original branch. The third `git checkout`
    command restores your code to the initial state before you made your edits and
    commits.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`git commit`命令（或命令集）将新分支的快照指针逐渐移离原始分支。第三个`git checkout`命令会将你的代码恢复到你进行编辑和提交之前的初始状态。'
- en: The `git merge` command moves the snapshot pointer for the initial branch to
    the snapshot of the branch you are merging.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`git merge`命令会将初始分支的快照指针移动到你正在合并的分支的快照。'
- en: There's more...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'After you merge a branch, you may not need it any longer. The `-d` option will
    delete the branch:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 合并一个分支后，你可能不再需要它。`-d`选项会删除该分支：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Sharing your work
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享你的工作
- en: Git lets you work without connecting to the Internet. Eventually, you'll want
    to share your work.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Git 允许你在没有连接互联网的情况下工作。最终，你会希望共享你的工作。
- en: There are two ways to do this, creating a patch or pushing your new code to
    the master repository.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有两种方法来实现：创建补丁或将你新的代码推送到主代码库。
- en: '**Making a patch...**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**制作补丁...**'
- en: A patch file is a description of the changes that have been committed. Another
    developer can apply your patch files to their code to use your new code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁文件是已提交更改的描述。其他开发人员可以将你的补丁文件应用到他们的代码中，以使用你的新代码。
- en: The format-patch command will collect your changes and create one or more patch
    files. The patch files will be named with a number, a description and `.patch`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`format-patch`命令将收集你的更改并创建一个或多个补丁文件。补丁文件将以数字、描述和`.patch`命名。'
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: The format-patch command requires an identifier to tell Git what the first patch
    should be. Git will create as many patch files as it needs to change code from
    what it was then to what it should be.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`format-patch`命令需要一个标识符来告诉Git第一个补丁应该是什么。Git会创建需要的补丁文件，直到它把代码从原始状态更改为目标状态。'
- en: There are several ways to identify the starting snapshot. One common use for
    a set of patches is to submit the changes you've made to a given branch to the
    package maintainer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以识别起始快照。一组补丁常见的用途是将你对特定分支所做的更改提交给包维护者。
- en: For example, suppose you've created a new branch off the master for a new feature.
    When you've completed your testing, you may send a set of patch files to the project
    maintainer so they can validate your work and merge the new feature into the project.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你为一个新功能从master分支创建了一个新分支。当你完成测试后，可以将一组补丁文件发送给项目维护者，以便他们验证你的工作并将新功能合并到项目中。
- en: 'The `format-patch` sub-command with the name of a parent branch will generate
    the patch file to create your current branch:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 带有父分支名称的`format-patch`子命令将生成用于创建当前分支的补丁文件：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Another common identifier is a git snapshot **SHA1**. Each git snapshot is identified
    by an SHA1 string.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的标识符是git快照**SHA1**。每个git快照都通过一个SHA1字符串来标识。
- en: 'You can view a log of all the commits in your repository with the `git log`
    command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`git log`命令查看仓库中所有提交的日志：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `git format-patch` command with an SHA1 identifier looks like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 带有SHA1标识符的`git format-patch`命令如下所示：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can use a unique leading segment of the SHA1 identifier or the full, long
    string:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用SHA1标识符的唯一前段或完整的长字符串：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can also identify a snapshot by its distance from your current location
    with a `-#` option.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过其与当前位置的距离来识别快照，使用`-#`选项。
- en: 'This command will make a patch file for the most recent change to the master
    branch:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将为master分支的最新更改创建补丁文件：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This command will make a patch file for the two most recent changes to the
    `bleedingEdge` branch:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将为`bleedingEdge`分支的最近两次更改创建补丁文件：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Applying a patch**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用补丁**'
- en: The `git apply` command applies a patch to your working code set. You'll have
    to check out the appropriate snapshot before running this command.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`git apply`命令将补丁应用到你的工作代码集。在执行此命令之前，你必须签出相应的快照。'
- en: You can test that the patch is valid with the `--check` option.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`--check`选项测试补丁是否有效。
- en: 'If your environment is correct for this patch, there will be no return. If
    you don''t have the correct branch checked out, the patch `-check` command will
    generate an error condition:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的环境适用于此补丁，将不会返回任何信息。如果你没有签出正确的分支，补丁`-check`命令将生成错误条件：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When the `--check` option does not generate an error message, use the `git
    apply` command to apply the patch:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当`--check`选项没有生成错误信息时，使用`git apply`命令应用补丁：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Pushing a branch to a server
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将分支推送到服务器
- en: Eventually, you'll want to share your new code with everyone, not just send
    patches to individuals.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你会希望与所有人分享你的新代码，而不仅仅是将补丁发送给个别人员。
- en: The `git push` command will push a branch to the master.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`git push`命令将分支推送到master。'
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'If you have a unique branch, it can always be pushed to the master repository:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个唯一的分支，它可以始终推送到master仓库：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you''ve modified an existing branch, you may receive an error message as
    follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你修改了现有的分支，你可能会收到如下错误信息：
- en: '`remote: error`: Refusing to update checked out branch: `refs/heads/master`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remote: error`: 拒绝更新已签出的分支：`refs/heads/master`'
- en: '`remote: error`: By default, updating the current branch in a non-bare repository'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remote: error`: 默认情况下，在非裸仓库中更新当前分支'
- en: 'In this case, you need to push your changes to a new branch on the remote site:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你需要将你的更改推送到远程站点的一个新分支：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You''ll also need to alert the package maintainer to merge this branch into
    the master:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要通知包维护者将此分支合并到master分支中：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Retrieving the latest sources for the current branch. If there are multiple
    developers on a project, you'll need to synchronize with the remote repository
    occasionally to retrieve data that's been pushed by other developers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 获取当前分支的最新源代码。如果项目有多个开发者，你需要定期与远程仓库同步，获取其他开发者推送的数据。
- en: The `get fetch` and `git pull` commands will download data from the remote site
    to your local repository.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`git fetch` 和 `git pull` 命令会从远程站点下载数据到你的本地仓库。'
- en: Update your repository without changing the working code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 更新你的仓库而不更改工作代码。
- en: The `git fetch` and `git pull` command will download new code but not modify
    your working code set.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`git fetch` 和 `git pull` 命令会下载新代码，但不会修改你当前的工作代码集。'
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The site you cloned your repository from is named origin:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆你仓库的站点被命名为 origin：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To fetch from another developer''s repository, use the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要从其他开发者的仓库获取数据，使用以下命令：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Update your repository and the working code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 更新你的仓库和工作代码。
- en: 'The `git pull` command performs a fetch and then merges the changes into your
    current code. This will fail if there are conflicts you need to resolve:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`git pull` 命令执行获取操作并将更改合并到当前代码中。如果存在冲突需要解决，这个操作会失败：'
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Checking the status of a git repository
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查 git 仓库的状态
- en: After a concentrated development and debugging session you are likely to forget
    all the changes you've made.  The `>git status` command will remind you.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行集中的开发和调试后，你很可能会忘记所有的更改。`>git status` 命令会提醒你。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'The `git status` command reports the current status of your project. It will
    tell you what branch you are on, whether you have uncommitted changes and whether
    you are out of sync with the origin repository:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`git status` 命令报告当前项目的状态。它会告诉你所在的分支，是否有未提交的更改，以及你是否与远程仓库不同步：'
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The previous recipe shows `git status` output when a change has been added and
    committed and one file was modified but not yet committed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例显示了在添加并提交更改后，`git status` 输出的内容，并且有一个文件已被修改但尚未提交。
- en: 'This line indicates that there has been a commit that hasn''t been pushed:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这行表示有一个提交尚未被推送：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Lines in this format report on files that have been modified, but not yet committed:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式的行报告了已经修改但尚未提交的文件：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the identity used for this commit is wrong, you can fix it with the following
    command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用于此提交的身份信息错误，你可以使用以下命令来修复：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Viewing git history
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看 git 历史
- en: Before you start working on a project, you should review what's been done. You
    may need to review what's been done recently to keep up with other developer's
    work.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始一个项目之前，你应该回顾一下已完成的工作。你可能需要回顾最近的工作，以便跟上其他开发者的进度。
- en: The `git log` command generates a report to help you keep up with a project's
    changes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`git log` 命令生成一份报告，帮助你跟踪项目的更改。'
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'The `git log` command generates a report of SHA1 IDs, the author who committed
    that snapshot, the date it was committed, and the log message:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`git log` 命令生成一个包含 SHA1 ID、提交该快照的作者、提交日期和日志信息的报告：'
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Finding bugs
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找 bug
- en: Even the best testing groups let bugs slip out into the field. When that happens,
    it's up to the developers to figure out what the bug is and how to fix it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最好的测试小组也难免会让 bug 滑出去。当这种情况发生时，开发者需要弄清楚是什么问题以及如何修复它。
- en: Git has tools to help.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Git 提供了工具来帮助你。
- en: Nobody deliberately creates bugs, so the problem is probably caused by fixing
    an old bug or adding a new feature.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人故意制造bug，所以问题可能是由修复旧bug或添加新特性导致的。
- en: If you can isolate the code that causes the issue, use the `git blame` command
    to find who committed the code that caused the problem and what the commit SHA
    code was.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够隔离出引发问题的代码，可以使用 `git blame` 命令找到是谁提交了这段代码，以及提交的 SHA 编码是什么。
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'The `git blame` command returns a list of commit hash codes, author, date,
    and the first line of the commit message:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`git blame` 命令返回一个包含提交哈希码、作者、日期和提交消息第一行的列表：'
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There's more...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多……
- en: If you have a test that indicates the problem, but don't know the line of code
    that's at issue, you can use the `git bisect` command to find the commit that
    introduced the problem.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个测试表明问题所在，但不清楚是哪行代码出了问题，你可以使用 `git bisect` 命令来找到引入问题的提交。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: The `git bisect` command requires two identifiers, one for the last known good
    code and one for the bad release. The bisect command will identify a revision
    midway between the good and bad for you to test.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`git bisect` 命令需要两个标识符，一个是最后已知的良好代码，另一个是已知的坏版本。bisect 命令会为您识别一个位于好版本和坏版本之间的修订版本，供您进行测试。'
- en: After you test the code, you reset the good or bad pointer. If the test worked,
    reset the good pointer, if the test failed, reset the bad pointer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完代码后，您可以重置好版本或坏版本的指针。如果测试成功，重置好版本指针；如果测试失败，重置坏版本指针。
- en: 'Git will then check out a new snapshot midway between the new good and bad
    locations:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Git 会在新的好版本和坏版本之间检查一个新的快照：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `git bisect` command identifies the version of your code midway between
    a known good and known bad version. You can now build and test that version. After
    testing, rerun `git bisect` to declare that branch as good or bad. After the branch
    is declared, `git bisect` will identify a new version, halfway between the new
    good and bad markers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`git bisect` 命令可以在已知良好版本和已知坏版本之间识别代码的版本。现在，您可以构建并测试该版本。测试后，重新运行 `git bisect`
    以声明该分支是好版本还是坏版本。分支声明后，`git bisect` 会识别一个新版本，该版本位于新的好坏标记之间的中间位置。'
- en: Tagging snapshots
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记快照
- en: Git supports tagging specific snapshots with a mnemonic string and an additional
    message. You can use the tags to make the development tree clearer with information
    such as *Merged in new memory management* or to mark specific snapshots along
    a branch. For example, you can use a tag to mark **release-1.0** and **release-1.1**
    along the **release-1** branch.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Git 支持使用助记符字符串和附加消息标记特定快照。您可以使用标签使开发树更加清晰，提供如 *已合并新内存管理* 之类的信息，或者标记沿分支的特定快照。例如，您可以使用标签标记
    **release-1.0** 和 **release-1.1**，这两者位于 **release-1** 分支上。
- en: Git supports both lightweight tags (just tagging a snapshot) and tags with associated
    annotation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Git 支持轻量级标签（仅标记快照）和带注释的标签。
- en: 'Git tags are local only. `git push` will not push your tags by default. To
    send tags to the origin repository, you must include the -tags option:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签是仅限本地的。`git push` 默认不会推送标签。要将标签发送到远程仓库，必须包含 -tags 选项：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `git tag` command has options to add, delete, and list tags.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`git tag` 命令有添加、删除和列出标签的选项。'
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The `git tag` command with no argument will list the visible tags:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`git tag` 命令没有参数时，会列出所有可见标签：'
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can create a tag on your current checkout by adding a tag name:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加标签名在当前检出的版本上创建标签：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can add a tag to a previous commit by appending an SHA-1 identifier to
    the git tag command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 git tag 命令后添加 SHA-1 标识符，向之前的提交添加标签：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `-a` option will attach annotation to a tag:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`-a` 选项会将注释附加到标签：'
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can define the message on the command line with the `-m` option:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在命令行上使用 `-m` 选项来定义消息：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The message will be displayed when you use the `git show` command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 `git show` 命令时，将显示该消息：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `-d` option will delete a tag:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d` 选项会删除标签：'
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Committing message ethics
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交信息伦理
- en: The commit message is free form text. It can be whatever you think is useful.
    However, there are comment conventions used in the Git community.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 提交信息是自由格式的文本。它可以是任何您认为有用的内容。然而，Git 社区中有一些注释规范。
- en: How to do it...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Use 72 characters or less on each line. Use blank lines to separate paragraphs.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每行使用 72 个字符或更少。使用空行分隔段落。
- en: The first line should be 50 characters or less and summarize why this commit
    was made. It should be specific enough that someone reading just this line will
    understand what happened.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行应为 50 个字符或更少，并总结为什么做出此提交。它应该足够具体，让阅读此行的人了解发生了什么。
- en: 'Don''t write `Fix bug` or even `Fix bugzilla bug #1234`, write `Remove silly
    messages that appear each April 1`.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '不要写 `Fix bug` 或者甚至是 `Fix bugzilla bug #1234`，而是写 `删除每年4月1日出现的愚蠢消息`。'
- en: The following paragraphs describe details that will be important to someone
    following up on your work. Mention any global state variables your code uses,
    side effects, and so on. If there is a description of the problem you fixed, include
    the URL for the bug report or feature request.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下段落描述了对跟踪您工作的人很重要的细节。提及您的代码使用的任何全局状态变量、副作用等。如果您修复了某个问题，包含该问题报告或功能请求的 URL。
- en: Using fossil
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 fossil
- en: The fossil application is another distributed version control system. Like Git,
    it maintains a record of changes regardless of whether the developer has access
    to the master repository site. Unlike Git, fossil supports an auto-sync mode that
    will automatically push commits to the remote repository if it's accessible. If
    the remote site is not available at commit time, fossil saves the changes until
    the remote site becomes available.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Fossil 应用程序是另一种分布式版本控制系统。像 Git 一样，它会记录更改，无论开发者是否能够访问主仓库站点。与 Git 不同，Fossil 支持自动同步模式，如果远程仓库可用，它会自动将提交推送到远程仓库。如果在提交时远程站点不可用，Fossil
    会保存更改，直到远程站点可用为止。
- en: Fossil differs from Git in several respects. The fossil repository is implemented
    in a single SQLite database instead of a set of folders as Git is implemented.
    The fossil application includes several other tools such as a web interface, a
    trouble-ticket system, and a wiki, while Git uses add-on applications to provide
    these services.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Fossil 与 Git 在多个方面有所不同。Fossil 仓库使用一个单一的 SQLite 数据库来实现，而 Git 则使用一组文件夹来实现。Fossil
    应用程序包括多个其他工具，例如 Web 界面、故障单系统和 Wiki，而 Git 则使用附加应用程序来提供这些服务。
- en: Like Git, the main interface to fossil is the `fossil` command with subcommands
    to perform specific actions like creating a new repository, cloning an existing
    repository, adding, committing files, and so on.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Git 一样，Fossil 的主要界面是 `fossil` 命令，带有子命令来执行特定操作，如创建新仓库、克隆现有仓库、添加、提交文件等。
- en: 'Fossil includes a help facility. The fossil help command will generate a list
    of supported commands, and `fossil help CMDNAME` will display a help page:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Fossil 包含一个帮助功能。`fossil help` 命令将生成一个支持命令的列表，而 `fossil help CMDNAME` 将显示帮助页面：
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Getting ready
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Fossil may not be installed on your system, and is not maintained by all repositories.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Fossil 可能尚未安装在你的系统上，并且并非所有仓库都由其维护。
- en: The definitive site for fossil is [h t t p ://w w w . f o s s i l - s c m .
    o r g](http://www.fossil-scm.org) .
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Fossil 的官方网站是 [h t t p ://w w w . f o s s i l - s c m . o r g](http://www.fossil-scm.org)。
- en: How to do it...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Download a copy of the fossil executable for your platform from [http://www.fossil-scm.org](http://www.fossil-scm.org)
    and move it to your `bin` folder.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [http://www.fossil-scm.org](http://www.fossil-scm.org) 下载适用于你的平台的 Fossil 可执行文件，并将其移至你的
    `bin` 文件夹。
- en: Creating a new fossil repository
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的 Fossil 仓库
- en: Fossil is easy to set up and use for your own projects as well as existing projects
    that you join.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Fossil 对于你的个人项目以及你加入的现有项目来说，设置和使用都非常简单。
- en: The `fossil new` and `fossil init` commands are identical. You can use either
    depending on your preference.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil new` 和 `fossil init` 命令是相同的。你可以根据自己的偏好选择使用其中之一。'
- en: How to do it...
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The `fossil new` and `fossil init` commands create an empty fossil repository:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil new` 和 `fossil init` 命令会创建一个空的 Fossil 仓库：'
- en: '[PRE48]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `fossil init` and fossil new commands are the same. They create a new empty
    repository database with the name you request. The `.fossil` suffix is not required,
    but it's a common convention.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil init` 和 `fossil new` 命令是相同的。它们会创建一个空的仓库数据库，并命名为你请求的名称。`.fossil` 后缀不是必需的，但它是一个常见的约定。'
- en: There's more...
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Let us look at some more recipes:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些更多的操作方法：
- en: Web interface to fossil
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fossil 的 Web 界面
- en: The fossil web server provides either local or remote access to many features
    of the fossil system including configuration, trouble ticket management, a wiki,
    graphs of the commit history, and more.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Fossil 的 Web 服务器提供本地或远程访问 Fossil 系统的许多功能，包括配置、故障单管理、Wiki、提交历史图表等。
- en: The `fossil ui` command starts an http server and attempts to connect your local
    browser to the fossil server. By default, this interface connects you to the UI
    and you can perform any required task.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil ui` 命令启动一个 http 服务器，并尝试将你的本地浏览器连接到 Fossil 服务器。默认情况下，该界面将连接到 UI，你可以执行任何需要的任务。'
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Making a repository available to remote users
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使仓库可供远程用户使用
- en: The fossil server command starts a fossil server that allows a remote user to
    clone your repository. By default, fossil allows anyone to clone a project. Disable
    the checkin, checkout, clone, and download zip capabilities on the `Admin/Users/Nobody`
    and `Admin/Users/Anonymous` pages to restrict access to only registered users.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: fossil server 命令启动一个 fossil 服务器，允许远程用户克隆你的仓库。默认情况下，fossil 允许任何人克隆项目。禁用 `Admin/Users/Nobody`
    和 `Admin/Users/Anonymous` 页面上的提交、签出、克隆和下载 zip 功能，以将访问权限限制为仅注册用户。
- en: The web interface for configuration is supported when running fossil server,
    but instead of being the default, you must log in using the credentials provided
    when you created the repository.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行 fossil server 时，支持通过 Web 界面进行配置，但与默认设置不同，必须使用创建仓库时提供的凭据登录。
- en: 'The fossil server can be started with a full path to the repository:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil server` 可以通过提供仓库的完整路径来启动：'
- en: '[PRE50]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The fossil server can be started from a folder with the fossil repository without
    defining the repository:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil server` 可以在不定义仓库的情况下从包含 fossil 仓库的文件夹启动：'
- en: '[PRE51]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Cloning a remote fossil repository
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆远程 fossil 仓库
- en: Because the fossil repository is contained in a single file, you can clone it
    simply by copying that file. You can send a fossil repository to another developer
    as an e-mail attachment, put it on a website, or copy it to a USB memory stick.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 fossil 仓库包含在一个单一的文件中，你可以通过复制该文件来简单地克隆它。你可以将一个 fossil 仓库作为电子邮件附件发送给其他开发者，放到网站上，或复制到
    USB 闪存驱动器中。
- en: The fossil scrub command removes user and password information that the web
    server may require from the database. This step is recommended before you distribute
    copies of your repository.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil scrub` 命令会从数据库中删除 Web 服务器可能需要的用户和密码信息。建议在分发仓库副本之前执行此步骤。'
- en: How to do it...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You can clone fossil from a site running fossil in the server mode with the
    fossil clone command. The fossil clone command distributes the version history,
    but not the users and password information:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `fossil clone` 命令从运行 fossil 的服务器模式网站克隆化石库。`fossil clone` 命令会分发版本历史，但不会包含用户和密码信息：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The fossil clone command copies the repository from the site you''ve specified
    to a local file with a name you provide (in the example: `projectName.fossil`).'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil clone` 命令将指定网站上的仓库复制到你提供的本地文件中（示例中为 `projectName.fossil`）。'
- en: Opening a fossil project
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开一个 fossil 项目
- en: The fossil open command extracts the files from a repository. It's usually simplest
    to create a subfolder under the folder with the fossil repository to hold the
    project.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil open` 命令会提取仓库中的文件。通常最好在包含 fossil 仓库的文件夹下创建一个子文件夹，用于存放项目。'
- en: How to do it...
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Download the fossil repository:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 fossil 仓库：
- en: '[PRE53]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Make a new folder for your working directory and change to it:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的工作目录创建一个新文件夹并切换到该目录：
- en: '[PRE54]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Open the repository in your working folder:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作文件夹中打开仓库：
- en: '[PRE55]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The fossil open command extracts all the folders, subfolders, and files that
    have been checked into the fossil repository.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil open` 命令会提取所有已检查到 fossil 仓库中的文件夹、子文件夹和文件。'
- en: There's more...
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can use fossil open to extract specific revisions of the code in the repository.
    This example shows how to check out the 1.0 release to fix an old bug. Make a
    new folder for your working directory and change it as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `fossil open` 提取仓库中特定版本的代码。这个示例展示了如何签出 1.0 版本来修复旧的 bug。为你的工作目录创建一个新文件夹，并按以下方式更改：
- en: '[PRE56]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Open the repository in your working folder:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作文件夹中打开仓库：
- en: '[PRE57]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Adding and committing changes with fossil
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 fossil 添加和提交更改
- en: Once you've created a repository, you want to add and edit files. The fossil
    add command adds a new file to a repository and the fossil commit command commits
    changes to the repository. This is different from Git in which the `add` command
    marks changes to be added and the commit command actually does the commit.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 创建仓库后，你可以添加和编辑文件。`fossil add` 命令将新文件添加到仓库，而 `fossil commit` 命令则将更改提交到仓库。这与 Git
    不同，在 Git 中，`add` 命令标记要添加的更改，而 `commit` 命令则执行提交操作。
- en: How to do it...
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The next examples show how fossil behaves if you have not defined the `EDITOR`
    or `VISUAL` shell variables. If `EDITOR` or `VISUAL` are defined, fossil will
    use that editor instead of prompting you on the command line:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如果没有定义 `EDITOR` 或 `VISUAL` shell 变量时，fossil 的行为。如果定义了 `EDITOR` 或 `VISUAL`，fossil
    将使用该编辑器，而不是在命令行中提示你：
- en: '[PRE58]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There's more...
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When you edit a file you only need to commit. By default, the commit will remember
    all your changes to the local repository. If auto-sync is enabled, the commit
    will also be pushed to the remote repository:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编辑文件时，只需要提交。默认情况下，提交会记住你对本地仓库的所有更改。如果启用了自动同步，提交也会推送到远程仓库：
- en: '[PRE59]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Using branches and forks with fossil
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用分支和分叉与 fossil
- en: In an ideal world, a development tree is a straight line with one revision following
    directly from the previous. In reality, developers frequently work from a stable
    code base and make changes that are then merged back into the mainline development.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的情况下，开发树是一个直线，每个修订版紧接着上一个修订版。然而，在现实中，开发人员通常从一个稳定的代码库开始工作，并进行更改，然后将其合并回主线开发。
- en: The fossil system distinguishes temporary divergences from the mainline code
    (for example, a bug fix in your repository) from permanent divergences (like the
    1.x release that gets only bug fixes, while new features go into 2.x).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Fossil 系统区分主线代码的临时分歧（例如，你仓库中的一个 bug 修复）和永久分歧（例如 1.x 版本仅进行 bug 修复，而新特性则进入 2.x
    版本）。
- en: The convention in fossil is to refer to intentional divergences as branches
    and unintentional divergences as forks. For example, you might create a branch
    for a new code you are developing, while trying to commit a change to a file after
    someone else has committed a change to that file would cause a fork unless you
    first update and resolve collisions.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fossil 中的约定是将有意的分歧称为分支，而将无意的分歧称为分叉。例如，你可能会为正在开发的新代码创建一个分支，而在你尝试提交对某个文件的修改时，如果另一个人已经提交了更改，那么除非你先更新并解决冲突，否则这将会导致分叉。
- en: Branches can be temporary or permanent. A temporary branch might be one you
    create while developing a new feature. A permanent branch is when you make a release
    that is intended to diverge from the mainline code.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 分支可以是临时的，也可以是永久的。临时分支可能是在你开发新特性时创建的分支。永久分支则是在你进行版本发布时，打算与主线代码分歧的分支。
- en: Both temporary and permanent branches are managed with tags and properties.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 临时和永久分支都通过标签和属性进行管理。
- en: When you create a fossil repository with fossil `init` or fossil new, it assigns
    the tag `trunk` to the tree.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `fossil init` 或 `fossil new` 创建一个 Fossil 仓库时，它会将标签 `trunk` 分配给树。
- en: The fossil branch command manages branches. There are subcommands to create
    new branches, list branches, and close branches.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil branch` 命令用于管理分支。它有子命令可以创建新分支、列出分支和关闭分支。'
- en: How to do it
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: The first step in working with branches is to create one. The fossil branch
    new command creates a new branch. It can either create a branch based on your
    current checkout of the project, or you can create a branch at an earlier state
    of the project.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用分支的第一步是创建一个分支。`fossil branch new` 命令可以创建一个新分支。它可以基于你当前检出的项目创建分支，也可以在项目的早期状态下创建分支。
- en: 'The fossil branch new command will create a new branch from a given checkin:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fossil branch new` 命令将从指定的检查点创建一个新分支：'
- en: '[PRE60]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `Basis-Id` is an identifier to tell fossil what code snapshot to branch
    from. There are several ways to define the `Basis-Id`. The most common of these
    are discussed in the next section.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Basis-Id` 是一个标识符，用于告诉 Fossil 从哪个代码快照创建分支。定义 `Basis-Id` 有多种方法，最常见的方法将在下一节中讨论。'
- en: 'Note that you need to perform a checkout to update your working folder to the
    new branch:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，你需要执行检出操作，将工作文件夹更新到新分支：
- en: '[PRE61]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`NewBranchName` is the name for your new branch. A convention is to name branches
    in a way that describes the modification being made. Branch names such as `localtime_fixes`
    or `bug_1234_fix` are common.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewBranchName` 是新分支的名称。一个常见的约定是按描述所做修改的方式命名分支。例如，`localtime_fixes` 或 `bug_1234_fix`
    等分支名称较为常见。'
- en: The `Basis-Id` is a string that identifies the node where the branch diverges.
    This can be the name of a branch if you are diverging from the head of a given
    branch.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`Basis-Id` 是一个字符串，标识分支分歧的节点。如果你从某个分支的头部开始分歧，这个 `Basis-Id` 可以是分支的名称。'
- en: 'The following commands show how to create a branch from the tip of a trunk:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令展示了如何从主干的最新状态创建一个分支：
- en: '[PRE62]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The fossil commit command allows you to specify a new branch name at commit
    time with the `--branch` option:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil commit` 命令允许你在提交时使用 `--branch` 选项指定一个新的分支名称：'
- en: '[PRE63]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: There's more...
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Merging forks and branches
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并分叉和分支
- en: Branches and forks can both be merged back into their parent branch. The forks
    are considered temporary and should be merged as soon as the modifications are
    approved. Branches are considered permanent, but even these may be merged back
    into the mainline code.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 分支和分叉都可以合并回其父分支。分叉被认为是临时的，应在修改得到批准后尽快合并。分支被认为是永久性的，但即使是这些也可以合并回主线代码。
- en: The fossil merge command will merge a temporary fork into another branch.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil merge` 命令将合并一个临时分叉到另一个分支中。'
- en: How to do it...
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a temporary fork and merge it back into an existing branch, you must
    first check out the branch you intend to work on:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个临时分支并将其合并回现有分支，您必须首先检出您打算进行开发的分支：
- en: '[PRE64]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now you can edit and test. When you''re satisfied with the new code, commit
    the new code onto a new branch. The `--branch` option creates a new branch if
    necessary and sets your current branch to the new `branch`:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您可以编辑并进行测试。当您对新代码满意时，将新代码提交到新的分支上。`--branch`选项会在必要时创建一个新分支，并将您的当前分支设置为新的`branch`：
- en: '[PRE65]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'After the code has been tested and verified, you can merge it back into the
    appropriate branch by performing a checkout of the branch you want to merge into,
    then invoke the fossil merge command to schedule the merge, and finally commit
    the merge:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码经过测试和验证后，您可以通过检出要合并的分支，然后调用fossil merge命令来安排合并，最后提交合并：
- en: '[PRE66]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Fossil and Git behave slightly differently in this respect. The `git merge`
    command updates the repository, while the fossil merge command doesn't modify
    the repository until the merge is committed.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，Fossil和Git的行为略有不同。`git merge`命令会更新仓库，而化石合并命令则不会修改仓库，直到合并被提交。
- en: Sharing your work with fossil
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与化石共享您的工作
- en: If you use multiple platforms for development, or if you work on someone else's
    project, you need to synchronize your local repository with the remote, master
    repository. Fossil has several ways to handle this.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在多个平台上进行开发，或者您在参与他人的项目，您需要将本地仓库与远程主仓库进行同步。Fossil有几种方式来处理这种情况。
- en: How to do it...
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: By default fossil runs in the `autosync` mode. In this mode, your commits are
    immediately propagated to the remote repository.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，fossil在`autosync`模式下运行。在这种模式下，您的提交会立即传播到远程仓库。
- en: 'The `autosync` setting can be enabled and disabled with the fossil setting
    command:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`autosync`设置可以通过fossil设置命令启用或禁用：'
- en: '[PRE67]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'When `autosync` is disabled (fossil is running in manual merge mode), you must
    use the fossil push command to send changes in your local repository to the remote:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当`autosync`被禁用（fossil在手动合并模式下运行）时，您必须使用fossil push命令将本地仓库的更改发送到远程仓库：
- en: '[PRE68]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How it works...
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `push` command pushes all changes in your local repository to the remote
    repository. It does not modify any checked out code.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`push`命令会将本地仓库中的所有更改推送到远程仓库。它不会修改任何已检出的代码。'
- en: Updating your local fossil repository
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新您的本地fossil仓库
- en: The flip side of pushing your work to the remote repository is updating your
    local repository. You'll need to do this if you do some development on your laptop
    while the main repository is on your companies server, or if you are working on
    a project with multiple people and you need to keep up to date on their new features.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的工作推送到远程仓库的反面是更新您的本地仓库。如果您在笔记本电脑上进行开发，而主仓库在公司服务器上，或者您正在与多人合作的项目中工作并需要保持与他们的新功能同步，您将需要执行此操作。
- en: How to do it...
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The fossil server does not push updates to remote repositories automatically.
    The `fossil pull` command will pull updates to your repository. It updates the
    repository, but does not change your working code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 化石服务器不会自动将更新推送到远程仓库。`fossil pull`命令将会将更新拉取到您的仓库中。它会更新仓库，但不会更改您的工作代码：
- en: '[PRE69]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `fossil checkout` command will update your working code if there were changes
    in the repository:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil checkout`命令将在仓库发生更改时更新您的工作代码：'
- en: '[PRE70]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You can combine the pull and checkout subcommands with the `fossil update`
    command:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将pull和checkout子命令与`fossil update`命令结合使用：
- en: '[PRE71]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Checking the status of a fossil repository
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查化石仓库的状态
- en: Before you start any new development, you should compare the state of your local
    repository to the master repository. You don't want to waste time writing code
    that conflicts with code that's been accepted.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始任何新开发之前，您应当将本地仓库的状态与主仓库进行比较。您不想浪费时间编写与已接受代码冲突的代码。
- en: How to do it...
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The `fossil status` command will report the current status of your project,
    whether you have uncommitted edits and whether your working code is at the tip:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil status`命令将报告项目的当前状态，包括是否有未提交的编辑，以及您的工作代码是否处于最新状态：'
- en: '[PRE72]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If there has been a commit made to the branch you''re working on since your
    last checkout, the status will include a line resembling the following:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自您上次检出以来，您正在工作的分支上有新的提交，状态将包括一行类似于以下内容：
- en: '[PRE73]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This indicates that there is a commit after your code. You will have to do a
    `fossil update` to bring your working copy of the code into sync before you can
    commit to the head of the branch. This may require you to fix conflicts by hand.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示在你的代码之后有一个提交。在你提交到分支头之前，你需要执行 `fossil update` 将你的工作副本同步。这可能需要你手动解决冲突。
- en: Note that fossil can only report the data in your local repository. If commits
    have been made but not pushed to the server and pulled into your local repository,
    they won't be displayed. You should invoke `fossil sync` before `fossil status`
    to confirm that your repository has all the latest information.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，fossil 只能报告你本地仓库中的数据。如果提交已经完成，但尚未推送到服务器并拉取到本地仓库，它们将不会显示。在执行 `fossil status`
    之前，你应该先执行 `fossil sync`，以确认你的仓库已包含所有最新信息。
- en: Viewing fossil history
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看 fossil 历史
- en: The `fossil server` and `fossil ui` commands start fossil's web server and let
    you view the history of check-ins and navigate through code via your favorite
    browser.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil server` 和 `fossil ui` 命令启动 fossil 的 Web 服务器，并允许你通过你最喜欢的浏览器查看提交历史并浏览代码。'
- en: The timeline tab provides a tree-structured view of the branches, commits, and
    merges. The web interface supports viewing the source code associated with the
    commits and performing diffs between different versions.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 时间轴标签提供了一个树状结构的视图，展示了分支、提交和合并。Web 界面支持查看与提交相关联的源代码，并在不同版本之间执行差异比较。
- en: How to do it...
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Start fossil in the UI mode. It will try to find your browser and open the
    main page. If that fails, you can point your browser to fossil:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 fossil 的 UI 模式。它会尝试找到你的浏览器并打开主页。如果失败，你可以手动将浏览器指向 fossil：
- en: '[PRE74]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '![](img/image_06_001.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_001.png)'
- en: Finding bugs
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找 bug
- en: 'Fossil provides tools to help locate the commit where a bug was introduced:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: Fossil 提供了帮助定位引入 bug 的提交的工具：
- en: '| **Tools** | **Description** |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| **工具** | **描述** |'
- en: '| `fossil diff` | This displays the difference between two revisions of a file
    |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| `fossil diff` | 该命令显示文件两个修订版本之间的差异 |'
- en: '| `fossil blame` | This generates a report showing the commit information for
    each line in a file |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| `fossil blame` | 该命令生成一份报告，显示文件中每行代码的提交信息 |'
- en: '| `fossil bisect` | This uses binary search to step between good and bad versions
    of an application |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| `fossil bisect` | 该命令使用二分查找法在应用程序的良好和坏版本之间进行切换 |'
- en: How to do it...
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The `fossil diff` command has several options. When looking for the code that
    introduced a problem, we generally want to perform a diff on two versions of a
    file. The `-from` and `-to` options to `fossil diff` perform this action:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil diff` 命令有多个选项。在寻找引入问题的代码时，我们通常需要对两个版本的文件进行差异比较。`fossil diff` 的 `-from`
    和 `-to` 选项可以执行此操作：'
- en: '[PRE75]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`ID-1` and `ID-2` are identifiers used in the repository. They may be SHA-1
    hashes, tags or dates, and so on. The `FILENAME` is the file that was committed
    to fossil.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`ID-1` 和 `ID-2` 是在仓库中使用的标识符。它们可能是 SHA-1 哈希值、标签、日期等。`FILENAME` 是提交到 fossil 的文件。'
- en: 'For example, to find the difference between two revisions of `main.tcl` use
    the following command:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要查找 `main.tcl` 两个修订版本之间的差异，请使用以下命令：
- en: '[PRE76]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: There's more...
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The differences between two revisions are useful, but it's more useful to see
    the entire file annotated to show when lines were added.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 两个修订版本之间的差异很有用，但查看整个文件的注释版更有帮助，这样你就能看到每一行代码的添加时间。
- en: 'The `fossil blame` command generates an annotated listing of a file showing
    when lines were added:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil blame` 命令生成一个带有注释的文件列表，显示每一行代码的添加时间：'
- en: '[PRE77]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: When you know that there's a problem in one version but not in another, you
    need to center in on the version where the problem was introduced.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道某个版本存在问题，但另一个版本没有时，你需要集中精力查找引入问题的版本。
- en: The `fossil bisect` command provides support for this. It lets you define a
    good and bad version of the code and automatically checks out the version between
    those to be tested. You can then mark this version as good or bad and fossil will
    repeat the process. Fossil bisect also generates reports showing how many versions
    have been tested and how many need to be tested.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil bisect` 命令提供了对这一过程的支持。它允许你定义代码的良好和坏版本，并自动检出这两个版本之间的版本进行测试。然后，你可以将此版本标记为好或坏，fossil
    将重复此过程。Fossil bisect 还会生成报告，显示已测试的版本数量和待测试的版本数量。'
- en: How to do it...
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The `fossil bisect reset` command initializes the good and bad pointers. The
    `fossil bisect good` and `fossil bisect bad` commands mark versions as good or
    bad and check out the version of the code that''s midway between the good and
    bad version:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil bisect reset` 命令初始化好与坏指针。`fossil bisect good` 和 `fossil bisect bad`
    命令将版本标记为好或坏，并检出介于好坏版本之间的代码版本：'
- en: '[PRE78]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: After testing the `f64ca` version of the code, you can mark it good or bad and
    `fossil bisect` will check out the next version for testing.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试完`f64ca`版本的代码后，你可以将其标记为好或坏，`fossil bisect`将检出下一个版本进行测试。
- en: There's more...
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'The `fossil bisect status` command generates a report of the available versions
    and marks the tested versions:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil bisect status` 命令生成一个报告，列出可用版本并标记已测试的版本：'
- en: '[PRE79]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Tagging snapshots
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记快照
- en: Every node in the fossil graph can have one or more tags attached to it. Tags
    can identify releases, branches, or just particular milestones that you may want
    to refer to. For example, you may want a release-1 branch with tags for release-1.0,
    release-1.1, and so on. A tag can be used with checkout or merge instead of using
    the SHA1 identifier.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Fossil图中的每个节点都可以附加一个或多个标签。标签可以标识发布、分支或你可能希望引用的特定里程碑。例如，你可能希望创建一个release-1分支，并标记release-1.0、release-1.1等。标签可以与checkout或merge一起使用，而不是使用SHA1标识符。
- en: Tags are implemented with the fossil tag command. Fossil supports several subcommands
    to add, cancel, find, and list tags.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 标签通过fossil tag命令实现。Fossil支持多个子命令来添加、取消、查找和列出标签。
- en: 'The `fossil tag add` command creates a new tag:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`fossil tag add` 命令创建一个新标签：'
- en: '[PRE80]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How to do it...
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: The `TagName` is whatever you want to call the branch.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`TagName`是你为分支命名的任何名称。'
- en: 'Identifier is an identifier for the node to be tagged. The identifier can be
    one of the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符是要标记的节点的标识符。标识符可以是以下之一：
- en: '**A branch name**: Tag the most recent commit on this branch'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个分支名称**：标记此分支上最新的提交'
- en: '**An SHA1 identifier**: Tag the commit with this SHA1 identifier'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个SHA1标识符**：用这个SHA1标识符标记提交'
- en: '**A datestamp (YYYY-MM-DD)**: Tag the commit just previous to this datestamp'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个日期戳 (YYYY-MM-DD)**：标记此日期戳之前的提交'
- en: '**A timestamp (YYYY-MM-DD HH:MM:SS)**: Tag the commit just previous to this
    timestamp'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个时间戳 (YYYY-MM-DD HH:MM:SS)**：标记此时间戳之前的提交'
- en: '[PRE81]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: There's more...
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'A tag can be used as an identifier to create a fork or branch:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 标签可以作为标识符来创建一个分支或分支：
- en: '[PRE82]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'A tag can create a branch with a commit and the `-branch` option:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 标签可以使用`-branch`选项与提交一起创建分支：
- en: '[PRE83]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
