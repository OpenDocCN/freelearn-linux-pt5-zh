- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Infrastructure and Automation with Ansible
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 进行基础设施和自动化管理
- en: If your day-to-day system administration or development work involves tedious
    and repetitive operations, **Ansible** could help you run your tasks while saving
    you precious time. Ansible is a tool for automating **software provisioning**,
    **configuration management**, and **application deployment workflows**. Initially
    developed by Michael DeHaan in 2012, Ansible was acquired by Red Hat in 2015 and
    is now maintained as an open source project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你日常的系统管理或开发工作涉及繁琐和重复的操作，**Ansible** 可以帮助你在节省宝贵时间的同时完成任务。Ansible 是一款用于自动化**软件配置**、**配置管理**和**应用部署工作流**的工具。Ansible
    最初由 Michael DeHaan 在 2012 年开发，2015 年被 Red Hat 收购，并现在作为开源项目进行维护。
- en: 'In this chapter, you’ll learn about the fundamental concepts of Ansible, along
    with a variety of hands-on examples. In particular, we’ll explore the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习 Ansible 的基本概念，以及一系列动手操作的示例。特别是，我们将探索以下主题：
- en: Introducing Ansible architecture and configuration management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Ansible 架构和配置管理
- en: Installing Ansible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Ansible
- en: Working with Ansible
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: First, you should be familiar with the Linux command-line Terminal in general.
    Intermediate knowledge of Linux will help you understand some of the intricacies
    of the practical illustrations used throughout this chapter. You should also be
    proficient in using a Linux-based text editor.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你应该对 Linux 命令行终端有一定的了解。中级的 Linux 知识将帮助你理解本章中实际示例的某些细节。你还应该熟练使用基于 Linux 的文本编辑器。
- en: For the hands-on examples, we recommend setting up a lab environment similar
    to the one we’re using. To replicate this environment, your CPU will need to have
    at least 6 physical cores and 6 virtual cores (12 in total). A quad-core CPU with
    hyper-threading is not enough. Also, OpenSSH should be installed on all the hosts.
    You’ll find related instructions in the *Setting up the lab environment* section
    of this chapter. If you don’t configure a lab environment, you will still benefit
    from the detailed explanations associated with the practical examples in this
    chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际操作的示例，我们建议设置一个与我们使用的实验环境类似的实验室环境。为了复制这个环境，您的 CPU 至少需要 6 个物理核心和 6 个虚拟核心（共
    12 个）。四核 CPU 带超线程功能是不够的。此外，所有主机上应安装 OpenSSH。在本章的*设置实验环境*部分，你将找到相关的配置说明。如果你没有配置实验环境，你仍然可以从本章与实际示例相关的详细解释中获益。
- en: Now, let’s start our journey by covering introductory concepts surrounding Ansible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过介绍 Ansible 的基本概念开始我们的学习之旅。
- en: Introducing Ansible architecture and configuration management
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Ansible 架构和配置管理
- en: In the introduction to this chapter, we captured one of the essential aspects
    of Ansible – it’s a tool for automating workflows. Almost any Linux system administration
    task can be automated using Ansible. Using the Ansible CLI, we can invoke simple
    commands to change the **desired state** of a system. Usually, with Ansible, we
    execute tasks on a remote host or a group of hosts.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的介绍中，我们概述了 Ansible 的一个关键方面——它是一款自动化工作流的工具。几乎所有的 Linux 系统管理任务都可以使用 Ansible
    来自动化。通过使用 Ansible CLI，我们可以执行简单的命令来更改系统的**期望状态**。通常，使用 Ansible 时，我们会在远程主机或一组主机上执行任务。
- en: Let’s use the classic illustration of **package management**. Suppose you’re
    managing an infrastructure that includes a group of web servers, and you plan
    to install the latest version of a web server application (Nginx or Apache) on
    all of them. One way to accomplish this task is to SSH into each host and run
    the related shell commands to install the latest web server package. If you have
    a lot of machines, this will be a big task. You could argue that you can write
    a script to automate this job. This is possible, but then you’d have yet another
    job on your hands; that is, maintaining the script, fixing possible bugs, and,
    with your infrastructure growing, adding new features.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用经典的**包管理**来说明。假设你正在管理一个包含一组 web 服务器的基础设施，并且计划在所有这些服务器上安装最新版本的 web 服务器应用程序（Nginx
    或 Apache）。实现这一任务的一种方式是通过 SSH 连接到每个主机，执行相关的 shell 命令来安装最新的 web 服务器包。如果你的机器很多，这将是一项庞大的任务。你或许会认为可以写个脚本来自动化这个工作。这是可行的，但这样你又有了一项新工作；也就是维护脚本、修复可能的错误，随着基础设施的增长，添加新的功能。
- en: At some point, you may want to manage users or databases or configure network
    settings on multiple hosts. Soon, you’ll be looking at a Swiss Army knife tool,
    with capabilities that you’d rather get for free instead of writing them yourself.
    Here’s where Ansible comes in handy. With its myriad of modules – for almost any
    system administration task you can imagine – Ansible can remotely configure, run,
    or deploy your management jobs of choice, with minimal effort and in a very secure
    and efficient way.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能需要管理多个主机上的用户、数据库或配置网络设置。很快，你就会需要一款瑞士军刀式的工具，拥有你宁愿免费获得而不是自己编写的功能。此时，Ansible
    就派上用场了。凭借其丰富的模块——几乎涵盖了你能想象到的所有系统管理任务——Ansible 能够以最小的努力，并且在一个非常安全高效的方式下，远程配置、运行或部署你所选择的管理任务。
- en: We’ll consolidate these preliminary thoughts with a brief look at the Ansible
    architecture.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过简要了解 Ansible 架构来巩固这些初步的思路。
- en: Understanding the Ansible architecture
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 Ansible 架构
- en: The core Ansible framework is written in Python. Let’s mention upfront that
    Ansible has an **agentless** architecture. In other words, it runs on a **control
    node** that executes commands against remote hosts, without the need for a remote
    endpoint or service to be installed on the managed host to communicate with the
    control node. At a minimum, the only requirement for Ansible communication is
    SSH connectivity to the managed host. Yet, the number of Ansible operations would
    be relatively limited to only running scripts and raw SSH commands if the host
    didn’t have a Python framework installed. The vast majority of server OS platforms
    already have Python installed by default.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 核心框架是用 Python 编写的。我们要提前提到的是，Ansible 采用了 **无代理** 架构。换句话说，它在 **控制节点**
    上运行，向远程主机执行命令，无需在受管主机上安装远程端点或服务来与控制节点进行通信。至少，Ansible 通信的唯一要求是能够通过 SSH 连接到受管主机。然而，如果主机没有安装
    Python 框架，那么 Ansible 的操作将仅限于运行脚本和原始 SSH 命令。绝大多数服务器操作系统平台默认已经安装了 Python。
- en: 'Ansible can manage a fleet of remote hosts from a single control node using
    secure SSH connections. The following diagram shows the logical layout of a managed
    infrastructure using Ansible:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 可以通过一个控制节点使用安全的 SSH 连接管理一组远程主机。下图展示了使用 Ansible 管理的基础设施的逻辑布局：
- en: '![Figure 17.1 – The logical layout of a managed infrastructure using Ansible](img/B19682_17_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.1 – 使用 Ansible 管理的基础设施的逻辑布局](img/B19682_17_01.jpg)'
- en: Figure 17.1 – The logical layout of a managed infrastructure using Ansible
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.1 – 使用 Ansible 管理的基础设施的逻辑布局
- en: Production-grade enterprise environments usually include a **configuration management
    database** (**CMDB**) for organizing their IT infrastructure assets. Examples
    of IT infrastructure assets are servers, networks, services, and users. Although
    not directly part of the Ansible architecture, the CMDB describes the assets and
    their relationship within a managed infrastructure and can be leveraged to build
    an **Ansible inventory**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 生产级企业环境通常会包含一个 **配置管理数据库** (**CMDB**)，用于组织其 IT 基础设施资产。IT 基础设施资产的示例包括服务器、网络、服务和用户。虽然
    CMDB 并不是 Ansible 架构的直接组成部分，但它描述了资产及其在受管基础设施中的关系，并且可以用于构建 **Ansible 清单**。
- en: The inventory is local storage on the Ansible control node – typically an **INI**
    or **YAML** file – that describes managed **hosts** or **groups** of hosts. The
    inventory is either inferred from the CMDB or manually created by the system administrator.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 清单是 Ansible 控制节点上的本地存储——通常是 **INI** 或 **YAML** 文件——它描述了受管的 **主机** 或 **主机组**。清单可以从
    CMDB 推断出来，也可以由系统管理员手动创建。
- en: 'Now, let’s have a closer look at the high-level Ansible architecture shown
    in the following diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地看看以下图示的高层次 Ansible 架构：
- en: '![Figure 17.2 – The Ansible architecture](img/B19682_17_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.2 – Ansible 架构](img/B19682_17_02.jpg)'
- en: Figure 17.2 – The Ansible architecture
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.2 – Ansible 架构
- en: 'The preceding diagram shows the Ansible control node interacting with managed
    hosts in a private or public cloud infrastructure. Here are some brief descriptions
    of the blocks featured in the architectural view:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上图展示了 Ansible 控制节点与私有或公共云基础设施中的受管主机之间的交互。以下是架构视图中所示区块的简要说明：
- en: '**API and core framework**: The main libraries encapsulating Ansible’s core
    functionality; the Ansible core framework is written in Python'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API 和核心框架**：封装 Ansible 核心功能的主要库；Ansible 核心框架是用 Python 编写的'
- en: '**Plugins**: Additional libraries extending the core framework’s functionality
    – for instance, the following:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件**：扩展核心框架功能的附加库——例如，以下内容：'
- en: '**Connection plugins**, such as cloud connectors'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接插件**，如云连接器'
- en: '**Test plugins**, verifying specific response data'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试插件**，验证特定的响应数据'
- en: '**Callback plugins** for responding to events'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回调插件**，用于响应事件'
- en: '`user` module for managing users'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user` 模块用于管理用户'
- en: '`package` module for managing software packages'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package` 模块用于管理软件包'
- en: '**Inventory**: The INI or YAML file describing the hosts and groups of hosts
    targeted by Ansible commands and playbooks*   **Playbooks**: The Ansible execution
    files describing a set of tasks that target managed hosts*   **Private or public
    clouds**: The managed infrastructure, hosted on-premises or in various cloud environments
    (for example, VMware, **Amazon Web Services** (**AWS**), and Azure)*   **Managed
    hosts**: The servers targeted by Ansible commands and playbooks*   `ansible`,
    `ansible-playbook`, `ansible-doc`, and so on*   **Users**: The administrators,
    power users, and automated user processes running Ansible commands or playbooks'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清单**：描述由 Ansible 命令和 Playbooks 目标的主机和主机组的 INI 或 YAML 文件*   **Playbooks**：描述一组针对托管主机的任务的
    Ansible 执行文件*   **私有或公共云**：托管在本地或各种云环境中的托管基础设施（例如 VMware、**亚马逊网络服务**（**AWS**）和
    Azure）*   **托管主机**：由 Ansible 命令和 Playbooks 目标的服务器*   `ansible`、`ansible-playbook`、`ansible-doc`
    等*   **用户**：运行 Ansible 命令或 Playbooks 的管理员、高级用户和自动化用户进程'
- en: Now that we have a basic understanding of the Ansible architecture, let’s look
    at what makes Ansible a great tool for automating management workflows. We’ll
    introduce the concept of **configuration** **management** next.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Ansible 架构有了基本的理解，接下来让我们看看是什么使得 Ansible 成为自动化管理工作流的一个优秀工具。接下来我们将介绍**配置**
    **管理**的概念。
- en: Introducing configuration management
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍配置管理
- en: If we look back at the old days, system administrators usually managed a relatively
    low number of servers, running everyday administrative tasks by using a remote
    shell on each host. Relatively simple operations, such as copying files, updating
    software packages, and managing users, could easily be scripted and reused regularly.
    With the recent surge in apps and services, driven by the vast expansion of the
    internet, modern-day on-premises and cloud-based IT infrastructures – sustaining
    the related platforms – have grown significantly. The sheer amount of configuration
    changes involved would by far exceed the capacity of a single admin running and
    maintaining a handful of scripts. Here’s where configuration management comes
    to the rescue.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾过去，系统管理员通常管理的服务器数量相对较少，通过在每台主机上使用远程 shell 来运行日常管理任务。诸如复制文件、更新软件包和管理用户等相对简单的操作，可以轻松编写脚本并定期重复使用。随着应用程序和服务的激增，互联网的快速发展，现代本地和基于云的
    IT 基础设施——支撑这些相关平台——已经显著增长。涉及的大量配置变更远远超过了一个管理员运行和维护少数脚本的能力。在这种情况下，配置管理应运而生。
- en: With configuration management, managed hosts and assets are grouped into logical
    categories, based on specific criteria, as suggested in *Figure 17**.1*. Managing
    assets other than hosts ultimately comes down to performing specific tasks on
    the servers hosting those assets. The **configuration management manifest** is
    the Ansible inventory file that manages these hosts and assets. Thus, Ansible
    becomes the configuration management endpoint.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置管理中，托管的主机和资产根据特定标准被分组为逻辑类别，如*图 17.1*所示。除了主机之外，管理其他资产最终还是要在托管这些资产的服务器上执行特定任务。**配置管理清单**是
    Ansible 的清单文件，用于管理这些主机和资产。因此，Ansible 成为配置管理的端点。
- en: With Ansible, we can run single one-off commands to carry out specific tasks,
    but a far more efficient configuration management workflow can be achieved via
    `ansible-playbook` runs for regular maintenance and configuration management tasks
    is a common practice in IT infrastructure automation. We will discuss Ansible
    playbooks later in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ansible，我们可以运行单个一次性命令来执行特定任务，但通过 `ansible-playbook` 执行定期的维护和配置管理任务，可以实现更加高效的配置管理工作流，这在
    IT 基础设施自动化中是一个常见的做法。我们将在本章稍后讨论 Ansible 的 Playbooks。
- en: Running Ansible tasks repeatedly (or on a scheduled basis) against a specific
    target raises the concern of unwanted changes in the desired state due to repetitive
    operations. This issue brings us to one of the essential aspects of configuration
    management – the **idempotency** of configuration changes. We’ll look at what
    idempotent changes are next.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 反复（或定期）对特定目标执行 Ansible 任务时，会引发由于重复操作导致的期望状态发生不必要变化的问题。这个问题引出了配置管理的一个核心方面——配置更改的**幂等性**。接下来，我们将看看什么是幂等性更改。
- en: Explaining idempotent operations
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 解释幂等操作
- en: In configuration management, an operation is **idempotent** when running it
    multiple times yields the same result as running it once. In this sense, Ansible
    is an idempotent configuration management tool.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置管理中，操作是**幂等的**，当多次运行它时，结果与第一次运行时相同。从这个意义上讲，Ansible 是一个幂等的配置管理工具。
- en: Let us explain how an idempotent operation works. Let us suppose we have an
    Ansible task creating a user. When the task runs for the first time, it creates
    the user. Running it for a second time – when the user has already been created
    – would result in a **no-operation** (**no-op**). *Without* idempotency, subsequent
    runs of the same task would produce errors due to attempting to create a user
    that already exists.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下幂等操作是如何工作的。假设我们有一个 Ansible 任务，用来创建一个用户。当任务第一次运行时，它会创建该用户。如果在第二次运行时用户已经被创建，那么这次操作将是一个**空操作**（**no-op**）。*没有*幂等性的话，后续运行相同任务时，由于尝试创建已存在的用户，将会产生错误。
- en: We should note that Ansible is not the only configuration management tool on
    the market. We have **Chef**, **Puppet**, and **SaltStack**, to name a few. Most
    of these platforms have been acquired by larger enterprises, such as SaltStack,
    being owned by VMware, and some may argue that Ansible’s success could be attributed
    to Red Hat’s open sourcing of the project. Ansible appears to be the most successful
    configuration management platform of our day. The industry consensus is that Ansible
    provides a user-friendly experience, high scalability, and affordable licensing
    tiers in enterprise-grade deployments.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意到，Ansible 并不是市场上唯一的配置管理工具。还有**Chef**、**Puppet** 和 **SaltStack** 等平台。大多数这些平台已经被更大的企业收购，例如
    SaltStack 被 VMware 收购，有些人可能会认为 Ansible 的成功归功于 Red Hat 将该项目开源。Ansible 似乎是当今最成功的配置管理平台。业界普遍认为，Ansible
    提供了用户友好的体验、高可扩展性和企业级部署中负担得起的许可层次。
- en: With the introductory concepts covered, let’s roll up our sleeves and install
    Ansible on a Linux platform of choice.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍完基础概念后，让我们动手安装 Ansible，在选择的 Linux 平台上。
- en: Installing Ansible
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Ansible
- en: 'In this section, we’ll show you how to install Ansible on a **control node**.
    On Linux, we can install Ansible in a couple of ways:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向你展示如何在**控制节点**上安装 Ansible。在 Linux 上，我们可以通过几种方式来安装 Ansible：
- en: Using the platform-specific package manager (for example, `apt` on Ubuntu/Debian)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特定平台的软件包管理器（例如，Ubuntu/Debian 上的 `apt`）
- en: Using `pip`, the Python package manager
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `pip`，Python 包管理器
- en: The Ansible community recommends `pip` for installing Ansible since it provides
    the most recent stable version of Ansible. In this section, we’ll use Ubuntu as
    our distribution of choice. For a complete Ansible installation guide for all
    major OS platforms, please follow the online documentation at [https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 社区推荐使用 `pip` 来安装 Ansible，因为它提供了 Ansible 的最新稳定版本。在本节中，我们将使用 Ubuntu 作为我们选择的发行版。对于所有主要操作系统平台的完整
    Ansible 安装指南，请参阅在线文档：[https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html)。
- en: On the control node, Ansible requires Python, so before installing Ansible,
    we need to make sure we have Python installed on our system.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制节点上，Ansible 需要 Python，因此在安装 Ansible 之前，我们需要确保系统中已安装 Python。
- en: Important note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Python 2 is no longer supported as of January 1, 2020\. Please use Python 3.8
    (or newer) instead.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2 自 2020 年 1 月 1 日起不再受支持，请改用 Python 3.8（或更新版本）。
- en: Let’s start by installing Ansible on Ubuntu.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在 Ubuntu 上安装 Ansible。
- en: Installing Ansible on Ubuntu
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Ubuntu 上安装 Ansible
- en: 'With Ubuntu 22.04 LTS, we have Python 3 installed by default. We can proceed
    with installing Ansible by following these steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 22.04 LTS 中，默认安装了 Python 3。我们可以按照以下步骤继续安装 Ansible：
- en: 'Let’s first check the Python 3 version we have by using the following command:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先通过以下命令检查 Python 3 的版本：
- en: '[PRE0]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: sudo apt update
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sudo apt update
- en: '[PRE1]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we must add the Ansible PPA:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须添加 Ansible PPA：
- en: '[PRE2]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can install the Ansible package with the following command:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令安装 Ansible 包：
- en: '[PRE3]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With Ansible installed, we can check its current version:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装好 Ansible 后，我们可以检查其当前版本：
- en: '[PRE4]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In our case, the relevant excerpt in the output of the previous command is
    as follows:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的例子中，前一条命令的相关输出摘录如下：
- en: '[PRE5]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we’ll look at how to install Ansible using `pip`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍如何使用 `pip` 安装 Ansible。
- en: Installing Ansible using pip
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pip 安装 Ansible
- en: 'Before we install Ansible with `pip`, we need to make sure Python is installed
    on the system. We assume Python 3 is installed based on the steps presented in
    the previous section. When installing Ansible using `pip`, it is a safe practice
    to previously uninstall any version of Ansible that was installed using the local
    package manager (such as `apt`). This will ensure that `pip` will install the
    latest version of Ansible successfully. To proceed with the installation, follow
    these steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `pip` 安装 Ansible 之前，我们需要确保系统上已安装 Python。我们假设根据前一节提供的步骤，已经安装了 Python 3。在使用
    `pip` 安装 Ansible 时，最好先卸载通过本地包管理器（如 `apt`）安装的任何版本的 Ansible。这将确保 `pip` 成功安装最新版本的
    Ansible。继续安装之前，请按照以下步骤操作：
- en: 'We should remove any existing version of Ansible that’s been installed with
    the platform-specific package manager (for example, `apt` or `yum`). To uninstall
    Ansible on Ubuntu, run the following command:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应当删除任何通过特定平台包管理器（例如 `apt` 或 `yum`）安装的现有版本的 Ansible。要卸载 Ubuntu 上的 Ansible，可以运行以下命令：
- en: '[PRE6]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'pip installer first:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 先使用 pip 安装器：
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'pip and Ansible with the following commands:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 pip 和 Ansible，执行以下命令：
- en: '[PRE8]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you wish to install Ansible *globally* on the system, the equivalent commands
    are as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你希望将 Ansible *全局*安装在系统上，等效的命令如下：
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After the installation completes, you may have to log out and log back in to
    your Terminal again before using Ansible. You can check the Ansible version you
    have installed with the following command:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，你可能需要退出并重新登录终端，然后才能使用 Ansible。你可以使用以下命令检查安装的 Ansible 版本：
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In our case, the output shows the following:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的例子中，输出显示如下：
- en: '[PRE12]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, you can get the most recent version (as of writing) of Ansible
    by using `pip`. Therefore, it is the recommended method of installing Ansible.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过使用 `pip`，你可以获得 Ansible 的最新版本（截至写作时）。因此，它是安装 Ansible 的推荐方法。
- en: With Ansible installed on our control node, let’s look at some practical examples
    of using Ansible.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的控制节点上安装了 Ansible 后，让我们看一些使用 Ansible 的实际示例。
- en: Working with Ansible
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible
- en: In this section, we’ll use the Ansible CLI tools extensively to perform various
    configuration management tasks. To showcase our practical examples, we’ll work
    with a custom lab environment, and we highly encourage you to reproduce it for
    a complete configuration management experience.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将广泛使用 Ansible CLI 工具来执行各种配置管理任务。为了展示实际操作示例，我们将使用自定义实验环境，并强烈建议你复制该环境以获得完整的配置管理体验。
- en: 'Here’s a high-level outline of this section:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的高层次大纲如下：
- en: Setting up the lab environment
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置实验环境
- en: Configuring Ansible
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Ansible
- en: Using Ansible ad hoc commands
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 临时命令
- en: Using Ansible playbooks
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible playbook
- en: Using templates with Jinja2
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jinja2 模板
- en: Using Ansible roles
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 角色
- en: Let’s start with an overview of the lab environment.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实验环境的概述开始。
- en: Setting up the lab environment
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置实验环境
- en: 'Our lab uses **Kernel-based Virtual Machine** (**KVM**) as a hypervisor for
    the virtual environment, but any other hypervisor will do. [*Chapter 11*](B19682_11.xhtml#_idTextAnchor231),
    *Working with Virtual Machines*, describes the process of creating Linux **virtual
    machines** (**VMs**) in detail. We deployed the following VMs using Ubuntu Server
    LTS to mimic a real-world configuration management infrastructure:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实验环境使用 **基于内核的虚拟机**（**KVM**）作为虚拟环境的虚拟化管理程序，但任何其他虚拟化管理程序都可以使用。[*第 11 章*](B19682_11.xhtml#_idTextAnchor231)，*与虚拟机的操作*，详细描述了如何创建
    Linux **虚拟机**（**VMs**）。我们使用 Ubuntu Server LTS 部署了以下虚拟机，模拟现实世界中的配置管理基础设施：
- en: '`neptune`: The Ansible control node'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`neptune`: Ansible 控制节点'
- en: '`ans-web1`: Web server'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ans-web1`: Web 服务器'
- en: '`ans-web2`: Web server'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ans-web2`: Web 服务器'
- en: '`ans-db1`: Database server'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ans-db1`: 数据库服务器'
- en: '`ans-db2`: Database server'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ans-db2`: 数据库服务器'
- en: All VMs have the default server components installed. On each host, we created
    a default admin user called `packt` with SSH access enabled. Each VM will have
    2 vCPUs, 2 GB of RAM, and 20 GB minimum.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所有虚拟机都已安装默认的服务器组件。在每个主机上，我们创建了一个名为`packt`的默认管理员用户，并启用了SSH访问。每台虚拟机将拥有2个vCPU，2
    GB的RAM，以及至少20 GB的磁盘空间。
- en: Now, let’s briefly describe the setup for these VMs, starting with managed hosts.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要描述这些虚拟机的设置，从托管主机开始。
- en: Setting up managed hosts
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置托管主机
- en: 'There are a couple of key requirements for managed hosts to fully enable configuration
    management access from the Ansible control node:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于托管主机，完全启用从Ansible控制节点进行配置管理访问有几个关键要求：
- en: They must have an OpenSSH server installed and running
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们必须安装并运行OpenSSH服务器
- en: They must have Python installed
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们必须安装Python
- en: As specified in the *Technical requirements* section, we assume you have OpenSSH
    enabled on your hosts. For installing Python, you may follow the related steps
    described in the *Installing* *Ansible* section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如*技术要求*部分所述，我们假设您的主机上已启用OpenSSH。有关安装Python的信息，您可以按照*安装* *Ansible*部分中描述的相关步骤进行操作。
- en: Important note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Managed hosts don’t require Ansible to be installed on the system.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 托管主机不需要在系统上安装Ansible。
- en: 'To set the hostname on each VM, you may run the following command (for example,
    for the `ans-web1` hostname):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置每个虚拟机的主机名，可以运行以下命令（例如，对于`ans-web1`主机名）：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We also want to disable the `sudo` login password on our managed hosts to facilitate
    unattended privilege escalation when running automated scripts. If we don’t make
    this change, remotely executing Ansible commands will require a password.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望在托管主机上禁用`sudo`登录密码，以便在运行自动化脚本时促进无人值守的权限提升。如果不进行此更改，远程执行Ansible命令时将需要密码。
- en: 'To disable the `sudo` login password, edit the `sudo` configuration with the
    following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用`sudo`登录密码，请使用以下命令编辑`sudo`配置文件：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following line and save the configuration file. Replace `packt` with
    your username if it’s different:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下行并保存配置文件。如果用户名不同，请将`packt`替换为您的用户名：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You’ll have to make this change on all managed hosts.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在所有托管主机上进行此更改。
- en: Next, we’ll look at the initial setup for the Ansible control node.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看Ansible控制节点的初始设置。
- en: Setting up the Ansible control node
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置Ansible控制节点
- en: 'The Ansible `neptune`) interacts with `ans-web1`, `ans-web2`, `ans-db1`, and
    `ans-db2`) using Ansible commands and playbooks. For convenience, our examples
    will reference the managed hosts by their hostnames instead of their IP addresses.
    To easily accomplish this, we added the following entries to the `/etc/hosts`
    file on the Ansible control node (`neptune`):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible `neptune`与`ans-web1`、`ans-web2`、`ans-db1`和`ans-db2`通过Ansible命令和剧本进行交互。为了方便起见，我们的示例将使用托管主机的主机名而不是IP地址。为了轻松实现这一点，我们在Ansible控制节点（`neptune`）的`/etc/hosts`文件中添加了以下条目：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You’ll have to match the hostnames and IP addresses according to your VM environment.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要根据虚拟机环境匹配主机名和IP地址。
- en: Next, we must install Ansible on our managed hosts too. Use the related procedure
    described in the *Installing Ansible* section earlier in this chapter, when we
    showed you how to install Ansible on the control node. In our case, we followed
    the steps in the *Installing Ansible using pip* section to benefit from the latest
    Ansible release at the time of writing.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须在托管主机上安装Ansible。使用本章早些时候描述的*安装Ansible*部分中介绍的相关步骤，我们展示了如何在控制节点上安装Ansible。在我们的案例中，我们按照*使用pip安装Ansible*部分中的步骤操作，以便享受撰写时的最新Ansible版本。
- en: Finally, we’ll set up SSH key-based authentication between the Ansible control
    node and the managed hosts.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将设置Ansible控制节点与托管主机之间的SSH密钥认证。
- en: Setting up SSH key-based authentication
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置SSH密钥认证
- en: Ansible uses SSH communication with managed hosts. The SSH key authentication
    mechanism enables remote SSH access without the need to enter user passwords.
    To enable SSH key-based authentication, run the following commands on the Ansible
    control host (`neptune`).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible使用SSH与托管主机通信。SSH密钥认证机制使得远程SSH访问无需输入用户密码。要启用SSH密钥认证，请在Ansible控制主机（`neptune`）上运行以下命令。
- en: 'Use the following command to generate a secure key pair and follow the default
    prompts:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令生成一个安全的密钥对，并按照默认提示操作：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With the key pair generated, copy the related public key to each managed host.
    You’ll have to target one host at a time and authenticate with the remote `packt`
    user’s password. Accept the SSH key exchange when prompted:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 生成密钥对后，将相关的公钥复制到每个受管主机。你需要一次针对一个主机，并使用远程`packt`用户的密码进行身份验证。当提示时，接受 SSH 密钥交换：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, you should be able to SSH into any of the managed hosts from the Ansible
    control node (`neptune`) without being prompted for a password. For example, to
    access `ans-web1`, you can test it with the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够从 Ansible 控制节点（`neptune`）通过 SSH 访问任何受管主机，而不需要输入密码。例如，要访问`ans-web1`，你可以用以下命令进行测试：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The command will take you to the remote server’s (`ans-web1`) Terminal. Make
    sure you go back to the Ansible control node’s Terminal (on `neptune`) before
    following the next steps.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将带你进入远程服务器（`ans-web1`）的终端。确保在继续执行下一步之前，回到 Ansible 控制节点（`neptune`）的终端。
- en: We’re now ready to configure Ansible on the control node.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好在控制节点上配置 Ansible。
- en: Configuring Ansible
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Ansible
- en: This section explores some of the basic configuration concepts of Ansible that
    are related to the Ansible **configuration file** and **inventory**. Using a configuration
    file and the parameters within, we can change the *behavior* of Ansible, such
    as privilege escalation, connection timeout, and default inventory file path.
    The inventory defines managed hosts, acting as the CMDB of Ansible.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将探讨与 Ansible **配置文件**和**清单**相关的一些基本配置概念。通过使用配置文件及其内部的参数，我们可以改变 Ansible 的*行为*，例如特权升级、连接超时和默认清单文件路径。清单定义了受管主机，充当
    Ansible 的 CMDB。
- en: Let’s look at the Ansible configuration file first.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看 Ansible 配置文件。
- en: Creating an Ansible configuration file
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Ansible 配置文件
- en: 'The following command provides some helpful information about our Ansible environment,
    including the current configuration file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令提供了一些关于我们的 Ansible 环境的有用信息，包括当前的配置文件：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here’s the complete output of the preceding command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述命令的完整输出：
- en: '![Figure 17.3 – The default Ansible configuration settings](img/B19682_17_03.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.3 – 默认的 Ansible 配置设置](img/B19682_17_03.jpg)'
- en: Figure 17.3 – The default Ansible configuration settings
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.3 – 默认的 Ansible 配置设置
- en: A default Ansible installation will set the configuration file path to `/etc/ansible/ansible.cfg`.
    As you can probably guess, the default configuration file has a *global scope*,
    which means that it’s used by default when we run Ansible tasks.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 Ansible 安装会将配置文件路径设置为`/etc/ansible/ansible.cfg`。正如你可能猜到的，默认的配置文件具有*全局范围*，这意味着当我们运行
    Ansible 任务时，默认使用的是这个文件。
- en: 'Now, let’s look at some different scenarios and how they can be addressed:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些不同的场景以及如何解决这些问题：
- en: 'What if there are multiple users on the same control host running Ansible tasks?
    Our instinct suggests that each user may have their own set of configuration parameters.
    Ansible resolves this problem by looking into the user’s home directory for the
    `~/.ansible.cfg` file. Let’s verify this behavior by creating a dummy configuration
    file in our user’s (`packt`) home directory:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在同一控制主机上有多个用户运行 Ansible 任务怎么办？我们的直觉告诉我们，每个用户可能会有自己的一套配置参数。Ansible 通过查找用户的主目录中的`~/.ansible.cfg`文件来解决这个问题。让我们通过在用户（`packt`）的主目录中创建一个虚拟配置文件来验证这一行为：
- en: '[PRE21]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![Figure 17.4 – Changing the default configuration file](img/B19682_17_04.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.4 – 更改默认配置文件](img/B19682_17_04.jpg)'
- en: Figure 17.4 – Changing the default configuration file
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.4 – 更改默认配置文件
- en: In other words, `~/.ansible.cfg` takes precedence over the global `/etc/ansible/ansible.cfg`
    configuration file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`~/.ansible.cfg`会优先于全局的`/etc/ansible/ansible.cfg`配置文件。
- en: Now, suppose our user (`packt`) creates multiple Ansible projects, some managing
    on-premises hosts and others interacting with public cloud resources. Again, we
    may need a different set of Ansible configuration parameters (such as a connection
    timeout and inventory file). Ansible accommodates this scenario by looking for
    the `./ansible.cfg` file in the current folder.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，假设我们的用户（`packt`）创建了多个 Ansible 项目，其中一些管理本地主机，其他则与公共云资源交互。同样，我们可能需要一套不同的 Ansible
    配置参数（例如连接超时和清单文件）。Ansible 通过在当前文件夹中查找`./ansible.cfg`文件来适应这种情况。
- en: 'Let’s create a dummy `ansible.cfg` file in a new `~/``ansible/` directory:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们在新的`~/ansible/`目录中创建一个虚拟的`ansible.cfg`文件：
- en: '[PRE22]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![Figure 17.5 – Changing the current directory and configuration file](img/B19682_17_05.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.5 – 更改当前目录和配置文件](img/B19682_17_05.jpg)'
- en: Figure 17.5 – Changing the current directory and configuration file
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.5 – 更改当前目录和配置文件
- en: We could have named our project directory anything, not necessarily `/home/packt/ansible`.
    Ansible prioritizes the `./ansible.cfg` file over the `~/.ansible.cfg` configuration
    file in the user’s home directory.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以将项目目录命名为任何名字，不一定非得是`/home/packt/ansible`。Ansible优先使用`./ansible.cfg`文件，而不是用户主目录中的`~/.ansible.cfg`配置文件。
- en: Finally, we may want the ultimate flexibility of a configuration file that doesn’t
    depend on the directory or location originating from our Ansible commands. Such
    a feature could be helpful while testing ad hoc configurations without altering
    the main configuration file. For this purpose, Ansible reads the `ANSIBLE_CONFIG`
    environment variable for the path of the configuration file.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们可能希望拥有一个不依赖于目录或来自Ansible命令的原始位置的配置文件的终极灵活性。这种功能在测试临时配置时非常有用，而不会更改主配置文件。为此，Ansible会读取`ANSIBLE_CONFIG`环境变量，以获取配置文件的路径。
- en: 'Assuming we are in the `~/ansible` project folder, where we already have our
    local `ansible.cfg` file defined, let’s create a dummy test configuration file
    named `test.cfg`:'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设我们已经在`~/ansible`项目文件夹中，并且已经定义了本地的`ansible.cfg`文件，现在让我们创建一个名为`test.cfg`的虚拟测试配置文件：
- en: '[PRE23]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output shows the following:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 17.6 – Verifying reading of the new configuration file](img/B19682_17_06.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图17.6 – 验证读取新配置文件](img/B19682_17_06.jpg)'
- en: Figure 17.6 – Verifying reading of the new configuration file
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.6 – 验证读取新配置文件
- en: We should note that the configuration file should always have the `.cfg` extension.
    Otherwise, Ansible will discard it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注意，配置文件应该始终具有`.cfg`扩展名，否则Ansible会忽略它。
- en: 'Here’s a list summarizing the order of precedence in descending order for Ansible
    configuration files:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个总结Ansible配置文件优先级顺序的列表，从高到低：
- en: The `ANSIBLE_CONFIG` environment variable
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ANSIBLE_CONFIG`环境变量'
- en: The `./ansible.cfg` file in the local directory
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地目录中的`./ansible.cfg`文件
- en: The `~/.ansible.cfg` file in the user’s home directory
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户主目录中的`~/.ansible.cfg`文件
- en: '`/``etc/ansible/ansible.cfg`'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/``etc/ansible/ansible.cfg`'
- en: 'In our examples, we’ll rely on the `ansible.cfg` configuration file in a local
    project directory (`~/ansible`). Let’s create this configuration file and leave
    it empty for now:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将依赖位于本地项目目录（`~/ansible`）中的`ansible.cfg`配置文件。现在让我们创建这个配置文件，并先将其留空：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For the rest of this chapter, we’ll run our Ansible commands from the `~/ansible`
    folder unless we specify otherwise.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将从`~/ansible`文件夹运行我们的Ansible命令，除非我们另行指定。
- en: Unless we specifically define (override) configuration parameters in our configuration
    file, Ansible will assume the system defaults. One of the attributes that we’ll
    add to the config file is the inventory file path. But first, we’ll need to create
    an inventory. The following section will show you how.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们在配置文件中明确定义（覆盖）配置参数，否则Ansible将假设使用系统默认值。我们将添加到配置文件中的属性之一是清单文件路径。但首先，我们需要创建一个清单。接下来的部分将向你展示如何操作。
- en: Creating an Ansible inventory
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Ansible清单
- en: An Ansible inventory is a regular **INI** or **YAML** file describing the managed
    hosts. In its simplest form, the inventory could be a flat list of hostnames or
    IP addresses, but Ansible can also organize the hosts into **groups**. Ansible
    inventory files are either **static** or **dynamic**, depending on whether they
    are created and updated manually or dynamically. For now, we’ll use a static inventory.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible清单是一个常规的**INI**或**YAML**文件，用于描述被管理的主机。它最简单的形式可能是一个平面列表，列出主机名或IP地址，但Ansible也可以将主机组织成**组**。Ansible清单文件可以是**静态**的或**动态**的，具体取决于它们是手动创建和更新的，还是动态生成的。现在，我们将使用静态清单。
- en: 'In our demo environment with two web servers (`ans-web1`, `ans-web2`) and two
    database servers (`ans-db1`, `ans-db2`), we can define the following inventory
    (in INI format) in a file named `hosts` (located inside `~/ansible`) that we will
    create later on, as shown in *Figure 17**.7*:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的演示环境中，拥有两台Web服务器（`ans-web1`、`ans-web2`）和两台数据库服务器（`ans-db1`、`ans-db2`），我们可以在一个名为`hosts`的文件中定义以下清单（采用INI格式）（稍后在`~/ansible`中创建），如*图17.7*所示：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We classified our hosts into a couple of groups, featured in bracketed names;
    that is, `[webservers]` and `[databases]`. As discussed earlier, groups are logical
    arrangements of hosts based on specific criteria. Hosts can be part of multiple
    groups. Group names are case-sensitive, should always start with a letter, and
    should not contain hyphens (`-`) or spaces.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主机分类为几个组，组名用括号表示；即 `[webservers]` 和 `[databases]`。如前所述，组是基于特定标准对主机的逻辑安排。主机可以属于多个组。组名是区分大小写的，应该始终以字母开头，并且不应包含连字符（`-`）或空格。
- en: 'Ansible has two default groups:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 有两个默认组：
- en: '`all`: Every host in the inventory'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all`：清单中的每个主机'
- en: '`ungrouped`: Every host in `all` that is not a member of another group'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ungrouped`：`all` 中每个不是其他组成员的主机'
- en: 'We can also define groups based on specific patterns. For example, the following
    group includes a range of hostnames starting with `ans-web` and ending with a
    number in the range of `1`-`2`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以根据特定模式定义组。例如，以下组包括一系列主机名，主机名以 `ans-web` 开头，并以数字范围 `1`-`2` 结尾：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Patterns are helpful when we’re managing a large number of hosts. For example,
    the following pattern includes all the hosts within a range of IP addresses:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 模式在我们管理大量主机时非常有用。例如，以下模式包括一个 IP 地址范围内的所有主机：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Ranges are defined as `[START:END]` and include all values from `START` to `END`.
    Examples of ranges are `[1:10]`, `[01:10]`, and `[a-g]`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 范围定义为 `[START:END]`，并包括从 `START` 到 `END` 的所有值。范围的示例有 `[1:10]`、`[01:10]` 和 `[a-g]`。
- en: 'Groups can also be nested. In other words, a group may contain other groups.
    This nesting is described with the `:children` suffix. For example, we can define
    a `[platforms]` group that includes the `[ubuntu]` and `[debian]` groups (all
    our VMs are running on Ubuntu, so this is only for explaining purposes):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 组也可以嵌套。换句话说，一个组可以包含其他组。这种嵌套通过 `:children` 后缀来描述。例如，我们可以定义一个 `[platforms]` 组，其中包含
    `[ubuntu]` 和 `[debian]` 组（由于我们的所有虚拟机都在 Ubuntu 上运行，所以这只是为了解释目的）：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s name our inventory file `hosts`. Please note that we are in the `~/ansible`
    directory. Using a Linux editor of your choice, add the following content to the
    `hosts` file:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将清单文件命名为 `hosts`。请注意，我们处在 `~/ansible` 目录下。使用你选择的 Linux 编辑器，将以下内容添加到 `hosts`
    文件中：
- en: '![Figure 17.7 – The inventory file in INI format](img/B19682_17_07.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.7 – INI 格式的清单文件](img/B19682_17_07.jpg)'
- en: Figure 17.7 – The inventory file in INI format
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.7 – INI 格式的清单文件
- en: 'After saving the inventory file, we can validate it with the following command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 保存清单文件后，我们可以使用以下命令来验证它：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here’s a brief explanation of the command’s parameters:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是命令参数的简要说明：
- en: '`-i (--inventory)`: Specifies the inventory file; that is, `./hosts`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i (--inventory)`：指定清单文件；即 `./hosts`'
- en: '`--list`: Lists the current inventory, as read by Ansible'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--list`：列出当前清单，按 Ansible 读取的方式'
- en: '`--yaml`: Specifies the output format as YAML'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--yaml`：指定输出格式为 YAML'
- en: Upon successfully validating the inventory, the command will show the equivalent
    YAML output (the default output format of the `ansible-inventory` utility is JSON).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 成功验证清单后，命令将显示等效的 YAML 输出（`ansible-inventory` 工具的默认输出格式是 JSON）。
- en: 'So far, we’ve expressed the Ansible inventory in INI format, but we may as
    well use a YAML file instead. The following screenshot shows the output of the
    preceding command in YAML format:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用 INI 格式表示了 Ansible 清单，但我们也可以使用 YAML 文件。以下屏幕截图显示了前面命令在 YAML 格式中的输出：
- en: '![Figure 17.8 – The output in YAML inventory format](img/B19682_17_08.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.8 – YAML 格式清单输出](img/B19682_17_08.jpg)'
- en: Figure 17.8 – The output in YAML inventory format
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.8 – YAML 格式清单输出
- en: The YAML representation could be somewhat challenging, especially with large
    configurations, due to the strict indentation and formatting requirements. We’ll
    continue to use the INI inventory format throughout the rest of this chapter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 表示法可能有些挑战，尤其是在配置较大的情况下，因为它对缩进和格式有严格要求。在本章的其余部分，我们将继续使用 INI 格式的清单。
- en: 'Next, we’ll point Ansible to our inventory. Edit the `./ansible.cfg` configuration
    file and add the following lines:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将指向我们的清单。编辑 `./ansible.cfg` 配置文件，并添加以下行：
- en: '![Figure 17.9 – Pointing to our inventory file](img/B19682_17_09.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.9 – 指向我们的清单文件](img/B19682_17_09.jpg)'
- en: Figure 17.9 – Pointing to our inventory file
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.9 – 指向我们的清单文件
- en: 'After saving the file, we’re ready to run Ansible commands or tasks that target
    our managed hosts. There are two ways we can perform Ansible configuration management
    tasks: using one-off **ad hoc commands** and via **Ansible playbooks**. We’ll
    look at ad hoc commands next.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，我们准备运行针对托管主机的 Ansible 命令或任务。我们可以通过两种方式执行 Ansible 配置管理任务：使用一次性 **临时命令**
    或通过 **Ansible 剧本（playbooks）**。接下来我们将查看临时命令。
- en: Using Ansible ad hoc commands
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ansible 临时命令
- en: Ad hoc commands execute a single Ansible task and provide a quick way to interact
    with our managed hosts. These simple operations are helpful when we’re making
    simple changes and performing testing.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 临时命令执行一个单一的 Ansible 任务，并提供一种与我们管理的主机快速互动的方式。这些简单的操作在我们进行简单更改和执行测试时非常有用。
- en: 'The general syntax of an Ansible ad hoc command is as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 临时命令的一般语法如下：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding command uses an Ansible `MODULE` to perform a particular task
    on select hosts based on a `PATTERN`. The task is described via arguments (`ARGS`).
    You may recall that modules encapsulate a specific functionality, such as managing
    users, packages, and services. To demonstrate the use of ad hoc commands, we’ll
    use some of the most common Ansible modules for our configuration management tasks.
    Let’s start with the Ansible `ping` module.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令使用 Ansible `MODULE` 在选择的主机上执行特定任务，基于 `PATTERN` 进行筛选。任务通过参数（`ARGS`）进行描述。你可能还记得，模块封装了特定的功能，如管理用户、软件包和服务。为了演示临时命令的使用，我们将使用一些最常见的
    Ansible 模块来执行配置管理任务。我们从 Ansible `ping` 模块开始。
- en: Working with the ping module
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ping 模块
- en: 'One of the simplest ad hoc commands is the Ansible `ping` test:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的临时命令之一是 Ansible `ping` 测试：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The command performs a quick test on all managed hosts to check their SSH connectivity
    and ensure the required Python modules are present. Here’s an excerpt from the
    output:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令对所有托管主机执行一个快速测试，检查它们的 SSH 连接性并确保所需的 Python 模块已安装。以下是输出的摘录：
- en: '![Figure 17.10 – A successful ping test with a managed host](img/B19682_17_10.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.10 – 与托管主机的成功 ping 测试](img/B19682_17_10.jpg)'
- en: Figure 17.10 – A successful ping test with a managed host
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.10 – 与托管主机的成功 ping 测试
- en: 'The output suggests that the command was successful (`| SUCCESS`) and that
    the remote servers responded with `"pong"` to our ping request (`"ping": "pong"`).
    Please note that the Ansible `ping` module doesn’t use `ping` module inside Ansible
    is just a test module that requires Python; it does not rely on the `ping` command
    we use when troubleshooting network issues.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '输出表明命令执行成功（`| SUCCESS`），并且远程服务器响应我们的 ping 请求，返回了 `"pong"`（`"ping": "pong"`）。请注意，Ansible
    的 `ping` 模块并不使用我们在排查网络问题时使用的 `ping` 命令，而只是一个需要 Python 的测试模块。'
- en: Next, we’ll look at ad hoc commands while using the Ansible `user` module.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 Ansible `user` 模块查看临时命令（ad hoc commands）。
- en: Working with the user module
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用用户模块
- en: 'Here’s another example of an ad hoc command. This one is checking if a particular
    user (`packt`) exists on all the hosts:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个临时命令的示例。这个命令检查特定用户（`packt`）是否存在于所有主机上：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following is an excerpt of the output yielded by a successful check:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是成功检查时产生的输出摘录：
- en: '![Figure 17.11 – Checking if a user account exists](img/B19682_17_11.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.11 – 检查用户帐户是否存在](img/B19682_17_11.jpg)'
- en: Figure 17.11 – Checking if a user account exists
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.11 – 检查用户帐户是否存在
- en: 'The preceding output also suggests that we could be even more specific when
    checking for a user account by also making sure they have a particular user and
    group ID:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出还表明，当检查用户帐户时，我们可以通过确保它们具有特定的用户和组 ID 来变得更加具体：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can target ad hoc commands against a limited subset of our inventory. The
    following command, for example, would only ping the `web1` host for Ansible connectivity:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将临时命令针对我们的库存的一个有限子集进行操作。例如，以下命令仅会对 `web1` 主机进行 Ansible 连接性 ping 测试：
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Host patterns can also include wildcards or group names. Here are a few examples:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 主机模式还可以包括通配符或组名。以下是一些示例：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s look at the available Ansible modules next. Before we do that, you may
    want to add the following line to `./ansible.cfg`, under the `[defaults]` section,
    to keep the noise down about deprecated modules:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下可用的 Ansible 模块。在此之前，你可能想在 `[defaults]` 部分下将以下行添加到 `./ansible.cfg`，以减少有关弃用模块的噪音：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To list all the modules available in Ansible, run the following command:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出 Ansible 中所有可用的模块，请运行以下命令：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You may search or `grep` the output for a particular module. For detailed information
    about a specific module (for example, `user`), you can run the following command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以搜索或使用`grep`命令查找特定模块的输出。要查看某个模块（例如`user`）的详细信息，你可以运行以下命令：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Make sure you check out the `EXAMPLES` section in the `ansible-doc` output for
    a specific module. You will find hands-on examples of using the module with ad
    hoc commands and playbook tasks.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 确保查看`ansible-doc`输出中的`EXAMPLES`部分，以获取特定模块的使用示例。你将看到如何在临时命令和剧本任务中使用该模块的实际例子。
- en: Furthermore, we can create new users for different use cases on our Ansible
    hosts. Next, we will show you how to create a new user.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以为不同的使用场景在 Ansible 主机上创建新用户。接下来，我们将向你展示如何创建一个新用户。
- en: Creating a new user
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建新用户
- en: 'If we want to create a new user (`webuser`) on all our web servers, we can
    perform the related operation with the following ad hoc command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在所有的 Web 服务器上创建一个新用户（`webuser`），可以通过以下临时命令执行相关操作：
- en: '[PRE39]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let’s explain the command’s parameters:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下命令的参数：
- en: '`-b` (`--become`): Changes the execution context to `sudo` (`root`)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-b`（`--become`）：将执行上下文更改为`sudo`（`root`）。'
- en: '`-K` (`--ask-become-pass`): Prompts for the `sudo` password on the remote hosts;
    the same password is used on all managed hosts'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-K`（`--ask-become-pass`）：提示输入远程主机上的`sudo`密码；所有受管主机使用相同的密码。'
- en: '`-m`: Specifies the Ansible module (`user`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-m`：指定 Ansible 模块（`user`）'
- en: '`-a`: Specifies the `user` module arguments as key-value pairs; `name=webuser`
    represents the username, while `state=present` checks whether the user account
    exists before attempting to create it'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-a`：指定`user`模块的参数为键值对；`name=webuser`表示用户名，而`state=present`在尝试创建用户之前检查该用户账户是否已存在。'
- en: '`webservers`: The group of managed hosts targeted by the operation'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webservers`：操作目标的受管主机组'
- en: Creating a user account requires administrative (`sudo`) privileges on the remote
    hosts. Using the `-b` (`--become`) option invokes the related **privilege escalation**
    for the Ansible command to act as a *sudoer* on the remote system.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户账户需要在远程主机上具有管理员（`sudo`）权限。使用`-b`（`--become`）选项会触发相关的**权限提升**，使 Ansible 命令以
    *sudoer* 身份在远程系统上执行。
- en: Important note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: By default, Ansible does not enable `sudo` privileges, you must explicitly set
    the `-b` `(--become`) flag. You can override this behavior in the Ansible configuration
    file.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible 不启用`sudo`权限，你必须显式地设置`-b`（`--become`）标志。你也可以在 Ansible 配置文件中覆盖这一行为。
- en: 'To enable unattended privilege escalation by default, add the following lines
    to the `ansible.cfg` file:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要默认启用无人值守的权限提升，请将以下行添加到`ansible.cfg`文件中：
- en: '![Figure 17.12 – Adding privilege escalation rules](img/B19682_17_12.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.12 – 添加权限提升规则](img/B19682_17_12.jpg)'
- en: Figure 17.12 – Adding privilege escalation rules
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.12 – 添加权限提升规则
- en: Now, you don’t have to specify the `--b` (`--become`) flag anymore with your
    ad hoc commands.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用临时命令时不再需要指定`--b`（`--become`）标志。
- en: 'If the sudoer account on the managed hosts has the `sudo` login password enabled,
    we’ll have to provide it to our ad hoc command. Here is where the `-K` (`--ask-become-pass`)
    option comes in handy. Consequently, we’re asked for a password with the following
    message:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果受管主机上的sudoer账户启用了`sudo`登录密码，我们需要将其提供给临时命令。此时，`-K`（`--ask-become-pass`）选项派上用场。结果，我们将看到以下提示要求输入密码：
- en: '[PRE40]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This password is used across all managed hosts targeted by the command.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 此密码在所有受命令影响的受管主机上使用。
- en: 'As you may recall, we disabled the `sudo` login password on our managed hosts
    (see the *Setting up the lab environment* section earlier in this chapter). Therefore,
    we can rewrite the previous ad hoc command without explicitly asking for privilege
    escalation and the related password:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记得，我们已经在受管主机上禁用了`sudo`登录密码（见本章前面“设置实验环境”部分）。因此，我们可以重写之前的临时命令，而无需显式要求权限提升和相关密码：
- en: '[PRE41]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There are some security concerns regarding privilege escalation, and Ansible
    has the mechanisms to mitigate the related risks. For more information on this
    topic, you may refer to [https://docs.ansible.com/ansible/latest/user_guide/become.html](https://docs.ansible.com/ansible/latest/user_guide/become.html).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 关于权限提升存在一些安全隐患，Ansible 提供了机制来缓解相关风险。如需更多关于此主题的信息，可以参考[https://docs.ansible.com/ansible/latest/user_guide/become.html](https://docs.ansible.com/ansible/latest/user_guide/become.html)。
- en: 'The preceding command produces the following output:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将生成以下输出：
- en: '![Figure 17.13 – Creating a new user using an ad hoc command](img/B19682_17_13.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.13 – 使用临时命令创建新用户](img/B19682_17_13.jpg)'
- en: Figure 17.13 – Creating a new user using an ad hoc command
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.13 – 使用临时命令创建新用户
- en: You may have noticed that the output text here is highlighted, as it was with
    our previous ad hoc commands. Ansible highlights the output if it corresponds
    to a change in the *desired state* of the managed host. If you run the same command
    a second time, the output will not be highlighted, suggesting that there’s been
    no change since the user account has been already created. Here, we can see Ansible’s
    *idempotent operation* at work.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到这里的输出文本被高亮显示，就像我们之前使用临时命令时一样。Ansible 会在输出文本表示管理主机的*期望状态*发生变化时进行高亮显示。如果你第二次运行相同的命令，输出将不会被高亮显示，表明自从用户账户已经创建后没有发生变化。在这里，我们可以看到
    Ansible 的 *幂等性操作*。
- en: With the previous command, we created a user without a password for demo purposes
    only. What if we want to add or modify the password? Next, we will show you how
    to do that.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，我们创建了一个没有密码的用户，仅用于演示。如果我们想添加或修改密码怎么办呢？接下来，我们将向您展示如何操作。
- en: Adding or modifying a password
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加或修改密码
- en: 'Glossing through the `user` module’s documentation with `ansible-doc user`,
    we can use the password field inside the module arguments, but Ansible will only
    accept `passlib`. Let’s install it on the Ansible control node with the following
    command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览 `user` 模块文档（使用 `ansible-doc user`），我们可以在模块参数中使用密码字段，但 Ansible 只接受 `passlib`。我们可以通过以下命令在
    Ansible 控制节点上安装它：
- en: '[PRE42]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You’ll need the Python package manager (`pip`) to run the previous command.
    If you installed Ansible using `pip`, you should be fine. Otherwise, follow the
    instructions in the *Installing Ansible using pip* section to download and install
    `pip`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要 Python 包管理器（`pip`）才能运行上述命令。如果您是通过 `pip` 安装的 Ansible，应该没有问题。否则，请按照 *使用 pip
    安装 Ansible* 部分的说明下载并安装 `pip`。
- en: 'With `passlib` installed, we can use the following ad hoc command to create
    or modify the user password:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 `passlib` 后，我们可以使用以下临时命令来创建或修改用户密码：
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here are the additional parameters helping with the user password:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是帮助设置用户密码的附加参数：
- en: '`-e` (`--extra-vars`): Specifies custom variables as key-value pairs; we set
    the value of a custom variable to `password=changeit!`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e` (`--extra-vars`): 以键值对的形式指定自定义变量；我们将自定义变量的值设置为 `password=changeit!`。'
- en: '`update_password=always`: Updates the password if it’s different from the previous
    one'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_password=always`：如果密码与之前的不同，则更新密码。'
- en: '`password={{...}}`: Sets the password to the value of the expression enclosed
    within double braces'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password={{...}}`：将密码设置为双大括号内表达式的值。'
- en: '`password | password_hash(''sha512'')`: Pipes the value of the `password` variable
    (`changeit!`) to the `password_hash()` function, thus generating an SHA-512 hash;
    `password_hash()` is part of the `passlib` module we installed earlier'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password | password_hash(''sha512'')`：将 `password` 变量（`changeit!`）的值传递给 `password_hash()`
    函数，从而生成 SHA-512 哈希值；`password_hash()` 是我们之前安装的 `passlib` 模块的一部分。'
- en: 'The command sets the password of `webuser` to `changeit!`, and is an example
    of using variables (`password`) in ad hoc commands. Here’s the related output:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将 `webuser` 的密码设置为 `changeit!`，并演示了如何在临时命令中使用变量（`password`）。以下是相关输出：
- en: '![Figure 17.14 – Changing the user’s password using an ad hoc command](img/B19682_17_14.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.14 – 使用临时命令更改用户密码](img/B19682_17_14.jpg)'
- en: Figure 17.14 – Changing the user’s password using an ad hoc command
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.14 – 使用临时命令更改用户密码
- en: Ansible won’t show the actual password for obvious security reasons.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全原因，Ansible 不会显示实际的密码。
- en: Now, you can try to SSH into any of the web servers (`web1` or `web2`) using
    the `webuser` account, and you should be able to authenticate successfully with
    the `changeit!` password.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以尝试通过 `webuser` 账户 SSH 登录到任何一台 Web 服务器（`web1` 或 `web2`），并应能使用 `changeit!`
    密码成功进行身份验证。
- en: Deleting a user
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除用户
- en: 'To delete the `webuser` account on all web servers, we can run the following
    ad hoc command:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除所有 Web 服务器上的 `webuser` 账户，我们可以运行以下临时命令：
- en: '[PRE44]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `state=absent` module parameter invokes the deletion of the `webuser` account.
    The `remove` and `force` parameters are equivalent to the `userdel -rf` command,
    deleting the user’s home directory and any files within, even if they’re not owned
    by the user.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`state=absent` 模块参数会触发删除 `webuser` 账户。`remove` 和 `force` 参数相当于 `userdel -rf`
    命令，删除用户的主目录及其中的所有文件，即使这些文件不是该用户所有的。'
- en: 'The related output is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 相关输出如下：
- en: '![Figure 17.15 – Deleting a user account using an ad hoc command](img/B19682_17_15.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.15 – 使用临时命令删除用户账户](img/B19682_17_15.jpg)'
- en: Figure 17.15 – Deleting a user account using an ad hoc command
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.15 – 使用临时命令删除用户账户
- en: You may safely ignore `stderr` and `stderr_lines`, which were captured in the
    output. The message is benign since the user didn’t create a mail spool previously.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以安全地忽略输出中捕获的`stderr`和`stderr_lines`，因为这些信息无关紧要，因为用户之前并没有创建邮件队列。
- en: We’ll look at the `package` module next and run a few related ad hoc commands.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将查看`package`模块，并运行一些相关的临时命令。
- en: Working with the package module
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`package`模块
- en: 'The following command installs the `webserver` group:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令安装`webserver`组：
- en: '[PRE45]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here’s an excerpt from the output:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出中的摘录：
- en: '![Figure 17.16 – Installing the nginx package on the web servers](img/B19682_17_16.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.16 – 在Web服务器上安装nginx软件包](img/B19682_17_16.jpg)'
- en: Figure 17.16 – Installing the nginx package on the web servers
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.16 – 在Web服务器上安装nginx软件包
- en: 'We use a similar ad hoc command to install the `databases` group:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用类似的临时命令来安装`databases`组：
- en: '[PRE46]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here’s an excerpt from the command’s output:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是命令输出中的摘录：
- en: '![Figure 17.17 – Installing the mysql-server package on the database servers](img/B19682_17_17.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.17 – 在数据库服务器上安装mysql-server软件包](img/B19682_17_17.jpg)'
- en: Figure 17.17 – Installing the mysql-server package on the database servers
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.17 – 在数据库服务器上安装mysql-server软件包
- en: If we wanted to remove a package, the ad hoc command would be similar but would
    feature `state=absent` instead.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要移除一个软件包，临时命令将类似，但会使用`state=absent`代替。
- en: Although the `package` module provides a good OS-level abstraction across various
    platforms, certain package management tasks are best handled with platform-specific
    package managers. We’ll show you how to use the `apt` module next.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`package`模块提供了一个跨平台的良好操作系统抽象，但某些包管理任务最好使用平台特定的包管理器来处理。接下来，我们将展示如何使用`apt`模块。
- en: Working with platform-specific package managers
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用平台特定的包管理器
- en: 'The following ad hoc command installs the latest updates on all Ubuntu machines
    in our managed environment. As all of our VMs are running Ubuntu, we will choose
    to run the commands only on the `webservers` group. The command will be the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下临时命令会在我们管理的环境中的所有Ubuntu机器上安装最新更新。由于所有的虚拟机都运行Ubuntu，我们将仅在`webservers`组上运行这些命令。命令如下：
- en: '[PRE47]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If we wanted, we could create one more group inside the `hosts` file, named
    `[ubuntu]` for example, and add all the VMs in there. This would be easier if
    we had different operating systems running, but that is not the case for us.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以在`hosts`文件中创建一个新的组，命名为`[ubuntu]`，并将所有虚拟机添加到该组。如果我们有不同的操作系统，这样做会更方便，但对我们来说并非如此。
- en: Thee platform-specific package management modules (`apt`, `yum`, and so on)
    match all the capabilities of the system-agnostic `package` module, featuring
    additional OS-exclusive functionality.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 平台特定的包管理模块（如`apt`、`yum`等）具备与系统无关的`package`模块相同的所有功能，同时提供额外的操作系统专用功能。
- en: Let’s look at the `service` module next and a couple of related ad hoc commands.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们看看`service`模块和几个相关的临时命令。
- en: Working with the service module
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`service`模块
- en: 'The following command restarts the `nginx` service on all hosts in the `webservers`
    group:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将在`webservers`组中的所有主机上重启`nginx`服务：
- en: '[PRE48]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here’s a relevant excerpt from the output:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出中的相关摘录：
- en: '![Figure 17.18 – Restarting the nginx service on the web servers](img/B19682_17_18.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.18 – 在Web服务器上重启nginx服务](img/B19682_17_18.jpg)'
- en: Figure 17.18 – Restarting the nginx service on the web servers
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.18 – 在Web服务器上重启nginx服务
- en: In the same way, we can restart the `mysql` service on all database servers,
    but there’s a trick to it! On Ubuntu, the MySQL service is named `mysql`. We could,
    of course, target each host with the appropriate service name, but if you had
    many database servers, it would be a laborious task. Alternatively, we can use
    the *exclusion pattern* (written as `!`) when targeting multiple hosts or groups.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在所有数据库服务器上重启`mysql`服务，但有一个小技巧！在Ubuntu中，MySQL服务的名称是`mysql`。当然，我们可以为每个主机指定适当的服务名称，但如果你有许多数据库服务器，这将是一项繁重的任务。另一种方法是，当目标是多个主机或组时，我们可以使用*排除模式*（用`!`表示）。
- en: 'The following command will restart the `mysql` service on all hosts in the
    `databases` group, except those that are members of the `debian` group (if we
    were to have a `debian` group):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将在`databases`组中的所有主机上重启`mysql`服务，除了那些属于`debian`组的主机（如果我们有一个`debian`组的话）：
- en: '[PRE49]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Similarly, we can restart the `mysqld` service on all hosts in the `databases`
    group, except for those that are members of the `ubuntu` group (if we were to
    have one), with the following ad hoc command:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以通过以下临时命令重启 `databases` 组中所有主机上的 `mysqld` 服务，除了那些属于 `ubuntu` 组（如果我们有的话）的主机：
- en: '[PRE50]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Always use single quotes (`''`) when you’re targeting multiple hosts or groups
    with an exclusion pattern; otherwise, the `ansible` command will fail.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用排除模式针对多个主机或组时，始终使用单引号（`''`）；否则，`ansible` 命令将会失败。
- en: Let’s look at one last Ansible module and the related ad hoc command, which
    is frequently used in upgrade scenarios.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看最后一个 Ansible 模块及其相关的临时命令，它在升级场景中经常使用。
- en: Working with the reboot module
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 reboot 模块
- en: 'The following ad hoc command reboots all hosts in the `webservers` group:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下临时命令重启 `webservers` 组中的所有主机：
- en: '[PRE51]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Slower hosts may take longer to reboot, especially during substantial upgrades,
    hence the increased reboot timeout of `3600` seconds. (The default timeout is
    `600` seconds.)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 较慢的主机可能需要更长的时间来重启，尤其是在进行大规模升级时，因此重启超时时间增加到了 `3600` 秒。（默认超时时间为 `600` 秒。）
- en: 'In our case, the reboot only took a few seconds. The output is as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，重启只用了几秒钟。输出如下：
- en: '![Figure 17.19 – Rebooting the webservers group](img/B19682_17_19.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.19 – 重启 webservers 组](img/B19682_17_19.jpg)'
- en: Figure 17.19 – Rebooting the webservers group
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.19 – 重启 webservers 组
- en: In this section, we showed a few examples of ad hoc commands using different
    modules. The next section will give you a brief overview of some of the most common
    Ansible modules and how to explore more.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了一些使用不同模块的临时命令示例。下一节将简要介绍一些最常用的 Ansible 模块以及如何进一步探索。
- en: Exploring Ansible modules
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Ansible 模块
- en: Ansible has a vast library of modules. As we noted previously, you may use the
    `ansible-doc --list` command to browse the available Ansible modules on the command-line
    Terminal. You can also access the same information online, on the Ansible modules
    index page, at [https://docs.ansible.com/ansible/2.9/modules/modules_by_category.html](https://docs.ansible.com/ansible/2.9/modules/modules_by_category.html).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 拥有一个庞大的模块库。正如我们之前提到的，您可以使用 `ansible-doc --list` 命令在命令行终端中浏览可用的 Ansible
    模块。您还可以在线访问相同的信息，网址为 [https://docs.ansible.com/ansible/2.9/modules/modules_by_category.html](https://docs.ansible.com/ansible/2.9/modules/modules_by_category.html)。
- en: 'The online catalog provides module-by-category indexing to help you quickly
    locate a particular module you’re looking for. Here are some of the most typical
    modules used in everyday system administration and configuration management tasks
    with Ansible:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在线目录提供了按类别索引的模块，帮助你快速定位所需的模块。以下是一些在日常系统管理和配置管理任务中常用的典型模块：
- en: '`apt`: Performs APT package management'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apt`：执行 APT 包管理'
- en: '`yum`: Performs YUM package management'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yum`：执行 YUM 包管理'
- en: '`dnf`: Performs DNF package management'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dnf`：执行 DNF 包管理'
- en: '`users`: Manages users*   `services`: Controls services*   `reboot`: Restarts
    machines*   `firewalld`: Performs firewall management*   `copy`: Copies local
    files to the managed hosts*   `synchronize`: Synchronizes files and directories
    using `rsync`*   `file`: Controls file permissions and attributes*   `lineinfile`:
    Manipulates lines in text files*   `nmcli`: Controls network settings*   `get_url`:
    Downloads files over HTTP, HTTPS, and FTP*   `uri`: Interacts with web services
    and API endpoints*   `raw`: Simply runs a remote command via SSH (which is an
    unsafe practice); doesn’t need Python installed on the remote host*   `command`:
    Runs commands securely using Python’s remote execution context*   `shell`: Executes
    shell commands on managed hosts'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users`：管理用户*   `services`：控制服务*   `reboot`：重启机器*   `firewalld`：执行防火墙管理*   `copy`：将本地文件复制到托管主机*   `synchronize`：使用
    `rsync` 同步文件和目录*   `file`：控制文件权限和属性*   `lineinfile`：操作文本文件中的行*   `nmcli`：控制网络设置*   `get_url`：通过
    HTTP、HTTPS 和 FTP 下载文件*   `uri`：与 Web 服务和 API 端点进行交互*   `raw`：通过 SSH 执行远程命令（这是一种不安全的做法）；不需要在远程主机上安装
    Python*   `command`：使用 Python 的远程执行上下文安全地运行命令*   `shell`：在托管主机上执行 shell 命令'
- en: We should note that ad hoc commands always execute a *single operation* using
    a *single module*. This feature is an advantage (for quick changes) but also a
    limitation. For more complex configuration management tasks, we use Ansible playbooks.
    The following section will take you through the process of authoring and running
    Ansible playbooks.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，临时命令总是使用*单一模块*执行*单一操作*。这个特点是一个优势（用于快速变更），但也是一个限制。对于更复杂的配置管理任务，我们使用 Ansible
    剧本。接下来的部分将带您了解编写和运行 Ansible 剧本的过程。
- en: Using Ansible playbooks
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ansible 剧本
- en: An **Ansible playbook** is essentially a list of tasks that are executed automatically.
    Ansible configuration management workflows are primarily driven by playbooks.
    More precisely, a playbook is a YAML file containing one or more **plays**, each
    with a list of **tasks** executed in the order they are listed. Plays are execution
    units that run the associated tasks against a set of hosts, and they are selected
    via a group identifier or a pattern. Each task uses a single module that executes
    a specific action targeted at the remote host. You may think of a task as a simple
    Ansible ad hoc command. As the majority of Ansible modules comply with idempotent
    execution contexts, playbooks are also idempotent. Running a playbook multiple
    times always yields the same result.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ansible 剧本**本质上是一个任务列表，这些任务会自动执行。Ansible 配置管理工作流主要由剧本驱动。更准确地说，剧本是一个包含一个或多个**play**的
    YAML 文件，每个 play 都有一个任务列表，任务按列出的顺序执行。Play 是执行单元，它将在一组主机上运行相关任务，可以通过组标识符或模式进行选择。每个任务使用一个单一模块，执行针对远程主机的特定操作。你可以将任务视为一个简单的
    Ansible 临时命令。由于大多数 Ansible 模块符合幂等执行环境，剧本也是幂等的。多次运行剧本总是会产生相同的结果。'
- en: Well-written playbooks can replace laborious administrative tasks and complex
    scripts with relatively simple and maintainable manifests, running easily repeatable
    and predictable routines.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 编写良好的剧本可以将繁琐的管理任务和复杂的脚本替换为相对简单且易于维护的清单，从而运行易于重复且可预测的例程。
- en: We’ll create our first Ansible playbook next.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将创建我们的第一个 Ansible 剧本。
- en: Creating a simple playbook
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个简单的剧本。
- en: 'We’ll build our playbook based on the ad hoc command we used for creating a
    user (`webuser`). As a quick refresher, the command was as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于用于创建用户（`webuser`）的临时命令来构建剧本。快速回顾一下，命令如下：
- en: '[PRE52]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As we write the equivalent playbook, you may notice some resemblance to the
    ad hoc command parameters.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写等效的剧本时，你可能会注意到一些与临时命令参数的相似之处。
- en: 'While editing the playbook YAML file, please be aware of the YAML formatting
    rules:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑剧本 YAML 文件时，请注意 YAML 格式规则。
- en: Use only space characters for indentation (no tabs)
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用空格字符进行缩进（禁止使用制表符）。
- en: Keep the indentation length consistent (for example, two spaces)
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持一致的缩进长度（例如，两个空格）。
- en: Items at the same level in the hierarchy (for example, list items) must have
    the same indentation
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层级结构中相同级别的项（例如，列表项）必须具有相同的缩进。
- en: A child item’s indentation is one indentation more than its parent
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子项的缩进比父项多一个缩进级别。
- en: 'Now, using a Linux editor of your choice, add the following lines to a `create-user.yml`
    file. Make sure you create the playbook in the `~/ansible` project directory,
    which is where we have our current inventory (`hosts`) and Ansible configuration
    file (`ansible.cfg`):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用你喜欢的 Linux 编辑器，将以下行添加到 `create-user.yml` 文件中。确保将剧本创建在 `~/ansible` 项目目录中，这里存放着我们的当前库存文件（`hosts`）和
    Ansible 配置文件（`ansible.cfg`）：
- en: '![Figure 17.20 – A simple playbook for creating a user](img/B19682_17_20.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.20 – 创建用户的简单剧本](img/B19682_17_20.jpg)'
- en: Figure 17.20 – A simple playbook for creating a user
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.20 – 创建用户的简单剧本
- en: 'Let’s look at each line in our `create-user.yml` playbook:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 `create-user.yml` 剧本中的每一行：
- en: '`---`: Marks the beginning of the playbook file'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`---`：标记剧本文件的开始。'
- en: '`- name`: Describes the name of the play; we can have one or more plays in
    a playbook'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`- name`：描述 play 的名称；在一个剧本中我们可以有一个或多个 play。'
- en: '`hosts: webservers`: Targets the hosts in the `webservers` group'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hosts: webservers`：指定目标主机为 `webservers` 组中的主机。'
- en: '`become: yes`: Enables privilege escalation for the current task; you can leave
    this line out if you enabled unattended privilege escalation in your Ansible configuration
    file (with `become = True` in the `[``privileged_escalation]` section)'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`become: yes`：为当前任务启用特权提升；如果你在 Ansible 配置文件中启用了无人值守特权提升（在 `[privileged_escalation]`
    部分中设置 `become = True`），则可以省略此行。'
- en: '`tasks`: The list of tasks in the current play'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasks`：当前 play 中任务的列表。'
- en: '`- name`: The name of the current task; we can have multiple tasks in a play'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`- name`：当前任务的名称；一个 play 中可以包含多个任务'
- en: '`user`: The module being used by the current task'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`：当前任务所使用的模块'
- en: '`name: webuser`: The name of the user account to create'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name: webuser`：要创建的用户帐户的名称'
- en: '`state: present`: The desired state upon creating the user – we want the user
    account to be present on the system'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state: present`：创建用户时的期望状态——我们希望用户帐户在系统中存在'
- en: 'Let’s run our `create-user.yml` playbook:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 `create-user.yml` playbook：
- en: '[PRE53]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here’s the output we get after a successful playbook run:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在成功运行 playbook 后得到的输出：
- en: '![Figure 17.21 – Running the create-user.yml playbook](img/B19682_17_21.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.21 – 运行 create-user.yml playbook](img/B19682_17_21.jpg)'
- en: Figure 17.21 – Running the create-user.yml playbook
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.21 – 运行 create-user.yml playbook
- en: 'Most of the `ansible-playbook` command-line options are similar to the ones
    for the `ansible` command. Let’s look at some of these parameters:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 `ansible-playbook` 命令行选项与 `ansible` 命令类似。我们来看看其中的一些参数：
- en: '`-i` (`--inventory`): Specifies an inventory file path'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i` (`--inventory`)：指定库存文件的路径'
- en: '`-b` (`--become`): Enables privilege escalation to `sudo` (`root`)'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-b` (`--become`)：启用特权升级为 `sudo`（`root`）'
- en: '`-C` `(--check`): Produces a dry run without making any changes and anticipating
    the end results – a useful option for validating playbooks'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-C` `(--check)`：进行干运行，不做任何更改并预测最终结果——这是验证 playbook 的有用选项'
- en: '`-l` (`--limit`): Limits the action of the command or playbook to a subset
    of managed hosts'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-l` (`--limit`)：将命令或 playbook 的作用限制为一部分被管理的主机'
- en: '`--syntax-check`: Validates the playbook’s syntax without making any changes;
    this option is only available for the `ansible-playbook` command'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--syntax-check`：验证 playbook 的语法而不进行任何更改；此选项仅适用于 `ansible-playbook` 命令'
- en: 'Let’s experiment with a second playbook, this time for deleting a user. We’ll
    name the playbook `delete-user.yml` and add the following content:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试第二个 playbook，这次是用来删除用户的。我们将命名该 playbook 为 `delete-user.yml` 并添加以下内容：
- en: '![Figure 17.22 – A simple playbook for deleting a user](img/B19682_17_22.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.22 – 删除用户的简单 playbook](img/B19682_17_22.jpg)'
- en: Figure 17.22 – A simple playbook for deleting a user
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.22 – 删除用户的简单 playbook
- en: 'Now, let’s run this playbook:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行这个 playbook：
- en: '[PRE54]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下：
- en: '![Figure 17.23 – Limiting the delete-user.yml playbook to the Ubuntu host group](img/B19682_17_23.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.23 – 将 delete-user.yml playbook 限制为 Ubuntu 主机组](img/B19682_17_23.jpg)'
- en: Figure 17.23 – Limiting the delete-user.yml playbook to the Ubuntu host group
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.23 – 将 delete-user.yml playbook 限制为 Ubuntu 主机组
- en: Next, we’ll look at ways to further streamline our configuration management
    workflows, starting with the use of variables in playbooks.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索如何进一步简化我们的配置管理工作流，从在 playbook 中使用变量开始。
- en: Using variables in playbooks
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 playbook 中使用变量
- en: Ansible provides a flexible and versatile model for working with variables in
    both playbooks and ad hoc commands. Through variables, we are essentially *parameterizing*
    a playbook, making it reusable or dynamic.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 提供了一个灵活多变的模型，用于在 playbook 和临时命令中处理变量。通过变量，我们本质上是在 *参数化* 一个 playbook，使其可重用或动态化。
- en: Take our previous playbook, for example, to create a user. We hardcoded the
    username (`webuser`) in the playbook. We can’t really reuse the playbook to create
    another user (for example, `webadmin`) unless we add the related task to it. But
    then, if we had many users, our playbook would grow proportionally, making it
    harder to maintain. And what if we wanted to specify a password for each user
    as well? The complexity of the playbook would grow even more.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们之前的 playbook 为例，创建一个用户。我们将用户名（`webuser`）硬编码到 playbook 中。如果我们想为另一个用户（例如 `webadmin`）创建帐户，我们无法重用这个
    playbook，除非我们将相关任务添加到其中。但如果我们有很多用户，playbook 将按比例增长，导致维护变得更加困难。如果我们还想为每个用户指定密码呢？那么
    playbook 的复杂性将会大大增加。
- en: Here’s where **variables** come into play. Let’s first look at what variables
    are and how they are written.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 **变量** 发挥作用的地方。让我们首先了解变量是什么以及如何书写它们。
- en: Introducing variables
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 引入变量
- en: 'We can substitute the hardcoded values with variables, making the playbook
    dynamic. In terms of pseudocode, our example of using a playbook to create a user
    with specific `username` and `password` variables would look like this:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用变量替代硬编码的值，使 playbook 变得动态。在伪代码的层面上，使用 playbook 创建具有特定 `username` 和 `password`
    变量的用户的示例如下：
- en: '[PRE55]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Variables in Ansible are enclosed in double braces; for example, `{{ username
    }}`. Let’s see how we can leverage variables in our playbooks. Edit the `create-user.yml`
    playbook we worked on in the previous section and adjust it as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 中的变量用双括号括起来；例如，`{{ username }}`。让我们看看如何在剧本中利用变量。编辑我们在上一节中处理的 `create-user.yml`
    剧本，并按以下方式调整：
- en: '![Figure 17.24 – Using the “username” variable in a playbook](img/B19682_17_24.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.24 – 在剧本中使用“username”变量](img/B19682_17_24.jpg)'
- en: Figure 17.24 – Using the “username” variable in a playbook
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.24 – 在剧本中使用“username”变量
- en: We use the `{{ username }}` variable substituting our previously hardcoded value
    (`webuser`). Then, we surrounded the double braces with quotes to avoid syntax
    interference with the YAML dictionary notation. Variable names in Ansible must
    begin with a letter and only contain alphanumerical characters and underscores.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `{{ username }}` 变量替代我们之前硬编码的值（`webuser`）。然后，我们将双括号用引号包裹起来，以避免与 YAML 字典表示法发生语法冲突。Ansible
    中的变量名必须以字母开头，并且只能包含字母数字字符和下划线。
- en: Setting values for variables
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为变量设置值
- en: 'Next, we’ll explain *how* and *where* to set values for variables. Ansible
    implements a hierarchical model for assigning values to variables:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将解释 *如何* 和 *在哪里* 设置变量值。Ansible 实现了一个层次化的模型来为变量分配值：
- en: '`–extra-vars ansible-playbook` command-line parameter or the `./``group_vars/all`
    file.'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`–extra-vars ansible-playbook` 命令行参数或 `./group_vars/all` 文件。'
- en: '`./group_vars` directory in files named after each group.'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`./group_vars` 目录中每个组命名的文件。'
- en: '`./host_vars` directory in files named after each host. Host-specific variables
    are also available from `gather_facts` directive. You can learn more about Ansible
    facts at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_vars_facts.html#ansible-facts](https://docs.ansible.com/ansible/latest/user_guide/playbooks_vars_facts.html#ansible-facts).'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`./host_vars` 目录中每个主机命名的文件。主机特定的变量也可以通过 `gather_facts` 指令获取。您可以在 [https://docs.ansible.com/ansible/latest/user_guide/playbooks_vars_facts.html#ansible-facts](https://docs.ansible.com/ansible/latest/user_guide/playbooks_vars_facts.html#ansible-facts)
    了解更多有关 Ansible 的信息。'
- en: '`vars` directive in a play or `include_vars` tasks.'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 play 或 `include_vars` 任务中的 `vars` 指令。
- en: In the preceding numbered list, the order of precedence for a variable’s value
    increases with each number. In other words, a variable value defined in a play
    will overwrite the same variable value specified at the host, group, or global
    level.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的编号列表中，变量值的优先级随着每个编号增加。换句话说，在 play 中定义的变量值将覆盖在主机、组或全局级别上指定的相同变量值。
- en: 'As an example, you may recall the peculiarity related to the MySQL service
    name on Ubuntu and RHEL/Fedora platforms. On Ubuntu, the service is `mysql`, while
    on Fedora, the service is `mysqld`. Suppose we want to restart the MySQL service
    on all hosts in our `databases` group. Assuming most of our database servers run
    Ubuntu, we can define a group-level `service` variable as `service: mysql`. We
    set this variable in the local project’s `./group_vars/databases` file. Then,
    in the play where we control the service status, we can override the `service`
    variable value with `mysqld` when the remote host’s OS platform is Fedora.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，您可能还记得与 MySQL 服务名称在 Ubuntu 和 RHEL/Fedora 平台上的差异。Ubuntu 上的服务是 `mysql`，而 Fedora
    上的服务是 `mysqld`。假设我们想要重新启动 `databases` 组中所有主机上的 MySQL 服务。假设我们的大部分数据库服务器运行的是 Ubuntu，我们可以在组级别定义一个
    `service` 变量，如 `service: mysql`。我们在本地项目的 `./group_vars/databases` 文件中设置该变量。然后，在我们控制服务状态的
    play 中，当远程主机的操作系统平台为 Fedora 时，我们可以用 `mysqld` 覆盖 `service` 变量值。'
- en: 'Let’s look at a few examples to illustrate what we’ve learned so far about
    placing variables and setting their values. Back in our `create-user.yml` playbook,
    we can define the `username` variable at the play level with the following directive:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看几个例子，来说明我们迄今为止关于变量放置和设置值的知识。在我们的 `create-user.yml` 剧本中，我们可以通过以下指令在剧本级别定义
    `username` 变量：
- en: '[PRE56]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here’s what it looks like in the overall playbook:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是整个剧本的样子：
- en: '![Figure 17.25 – Defining a variable at the play level](img/B19682_17_25.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.25 – 在剧本级别定义变量](img/B19682_17_25.jpg)'
- en: Figure 17.25 – Defining a variable at the play level
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.25 – 在剧本级别定义变量
- en: 'Let’s run our playbook with the following command:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行我们的剧本：
- en: '[PRE57]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A relevant excerpt from the output is shown in the next screenshot:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的相关片段显示在下一个截图中：
- en: '![Figure 17.26 – Creating a user with a playbook using variables](img/B19682_17_26.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.26 – 使用变量创建用户的剧本](img/B19682_17_26.jpg)'
- en: Figure 17.26 – Creating a user with a playbook using variables
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.26 – 使用变量创建用户的剧本
- en: Deleting user accounts
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除用户账户
- en: 'To delete user accounts, we can readjust our previous `delete-user.yml` file
    so that it looks as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除用户账户，我们可以重新调整之前的 `delete-user.yml` 文件，使其如下所示：
- en: '![Figure 17.27 – Deleting a user with a playbook using variables](img/B19682_17_27.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.27 – 使用变量通过 playbook 删除用户](img/B19682_17_27.jpg)'
- en: Figure 17.27 – Deleting a user with a playbook using variables
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.27 – 使用变量通过 playbook 删除用户
- en: 'After saving the file, run the following command to delete the `webuser` account
    on all web servers:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，运行以下命令以删除所有 web 服务器上的 `webuser` 账户：
- en: '[PRE58]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The relevant output from the preceding command run is as follows:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令运行后的相关输出如下：
- en: '![Figure 17.28 – Deleting a user with a playbook using variables](img/B19682_17_28.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.28 – 使用变量通过 playbook 删除用户](img/B19682_17_28.jpg)'
- en: Figure 17.28 – Deleting a user with a playbook using variables
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.28 – 使用变量通过 playbook 删除用户
- en: Enhancing our playbooks
  id: totrans-426
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 优化我们的 playbook
- en: 'We can improve our `create-user` and `delete-user` playbooks even further.
    You can follow these steps:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步优化我们的 `create-user` 和 `delete-user` playbook。您可以按照以下步骤操作：
- en: Since the play exclusively targets the `webservers` group, we can define a `username`
    variable in the `./group_vars/webservers` file instead. This way, we can keep
    the playbooks more compact. Let’s remove the variable definition from both files.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这个 play 只针对 `webservers` 组，我们可以在 `./group_vars/webservers` 文件中定义一个 `username`
    变量。这样，我们可以让 playbook 更加简洁。让我们从两个文件中移除变量定义。
- en: 'Next, create a `./group_vars` folder in the local directory (`~/ansible`) and
    add the following lines to a file named `webservers.yml`:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在本地目录（`~/ansible`）中创建一个 `./group_vars` 文件夹，并向名为 `webservers.yml` 的文件添加以下行：
- en: '[PRE59]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '![Figure 17.29 – The directory tree, including the group_vars folder](img/B19682_17_29.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.29 – 包括 group_vars 文件夹的目录树](img/B19682_17_29.jpg)'
- en: Figure 17.29 – The directory tree, including the group_vars folder
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.29 – 包括 group_vars 文件夹的目录树
- en: 'If we run our playbooks, the results should be identical to our previous runs:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行我们的 playbook，结果应该与之前的运行相同：
- en: '[PRE60]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, let’s add one more variable to our `create-user` playbook: the user’s
    `password` variable. You may recall the ad hoc command we created for the same
    purpose. See the *Using Ansible ad hoc commands* section earlier in this chapter
    for more information.'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在 `create-user` playbook 中再添加一个变量：用户的 `password` 变量。您可能还记得我们为相同目的创建的临时命令。请参阅本章前面“*使用
    Ansible 临时命令*”部分以了解更多信息。
- en: 'Add the following lines to the `create-user.yml` file of the `user` task, at
    the same level as `name`:'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `create-user.yml` 文件的 `user` 任务中，在与 `name` 相同的级别添加以下行：
- en: '[PRE61]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You may notice how these changes are similar to the related ad hoc command.
    The updated playbook contains the following content:'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可能会注意到这些更改与相关的临时命令非常相似。更新后的 playbook 包含以下内容：
- en: '![Figure 17.30 – The playbook with username and password variables](img/B19682_17_30.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.30 – 带有用户名和密码变量的 playbook](img/B19682_17_30.jpg)'
- en: Figure 17.30 – The playbook with username and password variables
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.30 – 带有用户名和密码变量的 playbook
- en: 'Next, edit the `./group_vars/webservers.yml` file and add the `password` variable
    with the `changeit!` value. Your updated file should have the following content:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编辑 `./group_vars/webservers.yml` 文件并添加 `password` 变量，值为 `changeit!`。更新后的文件应包含以下内容：
- en: '![Figure 17.31 – Adding the new variable value inside the webservers.yml file](img/B19682_17_31.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.31 – 在 webservers.yml 文件中添加新变量值](img/B19682_17_31.jpg)'
- en: Figure 17.31 – Adding the new variable value inside the webservers.yml file
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.31 – 在 webservers.yml 文件中添加新变量值
- en: 'Let’s run the playbook:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行 playbook：
- en: '[PRE62]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'webuser account on the web servers with the following command, to get back
    to our initial state:'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 web 服务器上使用以下命令删除 webuser 账户，恢复到初始状态：
- en: '[PRE63]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: -e (--extra-vars) option parameter takes a JSON string featuring the username
    and password fields, along with the corresponding values. These values will *override*
    the values of the same variables defined at the group level in the ./group_vars/webservers.yml
    file.
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -e (--extra-vars) 选项参数接受一个 JSON 字符串，其中包含用户名和密码字段，以及相应的值。这些值将会 *覆盖* 在 `./group_vars/webservers.yml`
    文件中按组级别定义的相同变量值。
- en: '[PRE64]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let’s remove the `webuser` and `webadmin` accounts before we proceed with the
    next steps. Let’s run the `delete-user` playbook, first without any parameters:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续执行下一步之前，让我们先移除 `webuser` 和 `webadmin` 账户。让我们首先不带任何参数运行 `delete-user` playbook：
- en: '[PRE66]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, we’ll use the `-e` (`--extra-vars`) option parameter to delete the `webadmin`
    user:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `-e` (`--extra-vars`) 选项参数来删除 `webadmin` 用户：
- en: '[PRE67]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Using `–extra-vars` with our `create-user` and `delete-user` playbooks, we can
    act on multiple user accounts by running the playbooks manually or in a loop and
    feeding the JSON blob with the required variables. While this method could easily
    be scripted, Ansible provides even more ways to improve our playbooks by using
    task iteration with loops. We’ll look at loops later in this chapter, but first,
    let’s handle our passwords more securely with Ansible’s encryption and decryption
    facilities for managing secrets.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `–extra-vars` 结合我们的 `create-user` 和 `delete-user` playbook，我们可以通过手动运行 playbook
    或在循环中运行 playbook 并提供包含所需变量的 JSON 数据来处理多个用户账户。虽然这种方法可以轻松地通过脚本化实现，Ansible 还提供了更多方式来改进我们的
    playbook，利用循环任务的迭代功能。我们将在本章稍后探讨循环，首先，让我们使用 Ansible 的加密和解密功能更安全地管理我们的密码。
- en: Working with secrets
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理机密数据
- en: Ansible has a dedicated module for managing secrets called **Ansible Vault**.
    With Ansible Vault, we can encrypt and store sensitive data such as variables
    and files that are referenced in playbooks. Ansible Vault is essentially a password-protected
    secure key-value data store.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 有一个专门用于管理机密信息的模块，叫做 **Ansible Vault**。使用 Ansible Vault，我们可以加密并存储敏感数据，例如在
    playbook 中引用的变量和文件。Ansible Vault 本质上是一个受密码保护的安全键值数据存储。
- en: 'To manage our secrets, we can use the `ansible-vault` command-line utility.
    Regarding our playbook, where we’re creating a user with a password, we want to
    avoid storing the password in clear text. It is currently in the `./group_vars/webservers.yml`
    file. As a reminder, our `webservers.yml` file has the following content:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理我们的机密数据，我们可以使用 `ansible-vault` 命令行工具。关于我们的 playbook，在创建用户并设置密码时，我们希望避免将密码以明文存储。目前它存储在
    `./group_vars/webservers.yml` 文件中。提醒一下，我们的 `webservers.yml` 文件包含以下内容：
- en: '![Figure 17.32 – Sensitive data stored in the password variable](img/B19682_17_32.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.32 – 存储在密码变量中的敏感数据](img/B19682_17_32.jpg)'
- en: Figure 17.32 – Sensitive data stored in the password variable
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.32 – 存储在密码变量中的敏感数据
- en: 'The last line contains sensitive data; the password is shown in plain text.
    We have a few options here to protect our data:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行包含敏感数据；密码以明文显示。我们有几个选项可以用来保护我们的数据：
- en: Encrypt the `webservers.yml` file. If we choose to encrypt the `webservers.yml`
    file, we could possibly incur the overhead of encrypting non-sensitive data, such
    as the username or other general-purpose information. If we have many users, encrypting
    and decrypting non-sensitive data would be highly redundant.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 `webservers.yml` 文件进行加密。如果我们选择加密 `webservers.yml` 文件，可能会带来加密非敏感数据（如用户名或其他通用信息）的额外开销。如果我们有很多用户，加密和解密非敏感数据会显得非常冗余。
- en: Encrypt the `password` variable only. This would work fine for a single user.
    But with a growing number of users, we’ll have multiple password variables to
    deal with, each with its own encryption and decryption. Performance will once
    again be an issue if we have a large number of users.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅加密 `password` 变量。这对于单个用户来说完全可行，但随着用户数量的增长，我们将需要处理多个密码变量，每个变量都有自己的加密和解密。如果用户数量庞大，性能将再次成为问题。
- en: Store the password in a separate protected file. Ideally, we should have a separate
    file for storing all sensitive data. This file would be decrypted only once during
    the playbook run, even with multiple passwords stored.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将密码存储在一个单独的受保护文件中。理想情况下，我们应该有一个单独的文件来存储所有敏感数据。即使存储了多个密码，该文件也只会在运行 playbook 时解密一次。
- en: We will pursue the third option and create a separate file to keep our user
    passwords in.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择第三种方式，创建一个单独的文件来存储用户密码。
- en: Protecting our data
  id: totrans-466
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 保护我们的数据
- en: 'Let’s look at the steps that need to be followed to ensure that our data is
    secure:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看需要遵循哪些步骤，以确保我们的数据安全：
- en: 'We’ll name the file `passwords.yml` (we create it inside the `~/ansible/` directory)
    and add the following content to it:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把文件命名为 `passwords.yml`（将其创建在 `~/ansible/` 目录中），并添加以下内容：
- en: '![Figure 17.33 – The passwords.yml file storing sensitive data](img/B19682_17_33.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.33 – 存储敏感数据的 passwords.yml 文件](img/B19682_17_33.jpg)'
- en: Figure 17.33 – The passwords.yml file storing sensitive data
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.33 – 存储敏感数据的 passwords.yml 文件
- en: 'We added a YAML dictionary (or hash) item matching the `webuser` username related
    to the password. This item contains another dictionary as a key-value pair: `password:
    changeit!`. The equivalent YAML representation is as follows:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们添加了一个与 `webuser` 用户名相关的 YAML 字典（或哈希）项，该项包含另一个作为键值对的字典：`password: changeit!`。其等效的
    YAML 表示如下：'
- en: '[PRE68]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This approach will allow us to add passwords that correspond to different users,
    like so:'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法将允许我们添加对应不同用户的密码，像这样：
- en: '[PRE69]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We’ll explain the concept behind this data structure and its use when we consume
    the `password` variable in the playbook, later in this section.
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们在本节后面使用 `password` 变量时，我们将解释这个数据结构背后的概念及其用途。
- en: 'Now, since we keep our password in a different file, we’ll remove the corresponding
    entry from `webusers.yml`. Let’s add some other user-related information using
    the `comment` variable. Here’s what our `webusers.yml` file looks like:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，由于我们将密码保存在一个不同的文件中，我们将从 `webusers.yml` 中移除相应的条目。让我们使用 `comment` 变量添加其他与用户相关的信息。以下是我们的
    `webusers.yml` 文件的样子：
- en: '![Figure 17.34 – The webusers.yml file storing non-sensitive user data](img/B19682_17_34.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![图17.34 – 存储非敏感用户数据的 webusers.yml 文件](img/B19682_17_34.jpg)'
- en: Figure 17.34 – The webusers.yml file storing non-sensitive user data
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.34 – 存储非敏感用户数据的 webusers.yml 文件
- en: 'Next, let’s protect our secrets by encrypting the `passwords.yml` file using
    Ansible Vault:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们通过使用 Ansible Vault 对 `passwords.yml` 文件进行加密来保护我们的机密：
- en: '[PRE70]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: cat passwords.yml
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cat passwords.yml
- en: '[PRE71]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '![Figure 17.35 – The encrypted passwords.yml file](img/B19682_17_35.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![图17.35 – 加密后的 passwords.yml 文件](img/B19682_17_35.jpg)'
- en: Figure 17.35 – The encrypted passwords.yml file
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.35 – 加密后的 passwords.yml 文件
- en: 'We can view the content of the `passwords.yml` file with the following command:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令查看 `passwords.yml` 文件的内容：
- en: '[PRE72]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You’ll be prompted for the vault password we created previously. The output
    shows the streamlined YAML content corresponding to our protected file:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统会提示您输入我们之前创建的 vault 密码。输出显示了与我们的受保护文件对应的简化 YAML 内容：
- en: '![Figure 17.36 – Viewing the content of the protected file](img/B19682_17_36.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![图17.36 – 查看受保护文件的内容](img/B19682_17_36.jpg)'
- en: Figure 17.36 – Viewing the content of the protected file
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.36 – 查看受保护文件的内容
- en: 'If you need to make changes, you can edit the encrypted file with the following
    command:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您需要进行更改，可以使用以下命令编辑加密文件：
- en: '[PRE73]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: ansible-vault rekey passwords.yml
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ansible-vault rekey passwords.yml
- en: '[PRE74]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: You’ll be prompted for the current vault password, followed by the new password.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统会提示您输入当前的 vault 密码，然后是新密码。
- en: Now, let’s learn how to reference secrets in our playbook.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何在 playbook 中引用机密。
- en: Referencing secrets in playbooks
  id: totrans-496
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 playbook 中引用机密
- en: 'To reference secrets, follow these steps:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用机密，请按照以下步骤操作：
- en: 'First, let’s make sure we can read our password from the vault. Let’s make
    a new file with the following lines in it. We will call it `create-user-new.yml`:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们确保可以从 vault 中读取密码。我们将创建一个新文件，内容如下。我们将其命名为 `create-user-new.yml`：
- en: '![Figure 17.37 – Debugging vault access with new create-user-new.yml file](img/B19682_17_37.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![图17.37 – 使用新 create-user-new.yml 文件调试 vault 访问](img/B19682_17_37.jpg)'
- en: Figure 17.37 – Debugging vault access with new create-user-new.yml file
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.37 – 使用新 create-user-new.yml 文件调试 vault 访问
- en: 'We’ve added a couple of tasks:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一些任务：
- en: '`include_vars` (*lines 6*-*8*): Reading variables from the `passwords.yml`
    file'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include_vars` (*第6行*-*第8行*): 从 `passwords.yml` 文件中读取变量'
- en: '`debug` (*lines 10*-*12*): Debugging the playbook and logging the password
    that was read from the vault'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug` (*第10行*-*第12行*): 调试 playbook 并记录从 vault 读取的密码'
- en: 'None of these tasks are *aware* that the `passwords.yml` file is protected.
    *Line 12* is where the magic happens:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务都*没有意识到* `passwords.yml` 文件是受保护的。*第12行* 是魔法发生的地方：
- en: '[PRE75]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We use the `vars[]` dictionary to query a specific variable in the playbook.
    `vars[]` is a *reserved* data structure for storing all the variables that were
    created via `vars` and `include_vars` in an Ansible playbook. We can query the
    dictionary based on a key appointed by `username`:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `vars[]` 字典在 playbook 中查询特定变量。`vars[]` 是一个*保留*数据结构，用于存储所有通过 `vars` 和 `include_vars`
    在 Ansible playbook 中创建的变量。我们可以根据 `username` 指定的键查询该字典：
- en: '[PRE76]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Our playbook gets `username` from the `./group_vars/webservers.yml` file, and
    its value is `webuser`. Consequently, the `vars[webuser]` dictionary item reads
    the corresponding entry from the `passwords.yml` file:'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的 playbook 从 `./group_vars/webservers.yml` 文件中获取 `username`，其值为 `webuser`。因此，`vars[webuser]`
    字典项从 `passwords.yml` 文件中读取相应条目：
- en: '[PRE77]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To get the password value from the corresponding key-value pair, we specify
    the `''password''` key in the `vars[username]` dictionary:'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了从相应的键值对中获取密码值，我们在 `vars[username]` 字典中指定 `'password'` 键：
- en: '[PRE78]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Let’s run this playbook with the following command:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用以下命令运行这个 playbook：
- en: '[PRE79]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '![Figure 17.38 – The playbook successfully reading secrets from the vault](img/B19682_17_38.jpg)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.38 – 剧本成功从保险库中读取机密](img/B19682_17_38.jpg)'
- en: Figure 17.38 – The playbook successfully reading secrets from the vault
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.38 – 剧本成功从保险库中读取机密
- en: Here, we can see that the playbook successfully retrieves the password from
    the vault.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到剧本成功地从保险库中检索到了密码。
- en: 'Let’s wrap up our `create-user-new.yml` playbook by adding the following code:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过添加以下代码来完成 `create-user-new.yml` 剧本：
- en: '![Figure 17.39 – The playbook creating a user with a password retrieved from
    the vault](img/B19682_17_39.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.39 – 使用从保险库中检索的密码创建用户的剧本](img/B19682_17_39.jpg)'
- en: Figure 17.39 – The playbook creating a user with a password retrieved from the
    vault
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.39 – 使用从保险库中检索的密码创建用户的剧本
- en: 'Here are a few highlights of the current implementation:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是当前实现的一些亮点：
- en: We’ve added a `vars` block (`password` variable (at the play scope) for reading
    the password from the vault; we are reusing the `password` variable in multiple
    tasks.
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个 `vars` 块（`password` 变量，位于剧本范围内）来从保险库中读取密码；我们在多个任务中重复使用了 `password` 变量。
- en: The `include_vars` task (`passwords.yml` file.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include_vars` 任务（`passwords.yml` 文件）。'
- en: 'The `debug` task (`no_log: true` enabled (*line 15*) to avoid logging sensitive
    information in the output. When debugging, you can temporarily set `no_log: false`.'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug` 任务（启用 `no_log: true` (*第 15 行*)，以避免在输出中记录敏感信息。当进行调试时，可以临时设置 `no_log:
    false`。'
- en: The `user` task (`password` variable and hashes the corresponding value. This
    hashing is required by the Ansible `user` module for security reasons. We also
    added a `comment` field with additional user information. This field maps to the
    **Linux General Electric Comprehensive Operating System** (**GECOS**) record of
    the user. See the *Managing users* section of [*Chapter 4*](B19682_04.xhtml#_idTextAnchor090),
    *Managing Users and Groups*, for related information.
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user` 任务（`password` 变量并哈希对应的值。出于安全原因，Ansible `user` 模块需要这种哈希处理。我们还添加了一个 `comment`
    字段，包含额外的用户信息。该字段映射到**Linux通用电气综合操作系统**（**GECOS**）记录。有关详细信息，请参见 [*第 4 章*](B19682_04.xhtml#_idTextAnchor090)
    中的 *用户和组管理* 部分。'
- en: 'Let’s run the playbook with the following command:'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用以下命令运行剧本：
- en: '[PRE80]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: tail -n 10 /etc/passwd
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: tail -n 10 /etc/passwd
- en: '[PRE81]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You should see the following line in the output (you’ll notice the GECOS field
    also):'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在输出中看到以下行（你会注意到 GECOS 字段也被显示）：
- en: '[PRE82]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You may want to run the `ansible-playbook` command without supplying a vault
    password, as required by `--ask-vault-pass`. Such functionality is essential in
    scripted or automated workflows when using Ansible Vault. To make your vault password
    automatically available when you’re running a playbook using sensitive data, start
    by creating a regular text file, preferably in your home directory; for example,
    `~/vault.pass`. Add the vault password to this file in a single line. Then, you
    can choose *either* of the following options to use the vault password file:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望在运行 `ansible-playbook` 命令时不提供保险库密码，因为 `--ask-vault-pass` 参数要求提供密码。这种功能在使用
    Ansible Vault 时对于脚本或自动化工作流非常重要。为了在运行剧本时自动提供保险库密码，可以通过创建一个常规文本文件来实现，最好放在你的家目录中；例如，`~/vault.pass`。将保险库密码添加到此文件的一行中。然后，你可以选择以下任一选项来使用保险库密码文件：
- en: 'Create the following environment variable:'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建以下环境变量：
- en: '[PRE83]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: vault_password_file = ~/vault.pass
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: vault_password_file = ~/vault.pass
- en: '[PRE84]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, you can run the `create-user-new` playbook without the `--``ask-vault-pass`
    option:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在没有 `--ask-vault-pass` 选项的情况下运行 `create-user-new` 剧本：
- en: '[PRE85]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Sometimes, protecting multiple secrets with a single vault password raises security
    concerns. Ansible supports multiple vault passwords through vault IDs.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用单一保险库密码保护多个机密会引发安全问题。Ansible 通过保险库 ID 支持多个保险库密码。
- en: Using vault IDs
  id: totrans-539
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用保险库 ID
- en: 'A `passwords.yml` file. Suppose we want to secure this file using a vault ID.
    The following command creates a vault ID labeled `passwords` and prompts us to
    create a password:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `passwords.yml` 文件。假设我们希望使用保险库 ID 来保护这个文件。以下命令创建一个名为 `passwords` 的保险库 ID，并提示我们创建密码：
- en: '[PRE86]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `passwords` vault ID protects the `passwords.yml` file. Now, let’s assume
    we also want to secure some API keys associated with users. If we stored these
    secrets in the `apikeys.yml` file, the following command would create a corresponding
    vault ID called `apikeys`:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '`passwords` 保险库 ID 保护 `passwords.yml` 文件。现在，假设我们还想保护一些与用户相关的 API 密钥。如果我们将这些机密存储在
    `apikeys.yml` 文件中，以下命令将创建一个名为 `apikeys` 的相应保险库 ID：'
- en: '[PRE87]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Here, we created two vault IDs, each with its own password and protecting different
    resources.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了两个Vault ID，每个Vault ID都有自己的密码，并保护不同的资源。
- en: 'The benefits of vault IDs are as follows:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: Vault ID的好处如下：
- en: They provide an improved security context when managing secrets. If one of the
    vault ID passwords becomes compromised, resources that have been secured by the
    other vault IDs are still protected.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供了在管理机密时改进的安全上下文。如果某个Vault ID的密码被泄露，其他Vault ID保护的资源仍然是安全的。
- en: With vault IDs, we can also leverage different access levels to vault secrets.
    For example, we can define `admin`, `dev`, and `test` vault IDs for related groups
    of users. Alternatively, we can have multiple configuration management projects,
    each with its own dedicated vault IDs and secrets; for example, `user-config`,
    `web-config`, and `db-config`.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Vault ID，我们还可以利用不同的访问级别来管理Vault机密。例如，我们可以为相关的用户组定义`admin`、`dev`和`test` Vault
    ID。或者，我们可以有多个配置管理项目，每个项目都有自己的专用Vault ID和机密；例如，`user-config`、`web-config`和`db-config`。
- en: 'You can associate a vault ID with multiple secrets. For example, the following
    command creates a `user-config` vault ID that secures the `passwords.yml` and
    `api-keys.yml` files:'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将一个Vault ID与多个机密关联。例如，以下命令创建了一个`user-config` Vault ID，用于保护`passwords.yml`和`api-keys.yml`文件：
- en: '[PRE88]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'passwords) to a playbook (create-users-new.yml) with the following command:'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将密码添加到剧本(create-users-new.yml)的命令如下：
- en: '[PRE89]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: For more information about Ansible Vault, you may refer to the related online
    documentation at [https://docs.ansible.com/ansible/latest/user_guide/vault.html](https://docs.ansible.com/ansible/latest/user_guide/vault.html).
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Ansible Vault的更多信息，您可以参考相关的在线文档：[https://docs.ansible.com/ansible/latest/user_guide/vault.html](https://docs.ansible.com/ansible/latest/user_guide/vault.html)。
- en: So far, we have created a single user account with a password. What if we want
    to onboard multiple users, each with their own password? As we noted previously,
    we could call the `create-user` playbook and override the `username` and `password`
    variables using the `--extra-vars` option parameter. But this method is not a
    very efficient one, not to mention the difficulty of maintaining it. In the next
    section, we’ll show you how to use task iteration in Ansible playbooks.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个带密码的单用户帐户。如果我们想要添加多个用户，每个用户都有自己的密码，该怎么办呢？正如我们之前提到的，我们可以调用`create-user`剧本，并使用`--extra-vars`选项参数覆盖`username`和`password`变量。但这种方法效率不高，更别提维护的难度了。在接下来的部分，我们将向您展示如何在Ansible剧本中使用任务迭代。
- en: Working with loops
  id: totrans-555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用循环
- en: '**Loops** provide an efficient way of running a task repeatedly in Ansible
    playbooks. There are several loop implementations in Ansible, and we can classify
    them into the following categories based on their keyword or syntax:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环**提供了一种在Ansible剧本中高效地重复执行任务的方法。Ansible中有多种循环实现，我们可以根据它们的关键字或语法将其分类为以下几种：'
- en: '`loop`: The recommended way of iterating through a collection'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop`：推荐的集合迭代方式'
- en: '`with_<lookup>`: Collection-specific implementations of loops; examples include
    `with_list`, `with_items`, and `with_dict`, to name a few'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with_<lookup>`：特定于集合的循环实现；例如，`with_list`、`with_items`和`with_dict`等'
- en: 'In this section, we’ll keep our focus on the `loop` iteration (equivalent to
    `with_list`), which is best suited for simple loops. Let’s expand our previous
    use case and adapt it to create multiple users. We’ll start by making a quick
    comparison between running repeated tasks *with* and *without* loops:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注`loop`迭代（等同于`with_list`），它最适合用于简单的循环。让我们扩展之前的用例，并将其调整为创建多个用户。首先，我们通过快速比较带有循环和不带循环的重复任务来开始：
- en: 'As a preparatory step, make sure `~/ansible` is your current working directory.
    Also, you can delete the `./group_vars` folder, as we’re not using it anymore.
    Now, let’s create a couple of playbooks, `create-users1.yml` and `create-users2.yml`,
    as shown in the following screenshot:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为准备步骤，请确保`~/ansible`是您的当前工作目录。此外，您可以删除`./group_vars`文件夹，因为我们不再使用它。现在，让我们创建两个剧本`create-users1.yml`和`create-users2.yml`，如下面的截图所示：
- en: '![Figure 17.40 – Playbooks with multiple versus iterative tasks](img/B19682_17_40.jpg)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.40 – 多任务与迭代任务的剧本](img/B19682_17_40.jpg)'
- en: Figure 17.40 – Playbooks with multiple versus iterative tasks
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.40 – 多任务与迭代任务的剧本
- en: 'Both playbooks create three users: `webuser`, `webadmin`, and `webdev`. The
    `create-users1` playbook has three distinct tasks, one for creating each user.
    On the other hand, `create-users2` implements a single task iteration using the
    `loop` directive (in *line 15*):'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 两个剧本都会创建三个用户：`webuser`、`webadmin` 和 `webdev`。`create-users1`剧本有三个不同的任务，每个任务负责创建一个用户。另一方面，`create-users2`实现了使用`loop`指令（*第15行*）的单一任务迭代：
- en: '[PRE91]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The loop iterates through the items of the `users` list, defined as a `play`
    variable in *lines 6-9*. The `user` task uses the `{{ item }}` variable, referencing
    each user while iterating through the list.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 循环遍历`users`列表中的项，这个列表被定义为*第6-9行*的`play`变量。`user`任务使用`{{ item }}`变量，在遍历列表时引用每个用户。
- en: 'Before running any of these playbooks, let’s also create one for deleting the
    users. We’ll name this playbook `delete-users2.yml,` and it will have a similar
    implementation to `create-users2.yml`:'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行这些剧本之前，我们还需要创建一个用于删除用户的剧本。我们将这个剧本命名为`delete-users2.yml`，它的实现与`create-users2.yml`类似：
- en: '![Figure 17.41 – A playbook using a loop for deleting users](img/B19682_17_41.jpg)'
  id: totrans-567
  prefs: []
  type: TYPE_IMG
  zh: '![图17.41 – 使用循环删除用户的剧本](img/B19682_17_41.jpg)'
- en: Figure 17.41 – A playbook using a loop for deleting users
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.41 – 使用循环删除用户的剧本
- en: 'Now, let’s run the `create-users1` playbook while targeting only the `ans-web1`
    web server:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行`create-users1`剧本，目标仅为`ans-web1` Web服务器：
- en: '[PRE92]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'In the output, we can see that three tasks have been executed, one for each
    user:'
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在输出中，我们可以看到已经执行了三个任务，每个任务对应一个用户：
- en: '![Figure 17.42 – The output of the create-users1 playbook, with multiple tasks](img/B19682_17_42.jpg)'
  id: totrans-572
  prefs: []
  type: TYPE_IMG
  zh: '![图17.42 – 带有多个任务的`create-users1`剧本输出](img/B19682_17_42.jpg)'
- en: Figure 17.42 – The output of the create-users1 playbook, with multiple tasks
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.42 – 带有多个任务的`create-users1`剧本输出
- en: 'Let’s delete the users by running the `delete-users2.yml` playbook:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过运行`delete-users2.yml`剧本来删除用户：
- en: '[PRE93]'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The output is as shown in the following screenshot:'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如以下截图所示：
- en: '![Figure 17.43 – Deleting users using the playbook](img/B19682_17_43.jpg)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
  zh: '![图17.43 – 使用剧本删除用户](img/B19682_17_43.jpg)'
- en: Figure 17.43 – Deleting users using the playbook
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.43 – 使用剧本删除用户
- en: 'Now, let’s run the `create-users2` playbook, again targeting only the `web1`
    web server:'
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行`create-users2`剧本，再次仅目标为`web1` Web服务器：
- en: '[PRE94]'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This time, the output shows a single task iterating through all the users:'
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次输出展示了一个任务遍历所有用户：
- en: '![Figure 17.44 – The output of the create-users2 playbook, with a single task
    iteration](img/B19682_17_44.jpg)'
  id: totrans-582
  prefs: []
  type: TYPE_IMG
  zh: '![图17.44 – 带有单一任务迭代的`create-users2`剧本输出](img/B19682_17_44.jpg)'
- en: Figure 17.44 – The output of the create-users2 playbook, with a single task
    iteration
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.44 – 带有单一任务迭代的`create-users2`剧本输出
- en: 'The difference between the two playbook runs is significant:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 两个剧本运行之间的差异非常明显：
- en: The first playbook executes a task for each user. While forking a task is not
    an expensive operation, you can imagine that creating hundreds of users would
    incur a significant load on the Ansible runtime.
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个剧本为每个用户执行一个任务。虽然分叉任务并不是一个昂贵的操作，但可以想象，创建数百个用户会对Ansible运行时造成显著负担。
- en: On the other hand, the second playbook runs a single task, loading the `user`
    module three times, to create each user. Loading a module takes significantly
    fewer resources than running a task.
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，第二个剧本运行一个单一任务，加载`user`模块三次以创建每个用户。加载模块比运行任务消耗的资源要少得多。
- en: For more information about loops, you may refer to the related online documentation
    at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html).
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 有关循环的更多信息，您可以参考相关的在线文档：[https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html)。
- en: Now that we know how to implement a simple loop, we’ll make our playbook more
    compact and maintainable.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何实现一个简单的循环，我们将使我们的剧本更加简洁和可维护。
- en: Configuring our playbooks
  id: totrans-589
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置我们的剧本
- en: Apart from enhancing our playbooks, we’ll also try to come closer to a real-world
    scenario by storing the users and their related passwords in a reusable and secure
    fashion.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 除了优化我们的剧本外，我们还将尝试通过以可重用且安全的方式存储用户及其相关密码，来尽可能接近真实世界的场景。
- en: 'We will keep the web users’ information in the `users.yml` file. The related
    passwords are in the `users_passwords.yml` file. Here are the two files, along
    with some example user data:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把Web用户的信息保存在`users.yml`文件中，相关的密码保存在`users_passwords.yml`文件中。以下是这两个文件及一些示例用户数据：
- en: '![Figure 17.45 – The users.yml and users_passwords.yml files](img/B19682_17_45.jpg)'
  id: totrans-592
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.45 – users.yml 和 users_passwords.yml 文件](img/B19682_17_45.jpg)'
- en: Figure 17.45 – The users.yml and users_passwords.yml files
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.45 – users.yml 和 users_passwords.yml 文件
- en: 'Let’s take a closer look at these files:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些文件：
- en: 'The `users.yml` file contains a dictionary with a single key-value pair:'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users.yml` 文件包含一个包含单一键值对的字典：'
- en: '`webusers`'
  id: totrans-596
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webusers`'
- en: '`username` and `comment` tuples'
  id: totrans-597
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username` 和 `comment` 元组'
- en: 'The `users_passwords.yml` file contains a nested dictionary with multiple key-value
    pairs, as follows:'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users_passwords.yml` 文件包含一个嵌套字典，其中包含多个键值对，如下所示：'
- en: '`<username>` (for example, `webuser`, `webadmin`, and so on)'
  id: totrans-599
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<username>`（例如，`webuser`、`webadmin` 等）'
- en: '`password: <value>` key-value pair'
  id: totrans-600
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password: <value>` 键值对'
- en: You may use the `ansible-vault edit` command to update the `users_passwords.yml`
    file, or you can create a new one, as we did. Alternatively, after you create
    a file from scratch, you will then have to encrypt it, following the steps previously
    described in the *Working with* *secrets* section.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `ansible-vault edit` 命令更新 `users_passwords.yml` 文件，或者像我们一样创建一个新文件。或者，在你从头创建文件后，你必须按照之前在
    *处理秘密* 部分描述的步骤对其进行加密。
- en: 'The new `create-users.yml` playbook file has the following implementation:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `create-users.yml` playbook 文件具有以下实现：
- en: '![Figure 17.46 – The create-users.yml playbook](img/B19682_17_46.jpg)'
  id: totrans-603
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.46 – 创建用户的 playbook](img/B19682_17_46.jpg)'
- en: Figure 17.46 – The create-users.yml playbook
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.46 – 创建用户的 playbook
- en: 'These files are also available in the GitHub repository for this book, in the
    related chapter folder. Let’s quickly go over the playbook’s implementation. We
    have three tasks:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件也可以在本书的 GitHub 仓库中找到，位于相关章节的文件夹中。让我们快速浏览一下 playbook 的实现。我们有三个任务：
- en: '`Load users`: Reads the web user information from the `users.yml` file and
    stores the related values in the `users` dictionary'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Load users`：从 `users.yml` 文件中读取 Web 用户信息，并将相关值存储在 `users` 字典中'
- en: '`Load passwords`: Reads the passwords from the encrypted `passwords.yml` file
    and stores the corresponding values in the `passwords` dictionary'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Load passwords`：从加密的 `passwords.yml` 文件中读取密码，并将相应的值存储在 `passwords` 字典中'
- en: '`Create user accounts`: Iterates through the `users.webusers` list and, for
    each item, creates a user account with the related parameters; the task performs
    a password lookup in the `passwords` dictionary based on `item.username`'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Create user accounts`：遍历 `users.webusers` 列表，对于每个项，使用相关参数创建一个用户账户；该任务根据 `item.username`
    在 `passwords` 字典中执行密码查找'
- en: 'Before running the playbook, let us encrypt the `users_passwords.yml` file
    using the following command:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 playbook 之前，使用以下命令加密 `users_passwords.yml` 文件：
- en: '[PRE95]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now, run the playbook with the following command:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令运行 playbook：
- en: '[PRE96]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Here’s the output:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '![Figure 17.47 – Running the create-users.yml playbook](img/B19682_17_47.jpg)'
  id: totrans-614
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.47 – 运行 create-users.yml playbook](img/B19682_17_47.jpg)'
- en: Figure 17.47 – Running the create-users.yml playbook
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.47 – 运行 create-users.yml playbook
- en: 'We can see the following playbook tasks at work:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到以下 playbook 任务在工作：
- en: '`Gathering Facts`: Discovering managed hosts and related system variables (facts);
    we’ll introduce Ansible facts later in this chapter'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gathering Facts`：发现已管理主机和相关的系统变量（事实）；我们将在本章稍后介绍 Ansible 事实'
- en: '`Load users`: Reading the users from the `users.yml` file'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Load users`：从 `users.yml` 文件中读取用户信息'
- en: '`Load passwords`: Reading the passwords from the encrypted `passwords.yml`
    file'
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Load passwords`：从加密的 `passwords.yml` 文件中读取密码'
- en: '`Create user accounts`: The task iteration loop creates users'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Create user accounts`：任务迭代循环创建用户'
- en: You may verify the new user accounts using the methods presented earlier in
    the *Working with secrets* section. As an exercise, create the `delete-users.yml`
    playbook using a similar implementation to the `create-users` playbook.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用之前在 *处理秘密* 部分介绍的方法来验证新用户账户。作为练习，使用与 `create-users` playbook 类似的实现来创建 `delete-users.yml`
    playbook。
- en: Now, let’s look at how we can improve our playbook and reuse it to seamlessly
    create users across all hosts in the inventory, web servers, and databases alike.
    We’ll use conditional tasks to accomplish this functionality.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何改进我们的 playbook，并将其复用以在所有主机中无缝创建用户，包括 Web 服务器和数据库。我们将使用条件任务来实现这一功能。
- en: Running conditional tasks
  id: totrans-623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行条件任务
- en: '`when` task-level directive to define a condition.'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '`when` 任务级别指令用于定义条件。'
- en: We learned about variables and how to use them in playbooks. Facts and results
    are essentially variables of a specific type and use. We’ll look at each of these
    variables in the context of conditional tasks. Let’s start with facts.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了变量以及如何在 playbook 中使用它们。Facts 和结果本质上是特定类型和用途的变量。接下来，我们将在条件任务的上下文中探讨这些变量。让我们从
    facts 开始。
- en: Using Ansible facts
  id: totrans-626
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Ansible facts
- en: '`ansible_` prefix.'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible_` 前缀。'
- en: 'Here are a few examples of Ansible facts:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些 Ansible facts 的示例：
- en: '`ansible_distribution`: The OS distribution (for example, `Ubuntu`)'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_distribution`：操作系统发行版（例如，`Ubuntu`）'
- en: '`ansible_all_ipv4_addresses`: The IPv4 addresses'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_all_ipv4_addresses`：IPv4 地址'
- en: '`ansible_architecture`: The platform architecture (for example, `x86_64` or
    `i386`)'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_architecture`：平台架构（例如，`x86_64` 或 `i386`）'
- en: '`ansible_processor_cores`: The number of CPU cores'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_processor_cores`：CPU 核心数'
- en: '`ansible_memfree_mb`: The available memory (in MB)'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_memfree_mb`：可用内存（以 MB 为单位）'
- en: Now, what if we didn’t have groups explicitly created for classifying our hosts
    in Ubuntu and Debian systems, for example (or any other distribution, for that
    matter)? In this case, we could gather facts about our managed hosts, detect their
    OS type, and perform the conditional update task, depending on the underlying
    platform. Let’s implement this functionality in a playbook using Ansible facts.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们没有明确为我们的主机创建分组，比如在 Ubuntu 和 Debian 系统中（或任何其他发行版）呢？在这种情况下，我们可以收集有关管理主机的
    facts，检测它们的操作系统类型，并根据底层平台执行条件更新任务。让我们在 playbook 中使用 Ansible facts 实现这个功能。
- en: 'We’ll name our playbook `install-updates.yml` and add the following content
    to it:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的 playbook 命名为 `install-updates.yml` 并添加以下内容：
- en: '![Figure 17.48 – The install-updates.yml playbook](img/B19682_17_48.jpg)'
  id: totrans-636
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.48 – install-updates.yml playbook](img/B19682_17_48.jpg)'
- en: Figure 17.48 – The install-updates.yml playbook
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.48 – install-updates.yml playbook
- en: 'The playbook targets all hosts and has two conditional tasks, based on the
    `ansible_distribution` fact:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 该 playbook 目标是所有主机，并有两个条件任务，基于 `ansible_distribution` fact：
- en: '`Install Ubuntu system updates`: Runs exclusively on Ubuntu hosts based on
    the `ansible_distribution == "Ubuntu"` condition (*line 9*)'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Install Ubuntu system updates`：基于 `ansible_distribution == "Ubuntu"` 条件，仅在
    Ubuntu 主机上运行（*第 9 行*）'
- en: '`Install Debian system updates`: Runs exclusively on Debian hosts based on
    the `ansible_distribution == "Debian"` condition (*line 13*)'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Install Debian system updates`：基于 `ansible_distribution == "Debian"` 条件，仅在
    Debian 主机上运行（*第 13 行*）'
- en: 'Let’s run our playbook:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的 playbook：
- en: '[PRE97]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The commands will take a significant time to run if there are any updates to
    install on the hosts. Here’s the corresponding output:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主机上有需要安装的更新，命令执行将花费相当长的时间。以下是相应的输出：
- en: '![Figure 17.49 – Running conditional tasks](img/B19682_17_49.jpg)'
  id: totrans-644
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.49 – 运行条件任务](img/B19682_17_49.jpg)'
- en: Figure 17.49 – Running conditional tasks
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.49 – 运行条件任务
- en: 'There are three tasks illustrated in the preceding output:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中有三个任务：
- en: '`Gathering Facts`: The default discovery task that’s executed by the playbook
    to gather facts about remote hosts'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gathering Facts`：默认的发现任务，由 playbook 执行，用于收集远程主机的信息'
- en: '`Install Ubuntu system updates`: The conditional task for running all Ubuntu
    hosts'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Install Ubuntu system updates`：针对所有 Ubuntu 主机的条件任务'
- en: '`Install Debian system updates`: The conditional task for skipping all Ubuntu-based
    hosts, as we don’t currently run any Debian ones'
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Install Debian system updates`：针对所有 Ubuntu 主机跳过的条件任务，因为我们当前没有运行任何 Debian 主机'
- en: Next, we’ll look at how to use Ansible’s environment-specific variables in conditional
    tasks.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看如何在条件任务中使用 Ansible 的环境特定变量。
- en: Using magic variables
  id: totrans-651
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用魔法变量
- en: '**Magic variables** describe the local Ansible environment and its related
    configuration data. Here are a few examples of magic variables:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '**魔法变量** 描述了本地 Ansible 环境及其相关的配置信息。以下是一些魔法变量的示例：'
- en: '`ansible_playhosts`: A list of active hosts in the current play'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_playhosts`：当前 play 中活动主机的列表'
- en: '`group_names`: A list of all groups the current host is a member of'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group_names`：当前主机所属的所有组的列表'
- en: '`vars`: A dictionary with all variables in the current play'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vars`：当前 play 中所有变量的字典'
- en: '`ansible_version`: The version of Ansible'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_version`：Ansible 版本'
- en: 'To see magic variables in action while using conditional tasks, we’ll improve
    our `create-users` playbook even further and create specific groups of users on
    different host groups. So far, the playbook only creates users on hosts that belong
    to the `webservers` group (`web1`, `web2`). The playbook creates `webuser`, `webadmin`,
    and `webdev` user accounts on all web servers. What if we want to create a similar
    group of users – `dbuser`, `dbadmin`, and `dbdev` – on all our database servers?
    To achieve this, you can follow these steps:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在使用条件任务时看到魔法变量的实际应用，我们将进一步改进`create-users`剧本，并在不同的主机组上创建特定的用户组。到目前为止，剧本仅在属于`webservers`组的主机（`web1`、`web2`）上创建用户。剧本在所有Web服务器上创建`webuser`、`webadmin`和`webdev`用户帐户。如果我们想在所有数据库服务器上创建类似的用户组——`dbuser`、`dbadmin`和`dbdev`呢？要实现这一点，可以按照以下步骤操作：
- en: 'Start by adding the new user accounts and passwords to the `users.yml` and
    `users_passwords.yml` files, respectively. Here’s what we have after adding the
    database’s user accounts and passwords:'
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将新用户帐户和密码分别添加到`users.yml`和`users_passwords.yml`文件中。以下是添加数据库用户帐户和密码后的内容：
- en: '![Figure 17.50 – The users.yml and passwords.yml files](img/B19682_17_50.jpg)'
  id: totrans-659
  prefs: []
  type: TYPE_IMG
  zh: '![图17.50 – users.yml和passwords.yml文件](img/B19682_17_50.jpg)'
- en: Figure 17.50 – The users.yml and passwords.yml files
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.50 – users.yml和passwords.yml文件
- en: Note that you can edit the `users_passwords.yml` file using the `ansible-vault
    edit` command. Alternatively, you can decrypt the file, edit it, and re-encrypt
    it.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以使用`ansible-vault edit`命令编辑`users_passwords.yml`文件。或者，您也可以解密文件、编辑它，然后重新加密。
- en: 'Now, let’s create a `create-users3` playbook with the required conditional
    tasks to handle both groups – `webusers` and `databases` – selectively. Let us
    create a new file called `create-users3.yml` with the following content:'
  id: totrans-662
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`create-users3`剧本，包含所需的条件任务，以有选择性地处理两个组——`webusers`和`databases`。我们将创建一个名为`create-users3.yml`的新文件，内容如下：
- en: '![Figure 17.51 – The create-users.yml playbook with conditional tasks](img/B19682_17_51.jpg)'
  id: totrans-663
  prefs: []
  type: TYPE_IMG
  zh: '![图17.51 – 带有条件任务的create-users.yml剧本](img/B19682_17_51.jpg)'
- en: Figure 17.51 – The create-users.yml playbook with conditional tasks
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.51 – 带有条件任务的create-users.yml剧本
- en: 'Let’s run the playbook:'
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行这个剧本：
- en: '[PRE98]'
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The following is an excerpt of the output that shows the web user task skipping
    the database servers and the database user task skipping the web servers, suggesting
    that the web and database users have been created successfully:'
  id: totrans-667
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是输出的一个摘录，显示Web用户任务跳过数据库服务器，数据库用户任务跳过Web服务器，表明Web和数据库用户已经成功创建：
- en: '![Figure 17.52 – The web and database user tasks running selectively](img/B19682_17_52.jpg)'
  id: totrans-668
  prefs: []
  type: TYPE_IMG
  zh: '![图17.52 – Web和数据库用户任务有选择性地运行](img/B19682_17_52.jpg)'
- en: Figure 17.52 – The web and database user tasks running selectively
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.52 – Web和数据库用户任务有选择性地运行
- en: For a complete list of Ansible special variables, including magic variables,
    please visit [https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html](https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html).
    For more information about facts and magic variables, check out the online documentation
    at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_vars_facts.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_vars_facts.html).
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Ansible的所有特殊变量列表，包括魔法变量，请访问[https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html](https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html)。有关事实和魔法变量的更多信息，请查看[https://docs.ansible.com/ansible/latest/user_guide/playbooks_vars_facts.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_vars_facts.html)中的在线文档。
- en: Next, we’ll look at variables for tracking task results, also known as register
    variables.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看用于跟踪任务结果的变量，也称为注册变量。
- en: Using register variables
  id: totrans-672
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用注册变量
- en: '`register` directive to capture the task’s output in a variable. A typical
    example of using register variables is collecting the result of a task for debugging
    purposes. In more complex workflows, a particular task may or may not run, depending
    on a previous task’s result.'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '`register`指令用于将任务的输出捕获到变量中。使用注册变量的典型示例是收集任务结果以进行调试。在更复杂的工作流中，某些任务可能会根据先前任务的结果决定是否执行。'
- en: 'Let’s consider a hypothetical use case. As we onboard new users and create
    different accounts on all our servers, we want to make sure the number of users
    doesn’t exceed the maximum number allowed. If the limit is reached, we may choose
    to launch a new server, redistribute the users, and so on. You can follow these
    steps:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个假设的使用案例。当我们新增用户并在所有服务器上创建不同帐户时，我们希望确保用户数量不会超过允许的最大数量。如果达到限制，我们可能会选择启动新服务器、重新分配用户等。你可以按照以下步骤进行操作：
- en: 'Let’s start by creating a playbook named `count-users.yml` with the following
    content:'
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 `count-users.yml` 的剧本并输入以下内容开始：
- en: '![Figure 17.53 – The count-users.yml playbook](img/B19682_17_53.jpg)'
  id: totrans-676
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.53 – count-users.yml 剧本](img/B19682_17_53.jpg)'
- en: Figure 17.53 – The count-users.yml playbook
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.53 – count-users.yml 剧本
- en: 'We created the following tasks in the playbook:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在剧本中创建了以下任务：
- en: '`Count all users`: A task that uses the `shell` module to count all users;
    we register the `count` variable by capturing the task output'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Count all users`：一个使用 `shell` 模块来统计所有用户的任务；我们通过捕获任务输出来注册 `count` 变量'
- en: '`Debug number of users`: A simple task for debugging purposes that logs the
    number of users and the maximum limit allowed'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Debug number of users`：一个用于调试目的的简单任务，记录用户数量和最大允许数量'
- en: '`Detect limit`: A conditional task that’s run when the limit has been reached;
    the task checks the value of the `count` register variable and compares it with
    the `max_allowed` variable'
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Detect limit`：一个条件任务，在达到限制时运行；该任务检查 `count` 注册变量的值，并将其与 `max_allowed` 变量进行比较'
- en: '*Line 17* in our playbook needs some further explanation. Here, we take the
    actual standard output of the register variable; that is, `count.stdout`. As is,
    the value would be a string, and we need to cast it to an integer; that is, `count.stdout
    | int`. Then, we compare the resulting number with `max_allowed`.'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 17 行* 在我们的剧本中需要进一步的解释。在这里，我们使用注册变量的实际标准输出，也就是 `count.stdout`。原始值是字符串类型，我们需要将其转换为整数，即
    `count.stdout | int`。然后，我们将得到的数字与 `max_allowed` 进行比较。'
- en: 'Let’s run the playbook while targeting only the `ans-web1` host:'
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在只针对 `ans-web1` 主机时运行剧本：
- en: '[PRE99]'
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The output is as follows:'
  id: totrans-685
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 17.54 – The conditional task (Detect limit) is executed](img/B19682_17_54.jpg)'
  id: totrans-686
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.54 – 条件任务（检测限制）已执行](img/B19682_17_54.jpg)'
- en: Figure 17.54 – The conditional task (Detect limit) is executed
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.54 – 条件任务（检测限制）已执行
- en: Here, we can see that the number of users is 36, thus exceeding the maximum
    limit of 30\. In other words, the `Detect limit` task ran as it was supposed to.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到用户数量是 36，已超出最大限制 30。换句话说，`Detect limit` 任务按照预期执行。
- en: 'Now, let’s edit the `count-users.yml` playbook and change the following:'
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编辑 `count-users.yml` 剧本并做如下更改：
- en: '[PRE100]'
  id: totrans-690
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Save and rerun the playbook. This time, the output shows that the `Detect limit`
    task was skipped:'
  id: totrans-691
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并重新运行剧本。这次，输出显示 `Detect limit` 任务被跳过：
- en: '![Figure 17.55 – The conditional task (Detect limit) is skipped](img/B19682_17_55.jpg)'
  id: totrans-692
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.55 – 条件任务（检测限制）被跳过](img/B19682_17_55.jpg)'
- en: Figure 17.55 – The conditional task (Detect limit) is skipped
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.55 – 条件任务（检测限制）被跳过
- en: To learn more about conditional tasks in Ansible playbooks, please visit [https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html).
    By combining conditional tasks with Ansible’s all-encompassing facts and special
    variables, we can write extremely powerful playbooks and automate a wide range
    of system administration operations.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多有关 Ansible 剧本中条件任务的信息，请访问[https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html)。通过将条件任务与
    Ansible 强大的事实和特殊变量结合使用，我们可以编写出功能强大的剧本并自动化各种系统管理操作。
- en: In the following sections, we’ll explore additional ways to make our playbooks
    more reusable and versatile. We’ll look at dynamic configuration templates next.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨使我们的剧本更具可重用性和通用性的方法。接下来，我们将介绍动态配置模板。
- en: Using templates with Jinja2
  id: totrans-696
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Jinja2 模板
- en: 'One of the most common configuration management tasks is copying files to managed
    hosts. Ansible provides the `copy` module for serving such tasks. A typical file
    copy operation has the following syntax in Ansible playbooks:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的配置管理任务之一是将文件复制到受管主机。Ansible 提供了 `copy` 模块来执行此类任务。一个典型的文件复制操作在 Ansible 剧本中的语法如下：
- en: '[PRE101]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The `copy` task takes a source file (`motd`) and copies it to a destination
    (`/etc/motd`) on the remote host. While this model would work for copying static
    files to multiple hosts, it won’t handle host-specific customizations in these
    files on the fly.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy`任务会将源文件（`motd`）复制到远程主机上的目标位置（`/etc/motd`）。虽然这种模型适用于将静态文件复制到多个主机，但它无法动态处理这些文件中的主机特定自定义内容。'
- en: Take, for example, a network configuration file featuring the IP address of
    a host. Attempting to copy this file on all hosts to configure the related network
    settings could render all but one host unreachable. Ideally, the network configuration
    file should have a *placeholder* for the dynamic content (for example, IP address)
    and adapt the file accordingly, depending on the target host.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 以网络配置文件为例，该文件包含主机的IP地址。试图将此文件复制到所有主机上以配置相关的网络设置，可能会导致除了一个主机之外的所有主机都无法访问。理想情况下，网络配置文件应具有*占位符*来表示动态内容（例如，IP地址），并根据目标主机适应文件内容。
- en: 'To address this functionality, Ansible provides the `template` module with
    the `template` syntax is very similar to `copy`:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一功能，Ansible提供了`template`模块，其`template`语法与`copy`非常相似：
- en: '[PRE102]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The source, in this case, is a Jinja2 template file (`motd.j2`) with host-specific
    customizations. Before copying the file to the remote host, Ansible reads the
    Jinja2 template and replaces the dynamic content with the host-specific data.
    This processing happens on the Ansible control node.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，源是一个包含主机特定自定义内容的Jinja2模板文件（`motd.j2`）。在将文件复制到远程主机之前，Ansible会读取Jinja2模板，并将动态内容替换为主机特定的数据。这个处理过程发生在Ansible控制节点上。
- en: To illustrate some of the benefits and internal workings of Ansible templates,
    we’ll work with a couple of use cases and create a Jinja2 template for each. Then,
    we’ll create and run the related playbooks to show the templates in action.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明Ansible模板的一些好处和内部工作原理，我们将通过几个用例来创建每个用例的Jinja2模板。然后，我们将创建并运行相关的剧本，以展示模板的实际效果。
- en: 'Here are the two templates we’ll be creating in this section:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将在本节中创建的两个模板：
- en: '`motd`): For displaying a customized message to users about scheduled system
    maintenance'
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`motd`): 用于向用户显示有关计划系统维护的定制消息'
- en: '`hosts`): For generating a custom `/etc/hosts` file on each system with the
    hostname records of the other managed hosts'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hosts`): 用于在每个系统上生成自定义的`/etc/hosts`文件，其中包含其他管理主机的主机名记录'
- en: Let’s start with the message-of-the-day template.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从每日一条信息模板开始。
- en: Creating a message-of-the-day template
  id: totrans-709
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建每日一条信息模板
- en: 'In our introductory notes, we used the `/etc/motd` file as an example. On a
    Linux system, the content of this file is displayed when a user logs in to the
    Terminal. Suppose you plan to upgrade your web servers on Thursday night and would
    like to give your users a friendly reminder about the upcoming outage. Your `motd`
    message could be something like this:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的介绍性说明中，我们以`/etc/motd`文件作为示例。在Linux系统中，当用户登录到终端时，系统会显示该文件的内容。假设你计划在星期四晚上升级你的Web服务器，并希望提醒用户即将发生的停机事件。你的`motd`信息可能是这样的：
- en: '[PRE103]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: There’s nothing special about this message, and the `motd` file could be easily
    deployed with a simple `copy` task. In most cases, such a message would probably
    do just fine, apart from the rare occasion when users may get confused about which
    exactly is “`this server`”. You may also consider that Thursday night in the US
    could be Friday afternoon on the other side of the world, and it would be nice
    if the announcement were more specific.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 这个消息没有什么特别的，`motd`文件可以通过一个简单的`copy`任务轻松部署。在大多数情况下，这样的消息可能就足够了，除非在某些特殊情况下，用户可能会对“`这台服务器`”具体是指哪一台感到困惑。你也可以考虑到，在美国的星期四晚上，世界另一端可能已经是星期五下午了，这样如果公告更具体一些会更好。
- en: 'Perhaps a better message would state, on the `ans-web1` web server, the following:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 也许一个更好的信息会在`ans-web1` Web服务器上显示以下内容：
- en: '[PRE104]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'On the `ans-web2` web server, the message would reflect the corresponding hostname
    and IP address. Ideally, the template should be reusable across multiple time
    zones, with playbooks running on globally distributed Ansible control nodes. Let’s
    see how we can implement such a template (we’ll assume your current working directory
    is `~/ansible`):'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ans-web2` Web服务器上，消息将反映相应的主机名和IP地址。理想情况下，模板应该在多个时区之间可复用，并且可以在全球分布的Ansible控制节点上运行剧本。让我们看看如何实现这样的模板（假设你当前的工作目录是`~/ansible`）：
- en: 'First, create a `templates` folder in your local Ansible project directory:'
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在本地Ansible项目目录中创建一个`templates`文件夹：
- en: '[PRE105]'
  id: totrans-717
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Using a Linux editor of your choice, create a `motd.j2` file in `./templates`
    with the following content:'
  id: totrans-718
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的 Linux 编辑器，在 `./templates` 中创建一个名为 `motd.j2` 的文件，内容如下：
- en: '![Figure 17.56 – The motd.j2 template file](img/B19682_17_56.jpg)'
  id: totrans-719
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.56 – motd.j2 模板文件](img/B19682_17_56.jpg)'
- en: Figure 17.56 – The motd.j2 template file
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.56 – motd.j2 模板文件
- en: 'Note some of the particularities of the Jinja2 syntax:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Jinja2 语法中的一些特点：
- en: 'Comments are enclosed in `{# ... #}`'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '注释被 `{# ... #}` 包围'
- en: Expressions are surrounded by `{% ... %}`
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式由 `{% ... %}` 包围
- en: External variables are referenced with `{{ ... }}`
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部变量使用 `{{ ... }}` 引用
- en: 'Here’s what the script does:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是脚本的操作：
- en: '*Lines 1*-*4* define an initial set of local variables for storing time boundaries
    for the outage: the day of the outage (`date`), the starting time (`start_time`),
    and the ending time (`end_time`).'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 1 行*-*第 4 行* 定义了一组初始本地变量，用于存储停机时间的边界：停机日期（`date`）、起始时间（`start_time`）和结束时间（`end_time`）。'
- en: '*Line 6* defines the input date-time format (`fmt`) for our starting and ending
    time variables.'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 6 行* 定义了我们用于起始时间和结束时间变量的输入日期时间格式（`fmt`）。'
- en: '*Lines 7*-*8* build `datetime` objects that correspond to `start_time` and
    `end_time`. These Python `datetime` objects are formatted according to our needs
    in the custom message.'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 7 行*-*第 8 行* 构建与 `start_time` 和 `end_time` 对应的 `datetime` 对象。这些 Python `datetime`
    对象根据我们在自定义消息中的需求进行格式化。'
- en: '*Line 11* prints the custom message, featuring user-friendly time outputs and
    a couple of Ansible facts, namely the `ansible_facts.fqdn`) and IPv4 address (`ansible_facts.default_ipv4.address`)
    of the host where the message is displayed.'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 11 行* 打印自定义消息，显示用户友好的时间输出和几个 Ansible 事实，具体包括显示消息的主机的 `ansible_facts.fqdn`
    和 IPv4 地址 (`ansible_facts.default_ipv4.address`)。'
- en: 'Now, let’s create a playbook running the template. We will name the playbook
    `update-motd.yml` and add the following content:'
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个运行模板的 playbook。我们将命名该 playbook 为 `update-motd.yml` 并添加以下内容：
- en: '![Figure 17.57 – The update-motd.yml playbook](img/B19682_17_57.jpg)'
  id: totrans-731
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.57 – update-motd.yml playbook](img/B19682_17_57.jpg)'
- en: Figure 17.57 – The update-motd.yml playbook
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.57 – update-motd.yml playbook
- en: The `template` module reads and processes the `motd.j2` file, generating related
    dynamic content, then copies the file to the remote host in `/etc/motd` with the
    required permissions.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '`template` 模块读取并处理 `motd.j2` 文件，生成相关的动态内容，然后将文件以所需的权限复制到远程主机的 `/etc/motd` 中。'
- en: 'Now, we’re ready to run our playbook:'
  id: totrans-734
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备好运行我们的 playbook：
- en: '[PRE106]'
  id: totrans-735
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The command should complete successfully. Here is a screenshot of our output:'
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令应该会成功完成。以下是我们输出的截图：
- en: '![Figure 17.58 – Running the update-motd.yml playbook](img/B19682_17_58.jpg)'
  id: totrans-737
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.58 – 运行 update-motd.yml playbook](img/B19682_17_58.jpg)'
- en: Figure 17.58 – Running the update-motd.yml playbook
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.58 – 运行 update-motd.yml playbook
- en: 'You can immediately verify the `motd` message on any of the hosts (for example,
    `ans-web1`) with the following command:'
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以立即通过以下命令在任何主机（例如，`ans-web1`）上验证 `motd` 消息：
- en: '[PRE107]'
  id: totrans-740
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '![Figure 17.59 – The content of the remote /etc/motd file](img/B19682_17_59.jpg)'
  id: totrans-741
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.59 – 远程 /etc/motd 文件的内容](img/B19682_17_59.jpg)'
- en: Figure 17.59 – The content of the remote /etc/motd file
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.59 – 远程 /etc/motd 文件的内容
- en: 'We can also SSH into any of the hosts to verify the `motd` prompt:'
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以通过 SSH 连接到任何主机以验证 `motd` 提示：
- en: '[PRE108]'
  id: totrans-744
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The Terminal shows the following output:'
  id: totrans-745
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 终端显示以下输出：
- en: '![Figure 17.60 – The motd prompt on the remote host](img/B19682_17_60.jpg)'
  id: totrans-746
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.60 – 远程主机上的 motd 提示](img/B19682_17_60.jpg)'
- en: Figure 17.60 – The motd prompt on the remote host
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.60 – 远程主机上的 motd 提示
- en: 'Now that we know how to write and handle Ansible templates, let’s improve `motd.j2`
    to make it a bit more reusable. We’ll *parameterize* the template by replacing
    the hardcoded local variables for date and time with input variables that are
    passed from the playbook. This way, we’ll make our template reusable across multiple
    playbooks and different input times for maintenance. Here’s the updated template
    file (`motd.j2`):'
  id: totrans-748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道如何编写和处理 Ansible 模板，接下来让我们改进 `motd.j2`，使其更加可重用。我们将通过替换硬编码的日期和时间本地变量为从 playbook
    传递的输入变量来*参数化*模板。这样，我们可以在多个 playbook 中重用模板，并为维护提供不同的输入时间。以下是更新后的模板文件（`motd.j2`）：
- en: '![Figure 17.61 – The modified motd.j2 template with input variables](img/B19682_17_61.jpg)'
  id: totrans-749
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.61 – 修改后的带有输入变量的 motd.j2 模板](img/B19682_17_61.jpg)'
- en: Figure 17.61 – The modified motd.j2 template with input variables
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.61 – 修改后的带有输入变量的 motd.j2 模板
- en: Relevant changes are in *lines 1*-*2*, where we build `datetime` objects using
    the `date`, `start_time`, `end_time`, and `utc` input variables. Notice the difference
    between the *local variables* – `start_time_` and `end_time_` (suffixed with `_`)
    – and the corresponding *input variables*; that is, `start_time` and `end_time`.
    You may choose any naming convention for the variables, assuming it is Ansible-compliant.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的更改出现在*第1行*–*第2行*，我们使用`date`、`start_time`、`end_time`和`utc`输入变量构建`datetime`对象。注意*本地变量*
    `start_time_` 和 `end_time_`（后缀为`_`）与相应的*输入变量* `start_time` 和 `end_time` 之间的区别。你可以选择任何符合Ansible规范的命名约定来命名这些变量。
- en: 'Now, let’s look at our modified playbook (`update-motd.yml`):'
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下我们修改过的Playbook（`update-motd.yml`）：
- en: '![Figure 17.62 – The modified update-motd.yml playbook with variables](img/B19682_17_62.jpg)'
  id: totrans-753
  prefs: []
  type: TYPE_IMG
  zh: '![图17.62 - 修改过的`update-motd.yml` Playbook，带有变量](img/B19682_17_62.jpg)'
- en: Figure 17.62 – The modified update-motd.yml playbook with variables
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.62 - 修改过的`update-motd.yml` Playbook，带有变量
- en: Relevant changes are highlighted in the preceding screenshot, where we added
    variables serving the input for the `motd.j2` template. Running the modified playbook
    should yield the same result as the previous implementation. We’ll leave the related
    exercise to you.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图中突出了相关的变化，我们为`motd.j2`模板添加了变量作为输入。运行修改后的Playbook应与先前的实现产生相同的结果。相关的练习留给你自己去完成。
- en: 'Next, we’ll look at another use case featuring template-based deployments:
    updating the `/etc/hosts` file on managed hosts with the host records of all the
    other servers in the group.'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下另一个基于模板的用例：通过模板更新所有服务器主机记录的`/etc/hosts`文件。
- en: Creating a hosts file template
  id: totrans-757
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个hosts文件模板
- en: 'Another example of using an Ansible template is to automatically update the
    `/etc/hosts` files on every machine by using Jinja2 templating. The `/etc/hosts`
    file contains numerical IP addresses and the names of all hosts on the network,
    and updating it regularly is a useful task for a system administrator. We will
    create a new template for the `hosts` file and then update the specific YAML file
    to access the new template file. To create a `hosts` file template, follow these
    steps:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ansible模板的另一个例子是通过使用Jinja2模板自动更新每台机器上的`/etc/hosts`文件。`/etc/hosts`文件包含了所有主机的数字IP地址和主机名，定期更新它是系统管理员的一项有用任务。我们将为`hosts`文件创建一个新的模板，并更新具体的YAML文件来访问新的模板文件。要创建`hosts`文件模板，请按照以下步骤操作：
- en: 'Let’s start by creating a new template file, named `hosts.j2`, in the `~/ansible/templates`
    directory. Add the following content:'
  id: totrans-759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`~/ansible/templates`目录下创建一个新的模板文件，命名为`hosts.j2`。添加以下内容：
- en: '![Figure 17.63 – The hosts.j2 template file](img/B19682_17_63.jpg)'
  id: totrans-760
  prefs: []
  type: TYPE_IMG
  zh: '![图17.63 - hosts.j2模板文件](img/B19682_17_63.jpg)'
- en: Figure 17.63 – The hosts.j2 template file
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.63 - `hosts.j2`模板文件
- en: 'Here’s how the template script works:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 这是模板脚本的工作原理：
- en: Adds a `localhost` record corresponding to the current host referenced by the
    `inventory_hostname` Ansible special variable
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个与当前主机对应的`localhost`记录，引用Ansible特殊变量`inventory_hostname`。
- en: Executes a loop through all hosts in the inventory referenced by the `groups['all']`
    list (special variable)
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`groups['all']`列表（特殊变量）中循环遍历所有主机。
- en: Checks if the current host in the loop matches the target host, and it will
    only execute next if the hosts are *different*
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查当前循环中的主机是否与目标主机匹配，只有当主机*不同*时，才会执行下一步。
- en: Adds a new host record by reading the default IPv4 address (`default_ipv4.address`)
    of the current host from the related Ansible facts (`hostvars[host].ansible_facts`)
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过读取当前主机的默认IPv4地址（`default_ipv4.address`），在相关的Ansible facts（`hostvars[host].ansible_facts`）中添加新的主机记录。
- en: 'Now, let’s create an `update-hosts.yml` playbook file referencing the `hosts.j2`
    template. Add the following content:'
  id: totrans-767
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`update-hosts.yml` Playbook文件，引用`hosts.j2`模板。添加以下内容：
- en: '![Figure 17.64 – The update-hosts.yml playbook file](img/B19682_17_64.jpg)'
  id: totrans-768
  prefs: []
  type: TYPE_IMG
  zh: '![图17.64 - update-hosts.yml Playbook文件](img/B19682_17_64.jpg)'
- en: Figure 17.64 – The update-hosts.yml playbook file
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.64 - `update-hosts.yml` Playbook文件
- en: This playbook is very similar to `update-motd.yml`. It targets the `/``etc/hosts`
    file.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Playbook与`update-motd.yml`非常相似，它的目标是`/etc/hosts`文件。
- en: 'With the playbook and template files ready, let’s run the following command:'
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Playbook和模板文件准备好后，运行以下命令：
- en: '[PRE109]'
  id: totrans-772
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: ansible ans-web1 -a "cat /etc/hosts"
  id: totrans-773
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ansible ans-web1 -a "cat /etc/hosts"
- en: '[PRE110]'
  id: totrans-774
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '![Figure 17.65 – The autogenerated /etc/hosts file on web1](img/B19682_17_65.jpg)'
  id: totrans-775
  prefs: []
  type: TYPE_IMG
  zh: '![图17.65 - web1上自动生成的`/etc/hosts`文件](img/B19682_17_65.jpg)'
- en: Figure 17.65 – The autogenerated /etc/hosts file on web1
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.65 - web1上自动生成的`/etc/hosts`文件
- en: 'You can also SSH into one of the hosts (for example, `ans-web1`) and ping any
    of the other hosts by name (for example, `ans-db2`):'
  id: totrans-777
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以通过 SSH 连接到其中一台主机（例如 `ans-web1`），然后通过主机名 ping 其他主机（例如 `ans-db2`）：
- en: '[PRE111]'
  id: totrans-778
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '![Figure 17.66 – Successful ping by hostname from one host to another](img/B19682_17_66.jpg)'
  id: totrans-779
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.66 – 从一台主机到另一台主机的成功 ping 操作](img/B19682_17_66.jpg)'
- en: Figure 17.66 – Successful ping by hostname from one host to another
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.66 – 从一台主机到另一台主机的成功 ping 操作
- en: This concludes our study of Ansible templates. However, the topics we covered
    in this section barely scratch the surface of the powerful features and versatility
    of Jinja2 templates. We strongly encourage you to explore the related online help
    resources at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html),
    as well as the titles mentioned in the *Further reading* section at the end of
    this chapter.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 Ansible 模板的学习。然而，我们在本节中所涉及的内容仅仅触及了 Jinja2 模板强大功能和多样性的表面。我们强烈建议你探索相关的在线帮助资源，[https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html)，以及本章结尾的*进一步阅读*部分提到的书目。
- en: 'Now, we will turn our attention to another essential feature of modern configuration
    management platforms: sharing reusable and flexible modules for a variety of system
    administration tasks. Ansible provides a highly accessible and extensible framework
    to accommodate this functionality – **Ansible roles** and **Ansible Galaxy**.
    In the next section, we’ll look at roles for automation reuse.'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把注意力转向现代配置管理平台的另一个重要特性：为各种系统管理任务共享可重用和灵活的模块。Ansible 提供了一个高度易于访问和扩展的框架，以适应这一功能——**Ansible
    角色**和**Ansible Galaxy**。在下一节中，我们将探讨自动化复用的角色。
- en: Creating Ansible roles
  id: totrans-783
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Ansible 角色
- en: With Ansible roles, you can bundle your automated workflows into reusable units.
    A role is essentially a package containing playbooks and other resources that
    have been adapted to a specific configuration using variables. An arbitrary playbook
    would invoke a role by providing the required parameters and running it just like
    any other task. Functionally speaking, roles encapsulate a generic configuration
    management behavior, making them reusable across multiple projects and even shareable
    with others.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ansible 角色，你可以将自动化工作流打包成可重用的单元。角色本质上是一个包含 playbook 和其他资源的包，这些资源通过变量已被调整为特定配置。一个任意的
    playbook 会通过提供所需的参数来调用一个角色，并像运行其他任务一样运行它。从功能上讲，角色封装了通用的配置管理行为，使它们可以在多个项目中重复使用，甚至与他人共享。
- en: 'Here are the key benefits of using roles:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 使用角色的主要好处如下：
- en: 'Encapsulation functionality provides standalone packaging that can easily be
    shared with others. Encapsulation also enables **separation of concerns** (**SoC**):
    multiple DevOps and system administrators can develop roles in parallel.'
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装功能提供了独立的打包形式，便于与他人共享。封装还支持**关注点分离**（**SoC**）：多个 DevOps 和系统管理员可以并行开发角色。
- en: Roles can make larger automation projects more manageable.
  id: totrans-787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色可以使更大的自动化项目变得更易于管理。
- en: 'In this section, we will describe the process of creating a role and how to
    use it in a sample playbook. When authoring roles, we usually follow these steps
    and practices:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述创建角色的过程以及如何在示例 playbook 中使用它。在编写角色时，我们通常遵循以下步骤和实践：
- en: Create or initialize the role directory’s structure. The directory contains
    all resources required by the role in a well-organized fashion.
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建或初始化角色目录结构。该目录以井然有序的方式包含角色所需的所有资源。
- en: Implement the role’s content. Create related playbooks, files, templates, and
    so on.
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现角色的内容。创建相关的 playbook、文件、模板等。
- en: Always start from simple to more advanced functionality. Test your playbooks
    as you add more content.
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终从简单的功能开始，逐步增加更高级的功能。在添加更多内容时，测试你的 playbook。
- en: Make your implementation as generic as possible. Use variables to expose related
    customizations.
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使你的实现尽可能通用。使用变量来暴露相关的自定义设置。
- en: Don’t store secrets in your playbooks or related files. Provide input parameters
    for them.
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将机密信息存储在你的 playbook 或相关文件中。为它们提供输入参数。
- en: Create a dummy playbook with a simple play running your role. Use this dummy
    playbook to test your role.
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的 playbook，运行你的角色作为一个虚拟 play。使用这个虚拟 playbook 来测试你的角色。
- en: Design your role with user experience in mind. Make it easy to use and share
    it with others if you think it would bring value to the community.
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计角色时要考虑用户体验。如果你认为它对社区有价值，可以让它更易用并与他人共享。
- en: 'At a high level, creating a role involves the following steps:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次看，创建角色包括以下步骤：
- en: Initializing the role directory structure
  id: totrans-797
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化角色目录结构
- en: Authoring the role’s content
  id: totrans-798
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写角色内容
- en: Testing the role
  id: totrans-799
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试角色
- en: 'We’ll use the `create-users3.yml` playbook we created earlier in the *Using
    Ansible playbooks* section as our example for creating a role. We will copy this
    file with a new name; `create-users-role.yml`, for example. Before proceeding
    with the next steps, let’s add the following line to our `ansible.cfg` file (which
    is located inside the `~/ansible` directory) in the `[``defaults]` section:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前在*使用Ansible剧本*部分创建的`create-users3.yml`剧本作为创建角色的示例。我们将复制此文件并更名为`create-users-role.yml`，例如。在继续进行下一步之前，让我们在`ansible.cfg`文件（该文件位于`~/ansible`目录中）的[`defaults`]部分添加以下行：
- en: '[PRE112]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This configuration parameter sets the default location for our roles.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置参数设置了我们角色的默认位置。
- en: Now, let’s start by initializing the role directory.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始初始化角色目录。
- en: Initializing the role directory’s structure
  id: totrans-804
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化角色目录结构
- en: Ansible has a strict requirement regarding the folder structure of the role
    directory. The directory must have the same name as the role; for example, `create-users-role`.
    We can create this directory manually or by using a specialized command-line utility
    for managing roles, called `ansible-galaxy`.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible对角色目录的文件夹结构有严格要求。目录必须与角色同名，例如`create-users-role`。我们可以手动创建此目录，也可以使用一个专门的命令行工具`ansible-galaxy`来管理角色。
- en: 'To create the skeleton of our role directory, run the following command:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建角色目录的骨架，请运行以下命令：
- en: '[PRE113]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The command completes with the following message:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 命令完成后会显示以下消息：
- en: '[PRE114]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'You can display the directory structure using the `tree` command:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`tree`命令显示目录结构：
- en: '[PRE115]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'You’ll have to manually install the `tree` command-line utility using your
    local package manager. The output shows the `create-users-role` directory structure
    of our role:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用本地包管理器手动安装`tree`命令行工具。输出显示了我们角色的`create-users-role`目录结构：
- en: '![Figure 17.67 – The create-users-role role directory](img/B19682_17_67.jpg)'
  id: totrans-813
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.67 – 创建用户角色目录](img/B19682_17_67.jpg)'
- en: Figure 17.67 – The create-users-role role directory
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.67 – 创建用户角色目录
- en: 'Here’s a brief explanation of each folder and the corresponding YAML file in
    the role directory:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对角色目录中每个文件夹和相应YAML文件的简要说明：
- en: '`defaults/main.yml`: The default variables for the role. They have the lowest
    priority among all available variables and can be overwritten by any other variable.'
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaults/main.yml`：角色的默认变量。它们在所有可用变量中优先级最低，可以被任何其他变量覆盖。'
- en: '`files`: The static files referenced in the role tasks.'
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`files`：角色任务中引用的静态文件。'
- en: '`handlers/main.yml`: The handlers used by the role. Handlers are tasks that
    are triggered by other tasks. You can read more about handlers at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_handlers.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_handlers.html).'
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handlers/main.yml`：角色使用的处理程序。处理程序是由其他任务触发的任务。您可以在[https://docs.ansible.com/ansible/latest/user_guide/playbooks_handlers.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_handlers.html)了解更多关于处理程序的信息。'
- en: '`README.md`: Explains the intended purpose of the role and how to use it.'
  id: totrans-819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.md`：解释角色的预期用途及如何使用它。'
- en: '`meta/main.yml`: Additional information about the role, such as the author,
    licensing model, platforms, and dependencies on other roles.'
  id: totrans-820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta/main.yml`：关于角色的附加信息，如作者、许可模型、平台以及对其他角色的依赖。'
- en: '`tasks/main.yml`: The tasks played by the role.'
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasks/main.yml`：角色执行的任务。'
- en: '`Templates`: The template files referenced by the role.'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Templates`：角色引用的模板文件。'
- en: '`tests/test.yml`: The playbook for testing the role. The `tests` folder may
    also contain a sample `inventory` file.'
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests/test.yml`：用于测试角色的剧本。`tests`文件夹中也可能包含一个示例`inventory`文件。'
- en: '`vars/main.yml`: The variables used internally by the role. These variables
    have high precedence and are not meant to be changed or overwritten.'
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vars/main.yml`：角色内部使用的变量。这些变量具有较高的优先级，不应更改或覆盖。'
- en: Now that we are familiar with the role directory and the related resource files,
    let’s create our first role.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了角色目录和相关的资源文件，让我们开始创建我们的第一个角色。
- en: Authoring the role’s content
  id: totrans-826
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写角色内容
- en: It is a common practice to start from a previously created playbook and evolve
    it into a role. We’ll take the `create-users-role.yml` playbook. Let’s refactor
    these files to make them more generic.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 从以前创建的剧本开始，并将其演化为角色是一种常见做法。我们将以`create-users-role.yml`剧本为基础。让我们重构这些文件，使它们更具通用性。
- en: 'We will create two new files for the users and passwords, called `users-role.yml`
    and `users_passwords-role.yml`, inside the `./create-users-role` directory files:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`./create-users-role`目录下创建两个新的文件，分别命名为`users-role.yml`和`users_passwords-role.yml`：
- en: '![Figure 17.68 – The users-role.yml and users_passwords-role.yml files](img/B19682_17_68.jpg)'
  id: totrans-829
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.68 – users-role.yml和users_passwords-role.yml文件](img/B19682_17_68.jpg)'
- en: Figure 17.68 – The users-role.yml and users_passwords-role.yml files
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.68 – users-role.yml和users_passwords-role.yml文件
- en: As you may have noticed, we renamed the example user accounts and gave them
    more generic names. We also changed the user dictionary key name from `webusers`
    to `list` in the `users-role.yml` file. Remember that Ansible requires root-level
    dictionary entries (key-value pairs) in YAML files that provide variables.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们重命名了示例用户帐户，并给它们赋予了更通用的名称。我们还将`users-role.yml`文件中的用户字典键名从`webusers`更改为`list`。记住，Ansible要求在YAML文件中提供变量时，字典条目（键值对）需要是根级的。
- en: 'Let’s look at the updated `create-users-role.yml` playbook:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看更新后的`create-users-role.yml`剧本：
- en: '![Figure 17.69 – The modified create-users-role.yml file](img/B19682_17_69.jpg)'
  id: totrans-833
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.69 – 修改后的create-users-role.yml文件](img/B19682_17_69.jpg)'
- en: Figure 17.69 – The modified create-users-role.yml file
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.69 – 修改后的create-users-role.yml文件
- en: 'We made the following modifications:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了以下修改：
- en: We readjusted the `loop` directive to read `users.list` instead of `users.webusers`
    due to the name change of the related dictionary key in the `users.yml` file
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调整了`loop`指令，将其从`users.webusers`改为`users.list`，因为`users.yml`文件中相关字典键名发生了变化。
- en: We refactored the `include_vars` file references to use variables instead of
    hardcoded filenames
  id: totrans-837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们重构了`include_vars`文件引用，改为使用变量而非硬编码的文件名。
- en: We added a `vars` section, with the `users_file` and `passwords_file` variables
    pointing to the corresponding YAML files
  id: totrans-838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个`vars`部分，其中`users_file`和`passwords_file`变量指向相应的YAML文件。
- en: 'With these changes in the playbook, we’re now ready to implement our role.
    Looking at the `create-users-role` role directory, we’ll do the following:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些剧本中的更改，我们现在可以实施我们的角色。查看`create-users-role`角色目录，我们将执行以下操作：
- en: Copy/paste the variables in the `vars` section of `create-users-role.yml` into
    `defaults/main.yml`.
  id: totrans-840
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`create-users-role.yml`中`vars`部分的变量复制/粘贴到`defaults/main.yml`中。
- en: Copy/paste the tasks from `create-users-role.yml` into `tasks/main.yml`. Make
    sure you keep the relative indentations.
  id: totrans-841
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`create-users-role.yml`中的任务复制/粘贴到`tasks/main.yml`中。确保保持相对缩进。
- en: Create a simple playbook using the role. Use the `tests/test.yml` file for your
    test playbook. Copy/move `users-role.yml` and `users_passwords-role.yml` to the
    `tests/` folder.
  id: totrans-842
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的剧本，使用该角色。将`tests/test.yml`文件用作你的测试剧本。将`users-role.yml`和`users_passwords-role.yml`复制/移动到`tests/`文件夹。
- en: 'The following screenshot captures all these changes:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了所有这些更改：
- en: '![Figure 17.70 – The files that we changed in the create-users role directory](img/B19682_17_70.jpg)'
  id: totrans-844
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.70 – 我们在create-users角色目录中更改的文件](img/B19682_17_70.jpg)'
- en: Figure 17.70 – The files that we changed in the create-users role directory
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.70 – 我们在create-users角色目录中更改的文件
- en: 'We also recommend updating the `README.md` file in the `create-users-role`
    directory with notes about the purpose and usage of the role. You should also
    mention the requirement of having the `users-role.yml` and `users_passwords-role.yml`
    files with the related data structures. The names of these files can be changed
    via the `users_file` and `passwords_file` variables in `defaults/main.yml`. You
    can also provide some examples of how to use the role. We also created an additional
    `test2.yml` playbook using a task to run the role:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还建议更新`create-users-role`目录中的`README.md`文件，添加有关角色的目的和使用说明。你还应该提到需要有`users-role.yml`和`users_passwords-role.yml`文件，并包含相关的数据结构。这些文件的名称可以通过`defaults/main.yml`中的`users_file`和`passwords_file`变量进行更改。你还可以提供一些如何使用该角色的示例。我们还创建了一个额外的`test2.yml`剧本，使用一个任务来运行该角色：
- en: '![Figure 17.71 – Running a role using a task](img/B19682_17_71.jpg)'
  id: totrans-847
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.71 – 使用任务运行角色](img/B19682_17_71.jpg)'
- en: Figure 17.71 – Running a role using a task
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.71 – 使用任务运行角色
- en: At this point, we’ve finished making the required changes for implementing the
    role. You may choose to remove all empty or unused folders in the `create-users-role`
    role directory.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经完成了实现角色所需的更改。你可以选择删除 `create-users-role` 角色目录中所有空的或未使用的文件夹。
- en: Now, let’s test our role.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来测试我们的角色。
- en: Testing the role
  id: totrans-851
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试角色
- en: 'To test our role, we will use the playbooks in the `tests/` folder and run
    them with the following commands:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的角色，我们将使用 `tests/` 文件夹中的剧本，并通过以下命令运行它们：
- en: '[PRE116]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Both commands should complete successfully.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令应该都能成功完成。
- en: With that, we’ve provided an exploratory view of Ansible roles, as they are
    a powerful feature of Ansible, and they enable modern system administrators and
    DevOps to move quickly from concept to implementation, accelerating the deployment
    of everyday configuration management workflows.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就提供了一个探索性视图，了解 Ansible 角色，它们是 Ansible 的一个强大功能，使现代系统管理员和 DevOps 能够从概念迅速过渡到实现，加速日常配置管理工作流的部署。
- en: Summary
  id: totrans-856
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered significant ground in terms of Ansible. Due to this
    chapter’s limited scope, we couldn’t capture all of Ansible’s vast number of features.
    However, we tried to provide an overarching view of the platform, from Ansible’s
    architectural principles to configuring and working with ad hoc commands and playbooks.
    You learned how to set up an Ansible environment, with several managed hosts and
    a control node, thereby emulating a real-world deployment at a high level. You
    also became familiar with writing Ansible commands and scripts for typical configuration
    management tasks. Most of the commands and playbooks presented throughout this
    chapter closely resemble everyday administrative operations.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经涵盖了 Ansible 的重要内容。由于本章范围有限，我们无法涵盖 Ansible 众多的功能。然而，我们尽力提供了平台的整体视图，从
    Ansible 的架构原则到配置和使用临时命令以及剧本。你学习了如何设置 Ansible 环境，包含多个受管主机和一个控制节点，从而在高层次上模拟了一个真实的部署环境。你还熟悉了编写
    Ansible 命令和脚本，用于典型的配置管理任务。本章中展示的大部分命令和剧本都与日常的管理操作非常相似。
- en: Whether you are a systems administrator or a DevOps engineer, a seasoned professional,
    or on the way to becoming one, we hope this chapter brought new insights to your
    everyday Linux administration tasks and automation workflows. The tools and techniques
    you’ve learned here will give you a good start for scripting and automating larger
    portions of your daily administrative routines.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是系统管理员、DevOps 工程师，还是一位经验丰富的专业人士，或者正在朝着这个目标前进，我们希望本章能够为你在日常 Linux 管理任务和自动化工作流中带来新的启示。你在这里学到的工具和技术将为你脚本化和自动化日常管理任务中的更大部分工作打下良好的基础。
- en: The same closing thoughts also apply to this book in general. You have come
    a long way in terms of learning and mastering some of the most typical Linux administration
    tasks in on-premises and cloud environments alike.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的结尾思考也适用于本书的整体内容。在学习和掌握一些最典型的 Linux 管理任务方面，无论是在本地环境还是云环境中，你已经走了很长一段路。
- en: We hope that you have enjoyed our journey together.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你在我们的旅程中获得了愉快的体验。
- en: Questions
  id: totrans-861
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s try to wrap up some of the essential concepts we learned about in this
    chapter by completing the following quiz:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过完成以下小测试来总结本章中学到的一些基本概念：
- en: What are idempotent operations or commands in Ansible?
  id: totrans-863
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible 中的幂等操作或命令是什么？
- en: You want to set up passwordless authentication with your managed hosts. What
    steps should you follow?
  id: totrans-864
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你想要设置与受管主机的免密码认证。你应该遵循哪些步骤？
- en: What is the ad hoc command for checking communication with all your managed
    hosts?
  id: totrans-865
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查与所有受管主机通信的临时命令是什么？
- en: Enumerate a few Ansible modules. Try to think of a configuration management
    scenario where you could use each module.
  id: totrans-866
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举一些 Ansible 模块。试着想出一个配置管理场景，在其中你可以使用每个模块。
- en: Think of a simple playbook that monitors the memory that’s available on your
    hosts and will notify you if that memory is above a given threshold.
  id: totrans-867
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象一个简单的剧本，它监控主机上可用的内存，并在内存超过给定阈值时通知你。
- en: Further reading
  id: totrans-868
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are a few resources we found helpful for learning more about Ansible internals:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们认为有助于深入了解 Ansible 内部结构的资源：
- en: 'Ansible documentation: [https://docs.ansible.com/](https://docs.ansible.com/)'
  id: totrans-870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ansible 文档: [https://docs.ansible.com/](https://docs.ansible.com/)'
- en: 'Ansible use cases, by Red Hat: [https://www.ansible.com/use-cases](https://www.ansible.com/use-cases)'
  id: totrans-871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ansible 使用案例，来自 Red Hat: [https://www.ansible.com/use-cases](https://www.ansible.com/use-cases)'
- en: '*Dive into Ansible – From Beginner to Expert in Ansible* [Video], by James
    Spurin, Packt Publishing ([https://www.packtpub.com/product/dive-into-ansible-from-beginner-to-expert-in-ansible-video/9781801076937](https://www.packtpub.com/product/dive-into-ansible-from-beginner-to-expert-in-ansible-video/9781801076937))'
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*深入了解 Ansible – 从初学者到专家* [视频]，作者：James Spurin，Packt Publishing ([https://www.packtpub.com/product/dive-into-ansible-from-beginner-to-expert-in-ansible-video/9781801076937](https://www.packtpub.com/product/dive-into-ansible-from-beginner-to-expert-in-ansible-video/9781801076937))'
- en: '*Practical Ansible 2*, by Daniel Oh, James Freeman, Fabio Alessandro Locati,
    Packt Publishing ([https://www.packtpub.com/product/practical-ansible-2/9781789807462](https://www.packtpub.com/product/practical-ansible-2/9781789807462))'
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实用 Ansible 2*，作者：Daniel Oh，James Freeman，Fabio Alessandro Locati，Packt Publishing
    ([https://www.packtpub.com/product/practical-ansible-2/9781789807462](https://www.packtpub.com/product/practical-ansible-2/9781789807462))'
