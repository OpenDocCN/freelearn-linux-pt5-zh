- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Securing Linux
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护 Linux
- en: '**Securing** a Linux machine is usually a balancing act. The endgame is essentially
    protecting data from unwanted access. While there are many ways to achieve this
    goal, we should adopt the methods that yield maximum protection, along with the
    most efficient system administration. Gauging the attack and vulnerability surfaces,
    both internal and external, is always a good start. The rest of the work is building
    fences and putting on armor—not too high and not too heavy. The outer fence is
    a **network firewall**. Internally, at the system level, we build **application
    security policies**. This chapter introduces both, albeit the art of the balancing
    act is left to you.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**保护** Linux 机器通常是一项平衡工作。最终目标本质上是防止数据被未授权访问。虽然有很多方法可以实现这一目标，但我们应当采用那些提供最大保护且最具效率的系统管理方法。评估攻击面和漏洞面（无论是内外部）通常是一个良好的起点。剩下的工作就是建立围栏并穿上盔甲——既不过高，也不过重。外部围栏是
    **网络防火墙**。在内部系统层面，我们构建 **应用安全策略**。本章介绍了这两者，尽管平衡的艺术将由你来掌握。'
- en: In the first part of this chapter, we’ll look at **access control mechanisms**
    (**ACMs**) and the related security modules—**Security-Enhanced Linux** (**SELinux**)
    and **AppArmor**. In the second part, we will explore packet filtering frameworks
    and firewall solutions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们将讨论 **访问控制机制**（**ACMs**）及相关的安全模块——**安全增强 Linux**（**SELinux**）和 **AppArmor**。第二部分将探讨数据包过滤框架和防火墙解决方案。
- en: After completing this chapter, you will have become acquainted with the tools
    for designing and managing application security frameworks and firewalls—a first
    solid step to securing a Linux system.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将熟悉用于设计和管理应用安全框架和防火墙的工具，这是保护 Linux 系统的第一步坚实基础。
- en: 'Here’s a brief overview of the topics that will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章将要讨论的主题概述：
- en: Understanding Linux security—An overview of the ACMs available in the Linux
    kernel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Linux 安全—Linux 内核中可用的 ACM 概述
- en: Introducing SELinux—An in-depth look at the Linux kernel security framework
    for managing access control policies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 SELinux—深入了解用于管理访问控制策略的 Linux 内核安全框架
- en: Introducing AppArmor—A relatively new security module that controls application
    capabilities based on security profiles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 AppArmor—一个相对较新的安全模块，它基于安全配置文件控制应用程序的功能
- en: Working with firewalls—A comprehensive overview of firewall modules, including
    `iptables`, `nftables`, `firewalld`, and the `ufw`)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用防火墙—全面概述防火墙模块，包括 `iptables`、`nftables`、`firewalld` 和 `ufw`
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter covers a relatively vast array of topics, some of which will be
    covered with extensive command-line operations. We recommend that you use both
    a Fedora and an Ubuntu platform with Terminal or SSH access. Direct console access
    to the systems is highly preferable due to the possibly disruptive way of altering
    firewall rules.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及多个主题，其中一些内容将通过大量命令行操作进行讲解。我们建议使用 Fedora 和 Ubuntu 平台，并通过终端或 SSH 访问。由于可能会影响防火墙规则的更改方式，直接访问控制台是更为理想的选择。
- en: Understanding Linux security
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Linux 安全
- en: 'One significant consideration for securing a computer system or network is
    the means for system administrators to control how users and processes can access
    various resources, such as files, devices, and interfaces, across systems. The
    Linux kernel provides a handful of such mechanisms, collectively referred to as
    ACMs. Let’s describe them briefly:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 保护计算机系统或网络的一个重要考虑因素是系统管理员控制用户和进程如何访问各类资源（如文件、设备和接口）的方法，这些资源遍布各个系统。Linux 内核提供了几种这样的机制，统称为
    **访问控制机制**（**ACMs**）。我们简要介绍它们：
- en: '**Discretionary access control** (**DAC**) is the typical ACM related to filesystem
    objects, including files, directories, and devices. Such access is at the discretion
    of the object’s owner when managing permissions. DAC controls access to *objects*
    based on the identity of users and groups (*subjects*). Depending on a subject’s
    access permissions, they could also pass permissions to other subjects —an administrator
    managing regular users, for example.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自主访问控制**（**DAC**）是与文件系统对象（包括文件、目录和设备）相关的典型 ACM。此类访问权限由对象的所有者在管理权限时自行决定。DAC
    根据用户和组的身份（即 **主体**）来控制对 *对象* 的访问。根据主体的访问权限，他们还可以将权限传递给其他主体——例如，管理员可以管理普通用户的权限。'
- en: '**Access control lists** (**ACLs**) provide control over which subjects (such
    as users and groups) have access to specific filesystem objects (such as files
    and directories).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问控制列表**(**ACLs**)提供了对哪些主体（如用户和组）可以访问特定文件系统对象（如文件和目录）的控制。'
- en: '**Mandatory access control** (**MAC**) provides different access control levels
    to subjects over the objects they own. Unlike DAC, where users have full control
    over the filesystem objects they own, MAC adds additional labels, or categories,
    to all filesystem objects. Consequently, subjects must have the appropriate access
    to these categories to interact with the objects labeled as such. MAC is enforced
    by *SELinux* on **Red Hat Enterprise Linux** (**RHEL**)/Fedora and *AppArmor*
    on Ubuntu/Debian/openSUSE.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制访问控制**(**MAC**)为主体提供不同的访问控制级别，以管理它们所拥有的对象。与DAC不同，DAC中用户对自己拥有的文件系统对象拥有完全控制权，而MAC为所有文件系统对象添加了额外的标签或类别。因此，主体必须具备访问这些类别的适当权限，才能与被标记为该类别的对象进行交互。MAC由*SELinux*在**Red
    Hat Enterprise Linux**(**RHEL**)/Fedora上执行，而在Ubuntu/Debian/openSUSE上则由*AppArmor*执行。'
- en: '**Role-based access control** (**RBAC**) is an alternative to the permission-based
    access control of filesystem objects. Instead of permissions, a system administrator
    assigns *roles* that have access to a specific filesystem object. Roles could
    be based on some business or functional criteria and may have different access
    levels to objects.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于角色的访问控制**(**RBAC**)是基于权限的文件系统对象访问控制的替代方法。系统管理员根据某些业务或功能标准为特定文件系统对象分配*角色*，而不是使用权限。角色可以基于某些业务或功能标准，并可能对对象有不同的访问级别。'
- en: In contrast to DAC or MAC, where subjects have access to objects based strictly
    on the permissions involved, the RBAC model represents a logical abstraction over
    MAC or DAC, where the subjects must be members of a specific group or role before
    interacting with objects.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与DAC或MAC不同，在DAC或MAC中，主体对对象的访问严格依赖于权限，而RBAC模型是基于MAC或DAC的一种逻辑抽象，主体必须先是特定组或角色的成员，才能与对象进行交互。
- en: '**Multi-level security** (**MLS**) is a specific MAC scheme where the *subjects*
    are processes and the *objects* are files, sockets, and other similar system resources.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多级安全**(**MLS**)是一种特定的MAC方案，其中*主体*是进程，*对象*是文件、套接字以及其他类似的系统资源。'
- en: '**Multi-category security** (**MCS**) is an improved version of SELinux that
    allows users to label files with *categories*. MCS reuses much of the MLS framework
    in SELinux.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多类别安全**(**MCS**)是SELinux的改进版本，允许用户为文件打上*类别*标签。MCS重用了SELinux中许多MLS框架的内容。'
- en: Wrapping up our brief discussion on ACMs, we should note that we covered some
    of the internals of DAC and ACL in [*Chapter 4*](B19682_04.xhtml#_idTextAnchor090),
    *Managing Users and Groups*, particularly in the *Managing* *permissions* section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下我们对ACM的简短讨论，我们应该指出，我们在[*第4章*](B19682_04.xhtml#_idTextAnchor090)，*管理用户和组*，特别是在*管理*
    *权限*部分，讨论了DAC和ACL的一些内部机制。
- en: Next, we’ll turn our attention to SELinux—a first-class citizen for MAC implementations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将关注SELinux——MAC实现中的重要组成部分。
- en: Introducing SELinux
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍SELinux
- en: '**SELinux** is a security framework in the Linux kernel for managing the access
    control policies of system resources. It supports a combination of the MAC, RBAC,
    and MLS models that were described in the previous section. SELinux is a set of
    kernel-space security modules and user-space command-line utilities, and it provides
    a mechanism for system administrators to have control over *who* can access *what*
    on the system. SELinux is designed to also protect a system against possible misconfigurations
    and potentially compromised processes.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**SELinux**是Linux内核中的一个安全框架，用于管理系统资源的访问控制策略。它支持前一节中描述的MAC、RBAC和MLS模型的组合。SELinux是一组内核空间的安全模块和用户空间的命令行工具，它为系统管理员提供了一个机制，可以控制*谁*可以访问*什么*资源。SELinux还旨在保护系统免受可能的配置错误和潜在受损进程的影响。'
- en: SELinux was introduced by the **National Security Agency** (**NSA**) as a collection
    of **Linux Security Modules** (**LSM**) with kernel updates. SELinux was eventually
    released to the open source community in 2000 and became part of Linux starting
    with the 2.6 kernel series in 2003.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux由**国家安全局**(**NSA**)作为一组**Linux安全模块**(**LSM**)和内核更新一起引入。SELinux最终于2000年发布给开源社区，并从2003年开始成为Linux
    2.6内核系列的一部分。
- en: So, how does SELinux work? We’ll look at this in the next section. We will use
    Fedora 37 Server Edition for all our examples.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，SELinux是如何工作的呢？我们将在下一节中讨论这个问题。我们将使用Fedora 37服务器版作为所有示例的操作系统。
- en: Working with SELinux
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SELinux
- en: SELinux uses **security policies** to define various access control levels for
    applications, processes, and files on a system. A security policy is a set of
    rules describing what can or cannot be accessed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 使用**安全策略**来定义系统中应用程序、进程和文件的各种访问控制级别。安全策略是一组规则，描述了什么可以或不能被访问。
- en: SELinux operates with **subjects** and **objects**. When a specific application
    or process (the *subject*) requests access to a file (the *object*), SELinux checks
    the required permissions involved in the request and enforces the related access
    control. The permissions for subjects and objects are stored in a lookup table
    known as the **Access Vector Cache** (**AVC**). The AVC is generated based on
    the **SELinux** **policy database**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 操作基于**主体**和**对象**。当一个特定的应用程序或进程（*主体*）请求访问一个文件（*对象*）时，SELinux 会检查请求中涉及的所需权限并执行相关的访问控制。主体和对象的权限存储在一个称为**访问向量缓存**（**AVC**）的查找表中。AVC
    是基于**SELinux** **策略数据库**生成的。
- en: 'A typical SELinux policy consists of the following resources (files), each
    reflecting a specific aspect of the security policy:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 SELinux 策略包含以下资源（文件），每个文件反映了安全策略的特定方面：
- en: '**Type enforcement**: Actions that have been granted or denied for the policy
    (such as read or write access to a file)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型强制**：对于策略已授予或拒绝的操作（例如读取或写入文件访问权限）'
- en: '**Interface**: The application interface the policy interacts with (such as
    logging)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**：策略与之交互的应用程序接口（例如日志记录）'
- en: '**File contexts**: The system resources associated with the policy (such as
    log files)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件上下文**：与策略相关的系统资源（例如日志文件）'
- en: These policy files are compiled together using SELinux build tools to produce
    a specific **security policy**. The policy is loaded into the kernel, added to
    the SELinux policy database, and made active without a system reboot.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些策略文件通过 SELinux 构建工具汇编在一起，生成一个特定的**安全策略**。该策略被加载到内核中，添加到 SELinux 策略数据库，并在不重启系统的情况下生效。
- en: 'When creating SELinux policies, we usually test them in *permissive* mode first,
    where violations are logged but still allowed. When violations occur, the `audit2allow`
    utility in the SELinux toolset comes to the rescue. We use the log traces produced
    by `audit2allow` to create additional rules required by the policy to account
    for legitimate access permissions. SELinux violations are logged in `/var/log/messages`
    and are prefixed with `avc: denied`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '在创建 SELinux 策略时，我们通常首先在*permissive*模式下测试它们，在该模式下，违规行为会被记录，但仍然允许。当违规发生时，SELinux
    工具集中的 `audit2allow` 工具会提供帮助。我们使用 `audit2allow` 产生的日志痕迹来创建政策所需的额外规则，以考虑合法的访问权限。SELinux
    违规行为会被记录在`/var/log/messages`中，并以`avc: denied`为前缀。'
- en: Before we learn how to create and manage a SELinux security policy, let’s look
    at some higher-level operations for managing and controlling SELinux in everyday
    administration tasks.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习如何创建和管理 SELinux 安全策略之前，让我们先看一些管理和控制 SELinux 的高级操作，用于日常管理任务。
- en: Understanding SELinux modes
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 SELinux 模式
- en: 'SELinux is either *enabled* or *disabled* in a system. When enabled, it operates
    in either of the following modes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 在系统中要么是*启用*的，要么是*禁用*的。当启用时，它以以下模式之一运行：
- en: '`enforcing`: SELinux effectively monitors and controls security policies. In
    RHEL/Fedora, this mode is enabled by default.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enforcing`：SELinux 有效地监控和控制安全策略。在 RHEL/Fedora 中，默认启用此模式。'
- en: '`permissive`: Security policies are actively monitored without enforcing access
    control. Policy violations are logged in `/var/log/messages`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`permissive`：安全策略被积极监控，但不执行访问控制。策略违规会被记录在`/var/log/messages`中。'
- en: 'When SELinux is disabled, security policies are neither monitored nor enforced.
    The following command retrieves the current status of SELinux on the system:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SELinux 被禁用时，安全策略既不被监控也不被执行。以下命令用于检索系统上 SELinux 的当前状态：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 9.1 – Getting the current status of SELinux](img/B19682_09_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 获取 SELinux 当前状态](img/B19682_09_01.jpg)'
- en: Figure 9.1 – Getting the current status of SELinux
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 获取 SELinux 当前状态
- en: 'When SELinux is enabled, the following command retrieves the current mode:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SELinux 启用时，以下命令用于检索当前模式：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In `permissive` mode, we get the `enforcing` output.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`permissive`模式下，我们得到`enforcing`的输出。
- en: 'To change from `enforcing` to `permissive` mode, we can run the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 `enforcing` 模式切换到 `permissive` 模式，我们可以运行以下命令：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `getenforce` command will display `permissive` in this case. To switch
    back into `enforcing` mode, we can run the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`getenforce` 命令会显示 `permissive`。要切换回 `enforcing` 模式，可以运行以下命令：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The SELinux mode can also be set by editing the `SELINUX` value in `/etc/selinux/config`.
    Possible values are documented in the configuration file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 模式也可以通过编辑 `/etc/selinux/config` 中的 `SELINUX` 值来设置。配置文件中记录了可能的值。
- en: Important note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Manually editing the SELinux configuration file requires a system reboot for
    changes to take effect.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 手动编辑 SELinux 配置文件需要重启系统才能使更改生效。
- en: 'With SELinux enabled, a system administrator may choose between the following
    SELinux policy levels by modifying the `SELINUXTYPE` value in `/etc/selinux/config`:
    `targeted`, `minimum`, and `mls`. The corresponding values are documented in the
    configuration file.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 SELinux 后，系统管理员可以通过修改 `/etc/selinux/config` 中的 `SELINUXTYPE` 值，选择以下 SELinux
    策略级别：`targeted`、`minimum` 和 `mls`。相应的值在配置文件中有详细说明。
- en: Important note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The default SELinux policy setting is `targeted`, and it’s generally recommended
    not to change this setting, except for `mls`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 SELinux 策略设置是 `targeted`，通常建议不更改此设置，除非是 `mls`。
- en: With the `targeted` policy in place, only processes that are specifically configured
    to use SELinux security policies can run in a *confined* (or restricted) domain.
    Such processes usually include system daemons (such as `dhcpd` and `sshd`) and
    well-known server applications (such as Apache and PostgreSQL). All other (non-targeted)
    processes run unrestricted and are usually labeled with the `unconfined_t` domain
    type.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用 `targeted` 策略后，只有那些专门配置为使用 SELinux 安全策略的进程才能在*受限*（或限制）域中运行。这些进程通常包括系统守护进程（如
    `dhcpd` 和 `sshd`）以及知名的服务器应用程序（如 Apache 和 PostgreSQL）。所有其他（非目标）进程不受限制，并通常被标记为 `unconfined_t`
    域类型。
- en: 'To completely disable SELinux, we can edit the `/etc/selinux/config` file using
    a text editor of our choice (such as `sudo nano /etc/selinux/config`) and make
    the following change:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全禁用 SELinux，我们可以使用我们选择的文本编辑器（如 `sudo nano /etc/selinux/config`）编辑 `/etc/selinux/config`
    文件，并进行以下更改：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, we can run the following command to change the SELinux mode
    from `enforcing` to `disabled`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以运行以下命令，将 SELinux 模式从 `enforcing` 更改为 `disabled`：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can retrieve the current configuration with the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令检索当前配置：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With SELinux disabled, we get the following output (excerpt):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SELinux 被禁用的情况下，我们将获得以下输出（摘录）：
- en: '![Figure 9.2 – Disabling SELinux](img/B19682_09_02.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 禁用 SELinux](img/B19682_09_02.jpg)'
- en: Figure 9.2 – Disabling SELinux
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 禁用 SELinux
- en: 'We need to reboot the system for changes to take effect:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重启系统才能使更改生效：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, let’s examine how access control decisions are made by introducing **SELinux
    contexts**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过介绍**SELinux 上下文**来查看访问控制决策是如何做出的。
- en: Understanding SELinux contexts
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 SELinux 上下文
- en: With SELinux enabled, processes and files are labeled with a **context** containing
    additional SELinux-specific information, such as *user*, *role*, *type*, and *level*
    (optional). The context data serves for SELinux access control decisions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 SELinux 后，进程和文件会被标记上一个包含附加 SELinux 特定信息的**上下文**，如*用户*、*角色*、*类型*和*级别*（可选）。该上下文数据用于
    SELinux 的访问控制决策。
- en: SELinux adds the `-Z` option to the `ls`, `ps`, and other commands, thus displaying
    the security context of filesystem objects, processes, and more.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 为 `ls`、`ps` 等命令添加了 `-Z` 选项，从而显示文件系统对象、进程等的安全上下文。
- en: 'Let’s create an arbitrary file and examine the related SELinux context:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个任意文件并检查相关的 SELinux 上下文：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 9.3 – Displaying the SELinux context of a file](img/B19682_09_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 显示文件的 SELinux 上下文](img/B19682_09_03.jpg)'
- en: Figure 9.3 – Displaying the SELinux context of a file
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 显示文件的 SELinux 上下文
- en: 'The SELinux context has the following format—a sequence of four fields, separated
    by a colon (`:`):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 上下文具有以下格式——由冒号（`:`）分隔的四个字段的序列：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let’s take a look at the SELinux context fields:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看 SELinux 上下文字段：
- en: '`semanage` utility is available with the `policycoreutils` package, which you
    may need to install on your system:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`semanage` 工具是 `policycoreutils` 包的一部分，您可能需要在系统上安装此包：'
- en: '[PRE10]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The command yields the following output. The output may differ slightly from
    system to system:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令的输出如下。输出可能因系统不同而略有差异：
- en: '![Figure 9.4 – Displaying the SELinux user mappings](img/B19682_09_04.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 显示 SELinux 用户映射](img/B19682_09_04.jpg)'
- en: Figure 9.4 – Displaying the SELinux user mappings
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 显示 SELinux 用户映射
- en: For more information on the `semanage` command-line utility, you may refer to
    the related system reference (`man semanage`, `man semanage-login`).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 若要获取更多关于 `semanage` 命令行工具的信息，可以参考相关的系统参考（`man semanage`，`man semanage-login`）。
- en: '**SELinux roles**: SELinux roles are part of the RBAC security model, and they
    are essentially RBAC attributes. In the SELinux context hierarchy, users are authorized
    for roles, and roles are authorized for types or domains. In the SELinux context
    terminology, **types** refer to filesystem object types and **domains** refer
    to process types (see more under *SELinux type* in this list).'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SELinux 角色**：SELinux 角色是 RBAC 安全模型的一部分，实质上是 RBAC 属性。在 SELinux 上下文层次结构中，用户被授权角色，角色被授权类型或域。在
    SELinux 上下文术语中，**类型**指的是文件系统对象类型，**域**指的是进程类型（参见此列表中的 *SELinux 类型*）。'
- en: Take Linux processes, for example. The SELinux role serves as an intermediary
    access layer between domains and SELinux users. An *accessible* role determines
    which domain (that is, processes) can be accessed through that role. Ultimately,
    this mechanism controls which object types can be accessed by the process, thus
    minimizing the surface for privilege escalation attacks.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以 Linux 进程为例，SELinux 角色作为域和 SELinux 用户之间的中介访问层。一个 *可访问* 的角色决定了哪个域（即进程）可以通过该角色进行访问。最终，这一机制控制了进程可以访问哪些对象类型，从而最小化权限提升攻击的攻击面。
- en: '**SELinux type**: The SELinux type is an attribute of SELinux *type enforcement*—a
    MAC security construct. For SELinux types, we refer to domains as process types
    and types as filesystem object types. SELinux security policies control how specific
    types can access each other—either with domain-to-type access or domain-to-domain
    interactions.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SELinux 类型**：SELinux 类型是 SELinux *类型强制*的一种属性——一种 MAC 安全构造。对于 SELinux 类型，我们将域称为进程类型，将类型称为文件系统对象类型。SELinux
    安全策略控制特定类型如何相互访问——无论是域到类型的访问，还是域到域的交互。'
- en: '`unclassified`, `confidential`, `secret`, and `top-secret` and are expressed
    as a `low-high` if the levels differ or just `low` if the levels are identical.
    For example, a level of `s0-s0` is the same as `s0`. Each level represents a *sensitivity-category*
    pair, with categories being optional. When a category is specified, the level
    is defined as `sensitivity:category-set`; otherwise, it’s defined as `sensitivity`
    only.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unclassified`、`confidential`、`secret` 和 `top-secret`，如果级别不同，则以 `low-high`
    表示，或者如果级别相同，则仅为 `low`。例如，`s0-s0` 等同于 `s0`。每个级别代表一个 *敏感性-类别* 对，其中类别是可选的。当指定类别时，级别定义为
    `sensitivity:category-set`；否则，仅定义为 `sensitivity`。'
- en: We are now familiar with SELinux contexts. We’ll see them in action, starting
    with the SELinux contexts for users, next.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经熟悉 SELinux 上下文。接下来，我们将看到 SELinux 用户上下文的实际应用。
- en: SELinux contexts for users
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SELinux 用户上下文
- en: 'The following command displays the SELinux context associated with the current
    user:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示与当前用户相关的 SELinux 上下文：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In our case, the output is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，输出如下：
- en: '![Figure 9.5 – Displaying the current user’s SELinux context](img/B19682_09_05.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 显示当前用户的 SELinux 上下文](img/B19682_09_05.jpg)'
- en: Figure 9.5 – Displaying the current user’s SELinux context
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 显示当前用户的 SELinux 上下文
- en: 'In RHEL/Fedora, Linux users are `unconfined` (unrestricted) by default, with
    the following context fields:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RHEL/Fedora 中，Linux 用户默认是 `unconfined`（不受限制）的，具有以下上下文字段：
- en: '`unconfined_u`: User identity'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unconfined_u`：用户身份'
- en: '`unconfined_r`: Role'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unconfined_r`：角色'
- en: '`unconfined_t`: Domain affinity'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unconfined_t`：域关联'
- en: '`s0-s0`: MLS range (the equivalent of `s0`)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s0-s0`：MLS 范围（相当于 `s0`）'
- en: '`c0.c1023`: Category set, representing all categories (from `c0` to `c1023`)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c0.c1023`：类别集，表示所有类别（从 `c0` 到 `c1023`）'
- en: Next, we’ll examine the SELinux context for processes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究进程的 SELinux 上下文。
- en: SELinux contexts for processes
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SELinux 进程上下文
- en: 'The following command displays the SELinux context for current SSH processes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示当前 SSH 进程的 SELinux 上下文：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The command yields the following output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 命令输出如下：
- en: '![Figure 9.6 – Displaying the SELinux context for SSH-related processes](img/B19682_09_06.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 显示与 SSH 相关进程的 SELinux 上下文](img/B19682_09_06.jpg)'
- en: Figure 9.6 – Displaying the SELinux context for SSH-related processes
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 显示与 SSH 相关进程的 SELinux 上下文
- en: From the output, we can infer that the first line refers to the `sshd` server
    process, which is running with the `system_u` user identity, `system_r` role,
    and `sshd_t` domain affinity. The second line refers to the current user’s SSH
    session, hence the `unconfined` context. System daemons are usually associated
    with the `system_u` user and `system_r` role.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出结果中，我们可以推断第一行指的是运行着`sshd`服务器进程，使用了`system_u`用户身份，`system_r`角色，以及`sshd_t`域亲和性。第二行指的是当前用户的SSH会话，因此使用了`unconfined`上下文。系统守护程序通常与`system_u`用户和`system_r`角色相关联。
- en: Before concluding this section on SELinux contexts, we’ll examine the relatively
    common scenario of SELinux domain transitions, which is where a process in one
    domain accesses an object (or process) in a different domain.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在总结本节关于SELinux上下文的内容之前，我们将详细讨论SELinux域过渡的相对常见情景，即一个域中的进程访问另一个域中的对象（或进程）。
- en: SELinux domain transitions
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SELinux域过渡
- en: Assuming an SELinux-secured process in one domain requests access to an object
    (or another process) in a different domain, SELinux **domain transitions** come
    into play. Unless there’s a specific security policy allowing the related domain
    transition, SELinux would deny access.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个SELinux保护的进程在一个域中请求访问另一个域中的对象（或另一个进程），SELinux **域过渡** 就会发挥作用。除非存在允许相关域过渡的特定安全策略，否则SELinux会拒绝访问。
- en: An SELinux-protected process transitioning from one domain into another invokes
    the `entrypoint` type of the new domain. SELinux evaluates the related entrypoint
    permission and decides if the soliciting process can enter the new domain.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个从一个域过渡到另一个域的SELinux保护进程会调用新域的`entrypoint`类型。SELinux会评估相关的入口点权限，并决定是否允许发起进程进入新的域。
- en: To illustrate a domain transition scenario, we will take the simple case of
    using the `passwd` utility when users change their password. The related operation
    involves the interaction between the `passwd` process and the `/etc/shadow` (and
    possibly `/etc/gshadow`) file(s). When the user enters (and reenters) the password,
    `passwd` would hash and store the user’s password in `/etc/shadow`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明域过渡情景，我们将以使用`passwd`实用程序更改用户密码为简单案例。相关操作涉及`passwd`进程与`/etc/shadow`（可能还包括`/etc/gshadow`）文件之间的交互。当用户输入（和重新输入）密码时，`passwd`将会对用户密码进行哈希处理并存储在`/etc/shadow`中。
- en: 'Let’s examine the SELinux domain affinities involved:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查涉及的SELinux域亲和性：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The corresponding output is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的输出如下：
- en: '![Figure 9.7 – Comparing the domain affinity context](img/B19682_09_07.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 比较域亲和性上下文](img/B19682_09_07.jpg)'
- en: Figure 9.7 – Comparing the domain affinity context
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 比较域亲和性上下文
- en: The `passwd` utility is labeled with the `passwd_exec_t` type, while `/etc/shadow`
    is labeled with `shadow_t`. There must be a specific security policy chain that
    allows the related domain to transition from `passwd_exec_t` to `shadow_t`; otherwise,
    `passwd` will not work as expected.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`passwd`实用程序标记为`passwd_exec_t`类型，而`/etc/shadow`标记为`shadow_t`。必须存在特定的安全策略链，允许相关域从`passwd_exec_t`过渡到`shadow_t`；否则，`passwd`将无法正常工作。'
- en: 'Let’s validate our assumption. We’ll use the `sesearch` tool to query for our
    assumed security policy. The command utility is not installed by default on Fedora,
    so you will have to install the `setools-console` package first. Use the following
    command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证我们的假设。我们将使用`sesearch`工具查询我们假设的安全策略。默认情况下，Fedora未安装该命令实用程序，因此您首先必须安装`setools-console`包。使用以下命令：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that the package is installed, we can use the following command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完软件包后，我们可以使用以下命令：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here’s a brief explanation of the preceding command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下面简要解释上述命令：
- en: '`sesearch`: Searches the SELinux policy database'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sesearch`：搜索SELinux策略数据库'
- en: '`-s passwd_t`: Finds policy rules with `passwd_t` as their source type or role'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s passwd_t`：查找源类型或角色为`passwd_t`的策略规则'
- en: '`-t shadow_t`: Finds policy rules with `shadow_t` as their target type or role'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t shadow_t`：查找目标类型或角色为`shadow_t`的策略规则'
- en: '`-p write`: Finds policy rules with `write` permissions'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p write`：查找具有写权限的策略规则'
- en: '`--allow`: Finds policy rules that allow the queried permissions (specified
    with `-p`)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--allow`：查找允许查询权限（用`-p`指定）的策略规则'
- en: 'The output of the preceding command is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下：
- en: '![Figure 9.8 – Querying SELinux policies](img/B19682_09_08.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – 查询SELinux策略](img/B19682_09_08.jpg)'
- en: Figure 9.8 – Querying SELinux policies
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 查询SELinux策略
- en: Here, we can see the `append create` permissions, as we correctly assumed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`append create`权限，正如我们正确假设的那样。
- en: How did we pick the `passwd_t` source type instead of `passwd_exec_t`? By definition,
    the *domain* type corresponding to the *executable file* type, `passwd_exec_t`,
    is `passwd_t`. If we were not sure about *who* has write permissions to the `shadow_t`
    file types, we could have simply excluded the source type (`-s passwd_t`) in the
    `sesearch` query and parsed the output (for example, using `grep passwd`).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么选择 `passwd_t` 源类型，而不是 `passwd_exec_t`？根据定义，*域*类型对应于 *可执行文件* 类型 `passwd_exec_t`
    的类型是 `passwd_t`。如果我们不确定谁拥有对 `shadow_t` 文件类型的写权限，我们可以简单地在 `sesearch` 查询中排除源类型（`-s
    passwd_t`），并解析输出（例如，使用 `grep passwd`）。
- en: The use of the `sesearch` tool is very convenient when we’re querying security
    policies. There are a handful of similar tools for troubleshooting or managing
    the SELinux configuration and policies. One of the most notable SELinux command-line
    utilities is `semanage` for managing SELinux policies. We’ll examine this in the
    *Managing SELinux policies* section. But first, let’s look at the necessary steps
    for creating an SELinux security policy.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sesearch` 工具查询安全策略非常方便。还有一些类似的工具可以用于故障排除或管理 SELinux 配置和策略。一个最为著名的 SELinux
    命令行工具是 `semanage`，它用于管理 SELinux 策略。我们将在 *管理 SELinux 策略* 部分进行详细探讨。但首先，让我们看看创建 SELinux
    安全策略的必要步骤。
- en: Creating an SELinux security policy
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 SELinux 安全策略
- en: 'For the examples in this section, we will use a program developed in the C
    programming language. This means that we will have to compile it, which is different
    than what we did in the previous chapter. In order to be able to compile C code,
    we will need to have the `gcc` on our Fedora system with the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的示例中，我们将使用一个用 C 语言开发的程序。这意味着我们需要编译它，这与我们在上一章所做的不同。为了能够编译 C 代码，我们需要在 Fedora
    系统上安装 `gcc`，可以使用以下命令：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let’s assume that we have a daemon called `packtd` and that we need to
    secure it to access `/var/log/messages`. For illustration purposes, the daemon
    has a straightforward implementation: periodically open the `/var/log/messages`
    file for writing. Use your favorite text editor (such as `nano`) to add the following
    content (C code) to a file. Let’s name the file `packtd.c`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个名为 `packtd` 的守护进程，并且我们需要确保它可以访问 `/var/log/messages`。为了说明，守护进程有一个简单的实现：定期打开
    `/var/log/messages` 文件进行写操作。使用您喜欢的文本编辑器（例如 `nano`）将以下内容（C 代码）添加到一个文件中。我们将该文件命名为
    `packtd.c`：
- en: '![Figure 9.9 – A simple daemon periodically checking logs](img/B19682_09_09.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 一个简单的守护进程定期检查日志](img/B19682_09_09.jpg)'
- en: Figure 9.9 – A simple daemon periodically checking logs
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 一个简单的守护进程定期检查日志
- en: 'Let’s compile and build `packtd.c` to generate the related binary executable
    (`packtd`):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并构建 `packtd.c` 以生成相关的二进制可执行文件（`packtd`）：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following is the result of the command used to compile the source code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是编译源代码所使用命令的结果：
- en: '![Figure 9.10 – Compiling the C source code](img/B19682_09_10.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 编译 C 源代码](img/B19682_09_10.jpg)'
- en: Figure 9.10 – Compiling the C source code
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 编译 C 源代码
- en: Now that the source code has been compiled, we are ready to proceed with the
    steps for creating the `packtd` daemon and the required SELinux security policy.
    This exercise is equally useful for SELinux administration and for creating a
    `systemd` daemon. Please refer to [*Chapter 5*](B19682_05.xhtml#_idTextAnchor104)
    if you need to refresh your memory on daemons. Now, let’s discuss the steps for
    creating a daemon and a security policy.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在源代码已经编译完成，我们准备继续创建 `packtd` 守护进程和所需的 SELinux 安全策略的步骤。这个练习对于 SELinux 管理和创建
    `systemd` 守护进程同样有用。如果需要复习守护进程的相关内容，请参考 [*第 5 章*](B19682_05.xhtml#_idTextAnchor104)。现在，让我们讨论创建守护进程和安全策略的步骤。
- en: Installing the daemon
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装守护进程
- en: 'First, we must create a `systemd` unit file for the `packtd` daemon. You may
    use your favorite text editor (such as `nano`) to create the related file. We
    will call this file `packtd.service`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须为 `packtd` 守护进程创建一个 `systemd` 单元文件。您可以使用您喜欢的文本编辑器（如 `nano`）来创建该文件。我们将这个文件命名为
    `packtd.service`：
- en: '![Figure 9.11 – The packtd daemon file](img/B19682_09_11.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – packtd 守护进程文件](img/B19682_09_11.jpg)'
- en: Figure 9.11 – The packtd daemon file
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – packtd 守护进程文件
- en: 'Copy the files we created to their respective locations, such as `/usr/local/bin`
    for `packtd` and `/usr/lib/systemd/system/` for `packtd.service`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们创建的文件复制到相应的位置，如将 `packtd` 复制到 `/usr/local/bin`，将 `packtd.service` 复制到 `/usr/lib/systemd/system/`：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At this point, we are ready to start our `packtd` daemon:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已准备好启动我们的 `packtd` 守护进程：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s make sure the `packtd` daemon is not confined or restricted yet by SELinux:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确认`packtd`守护进程还没有被SELinux限制或约束：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `-Z` option parameter of `ps` retrieves the SELinux context for processes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps`的`-Z`选项参数用于获取进程的SELinux上下文。'
- en: 'The output of all these commands is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些命令的输出如下：
- en: '![Figure 9.12 – Running status and confinement status of the packtd daemon](img/B19682_09_12.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – packtd守护进程的运行状态和限制状态](img/B19682_09_12.jpg)'
- en: Figure 9.12 – Running status and confinement status of the packtd daemon
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – packtd守护进程的运行状态和限制状态
- en: The `unconfined_service_t` security attribute suggests that `packtd` is not
    restricted by SELinux.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`unconfined_service_t`安全属性表明`packtd`没有受到SELinux的限制。'
- en: Next, we will generate security policy files for the `packtd` daemon.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为`packtd`守护进程生成安全策略文件。
- en: Generating policy files
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成策略文件
- en: 'To build a security policy for `packtd`, we need to generate the related policy
    files. The SELinux tool for building security policies is `sepolicy`. Also, packaging
    the final security policy binary requires the `rpm-build` utility. These command-line
    utilities may not be available by default on your system, so you may have to install
    the related packages using the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`packtd`构建安全策略，我们需要生成相关的策略文件。构建安全策略的SELinux工具是`sepolicy`。此外，打包最终的安全策略二进制文件需要使用`rpm-build`工具。这些命令行工具在你的系统上可能默认不可用，因此你可能需要使用以下命令安装相关的包：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will use the next command to generate policy files for `packtd` (no superuser
    privileges required):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用下一个命令为`packtd`生成策略文件（无需超级用户权限）：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 9.13 – Generating policy files with sepolicy](img/B19682_09_13.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13 – 使用sepolicy生成策略文件](img/B19682_09_13.jpg)'
- en: Figure 9.13 – Generating policy files with sepolicy
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – 使用sepolicy生成策略文件
- en: Take a moment and look over the preceding screenshot. You will see that *five
    new files* have been created in your home directory. Keep this in mind, as we
    will use them during our setup process. Next, we need to rebuild the system policy
    so that it includes the custom `packtd` policy module.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 稍作停顿，查看上面的截图。你会看到*五个新文件*已在你的主目录中创建。记住这一点，因为我们将在设置过程中使用这些文件。接下来，我们需要重新构建系统策略，以便它包含自定义的`packtd`策略模块。
- en: Building the security policy
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建安全策略
- en: 'To build the security policy, we will now use the `packtd.sh` build script
    that was created in the previous step (see *Figure 9**.13* for details). The following
    command requires superuser privileges since it installs the newly created policy
    on the system:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建安全策略，我们现在将使用在上一步中创建的`packtd.sh`构建脚本（有关详细信息，请参见*图 9.13*）。以下命令需要超级用户权限，因为它将新创建的策略安装到系统中：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The build takes a relatively long time to complete and yields the following
    output (excerpt):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程相对较长，输出如下（摘录）：
- en: '![Figure 9.14 – Building the security policy for packtd](img/B19682_09_14.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14 – 为packtd构建安全策略](img/B19682_09_14.jpg)'
- en: Figure 9.14 – Building the security policy for packtd
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 – 为packtd构建安全策略
- en: Please note that the build script reinstates the default *SELinux* security
    context for `packtd` using the `restorecon` command (highlighted in the previous
    output). Now that we’ve built the security policy, we’re ready to verify the related
    permissions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，构建脚本通过使用`restorecon`命令（在前面的输出中已突出显示）为`packtd`重新设置默认的*SELinux*安全上下文。现在我们已经构建了安全策略，接下来准备验证相关权限。
- en: Verifying the security policy
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 验证安全策略
- en: 'First, we need to restart the `packtd` daemon to account for the policy change:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要重启`packtd`守护进程，以应用策略更改：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `packtd` process should now reflect the new SELinux security context:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`packtd`进程现在应该反映出新的SELinux安全上下文：'
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output shows a new label (`packtd_t`) for our security context:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了我们的安全上下文的新标签（`packtd_t`）：
- en: '![Figure 9.15 – The new security policy for packtd](img/B19682_09_15.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.15 – packtd的新安全策略](img/B19682_09_15.jpg)'
- en: Figure 9.15 – The new security policy for packtd
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 – packtd的新安全策略
- en: 'Since SELinux now controls our `packtd` daemon, we should see the related audit
    traces in `/var/log/messages`, where SELinux logs the system’s activity. Let’s
    look at the audit logs for any permission issues. The following command fetches
    the most recent events for `AVC` message types using the `ausearch` utility:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SELinux现在控制着我们的`packtd`守护进程，我们应该能在`/var/log/messages`中看到相关的审计日志，其中SELinux记录了系统的活动。让我们查看审计日志，寻找任何权限问题。以下命令通过`ausearch`工具获取`AVC`消息类型的最新事件：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will immediately notice that `packtd` has no read/write access to `/var/log/messages`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将立即注意到，`packtd` 无法读取/写入 `/var/log/messages`：
- en: '![Figure 9.16 – No read/write access for packtd](img/B19682_09_16.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.16 – 不允许 packtd 读写](img/B19682_09_16.jpg)'
- en: Figure 9.16 – No read/write access for packtd
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16 – 不允许 packtd 读写
- en: 'To further inquire about the permissions needed by `packtd`, we will feed the
    output of `ausearch` into `audit2allow`, a tool for generating the required security
    policy stubs:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步查询 `packtd` 所需的权限，我们将把 `ausearch` 的输出输入到 `audit2allow`，这是一个生成所需安全策略存根的工具：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output provides the code macro we’re looking for:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 输出提供了我们需要的代码宏：
- en: '![Figure 9.17 – Querying the missing permissions for packtd](img/B19682_09_17.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.17 – 查询 packtd 缺失的权限](img/B19682_09_17.jpg)'
- en: Figure 9.17 – Querying the missing permissions for packtd
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17 – 查询 packtd 缺失的权限
- en: 'The `-R` (`--reference`) option of `audit2allow` invokes a stub generation
    task, which could sometimes yield inaccurate or incomplete results. In such cases,
    it may take a few iterations to update, rebuild, and verify the related security
    policies. Let’s proceed with the required changes, as suggested in the output
    shown in the preceding screenshot. We’ll edit the *type enforcement* file (`packtd.te`)
    generated previously and add the lines (copy/paste) exactly, as indicated by the
    output of `audit2allow`. The contents of the file are shown in the following screenshot
    (excerpt). The lines to be added by us are highlighted:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`audit2allow` 的 `-R`（`--reference`）选项会启动一个存根生成任务，有时可能会导致不准确或不完整的结果。在这种情况下，可能需要几次迭代来更新、重建并验证相关的安全策略。让我们按照之前屏幕截图中显示的输出所建议的进行必要的更改。我们将编辑之前生成的*类型强制*文件（`packtd.te`），并按照
    `audit2allow` 输出的指示，精确地添加这些行（复制/粘贴）。文件的内容如下图所示（摘录）。我们需要添加的行已被突出显示：'
- en: '![Figure 9.18 – Editing the packtd.te file](img/B19682_09_18.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.18 – 编辑 packtd.te 文件](img/B19682_09_18.jpg)'
- en: Figure 9.18 – Editing the packtd.te file
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18 – 编辑 packtd.te 文件
- en: 'After saving the file, we need to rebuild the security policy, restart the
    `packtd` daemon, and verify the audit logs. We’re reiterating the last three steps
    in our overall procedure:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，我们需要重新构建安全策略，重启 `packtd` 守护进程，并验证审计日志。我们将在整体流程中重述最后三个步骤：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This time, the SELinux audit should come out clean:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，SELinux 审计应该是干净的：
- en: '![Figure 9.19 – No more permission issues for packtd](img/B19682_09_19.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.19 – 解决 packtd 的权限问题](img/B19682_09_19.jpg)'
- en: Figure 9.19 – No more permission issues for packtd
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.19 – 解决 packtd 的权限问题
- en: 'Sometimes, it may take a little while for `ausearch` to refresh its `recent`
    buffer. Alternatively, we can specify a starting timestamp to analyze from, such
    as after we’ve updated the security policy, using a relatively recent timestamp:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，`ausearch` 刷新其`recent`缓冲区可能需要一些时间。或者，我们可以指定一个起始时间戳来进行分析，例如在我们更新安全策略后，使用一个相对较新的时间戳：
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now that we’ve created our own SELinux security policy, let’s understand how
    it can be managed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了自己的 SELinux 安全策略，让我们了解如何管理它。
- en: Managing SELinux policies
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理 SELinux 策略
- en: SELinux provides several utilities for managing security policies and modules,
    some of which will be briefly described in the *Troubleshooting SELinux issues*
    section. Examining each of these tools is beyond the scope of this chapter, but
    we’ll take `semanage` for a quick spin to reflect on some use cases involving
    security policy management.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 提供了几种管理安全策略和模块的工具，其中一些将在*SELinux 问题故障排除*部分中简要介绍。虽然详细探讨这些工具超出了本章的范围，但我们将简要使用
    `semanage` 来回顾一些涉及安全策略管理的使用案例。
- en: 'The general syntax of the `semanage` command is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`semanage` 命令的一般语法如下：'
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`TARGET` usually denotes a specific namespace for policy definitions (for example,
    `login`, `user`, `port`, `fcontext`, `boolean`, `permissive`, and so on). Let’s
    look at a few examples to get an idea of how `semanage` works.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`TARGET` 通常表示用于策略定义的特定命名空间（例如，`login`、`user`、`port`、`fcontext`、`boolean`、`permissive`
    等）。让我们看几个例子，以了解 `semanage` 是如何工作的。'
- en: Enabling secure binding on custom ports
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在自定义端口上启用安全绑定
- en: 'Let’s assume we want to enable SELinux for a custom SSH port instead of the
    default `22`. We can retrieve the current security records (labels) on the SSH
    port with the following command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想为自定义 SSH 端口启用 SELinux，而不是默认的 `22`。我们可以使用以下命令检索当前 SSH 端口上的安全记录（标签）：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For a default configuration, we will get the output shown in *line 2* in *Figure
    9**.20*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于默认配置，我们将获得如*图 9.20*中*第 2 行*所示的输出。
- en: 'If we want to enable SSH on a different port (such as `2222`), first, we need
    to configure the related service (`sshd`) to listen on a different port (shown
    in [*Chapter 13*](B19682_13.xhtml#_idTextAnchor276)). We won’t go into those details
    here. Here, we need to enable the secure binding on the new port with the following
    command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在不同的端口（比如`2222`）上启用SSH，首先，我们需要配置相关的服务（`sshd`）以便监听不同的端口（如[*第13章*](B19682_13.xhtml#_idTextAnchor276)所示）。我们这里不再深入讨论这些细节。这里，我们需要通过以下命令启用新端口上的安全绑定：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here’s a brief explanation of the preceding command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对前面命令的简要说明：
- en: '`-a` (`--add`): Adds a new record (label) for the given type'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-a`（`--add`）：为给定类型添加一个新的记录（标签）'
- en: '`-t ssh_port_t`: The SELinux type of the object'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t ssh_port_t`：对象的SELinux类型'
- en: '`-p tcp`: The network protocol associated with the port'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p tcp`：与端口相关的网络协议'
- en: 'As a result of the previous command and the output for the default configuration,
    the new security policy for the `ssh_port_t` type looks like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于之前的命令和默认配置的输出，新的`ssh_port_t`类型的安全策略如下所示：
- en: '![Figure 9.20 – Querying and changing the SELinux security label for the SSH
    port](img/B19682_09_20.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.20 – 查询并更改SSH端口的SELinux安全标签](img/B19682_09_20.jpg)'
- en: Figure 9.20 – Querying and changing the SELinux security label for the SSH port
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.20 – 查询并更改SSH端口的SELinux安全标签
- en: 'We could arguably delete the old security label (for port `22`), but that won’t
    really matter if we disable port `22`. If we want to delete a port security record,
    we can do so with the following command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑删除旧的安全标签（针对端口`22`），但如果我们禁用端口`22`，其实也没有太大影响。如果我们想删除端口的安全记录，可以使用以下命令：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We used the `-d` (`--delete`) option to remove the related security label.
    To view the local customization for our `semanage port` policies, we can invoke
    the `-C` (`--``locallist`) option:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`-d`（`--delete`）选项来移除相关的安全标签。要查看我们`semanage port`策略的本地自定义设置，我们可以调用`-C`（`--locallist`）选项：
- en: '[PRE34]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For more information on `semanage port`, you may refer to the related system
    reference (`man semanage port`). Next, we’ll look at how to modify security permissions
    for specific server applications.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`semanage port`的更多信息，请参考相关的系统手册（`man semanage port`）。接下来，我们将了解如何修改特定服务器应用程序的安全权限。
- en: Modifying security permissions for targeted services
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改目标服务的安全权限
- en: '`semanage` uses the `boolean` namespace to toggle specific features of targeted
    services on and off. A targeted service is a daemon with built-in SELinux protection.
    In the following example, we want to enable FTP over HTTP connections. By default,
    this security feature of Apache (`httpd`) is turned off. Installation of the `httpd`
    server is shown in [*Chapter 13*](B19682_13.xhtml#_idTextAnchor276). Let’s query
    the related `httpd` security policies with the following command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`semanage`使用`boolean`命名空间来切换目标服务的特定功能的开关。目标服务是具有内建SELinux保护的守护进程。在以下示例中，我们想要启用FTP
    over HTTP连接。默认情况下，Apache（`httpd`）的此安全功能是关闭的。[*第13章*](B19682_13.xhtml#_idTextAnchor276)展示了`httpd`服务器的安装。让我们通过以下命令查询相关的`httpd`安全策略：'
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We get the following output:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '![Figure 9.21 – Querying httpd policies related to FTP](img/B19682_09_21.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.21 – 查询与FTP相关的httpd策略](img/B19682_09_21.jpg)'
- en: Figure 9.21 – Querying httpd policies related to FTP
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.21 – 查询与FTP相关的httpd策略
- en: 'As we can see, the related feature—`httpd_enable_ftp_server`—is turned `off`
    by default. The `current` and `persisted` states are currently off: `(off, off)`.
    We can enable it with the following command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，相关的功能——`httpd_enable_ftp_server`——默认是`关闭`的。`current`和`persisted`的状态当前都是关闭的：`(off,
    off)`。我们可以通过以下命令启用它：
- en: '[PRE36]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To view the local customizations of the `semanage boolean` policies, we can
    invoke the `-C` (`--``locallist`) option:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`semanage boolean`策略的本地自定义设置，我们可以调用`-C`（`--locallist`）选项：
- en: '[PRE37]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The new configuration now looks like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 新配置现在如下所示：
- en: '![Figure 9.22 – Enabling the security policy for FTP over HTTP](img/B19682_09_22.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.22 – 启用FTP over HTTP的安全策略](img/B19682_09_22.jpg)'
- en: Figure 9.22 – Enabling the security policy for FTP over HTTP
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.22 – 启用FTP over HTTP的安全策略
- en: In the preceding example, we used the `-m` (`--modify`) option with the `semanage
    boolean` command to toggle the `httpd_enable_ftp_server` feature.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了`-m`（`--modify`）选项与`semanage boolean`命令一起，来切换`httpd_enable_ftp_server`功能。
- en: For more information on `semanage boolean`, you may refer to the related system
    reference (`man semanage boolean`). Now, let’s learn how to modify the security
    context of specific server applications.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `semanage boolean` 的更多信息，您可以参考相关的系统参考资料（`man semanage boolean`）。现在，让我们学习如何修改特定服务器应用程序的安全上下文。
- en: Modifying security contexts for targeted services
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为目标服务修改安全上下文
- en: In this example, we want to secure SSH keys stored in a custom location on the
    local system. Since we’re targeting a filesystem-related security policy, we will
    use the `fcontext` (file context) namespace with `semanage`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们希望保护存储在本地系统自定义位置的 SSH 密钥。由于我们正在针对与文件系统相关的安全策略，因此将使用 `semanage` 的 `fcontext`（文件上下文）命名空间。
- en: 'The following command queries the file context security settings for `sshd`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令查询 `sshd` 的文件上下文安全设置：
- en: '[PRE38]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here’s a relevant excerpt from the output:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出中的相关摘录：
- en: '![Figure 9.23 – The security context of SSH keys](img/B19682_09_23.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.23 – SSH 密钥的安全上下文](img/B19682_09_23.jpg)'
- en: Figure 9.23 – The security context of SSH keys
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.23 – SSH 密钥的安全上下文
- en: 'The following command also adds the `/etc/ssh/keys/` path to the secure locations
    associated with the `sshd_key_t` context type:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令还将 `/etc/ssh/keys/` 路径添加到与 `sshd_key_t` 上下文类型相关的安全位置：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `''/etc/ssh/keys(/.*)?''` regular expression matches any files in the `/etc/ssh/keys/`
    directory, including subdirectories at any nested level. To view the local customizations
    of the `semanage fcontext` policies, we can invoke the `-C` (`--``locallist`)
    option:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`''/etc/ssh/keys(/.*)?''` 正则表达式匹配 `/etc/ssh/keys/` 目录中的所有文件，包括任何嵌套级别的子目录。要查看
    `semanage fcontext` 策略的本地自定义设置，我们可以调用 `-C`（`--locallist`）选项：'
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![Figure 9.24 – The modified security context of our SSH keys](img/B19682_09_24.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.24 – 我们的 SSH 密钥的修改后的安全上下文](img/B19682_09_24.jpg)'
- en: Figure 9.24 – The modified security context of our SSH keys
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.24 – 我们的 SSH 密钥的修改后的安全上下文
- en: 'We should also initialize the filesystem security context of the `/etc/ssh/keys`
    directory (if we’ve already created it; otherwise, we would get an error message):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应初始化 `/etc/ssh/keys` 目录的文件系统安全上下文（如果我们已经创建了该目录；否则，将会出现错误消息）：
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`restorecon` is an SELinux utility for restoring the default security context
    to a filesystem object. The `-r` (or `-R`) option specifies a recursive action
    on the related path.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`restorecon` 是一个 SELinux 工具，用于将默认安全上下文恢复到文件系统对象。`-r`（或 `-R`）选项指定对相关路径执行递归操作。'
- en: For more information on `semanage fcontext`, you may refer to the related system
    reference (`man semanage fcontext`). Next, we’ll look at enabling the `permissive`
    mode of specific server applications.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `semanage fcontext` 的更多信息，您可以参考相关的系统参考资料（`man semanage fcontext`）。接下来，我们将研究如何启用特定服务器应用程序的
    `permissive` 模式。
- en: Enabling permissive mode for targeted services
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为目标服务启用宽松模式
- en: Earlier in this chapter, we created a custom daemon (`packtd`) with its security
    policy. See the related topic in the *Creating an SELinux security policy* section
    earlier in this chapter. During the entire process, we were able to run and test
    with `packtd` without having the daemon shut down by SELinux due to non-compliance.
    Our Linux system runs SELinux in `enforcing` mode (by default) and is not permissive.
    See the *Understanding SELinux modes* section for more information on `enforcing`
    and `permissive` modes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早些时候，我们创建了一个自定义守护进程（`packtd`）并为其配置了安全策略。请参阅本章早些时候的*创建 SELinux 安全策略*部分。在整个过程中，我们能够运行并测试
    `packtd`，而不会因不符合 SELinux 策略而导致守护进程被 SELinux 关闭。我们的 Linux 系统以 `enforcing` 模式（默认）运行
    SELinux，并且不是宽松模式。有关 `enforcing` 和 `permissive` 模式的更多信息，请参阅*理解 SELinux 模式*部分。
- en: By default, SELinux is permissive to any *untargeted* type in the system. By
    *untargeted*, we mean a domain (type) that hasn’t been forced into a restrictive
    (or confined) mode yet.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SELinux 对系统中任何*未定位*的类型都是宽松的。这里的*未定位*指的是尚未强制进入限制性（或受限）模式的域（类型）。
- en: 'When we built the security policy for our `packtd` daemon, we let the related
    SELinux build tools generate the default type enforcement file (`packt.te`) and
    other resources for our domain. A quick look at the `packt.te` file shows that
    our `packtd_t` type is `permissive`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为 `packtd` 守护进程构建安全策略时，我们让相关的 SELinux 构建工具生成默认的类型强制文件（`packt.te`）和其他资源。快速查看
    `packt.te` 文件显示我们的 `packtd_t` 类型是 `permissive`：
- en: '[PRE42]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here’s the relevant excerpt from the file:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是文件中的相关摘录：
- en: '![Figure 9.25 – The packtd_t domain is permissive](img/B19682_09_25.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.25 – `packtd_t` 域是宽松的](img/B19682_09_25.jpg)'
- en: Figure 9.25 – The packtd_t domain is permissive
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.25 – `packtd_t` 域是宽松的
- en: So, the `packtd_t` domain is permissive by nature. The only way to confine `packtd`
    is to remove the `permissive` line from the `packtd.te` file and rebuild the related
    security policy. We will leave that as an exercise for you. The case we wanted
    to make here was to present a possibly misbehaving—in our case, `permissive`—domain
    that we can *catch* by managing `permissive` types with the `semanage` `permissive`
    command.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`packtd_t` 域本质上是宽松的。限制 `packtd` 的唯一方法是从 `packtd.te` 文件中删除 `permissive` 行，并重建相关的安全策略。我们将把这个作为练习留给你。我们在这里要表达的是，展示一个可能存在问题的——在我们案例中是
    `permissive`——域，可以通过使用 `semanage` `permissive` 命令来管理 `permissive` 类型，从而*捕获*它。
- en: 'To manage `permissive` mode for individual targets, we can use the `semanage`
    command with our `permissive` namespace. The following command lists all the domains
    (types) currently in `permissive` mode:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理单个目标的 `permissive` 模式，我们可以使用带有 `permissive` 命名空间的 `semanage` 命令。以下命令列出当前所有处于
    `permissive` 模式的域（类型）：
- en: '[PRE43]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In our case, we have the built-in `packtd_t` domain, which is `permissive`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们有一个内置的 `packtd_t` 域，它是 `permissive`：
- en: '![Figure 9.26 – Displaying permissive types](img/B19682_09_26.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.26 – 显示宽松类型](img/B19682_09_26.jpg)'
- en: Figure 9.26 – Displaying permissive types
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.26 – 显示宽松类型
- en: In general, it is unlikely that a default SELinux configuration would have any
    `permissive` types.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，默认的 SELinux 配置不太可能有任何 `permissive` 类型。
- en: 'We can use the `semanage permissive` command to temporarily place a restricted
    domain into `permissive` mode while testing or troubleshooting a specific functionality.
    For example, the following command sets the Apache (`httpd`) daemon in `permissive`
    mode:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `semanage permissive` 命令，在测试或排查特定功能时，临时将受限域设置为 `permissive` 模式。例如，以下命令将
    Apache (`httpd`) 守护进程设置为 `permissive` 模式：
- en: '[PRE44]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When we query for `permissive` types, we get the following result:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查询 `permissive` 类型时，得到以下结果：
- en: '![Figure 9.27 – Customized permissive types](img/B19682_09_27.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.27 – 自定义宽松类型](img/B19682_09_27.jpg)'
- en: Figure 9.27 – Customized permissive types
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.27 – 自定义宽松类型
- en: Domains or types that are made permissive with the `semanage permissive` command
    will show up as `Customized` `Permissive Types`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `semanage permissive` 命令将域或类型设为宽松状态后，会显示为 `自定义` `宽松类型`。
- en: 'To revert the `httpd_t` domain to the confined (restricted) state, we can invoke
    the `semanage permissive` command with the `-d` (`--``delete`) option:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `httpd_t` 域恢复到受限（限制）状态，我们可以使用带有 `-d`（`--delete`）选项的 `semanage permissive`
    命令：
- en: '[PRE45]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output of the command is shown here:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出如下面所示：
- en: '![Figure 9.28 – Reverting permissive types](img/B19682_09_28.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.28 – 恢复宽松类型](img/B19682_09_28.jpg)'
- en: Figure 9.28 – Reverting permissive types
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.28 – 恢复宽松类型
- en: Note that we cannot confine built-in `permissive` types with the `semanage`
    command. As we mentioned previously, the `packtd_t` domain is permissive by nature
    and cannot be restricted.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不能使用 `semanage` 命令来限制内置的 `permissive` 类型。如前所述，`packtd_t` 域本质上是宽松的，无法被限制。
- en: At this point, we have a basic understanding of SELinux security policy internals.
    Next, we’ll turn to some higher-level operations for managing and controlling
    SELinux in everyday administration tasks.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经对 SELinux 安全策略的内部机制有了基本的了解。接下来，我们将转向一些更高层次的操作，用于在日常管理任务中管理和控制 SELinux。
- en: Troubleshooting SELinux issues
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排查 SELinux 问题
- en: Even during our relatively brief journey of exploring SELinux, we used a handful
    of tools and means to inspect some internal workings of security policies and
    access control between subjects (users and processes) and objects (files). SELinux’s
    problems usually come down to action being denied, either between specific subjects
    or between a subject and some objects. SELinux-related issues are not always obvious
    or easy to troubleshoot, but knowing about the tools that can help is already
    a good start for tackling these issues.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在我们相对简短的 SELinux 探索过程中，我们也使用了少数工具和方法来检查安全策略的内部机制，以及主体（用户和进程）与对象（文件）之间的访问控制。SELinux
    的问题通常归结为操作被拒绝，无论是在特定主体之间，还是在主体与某些对象之间。与 SELinux 相关的问题并不总是显而易见或容易排查，但了解可以帮助的工具已经是解决这些问题的一个良好开端。
- en: 'Here are some of these tools, briefly explained:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些这些工具的简要说明：
- en: '`/var/log/messages`: The log file containing SELinux access control traces
    and policy violations'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var/log/messages`：包含 SELinux 访问控制跟踪和策略违规的日志文件'
- en: '`audit2allow`: Generates SELinux policy rules from the log traces corresponding
    to denied operations'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`audit2allow`：从与被拒绝操作相关的日志跟踪生成 SELinux 策略规则'
- en: '`audit2why`: Provides user-friendly translations of SELinux audit messages
    of policy violations'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`audit2why`：提供SELinux审计消息的用户友好型翻译，用于策略违规的分析'
- en: '`ausearch`: Queries `/var/log/messages` for policy violations'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ausearch`：查询`/var/log/messages`中的策略违规记录'
- en: '`ls -Z`: Lists filesystem objects with their corresponding SELinux context'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls -Z`：列出文件系统对象及其对应的SELinux上下文'
- en: '`ps -Z`: Lists processes with their corresponding SELinux context'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps -Z`：列出进程及其相应的SELinux上下文'
- en: '`restorecon`: Restores the default SELinux context for filesystem objects'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restorecon`：恢复文件系统对象的默认SELinux上下文'
- en: '`seinfo`: Provides general information about SELinux security policies'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seinfo`：提供有关SELinux安全策略的一般信息'
- en: '`semanage`: Manages and provides insight into SELinux policies'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`semanage`：管理和提供SELinux策略的见解'
- en: '`semodule`: Manages SELinux policy modules'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`semodule`：管理SELinux策略模块'
- en: '`sepolicy`: Inspects SELinux policies'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sepolicy`：检查SELinux策略'
- en: '`sesearch`: Queries the SELinux policy database'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sesearch`：查询SELinux策略数据库'
- en: For most of these tools, there is a corresponding system reference (such as
    `man sesearch`) that provides detailed information about using the tool. Beyond
    these tools, you can also explore the vast documentation SELinux has to offer.
    Here’s how.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些工具中的大多数，都会有相应的系统参考（如`man sesearch`），提供关于如何使用这些工具的详细信息。除此之外，你还可以探索SELinux提供的广泛文档。方法如下。
- en: Accessing SELinux documentation
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问SELinux文档
- en: SELinux has extensive documentation, available as an RHEL/Fedora installable
    package or online at [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/using_selinux/index](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/using_selinux/index)
    (for RHEL 9).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux有大量的文档，可以通过RHEL/Fedora可安装的软件包获取，或者在线访问[https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/using_selinux/index](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/using_selinux/index)（适用于RHEL
    9）。
- en: 'The following command installs the SELinux documentation on RHEL 9 systems:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令安装RHEL 9系统上的SELinux文档：
- en: '[PRE46]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can browse a particular SELinux topic with (for example) the following
    command:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下命令浏览特定的SELinux主题（例如）：
- en: '[PRE47]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: SELinux is among the most established and highly customizable security frameworks
    in the Linux kernel. However, its relatively vast domain and inherent complexity
    may appear overwhelming to many. Sometimes, even for seasoned system administrators,
    the choice of a Linux distribution could hang in the balance based on the underlying
    security module. SELinux is mostly available on RHEL/Fedora platforms, but it
    is also available as an option on **SUSE Linux Enterprise** (**SLE**). Google’s
    Android also has SELinux available, and Debian also has it as an available option.
    Another relatively lighter and more efficient security framework is **AppArmor**,
    and it is available by default on Ubuntu, Debian, and openSUSE. Let us explore
    it in the next section.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux是Linux内核中最为成熟且高度可定制的安全框架之一。然而，它相对广泛的领域和固有的复杂性可能让很多人感到不知所措。有时，即使是经验丰富的系统管理员，选择一个Linux发行版时，也可能会因其底层安全模块的不同而有所犹豫。SELinux通常在RHEL/Fedora平台上可用，但它在**SUSE
    Linux Enterprise**（**SLE**）上也可以选择使用。谷歌的Android也支持SELinux，而Debian也提供了它作为一个选项。另一个相对轻量且高效的安全框架是**AppArmor**，它默认在Ubuntu、Debian和openSUSE上可用。我们将在下一节深入探讨它。
- en: Introducing AppArmor
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍AppArmor
- en: '**AppArmor** is a Linux security module based on the MAC model that confines
    applications to a limited set of resources. AppArmor uses an access control mechanism
    based on security profiles that have been loaded into the Linux kernel. Each profile
    contains a collection of rules for accessing various system resources. AppArmor
    can be configured to either enforce access control or just complain about access
    control violations.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**AppArmor**是一个基于MAC模型的Linux安全模块，限制应用程序对有限资源的访问。AppArmor使用基于安全配置文件的访问控制机制，这些配置文件已经被加载到Linux内核中。每个配置文件包含一系列访问各种系统资源的规则。AppArmor可以配置为强制访问控制，或仅对访问控制违规行为发出警告。'
- en: AppArmor proactively protects applications and operating system resources from
    internal and external threats, including zero-day attacks, by preventing both
    known and unknown vulnerabilities from being exploited.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: AppArmor通过防止已知和未知的漏洞被利用，主动保护应用程序和操作系统资源免受内外部威胁，包括零日攻击。
- en: AppArmor has been built into the mainline Linux kernel since version 2.6.36
    and is currently shipped with Ubuntu, Debian, openSUSE, and similar distributions.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 自2.6.36版本起，AppArmor已被集成到主线Linux内核中，并且目前与Ubuntu、Debian、openSUSE及类似发行版一起发布。
- en: In the following sections. we’ll use an Ubuntu Server 22.04 LTS environment
    to showcase a few practical examples with AppArmor. Most of the related command-line
    utilities will work the same on any platform with AppArmor installed.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用Ubuntu Server 22.04 LTS环境来展示一些AppArmor的实际示例。大多数相关的命令行工具在任何安装了AppArmor的平台上都可以正常工作。
- en: Working with AppArmor
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AppArmor
- en: 'AppArmor command-line utilities usually require superuser privileges. The following
    command checks the current status of AppArmor:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: AppArmor命令行工具通常需要超级用户权限。以下命令检查AppArmor的当前状态：
- en: '[PRE48]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here’s an excerpt from the command’s output:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是命令输出的摘录：
- en: '![Figure 9.29 – Getting the status of AppArmor](img/B19682_09_29.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图9.29 – 获取AppArmor的状态](img/B19682_09_29.jpg)'
- en: Figure 9.29 – Getting the status of AppArmor
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.29 – 获取AppArmor的状态
- en: The `aa-status` (or `apparmor_status`) command provides a full list of the currently
    loaded AppArmor profiles (not shown in the preceding excerpt). We’ll examine AppArmor
    profiles next.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`aa-status`（或`apparmor_status`）命令提供当前加载的所有AppArmor配置文件的完整列表（前面未显示）。我们接下来将查看AppArmor配置文件。'
- en: Introducing AppArmor profiles
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍AppArmor配置文件
- en: 'With AppArmor, processes are confined (or restricted) by profiles. AppArmor
    profiles are loaded upon system start and run either in `enforce` mode or `complain`
    mode. Let’s explore these modes in some detail:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AppArmor时，进程通过配置文件被限制（或约束）。AppArmor配置文件在系统启动时加载，并以`enforce`模式或`complain`模式运行。接下来，我们将详细探讨这些模式：
- en: '`enforce` mode: AppArmor prevents applications running in `enforce` mode from
    performing restricted actions. Access violations are signaled with log entries
    in `syslog`. Ubuntu, by default, loads the application profiles in `enforce` mode.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enforce`模式：AppArmor会阻止在`enforce`模式下运行的应用程序执行受限操作。访问违规会通过`syslog`中的日志条目进行信号提示。默认情况下，Ubuntu会以`enforce`模式加载应用程序配置文件。'
- en: '`complain` mode: Applications running in `complain` mode can take restricted
    actions, while AppArmor creates a log entry for the related violation. `complain`
    mode is ideal for testing AppArmor profiles. Potential errors or access violations
    can be caught and fixed before switching the profiles to `enforce` mode.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complain`模式：运行在`complain`模式中的应用程序可以执行受限操作，同时AppArmor会为相关违规行为创建日志条目。`complain`模式非常适合测试AppArmor配置文件。潜在的错误或访问违规可以在切换到`enforce`模式之前被捕获并修复。'
- en: With these introductory notes in mind, let’s create a simple application with
    an AppArmor profile.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这些介绍性说明后，让我们创建一个带有AppArmor配置文件的简单应用程序。
- en: Creating a profile
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建配置文件
- en: In this section, we’ll create a simple application guarded by AppArmor. We hope
    this exercise will help you get a reasonable idea of the inner workings of AppArmor.
    Let’s name this application `appackt`. We’ll make it a simple script that creates
    a file, writes to it, and then deletes the file. The goal is to have AppArmor
    prevent our app from accessing any other paths in the local system. To try to
    make some sense of this, think of it as trivial log recycling.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将创建一个由AppArmor保护的简单应用程序。我们希望这个练习能帮助你对AppArmor的内部工作有一个合理的了解。我们将这个应用命名为`appackt`，它将是一个简单的脚本，创建一个文件，向其中写入内容，然后删除文件。目标是让AppArmor阻止我们的应用访问本地系统中的任何其他路径。为了理解这一点，可以将其视为简单的日志回收。
- en: 'Here’s the `appackt` script, and please pardon the thrifty implementation:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`appackt`脚本，请原谅它的简陋实现：
- en: '![Figure 9.30 – The appackt script](img/B19682_09_30.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图9.30 – appackt脚本](img/B19682_09_30.jpg)'
- en: Figure 9.30 – The appackt script
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.30 – appackt脚本
- en: 'We are assuming that the `log` directory already exists at the same location
    as the script:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设`log`目录已经存在，并与脚本位于同一位置：
- en: '[PRE49]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let’s make the script executable and run it:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使脚本可执行并运行它：
- en: '[PRE50]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output is as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 9.31 – The output of the appackt script](img/B19682_09_31.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图9.31 – appackt脚本的输出](img/B19682_09_31.jpg)'
- en: Figure 9.31 – The output of the appackt script
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.31 – appackt脚本的输出
- en: 'Now, let’s work on guarding and enforcing our script with AppArmor. Before
    we start, we need to install the `apparmor-utils` package—the **AppArmor toolset**:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始使用AppArmor保护并强制执行我们的脚本。在开始之前，我们需要安装`apparmor-utils`包——**AppArmor工具集**：
- en: '[PRE51]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We’ll use a couple of tools to help create the profile:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用几个工具来帮助创建配置文件：
- en: '`aa-genprof`: Generates an AppArmor security profile'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aa-genprof`：生成一个AppArmor安全配置文件'
- en: '`aa-logprof`: Updates an AppArmor security profile'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aa-logprof`：更新一个AppArmor安全配置文件'
- en: We use `aa-genprof` to monitor our application at runtime and have AppArmor
    learn about it. In the process, we’ll be prompted to acknowledge and choose the
    behavior that’s required in specific circumstances.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`aa-genprof`在运行时监控我们的应用程序，并让AppArmor了解它。在此过程中，我们将被提示确认并选择在特定情况下需要的行为。
- en: Once the profile has been created, we’ll use the `aa-logprof` utility to make
    further adjustments while testing in `complain` mode, should any violations occur.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置文件创建完成，我们将使用`aa-logprof`工具进行进一步调整，在`complain`模式下测试，如果发生任何违规行为。
- en: 'Let’s start with `aa-genprof`. We need two terminals: one for the `aa-genprof`
    monitoring session (in *Terminal 1*) and the other for running our script (in
    *Terminal 2*).'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`aa-genprof`开始。我们需要两个终端：一个用于`aa-genprof`监控会话（在*终端 1*中），另一个用于运行我们的脚本（在*终端
    2*中）。
- en: 'We will start with *Terminal 1* and run the following command:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从*终端 1*开始，并运行以下命令：
- en: '[PRE52]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'There is a first prompt waiting for us. Next, while the prompt in *Terminal
    1* is waiting, we will switch to *Terminal 2* and run the following command:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个提示正在等待我们。接下来，在*终端 1*的提示等待时，我们将切换到*终端 2*并运行以下命令：
- en: '[PRE53]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we must go back to *Terminal 1* and answer the prompts sent by `aa-genprof`,
    as follows (output detailed in *Figure 9**.32*):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须回到*终端 1*并回答由`aa-genprof`发出的提示，如下所示（详细输出见*图 9.32*）：
- en: '`S` `(S)can`'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S`（`S`can）'
- en: '`/usr/bin/touch`, `/usr/bin/date`, `/usr/bin/cat`, and `/usr/bin/rm`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/bin/touch`、`/usr/bin/date`、`/usr/bin/cat`和`/usr/bin/rm`'
- en: This prompt requests execute permissions for all the processes running our app.
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该提示请求对运行我们应用程序的所有进程授予执行权限。
- en: '*Answer*: `I` `(I)nherit`'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*回答*：`I`（`I`nherit）'
- en: '`/dev/tty`, `/home/packt/log/appackt`, and `/etc/ld.so.cache`'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev/tty`、`/home/packt/log/appackt`和`/etc/ld.so.cache`'
- en: This prompt requests read/write permissions for the app to control different
    files.
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该提示请求应用程序对不同文件进行读/写权限。
- en: '*Answer*: `A` (`A)llow`'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*回答*：`A`（`A`llow）'
- en: '`S` (`S)ave`'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S`（`S`ave）'
- en: '![Figure 9.32 – Running aa-genprof and setting the profile](img/B19682_09_32.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.32 – 运行aa-genprof并设置配置文件](img/B19682_09_32.jpg)'
- en: Figure 9.32 – Running aa-genprof and setting the profile
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.32 – 运行aa-genprof并设置配置文件
- en: 'At this point, we have finished scanning with `aa-genprof`, and we can answer
    the last prompt with `F` `(F)inish`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经完成了使用`aa-genprof`的扫描，并且可以用`F`（`F`inish）回答最后一个提示：
- en: '![Figure 9.33 – Finishing the scanning](img/B19682_09_33.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.33 – 完成扫描](img/B19682_09_33.jpg)'
- en: Figure 9.33 – Finishing the scanning
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.33 – 完成扫描
- en: Our app (`appackt`) is now enforced by AppArmor in `enforce` mode (by default).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序（`appackt`）在`enforce`模式下受到AppArmor的强制保护（默认情况下）。
- en: 'For the rest of the steps, we only need one terminal window. Let’s run the
    `aa-logprof` command to further tune our `appackt` security profile if needed:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的步骤，我们只需要一个终端窗口。如果需要，我们将运行`aa-logprof`命令进一步调整`appackt`的安全配置文件：
- en: '[PRE54]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We’ll get several prompts again, similar to the previous ones, asking for further
    permissions needed by our script or by other applications. The prompts alternate
    between `Inherit` and `Allow` answers, where appropriate. We won’t go into the
    details here as it is beyond the scope of this book. By now, you should have a
    general idea about these prompts and their meaning. It’s always recommended, though,
    to ponder upon the permissions asked and act accordingly.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次收到几个类似的提示，要求进一步的权限，这些权限可能是我们的脚本或其他应用程序所需要的。提示会在`Inherit`和`Allow`之间交替，根据情况作出选择。这里不再详细说明，因为这超出了本书的范围。不过，到目前为止，你应该已经对这些提示及其含义有了大致的了解。尽管如此，建议你始终思考所请求的权限，并根据需要采取相应的行动。
- en: We may have to run the `aa-logprof` command a couple of times because, with
    each iteration, new permissions will be discovered and addressed, depending on
    the child processes that are spawned by our script, and so on. Eventually, the
    `appackt` script will run successfully.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要运行`aa-logprof`命令几次，因为每次迭代都会发现并处理新的权限，这取决于由我们的脚本生成的子进程等。最终，`appackt`脚本将成功运行。
- en: 'During the iterative process described previously, we may end up with a few
    unknown or orphaned entries in the AppArmor database, which are artifacts of our
    previous attempts to secure our application:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前描述的迭代过程中，我们可能会在AppArmor数据库中留下几个未知或孤立的条目，它们是我们之前尝试保护应用程序时的遗留物：
- en: '![Figure 9.34 – Remnants of the iterative process](img/B19682_09_34.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.34 – 迭代过程的残留物](img/B19682_09_34.jpg)'
- en: Figure 9.34 – Remnants of the iterative process
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.34 – 迭代过程的残留物
- en: 'They will all be named according to the path of our application (`/home/packt/appackt`).
    We can clean up these entries with the following command:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 它们将根据我们应用程序的路径（`/home/packt/appackt`）命名。我们可以使用以下命令清理这些条目：
- en: '[PRE55]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can now verify that our app is indeed guarded with AppArmor:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以验证我们的应用程序确实受到 AppArmor 的保护：
- en: '[PRE56]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The relevant excerpt from the output is as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的相关摘录如下：
- en: '![Figure 9.35 – appackt in complain mode](img/B19682_09_35.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.35 – appackt 处于投诉模式](img/B19682_09_35.jpg)'
- en: Figure 9.35 – appackt in complain mode
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.35 – appackt 处于投诉模式
- en: Our application (`/home/packt/appackt`) is shown, as expected, in `enforce`
    mode.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序（`/home/packt/appackt`）如预期般显示在 `enforce` 模式下。
- en: 'Next, we need to validate that our app complies with the security policies
    enforced by AppArmor. Let’s edit the `appackt` script and change the `LOG_FILE`
    path in *line 6* of *Figure 9**.35* to the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要验证我们的应用程序是否符合 AppArmor 强制执行的安全策略。让我们编辑 `appackt` 脚本并更改 *图 9.35* 中 *第
    6 行* 的 `LOG_FILE` 路径为以下内容：
- en: '[PRE57]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: mkdir logs
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: mkdir logs
- en: ./appackt
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: ./appackt
- en: '[PRE58]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: sudo aa-enforce /home/packt/appackt
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: sudo aa-enforce /home/packt/appackt
- en: '[PRE59]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: sudo aa-status
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: sudo aa-status
- en: '[PRE60]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: sudo aa-complain /home/packt/appackt
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: sudo aa-complain /home/packt/appackt
- en: '[PRE61]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: sudo ln -s /etc/apparmor.d/home.packt.appackt /etc/apparmor.d/disable/
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: sudo ln -s /etc/apparmor.d/home.packt.appackt /etc/apparmor.d/disable/
- en: sudo apparmor_parser -R /etc/apparmor.d/home.packt.appackt
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: sudo apparmor_parser -R /etc/apparmor.d/home.packt.appackt
- en: '[PRE62]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: sudo rm /etc/apparmor.d/disable/home.packt.appackt
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: sudo rm /etc/apparmor.d/disable/home.packt.appackt
- en: sudo apparmor_parser -r /etc/apparmor.d/home.packt.appackt
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: sudo apparmor_parser -r /etc/apparmor.d/home.packt.appackt
- en: '[PRE63]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: sudo systemctl stop firewalld
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: sudo systemctl stop firewalld
- en: sudo systemctl disable firewalld
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: sudo systemctl disable firewalld
- en: sudo systemctl mask firewalld
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: sudo systemctl mask firewalld
- en: '[PRE64]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: sudo dnf install iptables-services
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: sudo dnf install iptables-services
- en: '[PRE65]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: sudo iptables -L [CHAIN] [-t TABLE]
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: sudo iptables -L [CHAIN] [-t TABLE]
- en: '[PRE66]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: sudo iptables -L
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: sudo iptables -L
- en: '[PRE67]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: sudo iptables -L INPUT -t nat
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: sudo iptables -L INPUT -t nat
- en: '[PRE68]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: sudo iptables -F INPUT
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sudo iptables -F INPUT
- en: sudo iptables -F FORWARD
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sudo iptables -F FORWARD
- en: 'iptables command with the -v (--verbose) option.The output is as follows:'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 启用 -v (--verbose) 选项的 iptables 命令。输出如下：
- en: '[PRE69]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: sudo iptables -P INPUT DROP
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sudo iptables -P INPUT DROP
- en: sudo iptables -P FORWARD DROP
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sudo iptables -P FORWARD DROP
- en: -P (--policy) option parameter sets the policy for a specific chain (such as
    INPUT) to the given target (for example, DROP). The DROP target makes the system
    gracefully ignore all packets.At this point, if we were to save our firewall configuration,
    the system wouldn’t accept any incoming or outgoing packets. So, we should be
    careful not to inadvertently drop our access to the system if we use SSH or don’t
    have direct console access.
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -P (--policy) 选项参数将特定链（例如 INPUT）的策略设置为给定目标（例如 DROP）。DROP 目标使系统优雅地忽略所有数据包。此时，如果我们保存我们的防火墙配置，系统将不接受任何传入或传出的数据包。因此，我们应小心使用
    SSH 或在没有直接控制台访问的情况下，避免无意中断开对系统的访问。
- en: '[PRE70]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: sudo iptables -A INPUT -p tcp --dport 22 -m state \
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sudo iptables -A INPUT -p tcp --dport 22 -m state \
- en: --state NEW,ESTABLISHED -s 192.168.0.0/24 -j ACCEPT
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --state NEW,ESTABLISHED -s 192.168.0.0/24 -j ACCEPT
- en: sudo iptables -A OUTPUT -p tcp --sport 22 -m state \
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sudo iptables -A OUTPUT -p tcp --sport 22 -m state \
- en: '-A INPUT: Specifies the chain (for example, INPUT) to append the rule to'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -A INPUT：指定要追加规则的链（例如 INPUT）
- en: '[PRE71]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: sudo iptables -A INPUT -p tcp --dport 443 -m state \
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: sudo iptables -A INPUT -p tcp --dport 443 -m state \
- en: --state NEW,ESTABLISHED -j ACCEPT
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: --state NEW,ESTABLISHED -j ACCEPT
- en: sudo iptables -A OUTPUT -p tcp --sport 443 -m state \
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: sudo iptables -A OUTPUT -p tcp --sport 443 -m state \
- en: --state ESTABLISHED,RELATED -j ACCEPT
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: --state ESTABLISHED,RELATED -j ACCEPT
- en: '[PRE72]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: sudo iptables -A INPUT -p udp --dport 53 -j ACCEPT
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: sudo iptables -A INPUT -p udp --dport 53 -j ACCEPT
- en: 'iptables option parameters, please refer to the following system reference
    manuals:*   `iptables` (`man iptables`)*   `iptables-extensions` (`man iptables-extensions`)
    `iptables` configuration, we must run the following command:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: iptables 选项参数，请参考以下系统参考手册：*   `iptables` (`man iptables`)*   `iptables-extensions`
    (`man iptables-extensions`) `iptables` 配置，我们必须运行以下命令：
- en: '[PRE73]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output is as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE74]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '-f (--file) option parameter specifies the file to save (back up) the iptables
    configuration in. We can restore the saved iptables configuration later with the
    following command:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: -f (--file) 选项参数指定保存（备份）iptables 配置的文件。我们可以稍后使用以下命令恢复已保存的 iptables 配置：
- en: '[PRE75]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: sudo yum install -y nftables
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: sudo yum install -y nftables
- en: '[PRE76]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: sudo systemctl stop iptables
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: sudo systemctl stop iptables
- en: sudo systemctl disable iptables
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: sudo systemctl disable iptables
- en: '[PRE77]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: sudo systemctl enable nftables
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: sudo systemctl enable nftables
- en: sudo systemctl start nftables
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: sudo systemctl start nftables
- en: '[PRE78]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: sudo systemctl status nftables
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: sudo systemctl status nftables
- en: '[PRE79]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: sudo cat /etc/sysconfig/nftables.conf
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: sudo cat /etc/sysconfig/nftables.conf
- en: '[PRE80]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: sudo nft list ruleset
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: sudo nft list ruleset
- en: '[PRE81]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: sudo nft flush ruleset
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: sudo nft flush ruleset
- en: '[PRE82]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'sudo nft add table inet packt_chain within packt_table:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: sudo nft add table inet packt_chain within packt_table：
- en: '[PRE83]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'sudo nft add rule inet packt_table packt_chain tcp dport {ping):'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: sudo nft add rule inet packt_table packt_chain tcp dport {ping}：
- en: '[PRE84]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Finally, we will reject everything else:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将拒绝其他所有流量：
- en: '[PRE85]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, let’s have a look at our new configuration:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的新配置：
- en: '[PRE86]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The output is as follows:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 9.48 – A simple firewall configuration with nftables](img/B19682_09_48.jpg)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.48 – 使用nftables的简单防火墙配置](img/B19682_09_48.jpg)'
- en: Figure 9.48 – A simple firewall configuration with nftables
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.48 – 使用nftables的简单防火墙配置
- en: 'The output suggests the following settings for our input chain (`packt_chain`):'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 输出建议我们为输入链（`packt_chain`）设置以下配置：
- en: Allow TCP traffic on destination ports `22`, `80`, and `443` (`tcp dport { 22,
    80, 443 }` `accept`)
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许目标端口`22`、`80`和`443`上的TCP流量（`tcp dport { 22, 80, 443 }` `accept`）
- en: Allow `ping` requests (`ip protocol` `icmp accept`)
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许`ping`请求（`ip protocol` `icmp accept`）
- en: Reject everything else (`meta nfproto` `ipv4 reject`)
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝其他所有流量（`meta nfproto` `ipv4 reject`）
- en: 'Next, we will save the current configuration to `/etc/nftables/packt.nft`:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把当前配置保存到`/etc/nftables/packt.nft`：
- en: '[PRE87]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Finally, we will point the current `nftables` configuration to `/etc/nftables/packt.nft`
    in the `/etc/sysconfig/nftables.conf` file by adding the following line:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过添加以下行，将当前的`nftables`配置指向`/etc/nftables/packt.nft`，在`/etc/sysconfig/nftables.conf`文件中：
- en: '[PRE88]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We will use `vim` (or your editor of choice) to make this change:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`vim`（或你选择的编辑器）进行此更改：
- en: '[PRE89]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The new `nftables.conf` file now contains the reference to our `packt.nft`
    configuration file:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`nftables.conf`文件现在包含对我们的`packt.nft`配置文件的引用：
- en: '![Figure 9.49 – Including the new configuration in nftables.conf](img/B19682_09_49.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.49 – 在nftables.conf中包含新的配置](img/B19682_09_49.jpg)'
- en: Figure 9.49 – Including the new configuration in nftables.conf
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.49 – 在nftables.conf中包含新的配置
- en: 'The following command reloads the new `nftables` configuration:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令重新加载新的`nftables`配置：
- en: '[PRE90]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: After this exercise, you can quickly write a script for configuring `nftables`
    using the output of the `nft list ruleset` command. As a matter of fact, we just
    did that with the `/etc/nftables/packt.nft` configuration file.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，您可以快速编写一个脚本，使用`nft list ruleset`命令的输出配置`nftables`。事实上，我们刚刚用`/etc/nftables/packt.nft`配置文件做了这件事。
- en: With that, we will conclude our examination of packet filtering frameworks and
    the related command-line utilities. They enable power users to have granular control
    over every functional aspect of underlying network chains and rules. Yet, some
    Linux administrators may find the use of such tools overwhelming and turn to relatively
    simpler firewall management utilities instead. So, next, we’ll look at a couple
    of native Linux firewall management tools that provide a more streamlined and
    user-friendly command-line interface for configuring and managing firewalls.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们将结束对数据包过滤框架及相关命令行工具的讨论。它们使高级用户能够对底层网络链路和规则的每个功能方面进行精细控制。然而，一些Linux管理员可能会觉得使用这些工具过于复杂，而转向相对简单的防火墙管理工具。因此，接下来，我们将介绍几种本地的Linux防火墙管理工具，它们提供了更简化且用户友好的命令行界面，用于配置和管理防火墙。
- en: Using firewall managers
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 使用防火墙管理工具
- en: '**Firewall managers** are command-line utilities with a relatively easy-to-use
    configuration interface of firewall security rules. Generally, these tools require
    superuser privileges, and they are a significant asset for Linux system administrators.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '**防火墙管理工具**是命令行工具，具有相对易于使用的防火墙安全规则配置界面。通常，这些工具需要超级用户权限，它们对Linux系统管理员来说是非常有价值的工具。'
- en: 'In the following sections, we’ll present two of the most common firewall managers
    that are widely used across modern-day Linux distributions:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍两个在现代Linux发行版中广泛使用的最常见的防火墙管理工具：
- en: '`firewalld`: On RHEL/Fedora platforms'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firewalld`：在RHEL/Fedora平台上'
- en: '`ufw`: On Ubuntu/Debian platforms'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ufw`：在Ubuntu/Debian平台上'
- en: Firewall managers are similar to other network security tools (such as `iptables`,
    Netfilter, and `nftables`), with the main difference being that they offer a more
    streamlined user experience for firewall security. An essential benefit of using
    a firewall manager is the convenience of not having to restart network daemons
    when you’re operating various security configuration changes.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙管理工具类似于其他网络安全工具（如`iptables`、Netfilter和`nftables`），主要的区别在于它们为防火墙安全提供了更简化的用户体验。使用防火墙管理工具的一个重要好处是，操作各种安全配置更改时，无需重新启动网络守护进程。
- en: Let’s start with `firewalld`, the default firewall manager for RHEL/Fedora.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `firewalld` 开始，这是 RHEL/Fedora 的默认防火墙管理器。
- en: Using firewalld
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `firewalld`
- en: '`firewalld` is the default firewall management utility for a variety of Linux
    distributions, including the following:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`firewalld` 是多种 Linux 发行版的默认防火墙管理工具，包括以下发行版：'
- en: RHEL 7 (and newer)
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RHEL 7（及更新版本）
- en: openSUSE 15 (and newer)
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: openSUSE 15（及更新版本）
- en: Fedora 18 (and newer)
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fedora 18（及更新版本）
- en: 'On RHEL, if `firewalld` is not present, we can install it with the following
    command:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RHEL 上，如果没有安装 `firewalld`，我们可以使用以下命令进行安装：
- en: '[PRE91]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'You may also have to enable the `firewalld` daemon at startup with the following
    command:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可能需要使用以下命令在启动时启用 `firewalld` 守护进程：
- en: '[PRE92]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If you use the same system you used to execute previous examples with `iptables`
    and `nftables`, remember that we had to disable `firewalld` at the beginning on
    our Fedora distribution. Now, it is time to re-enable it. We will use the following
    commands to do so:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是与执行先前示例时相同的系统（如 `iptables` 和 `nftables`），请记得我们在 Fedora 发行版中一开始需要禁用 `firewalld`。现在，是时候重新启用它了。我们将使用以下命令进行操作：
- en: '![Figure 9.50 – Re-enabling firewalld](img/B19682_09_50.jpg)'
  id: totrans-506
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.50 – 重新启用 `firewalld`](img/B19682_09_50.jpg)'
- en: Figure 9.50 – Re-enabling firewalld
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.50 – 重新启用 `firewalld`
- en: '`firewalld` has a set of command-line utilities for different tasks:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '`firewalld` 提供了一组用于不同任务的命令行工具：'
- en: '`firewall-cmd`: The primary command-line tool of `firewalld`'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firewall-cmd`：`firewalld` 的主要命令行工具'
- en: '`firewall-offline-cmd`: Used for configuring `firewalld` while it’s offline
    (not running)'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firewall-offline-cmd`：用于在 `firewalld` 离线（未运行）时进行配置'
- en: '`firewall-config`: A graphical user interface tool for configuring `firewalld`'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firewall-config`：用于配置 `firewalld` 的图形用户界面工具'
- en: '`firewall-applet`: A system-tray app for providing essential information about
    `firewalld` (such as running status, connections, and so on)'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firewall-applet`：一个系统托盘应用程序，用于提供有关 `firewalld` 的基本信息（如运行状态、连接等）'
- en: In this section, we will look at a few practical examples of using the `firewall-cmd`
    utility. For any of the other utilities, you may refer to the related system reference
    manual (such as `man firewall-config`) for more information.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看一些使用 `firewall-cmd` 工具的实际示例。对于其他工具，您可以参考相关的系统参考手册（如 `man firewall-config`）以获取更多信息。
- en: '`firewalld` (and `firewalld-cmd`, for that matter) operates with a few key
    concepts related to monitoring and controlling network packets: *zones*, *rules*,
    and *targets*.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`firewalld`（以及 `firewalld-cmd`，其实也是）通过一些关键概念来操作，这些概念与监控和控制网络数据包相关：*区域*、*规则*
    和 *目标*。'
- en: Understanding firewalld zones
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 `firewalld` 区域
- en: '`firewalld` configuration. A network packet monitored by `firewalld` belongs
    to a zone if it matches the network interface or IP address/netmask source associated
    with the zone. The following command lists the names of the predefined zones:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '`firewalld` 配置。被 `firewalld` 监控的网络数据包，如果它与区域关联的网络接口或 IP 地址/子网掩码匹配，则属于该区域。以下命令列出了预定义区域的名称：'
- en: '[PRE93]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'For detailed information about all the zones that have currently been configured,
    we can run the following command:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前已配置的所有区域的详细信息，我们可以运行以下命令：
- en: '[PRE94]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Here’s an excerpt of the related output:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是相关输出的摘录：
- en: '![Figure 9.51 – Listing firewalld zones](img/B19682_09_51.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.51 – 列出 `firewalld` 区域](img/B19682_09_51.jpg)'
- en: Figure 9.51 – Listing firewalld zones
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.51 – 列出 `firewalld` 区域
- en: 'The preceding output illustrates the default (active) zone in Fedora 37 Server
    Edition with its own attributes, some of which will be explained next. Zones associated
    with an interface and a source are known as **active zones**. The following command
    retrieves the active zones:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出展示了 Fedora 37 Server Edition 中的默认（活动）区域及其属性，接下来将对其中的一些进行解释。与接口和源相关的区域被称为
    **活动区域**。以下命令用于检索活动区域：
- en: '[PRE95]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The output, in our case, is as follows:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，输出结果如下：
- en: '![Figure 9.52 – The firewalld active zones](img/B19682_09_52.jpg)'
  id: totrans-526
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.52 – `firewalld` 活动区域](img/B19682_09_52.jpg)'
- en: Figure 9.52 – The firewalld active zones
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.52 – `firewalld` 活动区域
- en: '**Interfaces** represent the network adapters that are attached to the localhost.
    Active interfaces are assigned to either the default zone or a user-defined zone.
    An interface cannot be assigned to multiple zones.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口** 代表附加到本地主机的网络适配器。活动接口被分配到默认区域或用户定义的区域。一个接口不能同时分配到多个区域。'
- en: '**Sources** are incoming IP addresses or address ranges, and they can also
    be assigned to zones. A single source or multiple overlapping IP address ranges
    cannot be assigned to more than one zone. Doing so would result in undefined behavior,
    as it would be unclear which rule takes precedence for the related zone.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源**是传入的 IP 地址或地址范围，也可以分配给区域。单个来源或多个重叠的 IP 地址范围不能分配到多个区域。如果这样做，将会导致未定义的行为，因为不清楚哪个规则在相关区域中具有优先权。'
- en: 'By default, `firewalld` assigns all network interfaces to the `public` zone
    without associating any sources with it. Also, by default, `public` is the only
    active zone and thus the default zone. The following command displays the default
    zone:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`firewalld` 将所有网络接口分配到 `public` 区域，而不将任何来源与其关联。此外，默认情况下，`public` 是唯一的活动区域，也是默认区域。以下命令显示默认区域：
- en: '[PRE96]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The default output is as follows:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 默认输出如下：
- en: '![Figure 9.53 – Displaying the default zone in firewalld](img/B19682_09_53.jpg)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.53 – 显示 firewalld 中的默认区域](img/B19682_09_53.jpg)'
- en: Figure 9.53 – Displaying the default zone in firewalld
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.53 – 显示 firewalld 中的默认区域
- en: Specifying a source for a zone is optional. Consequently, for every data packet,
    there will be a zone with a matching network interface. However, there won’t necessarily
    be a zone with a matching source. This paradigm would play an essential role in
    the order in which the matching rules are evaluated. We’ll discuss the related
    topic in the *Understanding rule precedence* section. But first, let’s get acquainted
    with `firewalld` rules.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 为区域指定来源是可选的。因此，对于每个数据包，将会有一个与之匹配的网络接口区域。然而，并不一定会有一个匹配来源的区域。这个范式将在匹配规则的评估顺序中起到重要作用。我们将在*理解规则优先级*部分讨论相关内容。但首先，让我们先了解一下
    `firewalld` 规则。
- en: Understanding firewalld rules
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 firewalld 规则
- en: '`firewalld` configuration represent the configuration settings for controlling
    the data packets associated with a specific zone. Usually, a rule would decide
    whether a packet is accepted or rejected, based on some predefined criteria.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '`firewalld` 配置表示控制与特定区域相关的数据包的配置设置。通常，规则会根据一些预定义的标准来决定是否接受或拒绝数据包。'
- en: 'For example, to block `ping` requests (ICMP protocol) for the `FedoraServer`
    zone, we can add the following `rich-rule` attribute:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要阻止 `FedoraServer` 区域的 `ping` 请求（ICMP 协议），我们可以添加以下 `rich-rule` 属性：
- en: '[PRE97]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We can retrieve the `FedoraServer` zone information with the following command:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令检索 `FedoraServer` 区域信息：
- en: '[PRE98]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The `rich-rule` attribute reflects the updated configuration:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '`rich-rule` 属性反映了更新后的配置：'
- en: '![Figure 9.54 – Getting the FedoraServer zone configuration with firewalld](img/B19682_09_54.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.54 – 使用 firewalld 获取 FedoraServer 区域配置](img/B19682_09_54.jpg)'
- en: Figure 9.54 – Getting the FedoraServer zone configuration with firewalld
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.54 – 使用 firewalld 获取 FedoraServer 区域配置
- en: 'At this point, our host won’t respond anymore to `ping` (ICMP) requests. We
    can remove the `rich-rule` attribute we just added with the following command:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的主机将不再响应 `ping`（ICMP）请求。我们可以使用以下命令移除刚刚添加的 `rich-rule` 属性：
- en: '[PRE99]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Alternatively, we can enable ICMP access with the following command:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用以下命令启用 ICMP 访问：
- en: '[PRE100]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Please note that changes that are made without the `--permanent` option of the
    `firewall-cmd` utility are transient and won’t persist after a system or `firewalld`
    restart.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，未使用 `--permanent` 选项的 `firewall-cmd` 工具所做的更改是临时性的，在系统或 `firewalld` 重启后不会保留。
- en: When no rich rules are defined or matched for a zone, `firewalld` uses the zone’s
    target to control the packet’s behavior. Let’s look at targets next.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有定义或匹配的 rich 规则时，`firewalld` 使用该区域的目标来控制数据包的行为。接下来，我们来看一下目标。
- en: Understanding firewalld targets
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 firewalld 目标
- en: 'When a packet matches a specific zone, `firewalld` controls the packet’s behavior
    based on the corresponding zone’s rich rules. If there are no rich rules defined,
    or none of the rich rules matches the data packet, the packet’s behavior is ultimately
    determined by the **target** associated with the zone. Possible target values
    are as follows:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据包匹配特定区域时，`firewalld` 会根据该区域的 rich 规则控制数据包的行为。如果没有定义 rich 规则，或者没有任何 rich 规则匹配数据包，则数据包的行为最终由与该区域关联的
    **目标** 决定。可能的目标值如下：
- en: '`ACCEPT`: Accepts the packet'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACCEPT`：接受数据包'
- en: '`REJECT`: Rejects the packet and responds with a reject reply'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REJECT`：拒绝数据包并返回拒绝回复'
- en: '`DROP`: Drops the packet without a reply'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DROP`：丢弃数据包，不进行回复'
- en: '`default`: Defers to the default behavior of `firewalld`'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：遵循 `firewalld` 的默认行为'
- en: Zones, rules, and targets are key configuration elements used by `firewalld`
    when analyzing and handling data packets. Packets are matched using zones and
    then acted upon using either rules or targets. Due to the dual nature of zones—based
    on network interfaces and IP address/range sources—`firewalld` follows a specific
    order (or precedence) when calculating the matching criteria. We’ll look at this
    next.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 区域、规则和目标是 `firewalld` 在分析和处理数据包时使用的关键配置元素。数据包通过区域进行匹配，然后通过规则或目标进行处理。由于区域的双重性质——基于网络接口和
    IP 地址/范围来源——`firewalld` 在计算匹配标准时遵循特定的顺序（或优先级）。接下来我们将详细讨论这个问题。
- en: Understanding rule precedence
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 理解规则优先级
- en: Let’s define the terminology first. We’ll refer to the zones associated with
    interfaces as **interface zones**. The zones associated with sources are known
    as **source zones**. Since zones can have both interfaces and sources assigned
    to them, a zone can act as either an interface zone, a source zone, or both.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义一些术语。我们将与接口相关的区域称为 **接口区域**。与源相关的区域称为 **源区域**。由于区域可以同时分配接口和源，因此一个区域可以充当接口区域、源区域或两者。
- en: '`firewalld` handles a data packet in the following order:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '`firewalld` 按照以下顺序处理数据包：'
- en: It checks the corresponding source zone. There will be, at most, one such zone
    (since sources can only be associated with a single zone). If there is a match,
    the packet is handled according to the rules or target associated with the zone.
    Otherwise, data packet analysis follows as the next step.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检查相应的源区域。最多只会有一个这样的区域（因为源只能与一个区域关联）。如果匹配，数据包会按照与该区域关联的规则或目标进行处理。否则，数据包分析会作为下一步进行。
- en: It checks the corresponding interface zone. Exactly one such zone would (always)
    exist. If we have a match, the packet is handled according to the zone’s rules
    or target. Otherwise, the packet validation follows as the next step.
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检查相应的接口区域。总是会有且仅有一个这样的区域。如果匹配，则数据包会按照该区域的规则或目标进行处理。否则，数据包验证会作为下一步进行。
- en: 'Let’s assume the default target of `firewalld`—it accepts ICMP packets and
    rejects everything else. The key takeaway from the preceding validation workflow
    is that source zones have precedence over interface zones. A typical design pattern
    for multi-zone `firewalld` configurations defines the following zones:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `firewalld` 的默认目标是——它接受 ICMP 数据包并拒绝其他所有数据包。从前面验证工作流的关键点是，源区域优先于接口区域。多区域 `firewalld`
    配置的典型设计模式定义了以下区域：
- en: '**Privileged source zone**: Elevated system access from select IP addresses'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特权源区域**：来自特定 IP 地址的提升系统访问权限'
- en: '**Restrictive interface zone**: Limited access for everyone else'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制性接口区域**：仅限其他人访问'
- en: Let’s explore some more potentially useful examples using the `firewall-cmd`
    utility.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨一些使用 `firewall-cmd` 工具的其他可能有用的示例。
- en: 'The following command displays services enabled in the firewall:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示防火墙中启用的服务：
- en: '[PRE101]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The following command enables HTTPS access (port `443`):'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令启用 HTTPS 访问（端口 `443`）：
- en: '[PRE102]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'To add a user-defined service or port (for example, `8443`), we can run the
    following command:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加用户定义的服务或端口（例如，`8443`），可以运行以下命令：
- en: '[PRE103]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The following command lists the open ports in the firewall:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令列出防火墙中打开的端口：
- en: '[PRE104]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Invoking the `firewall-cmd` command without the `--permanent` option results
    in transient changes that won’t persist after a system (or `firewalld`) restart.
    To reload the previously saved (permanent) configuration of `firewalld`, we can
    run the following command:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在没有 `--permanent` 选项的情况下调用 `firewall-cmd` 命令，将会导致暂时性更改，这些更改在系统（或 `firewalld`）重启后不会保留。要重新加载之前保存的（永久）`firewalld`
    配置，可以运行以下命令：
- en: '[PRE105]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: For more information on `firewalld`, refer to the related system reference (`man
    firewalld`) or [https://www.firewalld.org](https://www.firewalld.org).
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解有关 `firewalld` 的更多信息，请参阅相关的系统参考（`man firewalld`）或 [https://www.firewalld.org](https://www.firewalld.org)。
- en: Using ufw
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ufw
- en: '`ufw` is the default firewall manager in Ubuntu. `ufw` provides a relatively
    simple management framework for `iptables` and Netfilter and an easy-to-use command-line
    interface for manipulating the firewall.'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '`ufw` 是 Ubuntu 中的默认防火墙管理工具。`ufw` 为 `iptables` 和 Netfilter 提供了一个相对简单的管理框架，并且提供了一个易于使用的命令行接口来操作防火墙。'
- en: 'Let’s look at a few examples of using `ufw`. Please note that the `ufw` command-line
    utility needs superuser privileges. The following command reports the status of
    `ufw`:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看几个使用 `ufw` 的例子。请注意，`ufw` 命令行工具需要超级用户权限。以下命令报告 `ufw` 的状态：
- en: '[PRE106]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'By default, `ufw` is `inactive` (disabled). We can enable `ufw` with the following
    command:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`ufw` 是 `inactive`（禁用）的。我们可以使用以下命令启用 `ufw`：
- en: '[PRE107]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Always be careful when you enable the firewall or perform any changes that
    may affect your access to the system. By default, when enabled, `ufw` will block
    all incoming access except `ping` (ICMP) requests. If you’re logged in with SSH,
    you may get a prompt warning you that the SSH connection could be lost while trying
    to enable `ufw`. To play it safe, you may want to abort the preceding operation
    by pressing `n` (No) and enabling SSH access in the firewall first:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 启用防火墙或执行可能影响您访问系统的更改时，请始终小心。默认情况下，启用时，`ufw` 将阻止所有传入访问，除非是 `ping`（ICMP）请求。如果您通过
    SSH 登录，您可能会收到提示，警告您在启用 `ufw` 时可能会断开 SSH 连接。为了安全起见，您可能希望按 `n`（否）取消之前的操作，并首先在防火墙中启用
    SSH 访问：
- en: '[PRE108]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: If SSH access is already enabled, the output suggests that the related security
    rule will not be added. If not, the rule will be added.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经启用了 SSH 访问，输出会显示相关的安全规则不会被添加。如果没有，规则将被添加。
- en: At this point, you can safely enable `ufw` without fearing that your current
    or existing SSH connections will be dropped. Upon enabling `ufw`, we get the same
    prompt as before, but this time, we can press `y` (Yes).
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可以安全启用 `ufw`，无需担心当前或现有的 SSH 连接会中断。在启用 `ufw` 后，我们会看到与之前相同的提示，但这次我们可以按 `y`（是）继续。
- en: 'To check upon a detailed status of the firewall, you can run the following
    command:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看防火墙的详细状态，您可以运行以下命令：
- en: '[PRE109]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The output for running all these commands is shown in the following screenshot:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有这些命令的输出如下面的截图所示：
- en: '![Figure 9.55 – Enabling ufw, allowing ssh, and detailed status of ufw](img/B19682_09_55.jpg)'
  id: totrans-591
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.55 – 启用 ufw，允许 ssh，并显示 ufw 的详细状态](img/B19682_09_55.jpg)'
- en: Figure 9.55 – Enabling ufw, allowing ssh, and detailed status of ufw
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.55 – 启用 ufw，允许 ssh，并显示 ufw 的详细状态
- en: It’s always recommended to check your firewall settings to ensure that inadvertent
    access to the system is not allowed.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 始终建议检查防火墙设置，以确保不会意外允许对系统的访问。
- en: 'We can list the current application security profiles with the following command:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令列出当前的应用程序安全配置文件：
- en: '[PRE110]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: In our case, only OpenSSH is available, activated when we allowed SSH connections
    earlier in this section.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，只有 OpenSSH 可用，它是在我们之前允许 SSH 连接时激活的。
- en: Let us add other services, such as HTTP (port `80`) and HTTPS (port `443`),
    used by Apache and `nginx`. This can be achieved in several different ways. We
    can either use port numbers (`80`, `443`), we can use service names as an alternate
    way (`http`, `https`), or we can specify web server names directly (`Apache Full`,
    `Nginx Full`). Details are shown in *Figure 9**.56*.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加其他服务，如 Apache 和 `nginx` 使用的 HTTP（端口 `80`）和 HTTPS（端口 `443`）。这可以通过几种不同的方式实现。我们可以使用端口号（`80`，`443`），也可以使用服务名称作为替代方法（`http`，`https`），或者可以直接指定
    Web 服务器名称（`Apache Full`，`Nginx Full`）。详细信息请参见*图 9.56*。
- en: 'To remove a specific service’s access (such as HTTP), we can run the following
    command:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除特定服务的访问（例如 HTTP），我们可以运行以下命令：
- en: '[PRE111]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The output shows that a new rule has been added. A subsequent detailed status
    check would show that access to port `80/tcp` has been denied. Yet, the resulting
    status is somewhat convoluted. In the following screenshot, we can see the output
    of adding and removing the commands that were just discussed:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示已添加新规则。随后的详细状态检查将显示对端口 `80/tcp` 的访问已被拒绝。然而，结果状态有些复杂。在下面的截图中，我们可以看到添加和删除之前讨论的命令的输出：
- en: '![Figure 9.56 – Adding and denying rules in ufw](img/B19682_09_56.jpg)'
  id: totrans-601
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.56 – 在 ufw 中添加和拒绝规则](img/B19682_09_56.jpg)'
- en: Figure 9.56 – Adding and denying rules in ufw
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.56 – 在 ufw 中添加和拒绝规则
- en: 'To reinstate the rules in the right order, let’s get a numbered output of the
    rule list first:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按照正确的顺序恢复规则，首先让我们获取规则列表的编号输出：
- en: '[PRE112]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The output yields the following result:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 输出产生了以下结果：
- en: '![Figure 9.57 – Numbered list of rules in ufw](img/B19682_09_57.jpg)'
  id: totrans-606
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.57 – ufw 中的规则编号列表](img/B19682_09_57.jpg)'
- en: Figure 9.57 – Numbered list of rules in ufw
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.57 – ufw 中的规则编号列表
- en: The order of the rules is suggested by sequence numbers. Always put more specific
    (restrictive) rules first. As rules are being added or changed, you may need to
    delete old entries or rearrange their order to ensure that the rules are appropriately
    placed and evaluated.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 规则的顺序由序号建议。始终将更具体（限制性）的规则放在前面。在添加或更改规则时，您可能需要删除旧条目或重新排列其顺序，以确保规则被正确放置和评估。
- en: 'Alternatively, we could use the `insert` option to add a specific rule at a
    given position. For example, the following command places the `80/tcp DENY` rule
    in the second position:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `insert` 选项在特定位置添加规则。例如，以下命令将 `80/tcp DENY` 规则放在第二个位置：
- en: '[PRE113]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Let’s look at a few more examples of using `ufw`. The following command enables
    SSH access (port `22`) for all protocols (`any`) from a specific source address
    range (`192.168.0.0/24`):'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看几个使用 `ufw` 的例子。以下命令为来自特定源地址范围（`192.168.0.0/24`）的所有协议（`any`）启用 SSH 访问（端口
    `22`）：
- en: '[PRE114]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The following command enables `ufw` logging:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令启用 `ufw` 日志记录：
- en: '[PRE115]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The corresponding log traces are usually in `/var/log/syslog`:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的日志踪迹通常位于 `/var/log/syslog`：
- en: '[PRE116]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'To disable `ufw` logging, run the following command:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用 `ufw` 日志记录，请运行以下命令：
- en: '[PRE117]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The following command reverts `ufw` to the system’s defaults:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将 `ufw` 恢复为系统的默认设置：
- en: '[PRE118]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The preceding command results in removing all rules and disabling `ufw`.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令会移除所有规则并禁用 `ufw`。
- en: For more information about `ufw`, you may wish to explore the *UFW Community
    Help* wiki at [https://help.ubuntu.com/community/UFW](https://help.ubuntu.com/community/UFW)
    or the related system reference (`man ufw`).
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想了解更多关于 `ufw` 的信息，您可以访问 *UFW Community Help* 维基页面 [https://help.ubuntu.com/community/UFW](https://help.ubuntu.com/community/UFW)
    或相关的系统参考（`man ufw`）。
- en: The use of firewall management tools such as `ufw` and `firewalld` may have
    more appeal to some Linux administrators, compared with lower-level packet filtering
    utilities (for example, Netfilter, `iptables`, and `nftables`). One of the arguments
    for choosing one tool over the other, besides platform considerations, is related
    to scripting and automation capabilities. Some power users may consider the `nft`
    command-line utility the tool of choice for designing their firewall rules, due
    to the granular control provided by `nftables`. Other users may be inclined to
    use `iptables`, especially on older legacy platforms. In the end, it’s a matter
    of choice or preference, as all of these tools are capable of configuring and
    managing a firewall to roughly the same extent.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 与低级别的包过滤工具（例如 Netfilter、`iptables` 和 `nftables`）相比，像 `ufw` 和 `firewalld` 这样的防火墙管理工具可能对某些
    Linux 管理员更具吸引力。选择一个工具而非另一个的理由，除了平台的考虑外，还与脚本和自动化能力相关。一些高级用户可能会认为 `nft` 命令行工具是设计防火墙规则的首选工具，因为
    `nftables` 提供了更精细的控制。其他用户则可能倾向于使用 `iptables`，尤其是在较旧的遗留平台上。最终，这是个人选择或偏好的问题，因为所有这些工具都能大致相同程度地配置和管理防火墙。
- en: Let’s wrap up our chapter with some final considerations.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一些最后的考虑来结束本章内容。
- en: Summary
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 总结
- en: The relatively vast content of this chapter may appear overwhelming. A key takeaway
    should be the focus on the frameworks (modules). If we’re discussing firewalls,
    we should look at packet filtering frameworks such as `iptables`, Netfilter, and
    `nftables`. For access control, we have security modules such as SELinux and AppArmor.
    We covered some of the pros and cons of each. The pivoting choice, possibly deciding
    the Linux distro, is between AppArmor and SELinux. One is perhaps swifter than
    the other, with the related administration effort hanging in the balance. For
    example, choosing AppArmor would narrow down the major Linux distributions to
    Ubuntu, Debian, and openSUSE. The distro choice, in turn, would further dictate
    the available firewall management solutions, and so on.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容相对较多，可能会让人感到有些压倒性。一个关键的收获应该是集中关注框架（模块）。如果我们讨论的是防火墙，应该关注诸如 `iptables`、Netfilter
    和 `nftables` 等包过滤框架。对于访问控制，我们有 SELinux 和 AppArmor 等安全模块。我们已经讨论了它们的一些优缺点。可能决定 Linux
    发行版选择的关键点是 AppArmor 与 SELinux 的选择。一个可能比另一个更快速，而相关的管理工作量则取决于具体情况。例如，选择 AppArmor
    会将主要的 Linux 发行版缩小到 Ubuntu、Debian 和 openSUSE。发行版的选择反过来会影响可用的防火墙管理解决方案，等等。
- en: Mastering the application security frameworks and firewall management tools
    will help you keep your systems safe with minimal effort. As with any typical
    Linux system administration task, there are many ways of securing your system.
    We hope that you will build upon the exploratory knowledge and tools presented
    in this chapter to make a balanced decision regarding keeping your systems secure.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握应用安全框架和防火墙管理工具将帮助您以最小的努力保护系统安全。就像任何典型的 Linux 系统管理任务一样，确保系统安全有很多种方法。我们希望您能够在本章所介绍的探索性知识和工具基础上，做出平衡的决策，以确保系统安全。
- en: The next chapter will add a further notch to the safety and protection of your
    system by introducing **disaster recovery** (**DR**), diagnostics, and troubleshooting
    practices.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将通过介绍**灾难恢复**（**DR**）、诊断和故障排除实践，为您的系统提供更高的安全性和保护。
- en: Exercises
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 'Here’s a brief quiz about some of the essential concepts that were covered
    in this chapter:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个关于本章所涵盖的一些基本概念的小测试：
- en: Enumerate at least a couple of ACMs that are used in Linux.
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举出至少几个在 Linux 中使用的 ACM（访问控制模块）。
- en: '**Hint**: DAC, ACL, MAC, RBAC, MLS, MCS'
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**提示**：DAC、ACL、MAC、RBAC、MLS、MCS'
- en: Enumerate the fields of the SELinux security context.
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举 SELinux 安全上下文的字段。
- en: '**Hint**: user, role, type, level'
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**提示**：用户、角色、类型、级别'
- en: What is a domain in SELinux?
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SELinux 中的域是什么？
- en: '**Hint**: Type assigned to a process'
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**提示**：分配给进程的类型'
- en: Can you think of a significant difference between SELinux and AppArmor in terms
    of enforcing security policies?
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能想到 SELinux 和 AppArmor 在执行安全策略方面的显著区别吗？
- en: '**Hint**: SELinux uses policies based on file labels, while AppArmor uses security
    policies based on paths.'
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**提示**：SELinux 使用基于文件标签的策略，而 AppArmor 使用基于路径的安全策略。'
- en: How do we toggle an AppArmor application profile between the `enforce` and `complain`
    modes?
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 `enforce` 和 `complain` 模式之间切换 AppArmor 应用程序配置文件？
- en: '`aa-enforce` and `aa-complain`'
  id: totrans-640
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`aa-enforce` 和 `aa-complain`'
- en: How many chains can you think of in the Linux kernel networking stack?
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能想到 Linux 内核网络栈中的多少个链？
- en: '**Hint**: *Figure 9**.41* could help you.'
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**提示**：*图 9.41* 可能对你有所帮助。'
- en: What is the default firewall management solution in RHEL/Fedora? How about Ubuntu?
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RHEL/Fedora 的默认防火墙管理解决方案是什么？Ubuntu 又是如何处理的？
- en: '`firewalld` (Fedora) and `ufw` (Ubuntu)'
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`firewalld`（Fedora）和 `ufw`（Ubuntu）'
- en: Further reading
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Please refer to the following Packt books for more information about the topics
    that were covered in this chapter:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下 Packt 出版的书籍，了解本章所涵盖主题的更多信息：
- en: '*Mastering Linux Security and Hardening – Second Edition* by Donald A. Tevault,
    Packt Publishing'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《精通 Linux 安全与加固 – 第二版》* 由 Donald A. Tevault 编写，Packt 出版'
- en: '*Practical Linux Security Cookbook – Second Edition* by Tajinder Kalsi, Packt
    Publishing'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《实用 Linux 安全 Cookbook – 第二版》* 由 Tajinder Kalsi 编写，Packt 出版'
- en: '[PRE119]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
