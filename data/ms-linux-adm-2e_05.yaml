- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Working with Processes, Daemons, and Signals
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作与进程、守护进程和信号
- en: Linux is a multitasking operating system. Multiple programs or tasks can run
    in parallel, each with its own identity, scheduling, memory space, permissions,
    and system resources. **Processes** encapsulate the execution context of any such
    program. Understanding how processes work and communicate with each other is an
    important skill for any seasoned Linux system administrator and developer to have.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Linux是一种多任务操作系统。多个程序或任务可以并行运行，每个都有自己的身份、调度、内存空间、权限和系统资源。**进程**封装了任何这种程序的执行上下文。理解进程如何工作并相互通信是任何经验丰富的Linux系统管理员和开发人员必备的重要技能。
- en: This chapter explores the basic concepts behind Linux processes. We’ll look
    at different types of processes, such as **foreground** and **background** processes,
    with special emphasis being placed on **daemons** as a particular type of background
    process. We’ll closely study the anatomy of a process and various inter-process
    communication mechanisms in Linux – **signals** in particular. Along the way,
    we’ll learn about some of the essential command-line utilities for managing processes
    and daemons and working with signals. We will also introduce you to **scripts**
    for the first time in this book, which are described in detail later in [*Chapter
    8*](B19682_08.xhtml#_idTextAnchor164), *Linux Shell Scripting*. If you feel like
    you need more information when dealing with the scripts in this chapter, take
    a look at [*Chapter 8*](B19682_08.xhtml#_idTextAnchor164) in advance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了Linux进程背后的基本概念。我们将研究不同类型的进程，如**前台**和**后台**进程，特别强调**守护进程**作为一种特定类型的后台进程。我们将深入研究进程的解剖结构以及Linux中的各种进程间通信机制
    —— 特别是**信号**。在此过程中，我们还将了解一些管理进程和守护进程、处理信号的基本命令行实用工具。我们还会在本书中首次介绍**脚本**，稍后在[*第8章*](B19682_08.xhtml#_idTextAnchor164)，*Linux
    Shell 脚本编程*中详细描述。如果您在处理本章脚本时需要更多信息，请提前参阅[*第8章*](B19682_08.xhtml#_idTextAnchor164)。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing processes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍进程
- en: Working with processes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作与进程
- en: Working with daemons
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作与守护进程
- en: Exploring inter-process communication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索进程间通信
- en: Important note
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As we navigate through the content, we will occasionally reference signals *before*
    their formal introduction in the second half of this chapter. In Linux, signals
    are almost exclusively used in association with processes, hence our approach
    of becoming familiar with processes first. Yet, leaving the signals out from some
    of the process’ internals would do a disservice to understanding how processes
    work. Where signals are mentioned, we’ll point to the related section for further
    reference. We hope that this approach provides you with a better grasp of the
    overall picture and the inner workings of processes and daemons.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在内容导航过程中，我们将偶尔提前引用信号，在本章后半部分正式介绍之前。在Linux中，信号几乎只与进程关联，因此我们首先熟悉进程的方法。然而，从某些进程内部省略信号会对理解进程如何工作造成不利影响。提到信号时，我们会指向相关部分以供进一步参考。我们希望这种方法能让您更好地掌握整体和进程、守护进程的内部工作方式。
- en: Now, before we start, let’s look at the essential requisites for our study.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们先看一下我们学习所需的基本要求。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Practice makes perfect. Running the commands and examples in this chapter by
    hand would go a long way toward you learning about processes. As with any chapter
    in this book, we recommend that you have a working Linux distribution installed
    on a VM or PC desktop platform. We’ll be using Ubuntu or Fedora, but most of the
    commands and examples would be similar on any other Linux platform.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 熟能生巧。通过手动运行本章中的命令和示例，您将更好地了解进程的工作原理。与本书中的任何章节一样，我们建议您在虚拟机或PC桌面平台上安装工作中的Linux发行版。我们将使用Ubuntu或Fedora，但大多数命令和示例在任何其他Linux平台上都会类似。
- en: Introducing processes
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍进程
- en: A **process** represents the running instance of a program. In general, a program
    is a combination of instructions and data, compiled as an executable unit. When
    a program runs, a process is created. In other words, a process is simply a program
    in action. Processes execute specific tasks, and sometimes, they are also referred
    to as **jobs** (or **tasks**).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程**代表程序的运行实例。通常，程序是一组指令和数据，编译为可执行单元。当程序运行时，将创建一个进程。换句话说，进程只是一个活动中的程序。进程执行特定任务，有时也被称为**作业**（或**任务**）。'
- en: There are many ways to create or start a process. In Linux, every command starts
    a process. A command could be a user-initiated task in a Terminal session, a script,
    or a program (executable) that’s invoked manually or automatically.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建或启动进程的方式有很多。在Linux中，每个命令都会启动一个进程。命令可以是终端会话中用户启动的任务、脚本或手动或自动调用的程序（可执行文件）。
- en: Usually, the way a process is created and interacts with the system (or user)
    determines its process type. Let’s take a closer look at the different types of
    processes in Linux.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，进程的创建方式以及它如何与系统（或用户）交互决定了它的进程类型。让我们更仔细地看一下Linux中的不同类型的进程。
- en: Understanding process types
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解进程类型
- en: 'At a high level, there are two major types of processes in Linux:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，Linux中有两种主要的进程类型：
- en: '**Foreground** (*interactive*)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前台**（*交互式*）'
- en: '**Background** (*non-interactive* or *automated*)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后台**（*非交互式*或*自动化*）'
- en: Interactive processes assume some kind of user interaction during the lifetime
    of the process. Non-interactive processes are unattended, which means that they
    are either automatically started (for example, on system boot) or are scheduled
    to run at a particular time and date via job schedulers (for example, using the
    `at` and `cron` command-line utilities).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式进程假定在进程生命周期内会进行某种用户交互。非交互式进程是无人值守的，这意味着它们要么是自动启动的（例如，在系统启动时），要么是通过作业调度程序在特定时间和日期安排运行的（例如，使用`at`和`cron`命令行工具）。
- en: Our approach to exploring process types mainly pivots around the preceding classification.
    There are various other views or taxonomies surrounding process definitions, but
    they could ultimately be reduced to either foreground or background processes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探索进程类型的方法主要围绕上述分类展开。关于进程定义，还有其他多种视角或分类法，但最终可以归结为前台进程或后台进程。
- en: For example, batch processes and daemons are essentially background processes.
    Batch processes are automated in the sense that they are not user-generated but
    invoked by a scheduled task instead. Daemons are background processes that are
    usually started during system boot and run indefinitely.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，批处理进程和守护进程本质上是后台进程。批处理进程是自动化的，因为它们不是由用户生成的，而是由调度任务触发的。守护进程是后台进程，通常在系统启动时启动并无限期运行。
- en: There’s also the concept of parent and child processes. A parent process may
    create other subordinate child processes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还有父进程和子进程的概念。父进程可以创建其他从属的子进程。
- en: We’ll elaborate on these types (and beyond) in the following sections. Let’s
    start with the pivotal ones – foreground and background processes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中详细介绍这些类型（及其他类型）。让我们从关键的进程类型——前台进程和后台进程开始。
- en: Foreground processes
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前台进程
- en: '`stdout` or `stderr`) or accept user input. The lifetime of a foreground process
    is tightly coupled to the Terminal session (parent process). If the user who launched
    the foreground process exits the Terminal while the process is still running,
    the process will be abruptly terminated (via a `SIGHUP` signal sent by the parent
    process; see *Signals* in the *Exploring inter-process communication* section
    for more details).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdout`或`stderr`）或接受用户输入。前台进程的生命周期与终端会话（父进程）紧密相关。如果启动前台进程的用户在进程仍在运行时退出终端，该进程将被突然终止（通过父进程发送的`SIGHUP`信号；有关详细信息，请参阅*信号*部分中的*进程间通信探索*）。'
- en: 'A simple example of a foreground process is invocating the system reference
    manual (`man`) for an arbitrary Linux command (for example, `ps`):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前台进程的一个简单例子是调用系统参考手册（`man`）来查看某个Linux命令（例如，`ps`）：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `ps` command displays information about active processes. You will learn
    more about process management tools and command-line utilities in the *Working
    with* *processes* section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps`命令显示有关活动进程的信息。你将在*处理进程*章节中学习更多关于进程管理工具和命令行实用程序的内容。'
- en: Once a foreground process has been initiated, the user prompt is captured and
    controlled by the spawned process interface. The user can no longer interact with
    the initial command prompt until the interactive process relinquishes control
    to the Terminal session.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦前台进程启动，用户提示符将被捕获并由新启动的进程界面控制。用户在交互式进程放弃对终端会话的控制之前，无法与初始命令提示符进行交互。
- en: 'Let’s look at another example of a foreground process, this time invoking a
    long-lived task. The following command (one-liner) runs an infinite loop while
    displaying an arbitrary message every few seconds:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个前台进程的例子，这次调用一个长期运行的任务。以下命令（单行命令）会在显示任意消息的同时，运行一个无限循环，每几秒钟更新一次：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So long as the command runs without being interrupted, the user won’t have
    an interactive prompt in the Terminal. Using *Ctrl* + *C* would stop (interrupt)
    the execution of the related foreground process and yield a responsive command
    prompt:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 只要命令没有被中断，用户将不会在终端中看到交互式提示符。使用*Ctrl* + *C*会停止（中断）相关前台进程的执行，并返回一个响应式命令提示符：
- en: '![](img/Figure_05_01_B19682.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_05_01_B19682.jpg)'
- en: Figure 5.1 – A long-lived foreground process
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 一个长时间运行的前台进程
- en: Important note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When you press *Ctrl* + *C* while a foreground process is running, a `SIGINT`
    signal is sent to the running process by the current (parent) Terminal session,
    and the foreground process is interrupted. For more information, see the *Signals*
    section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在前台进程运行时按下*Ctrl* + *C*，当前（父）终端会话会向运行中的进程发送`SIGINT`信号，从而中断前台进程。有关更多信息，请参阅*信号*部分。
- en: If we want to maintain an interactive command prompt in the Terminal session
    while running a specific command or script, we should use a background process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在运行特定命令或脚本时保持终端会话中的交互式命令提示符，我们应当使用后台进程。
- en: Background processes
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后台进程
- en: '**Background processes** – also referred to as **non-interactive** or **automatic
    processes** – run independently of a Terminal session, without expecting any user
    interaction. A user may invoke multiple background processes within the same Terminal
    session without waiting on any of them to complete or exit.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**后台进程**—也称为**非交互式进程**或**自动进程**—独立于终端会话运行，不需要任何用户交互。用户可以在同一个终端会话中启动多个后台进程，而无需等待它们完成或退出。'
- en: Background processes are usually long-lived tasks that don’t require direct
    user supervision. The related process may still display its output in the Terminal
    console, but such background tasks typically write their results to different
    files instead (such as log files).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 后台进程通常是长时间运行的任务，不需要直接的用户监督。相关进程仍然可以在终端控制台中显示其输出，但这类后台任务通常将结果写入不同的文件中（例如日志文件）。
- en: 'The simplest invocation of a background process appends an ampersand (`&`)
    to the end of the related command. Building on our previous example (in the *Foreground
    processes* section), the following command creates a background process that runs
    an infinite loop, echoing an arbitrary message every few seconds:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的后台进程调用是在相关命令的末尾添加符号（`&`）。基于我们之前在*前台进程*部分中的示例，以下命令创建了一个后台进程，该进程运行一个无限循环，每隔几秒钟回显一个任意的消息：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note the ampersand (`&`) at the end of the command. By default, a background
    process would still direct the output (`stdout` and `stderr`) to the console when
    invoked with the ampersand (`&`), as shown previously. However, the Terminal session
    remains interactive. In the following figure, we are using the `echo` command
    while the previous process is still running:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意命令末尾的符号（`&`）。默认情况下，通过符号（`&`）调用的后台进程仍然会将输出（`stdout`和`stderr`）发送到控制台，如前所示。然而，终端会话保持交互式。在下图中，我们在之前的进程仍然运行时使用了`echo`命令：
- en: '![Figure 5.2 – Running a background process](img/Figure_05_02_B19682.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 运行后台进程](img/Figure_05_02_B19682.jpg)'
- en: Figure 5.2 – Running a background process
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 运行后台进程
- en: 'As shown in the preceding screenshot, the background process is given a `983`.
    While the process is running, we can still control the Terminal session and run
    a different command, like so:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，后台进程被分配了`983`。在进程运行时，我们仍然可以控制终端会话并执行不同的命令，像这样：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Eventually, we can force the process to terminate with the `kill` command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们可以使用`kill`命令强制终止该进程：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding command *kills* our background process (with PID `983`). The corresponding
    signal that’s sent by the parent Terminal session to terminate this process is
    `SIGKILL` (see the *Signals* section for more information) through the `-9` argument
    in our command.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令*杀死*了我们的后台进程（PID 为`983`）。父终端会话通过命令中的`-9`参数发送的信号是`SIGKILL`（有关更多信息，请参见*信号*部分），用于终止该进程。
- en: Both foreground and background processes are typically under the direct control
    of a user. In other words, these processes are created or started manually as
    a result of a command or script invocation. There are some exceptions to this
    rule, particularly when it comes to batch processes, which are launched automatically
    via scheduled jobs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前台和后台进程通常都在用户的直接控制下。换句话说，这些进程是通过命令或脚本的调用手动创建或启动的。虽然如此，也有一些例外，特别是在批处理进程的情况下，这些进程会通过计划任务自动启动。
- en: There’s also a select category of background processes that are automatically
    started during system boot and terminated at shutdown without user supervision.
    These background processes are also known as daemons.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一类选择性的后台进程，它们会在系统启动时自动启动，并在关机时终止，无需用户干预。这些后台进程也被称为守护进程。
- en: Introducing daemons
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍守护进程
- en: A`root` or other) and runs with the related privileges.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `root` 用户（或其他）以相关的权限运行。
- en: 'Daemons usually serve client requests or communicate with other foreground
    or background processes. Here are some common examples of daemons, all of which
    are generally available on most Linux platforms:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程通常用于服务客户端请求或与其他前台或后台进程进行通信。以下是一些常见的守护进程示例，它们通常在大多数 Linux 平台上可用：
- en: '`systemd`: The parent of all processes (formerly known as `init`)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd`：所有进程的父进程（以前称为 `init`）'
- en: '`crond`: A job scheduler that runs tasks in the background'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crond`：一个在后台运行任务的作业调度器'
- en: '`ftpd`: An FTP server that handles client FTP requests'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ftpd`：一个处理客户端 FTP 请求的 FTP 服务器'
- en: '`httpd`: A web server (Apache) that handles client HTTP requests'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httpd`：一个处理客户端 HTTP 请求的 Web 服务器（Apache）'
- en: '`sshd`: A Secure Shell server that handles SSH client requests'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sshd`：一个处理 SSH 客户端请求的安全外壳服务器'
- en: Typically, system daemons in Linux are named with `d` at the end, denoting a
    daemon process. Daemons are controlled by shell scripts usually stored in the
    `/etc/init.d/` or `/lib/systemd/` system directory, depending on the Linux platform.
    Ubuntu, for example, stores daemon script files in `/etc/init.d/`, while Fedora
    stores them in `/lib/systemd/`. The location of these daemon files depends on
    the platform implementation of `init`, a system-wide service manager for all Linux
    processes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Linux 系统中的守护进程名称以 `d` 结尾，表示它是一个守护进程。守护进程由通常存储在 `/etc/init.d/` 或 `/lib/systemd/`
    系统目录中的 Shell 脚本控制，这取决于 Linux 平台。例如，Ubuntu 将守护进程脚本文件存储在 `/etc/init.d/` 中，而 Fedora
    将它们存储在 `/lib/systemd/` 中。这些守护进程文件的位置取决于 `init` 的平台实现，它是一个针对所有 Linux 进程的系统级服务管理器。
- en: The Linux init-style startup process generally invokes these shell scripts at
    system boot. But the same scripts can also be invoked via service control commands,
    usually run by privileged system users, to manage the lifetime of specific daemons.
    In other words, a privileged user or system administrator can *stop* or *start*
    a particular daemon through the command-line interface. Such commands would immediately
    return the user’s control to the Terminal while performing the related action
    in the background.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 的 `init` 风格启动过程通常会在系统启动时调用这些 Shell 脚本。但是，通常通过服务控制命令也可以调用这些脚本，这些命令通常由拥有特权的系统用户执行，以管理特定守护进程的生命周期。换句话说，特权用户或系统管理员可以通过命令行界面来*停止*或*启动*某个特定的守护进程。此类命令会在执行相关操作的同时立即将用户的控制权交还给终端，并在后台执行相关任务。
- en: Let’s take a closer look at the `init` process.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解 `init` 进程。
- en: The init process
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`init` 进程'
- en: Throughout this chapter, we’ll refer to `init` as the *generic* system initialization
    engine and service manager on Linux platforms. Over the years, Linux distributions
    have evolved and gone through various `init` system implementations, such as `SysV`,
    `upstart`, `OpenRC`, `systemd`, and `runit`. There’s an ongoing debate in the
    Linux community about the supremacy or advantages of one over the other. For now,
    we will simply regard `init` as a system process, and we will briefly look at
    its relationship with other processes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将 `init` 称为 Linux 平台上的*通用*系统初始化引擎和服务管理器。多年来，Linux 发行版经历了各种 `init` 系统实现的演变，比如
    `SysV`、`upstart`、`OpenRC`、`systemd` 和 `runit`。Linux 社区关于这些实现的优劣存在持续的辩论。现在，我们将
    `init` 简单地看作一个系统进程，并简要了解它与其他进程的关系。
- en: '`init` (or `systemd`, and others) is essentially a system daemon, and it’s
    among the first process to start when Linux boots up. The related daemon process
    continues to run in the background until the system is shut down. `init` is the
    root (parent) process of all other processes in Linux, in the overall process
    hierarchy tree. In other words, it is a direct or indirect ancestor of all the
    processes in the system.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`（或 `systemd` 等）本质上是一个系统守护进程，它是 Linux 启动时最早启动的进程之一。相关的守护进程将持续在后台运行，直到系统关闭。`init`
    是所有其他进程的根（父）进程，处于整个进程层次结构的树顶。换句话说，它是系统中所有进程的直接或间接祖先。'
- en: In Linux, the `pstree` command displays the whole process tree, and it shows
    the `init` process at its root – in our case, `systemd` (on Ubuntu or Fedora).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，`pstree` 命令显示整个进程树，且在树的根部显示 `init` 进程——在我们的案例中是 `systemd`（在 Ubuntu
    或 Fedora 上）。
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![Figure 5.3 – init (systemd), the parent of all processes](img/Figure_05_03_B19682.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – init（systemd），所有进程的父进程](img/Figure_05_03_B19682.jpg)'
- en: Figure 5.3 – init (systemd), the parent of all processes
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – init（systemd），所有进程的父进程
- en: The `pstree` command’s output illustrates a hierarchy tree representation of
    the processes, where some appear as parent processes while others appear as child
    processes. Let’s look at the parent and child process types and some of the dynamics
    between them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`pstree` 命令的输出展示了进程的层次结构，其中一些进程作为父进程出现，而其他进程则作为子进程出现。我们来看看父进程和子进程的类型以及它们之间的一些动态。'
- en: Parent and child processes
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 父进程和子进程
- en: A `SIGHUP` signal that’s invoked by the parent process upon termination (for
    example, via the `nohup` command). See the *Signals* section for more information.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个由父进程在终止时触发的 `SIGHUP` 信号（例如，通过 `nohup` 命令）。更多信息请参见 *信号* 部分。
- en: In Linux, all processes except the `init` process (with its variations) are
    children of a specific process. Terminating a child process won’t stop the related
    parent process from running. A good practice for terminating a parent process
    when the child is done processing is to exit from the parent process itself after
    the child process completes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，除了 `init` 进程（及其变种）外，所有进程都是某个特定进程的子进程。终止子进程不会停止相关的父进程的运行。当子进程完成处理后，终止父进程的一个良好做法是让父进程本身退出。
- en: There are cases when processes run unattended, based on a specific schedule.
    Running a process without user interaction is known as batch processing. We’ll
    look at batch processes next.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有时进程会根据特定的计划无须人工干预地运行。没有用户交互的进程称为批处理进程。接下来，我们将讨论批处理进程。
- en: Batch processes
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批处理进程
- en: A `at` and `cron`. While `cron` is better suited to scheduled task management
    complexities, `at` is a more lightweight utility, better suited for one-off jobs.
    A detailed study of these commands is beyond the scope of this chapter. You may
    refer to the related system reference manuals for more information (`man at` and
    `man cron`).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`at` 和 `cron`。`cron` 更适合复杂的定时任务管理，而 `at` 是一个轻量级的工具，更适合一次性任务。对这些命令的详细研究超出了本章的范围。你可以参考相关的系统参考手册以获取更多信息（`man
    at` 和 `man cron`）。'
- en: We’ll conclude our study of process types with orphan and zombie processes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以孤儿进程和僵尸进程结束对进程类型的研究。
- en: Orphan and zombie processes
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 孤儿进程和僵尸进程
- en: When a child process is terminated, the related parent process is notified with
    a `SIGCHILD` signal. The parent can go on running other tasks or may choose to
    spawn another child process. However, there may be instances when the parent process
    is terminated before a related child process completes execution (or exits). In
    this case, the child process becomes an `init` process – the parent of all processes
    – automatically becomes the new parent of the orphan process.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当子进程被终止时，相关的父进程会收到一个 `SIGCHILD` 信号。父进程可以继续执行其他任务，或选择生成另一个子进程。然而，也有可能父进程在相关子进程完成执行（或退出）之前就被终止。在这种情况下，子进程会变成
    `init` 进程——所有进程的父进程——自动成为孤儿进程的新父进程。
- en: '`ps` command).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps` 命令）。'
- en: The main difference between the zombie and orphan processes is that a zombie
    process is dead (terminated), while an orphan process is still running.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 僵尸进程和孤儿进程的主要区别在于，僵尸进程是已死（终止）的进程，而孤儿进程仍在运行。
- en: As we differentiate between various process types and their behavior, a significant
    part of the related information is reflected in the composition or data structure
    of the process itself. In the next section, we’ll take a closer look at the makeup
    of a process, which is mostly echoed through the `ps` command-line utility – an
    ordinary yet very useful process explorer on Linux systems.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们区分不同的进程类型及其行为时，相关信息的一个重要部分反映在进程本身的组成或数据结构中。在下一节中，我们将更深入地了解进程的构成，这主要通过 `ps`
    命令行工具来体现——这是 Linux 系统上一个普通但非常有用的进程查看器。
- en: The anatomy of a process
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程的结构
- en: 'In this section, we will explore some of the common attributes of a Linux process
    through the lens of the `ps` and `top` command-line utilities. We hope that taking
    a practical approach based on these tools will help you gain a better understanding
    of process internals, at least from a Linux administrator’s perspective. Let’s
    start by taking a brief look at these commands. The `ps` command displays a current
    snapshot of the system processes. This command has the following syntax:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们将通过 `ps` 和 `top` 命令行工具，探讨 Linux 进程的一些常见属性。我们希望通过这些工具的实际应用，帮助你更好地理解进程的内部机制，至少从
    Linux 管理员的角度来看。我们先简单了解一下这些命令。`ps` 命令显示系统进程的当前快照。此命令的语法如下：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following command displays the processes owned by the current Terminal
    session:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示当前终端会话拥有的进程：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令输出可以在下面的截图中看到：
- en: '![Figure 5.4 – Displaying processes owned by the current shell](img/Figure_05_04_B19682.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 显示当前 shell 拥有的进程](img/Figure_05_04_B19682.jpg)'
- en: Figure 5.4 – Displaying processes owned by the current shell
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 显示当前 shell 拥有的进程
- en: 'Let’s look at each field in the top (header) row of the output and explain
    their meaning in the context of our relevant process – that is, the `bash` Terminal
    session:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看输出的顶部（标题）行中的每个字段，并解释它们在我们相关进程——也就是 `bash` 终端会话中的含义：
- en: '`PID`: Each process in Linux has a `PID` value automatically assigned by the
    kernel when the process is created. The `PID` value is a positive integer and
    is always guaranteed to be unique.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PID`：在 Linux 中，每个进程都有一个由内核自动分配的 `PID` 值。`PID` 值是一个正整数，并且始终保证是唯一的。'
- en: In our case, the relevant process is `bash` (the current shell), with a PID
    of `171233`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，相关的进程是 `bash`（当前 shell），其 PID 为 `171233`。
- en: '`TTY`: `TTY` attribute denotes the type of Terminal the process interacts with.
    In our example, the `bash` process representing the Terminal session has `pts/0`
    as its TTY type. `pts` stands for `/0` indicates the ordinal sequence of the related
    Terminal session. For example, an additional SSH session would have `pts/1`, and
    so on.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TTY`：`TTY` 属性表示进程与之交互的终端类型。在我们的示例中，代表终端会话的 `bash` 进程的 `TTY` 类型是 `pts/0`。`pts`
    代表 `/0` 表示相关终端会话的序列号。例如，额外的 SSH 会话将会有 `pts/1`，依此类推。'
- en: '`TIME`: The `TIME` field represents the cumulative CPU utilization (or time)
    spent by the process (in `[DD-]hh:mm:ss` format). Why is it zero (`00:00:00`)
    for the `bash` process in our example? We may have run multiple commands in our
    Terminal session, yet the CPU utilization could still be zero. That’s because
    the CPU utilization measures (and accumulates) the time spent for each command,
    and not the parent Terminal session overall. If the commands complete within a
    fraction of a second, they will not amount to a significant CPU utilization being
    shown in the `TIME` field.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIME`：`TIME` 字段表示该进程所消耗的累计 CPU 使用时间（以 `[DD-]hh:mm:ss` 格式显示）。为什么在我们的示例中，`bash`
    进程的 `TIME` 是零（`00:00:00`）？我们可能在终端会话中运行了多个命令，但 CPU 使用时间仍然为零。这是因为 CPU 使用时间是针对每个命令所消耗的时间进行测量（并累积），而不是针对整个父终端会话。如果命令在几分之一秒内完成，那么它们所消耗的
    CPU 时间不会在 `TIME` 字段中显示出显著的数值。'
- en: '`CMD`: The `CMD` field stands for command and indicates the name or full path
    of the command (including the arguments) that created the process. For well-known
    system commands (for example, `bash`), `CMD` displays the command’s name, including
    its arguments.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`：`CMD` 字段代表命令，指示创建该进程的命令的名称或完整路径（包括参数）。对于常见的系统命令（例如，`bash`），`CMD` 会显示命令名称，包括其参数。'
- en: 'The process attributes we’ve explored thus far represent a relatively simple
    view of Linux processes. There are situations when we may need more information.
    For example, the following command provides additional details about the processes
    running in the current Terminal session:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们探讨的进程属性代表了 Linux 进程的相对简单视图。但有时我们可能需要更多的信息。例如，以下命令提供了当前终端会话中运行进程的额外详细信息：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `-l` option parameter invokes the so-called *long format* for the `ps`
    output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`-l` 选项参数调用了所谓的 *长格式* 以显示 `ps` 的输出：'
- en: '![Figure 5.5 – A more detailed view of processes](img/Figure_05_05_B19682.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 进程的更详细视图](img/Figure_05_05_B19682.jpg)'
- en: Figure 5.5 – A more detailed view of processes
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 进程的更详细视图
- en: 'Here are just a few of the more relevant output fields of the `ps` command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `ps` 命令的一些更相关的输出字段：
- en: '`F`: Process flags (for example, `0` – none, `1` – forked, and `4` – superuser
    privileges)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F`：进程标志（例如，`0` – 无，`1` – 已分叉，`4` – 超级用户权限）'
- en: '`S`: Process status code (for example, `R` – running, `S` – interruptible sleep,
    and so on)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S`：进程状态代码（例如，`R` – 运行中，`S` – 可中断休眠，等等）'
- en: '`UID`: The username or owner of the process (the user ID)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UID`：进程的用户名或所有者（用户 ID）'
- en: '`PID`: The process ID'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PID`：进程 ID'
- en: '`PPID`: The process ID of the parent process'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PPID`：父进程的进程 ID'
- en: '`PRI`: The priority of the process (a higher number means lower priority)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRI`：进程的优先级（数字越大表示优先级越低）'
- en: '`SZ`: The virtual memory usage'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SZ`：虚拟内存使用量'
- en: There are many more such attributes and exploring them all is beyond the scope
    of this book. For additional information, refer to the `ps` system reference manual
    (`man ps`).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他这样的属性，探索它们超出了本书的范围。如需更多信息，请参考 `ps` 系统参考手册（`man ps`）。
- en: The `ps` command examples we’ve used so far have only displayed the processes
    that are owned by the current Terminal session. This approach, we thought, would
    add less complexity to analyzing process attributes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我们使用的 `ps` 命令示例只显示了当前终端会话所拥有的进程。我们认为这种方式有助于减少分析进程属性时的复杂度。
- en: 'Besides `ps`, another command that’s used is `top`, and it provides a live
    (real-time) view of all the running processes in a system. Its syntax is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `ps`，另一个常用命令是 `top`，它提供了系统中所有运行进程的实时（动态）视图。其语法如下：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Many of the process output fields displayed by the `ps` command are also reflected
    in the `top` command, albeit some of them with slightly different notations. Let’s
    look at the `top` command and the meaning of the output fields that are displayed.
    The following command displays a real-time view of running processes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps` 命令显示的许多进程输出字段也在 `top` 命令中有所体现，尽管有些字段的表示方式略有不同。让我们来看看 `top` 命令以及显示的输出字段的含义。以下命令显示正在运行进程的实时视图：'
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![Figure 5.6 – A real-time view of the current processes](img/Figure_05_06_B19682.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 当前进程的实时视图](img/Figure_05_06_B19682.jpg)'
- en: Figure 5.6 – A real-time view of the current processes
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 当前进程的实时视图
- en: 'Here are some of the output fields, briefly explained:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些输出字段的简要说明：
- en: '`USER`: The username or owner of the process'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER`：进程的用户名或所有者'
- en: '`PR`: The priority of the process (a lower number means higher priority)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PR`：进程的优先级（数字越小表示优先级越高）'
- en: '`NI`: The nice value of the process (a sort of dynamic/adaptive priority)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NI`：进程的 nice 值（一种动态/自适应的优先级）'
- en: '`VIRT`: The virtual memory size (in KB) – the total memory used by the process'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIRT`：虚拟内存大小（以 KB 为单位）– 进程使用的总内存'
- en: '`RES`: The resident memory size (in KB) – the physical (non-swapped) memory
    used by the process'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RES`：常驻内存大小（以 KB 为单位）– 进程使用的物理内存（非交换内存）'
- en: '`SHR`: The shared memory size (in KB) – a subset of the process memory shared
    with other processes'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHR`：共享内存大小（以 KB 为单位）– 进程与其他进程共享的内存子集'
- en: '`S`: The process’ status (for example, `R` – running, `S` – interruptible sleep,
    `I` – idle, and so on)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S`：进程的状态（例如，`R` – 运行中，`S` – 可中断休眠，`I` – 空闲，等等）'
- en: '`%CPU`: CPU usage (percentage)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%CPU`：CPU 使用率（百分比）'
- en: '`%MEM`: `RES` memory usage (percentage)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%MEM`：`RES` 内存使用率（百分比）'
- en: '`COMMAND`: Command name or command line'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMMAND`：命令名称或命令行'
- en: Each of these fields (and many more) are explained in detail in the `top` system
    reference manual (`man top`).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段（以及更多字段）在 `top` 系统参考手册中有详细说明（`man top`）。
- en: Every day, Linux administration tasks frequently use process-related queries
    based on the preceding presented fields. The *Working with processes* section
    will explore some of the more common usages of the `ps` and `top` commands, and
    beyond.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每天，Linux管理任务经常使用基于上述字段的与进程相关的查询。*处理进程*部分将探讨`ps`和`top`命令的一些更常见用法，以及更多内容。
- en: An essential aspect of a process’s lifetime is the `ps` and `top` commands provide
    information about the status of the process via the `S` field. Let’s take a closer
    look at these states.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 进程生命周期的一个重要方面是`ps`和`top`命令通过`S`字段提供有关进程状态的信息。让我们更仔细地查看这些状态。
- en: Process states
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进程状态
- en: 'During its lifetime, a process may change states according to circumstances.
    According to the `S` (status) field of the `ps` and `top` commands, a Linux process
    can have any of the following states:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在其生命周期内，进程可能会根据情况改变状态。根据`ps`和`top`命令的`S`（状态）字段，Linux进程可以具有以下任一状态：
- en: '`D`: Uninterruptible sleep'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`D`: 不可中断的睡眠'
- en: '`I`: Idle'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`I`: 空闲'
- en: '`R`: Running'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R`: 运行'
- en: '`S`: Sleeping (interruptible sleep)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S`: 睡眠（可中断的睡眠）'
- en: '`T`: Stopped by a job control signal'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T`: 被作业控制信号停止'
- en: '`t`: Stopped by the debugger during a trace'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t`: 在跟踪期间被调试器停止'
- en: '`Z`: Zombie'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Z`: 僵尸'
- en: 'At a high level, any of these states can be identified with the following process
    states:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，可以将这些状态识别为以下过程状态：
- en: '`R` state) or is an idle process (the `I` state). In Linux, an idle process
    is a specific task that’s assigned to every processor (CPU) in the system and
    is scheduled to run only when there’s no other process running on the related
    CPU. The time that’s spent on idle tasks accounts for the idle time that’s reported
    by the `top` command.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R` 状态）或是空闲进程（`I` 状态）。在Linux中，空闲进程是分配给系统中每个处理器（CPU）的特定任务，只有在相关CPU上没有其他进程运行时才会被调度运行。在空闲任务上花费的时间占了`top`命令报告的空闲时间。'
- en: '`S` state) and uninterruptible sleep (the `D` state). Interruptible sleep can
    be disturbed by specific process signals, yielding further process execution.
    On the other hand, uninterruptible sleep is a state where the process is blocked
    in a system call (possibly waiting on some hardware conditions), and it cannot
    be interrupted.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S` 状态）和不可中断的睡眠（`D` 状态）。可中断的睡眠可以通过特定的进程信号中断，从而产生进一步的进程执行。另一方面，不可中断的睡眠是一个进程被阻塞在系统调用中的状态（可能在等待某些硬件条件），它无法被中断。'
- en: '`T` state) or a debugging signal (the `t` state).'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T` 状态）或是调试信号（`t` 状态）。'
- en: '`Z` state) – it’s terminated without being reaped by its parent. A zombie process
    is essentially a dead reference for an already terminated process in the system’s
    process table. This will be discussed in more detail in the *Orphan and zombie*
    *processes* section.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Z` 状态）- 它在没有被其父进程回收的情况下终止。僵尸进程本质上是系统进程表中已终止进程的死引用。这将在*孤儿和僵尸进程*部分详细讨论。'
- en: 'To conclude our analysis of process states, let’s look at the lifetime of a
    Linux process. Usually, a process starts with a running state (`R`) and terminates
    once its parent has reaped it from the zombie state (`Z`). The following diagram
    provides an abbreviated view of the process states and the possible transitions
    between them:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要总结我们对进程状态的分析，让我们来看一下Linux进程的生命周期。通常，进程从运行状态（`R`）开始，并在其父进程从僵尸状态（`Z`）中回收它后终止。下图提供了进程状态的简略视图及其之间可能的转换：
- en: '![Figure 5.7 – The lifetime of a Linux process](img/Figure_05_07_B19682.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 - Linux进程的生命周期](img/Figure_05_07_B19682.jpg)'
- en: Figure 5.7 – The lifetime of a Linux process
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 - Linux进程的生命周期
- en: Now that we’ve introduced processes and provided you with a preliminary idea
    of their type and structure, we’re ready to interact with them. In the following
    sections, we will explore some standard command-line utilities for working with
    processes and daemons. Most of these tools operate with input and output data,
    which we covered in the *Anatomy of a process* section. We’ll look at working
    with processes next.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了进程，并为您提供了它们类型和结构的初步概念，我们准备与它们进行交互。在接下来的章节中，我们将探讨一些用于处理进程和守护程序的标准命令行实用工具。这些工具大多数操作输入和输出数据，我们在*进程的解剖*部分已经涵盖了这些。接下来我们将看看如何处理进程。
- en: Working with processes
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理进程
- en: This section serves as a practical guide to managing processes via resourceful
    command-line utilities that are used in everyday Linux administration tasks. Some
    of these tools were mentioned in previous sections (for example, `ps` and `top`)
    when we covered specific process internals. Here, we will summon most of the knowledge
    we’ve gathered so far and take it for a real-world spin by covering some hands-on
    examples.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本节作为通过资源丰富的命令行工具来管理进程的实用指南，这些工具用于日常的 Linux 管理任务。在之前的章节中我们提到了一些工具（例如 `ps` 和 `top`），当时我们讲解了特定进程的内部结构。在这里，我们将调用到目前为止我们收集的大部分知识，并通过一些实际的示例来实际应用它们。
- en: Let’s start with the `ps` command – the Linux process explorer.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `ps` 命令开始——Linux 进程探测器。
- en: Using the ps command
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ps 命令
- en: 'We described the `ps` command and its syntax in the *Anatomy of a process*
    section. The following command displays a selection of the current processes running
    in the system:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*进程结构*部分描述了 `ps` 命令及其语法。以下命令显示当前系统中运行的一些进程：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `-e` option (or `-A`) selects *all* the processes in the system. The `head`
    pipe invocation displays only the first few lines (10 by default):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`-e` 选项（或 `-A`）选择系统中的*所有*进程。`head` 管道调用仅显示前几行（默认显示 10 行）：'
- en: '![Figure 5.8 – Displaying the first few processes](img/Figure_05_08_B19682.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 显示前几个进程](img/Figure_05_08_B19682.jpg)'
- en: Figure 5.8 – Displaying the first few processes
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 显示前几个进程
- en: The preceding information may not always be particularly useful. Perhaps we’d
    like to know more about each process, beyond just the `PID` or `CMD` fields in
    the `ps` command’s output. (We described some of these process attributes in the
    *Anatomy of a* *process* section).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 上述信息可能并不总是特别有用。也许我们想了解更多关于每个进程的内容，而不仅仅是 `PID` 或 `CMD` 字段在 `ps` 命令输出中的内容。（我们在*进程结构*部分描述了一些进程的属性）。
- en: 'The following command lists the processes owned by the current user more elaborately:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令更详细地列出了当前用户拥有的进程：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `-f` option specifies the full-format listing, which displays more detailed
    information for each process. The `-U $(whoami)` option parameter specifies the
    current user (`packt`) as the real user (owner) of the processes we’d like to
    retrieve. In other words, we want to list all the processes we own:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f` 选项指定完整格式的列表，显示每个进程的更多详细信息。`-U $(whoami)` 选项指定当前用户（`packt`）作为我们想要检索的进程的实际用户（所有者）。换句话说，我们想列出我们拥有的所有进程：'
- en: '![Figure 5.9 – Displaying the processes owned by the current user](img/Figure_05_09_B19682.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 显示当前用户拥有的进程](img/Figure_05_09_B19682.jpg)'
- en: Figure 5.9 – Displaying the processes owned by the current user
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 显示当前用户拥有的进程
- en: 'There are situations when we may look for a specific process, either for monitoring
    purposes or to act upon them. Let’s take a previous example, where we showcased
    a long-lived process and wrapped the related command into a simple script. The
    command is a simple `while` loop that runs indefinitely:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能需要查找特定的进程，无论是为了监控目的还是对它们进行操作。让我们回顾之前的例子，其中我们展示了一个长期运行的进程，并将相关命令包装成一个简单的脚本。这个命令是一个简单的
    `while` 循环，它会无限期地运行：
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using an editor of our preference (for example, `nano`), we can create a script
    file (for example, `test.sh`) with the following content:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们偏好的编辑器（例如 `nano`），我们可以创建一个脚本文件（例如 `test.sh`），并编写以下内容：
- en: '![Figure 5.10 – A simple test script running indefinitely](img/Figure_05_10_B19682.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 一个简单的测试脚本无限运行](img/Figure_05_10_B19682.jpg)'
- en: Figure 5.10 – A simple test script running indefinitely
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 一个简单的测试脚本无限运行
- en: 'We can make the test script executable and run it as a background process:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使测试脚本可执行并将其作为后台进程运行：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note the ampersand (`&`) at the end of the command, which invokes the background
    process:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意命令末尾的与号（`&`），它用于启动后台进程：
- en: '![Figure 5.11 – Running a script as a background process](img/Figure_05_11_B19682.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – 作为后台进程运行脚本](img/Figure_05_11_B19682.jpg)'
- en: Figure 5.11 – Running a script as a background process
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 作为后台进程运行脚本
- en: 'The background process running our script has a process ID (`PID`) of `1094`.
    Suppose we want to find our process by its name (`test.sh`). For this, we can
    use the `ps` command with a `grep` pipe:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们脚本的后台进程的进程 ID（`PID`）是 `1094`。假设我们想通过进程名称（`test.sh`）来查找我们的进程。为此，我们可以使用 `ps`
    命令并加上 `grep` 管道：
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![ Figure 5.12 – Finding a process by name using the ps command](img/Figure_05_12_B19682.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – 使用ps命令通过名称查找进程](img/Figure_05_12_B19682.jpg)'
- en: Figure 5.12 – Finding a process by name using the ps command
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 使用ps命令通过名称查找进程
- en: The preceding output shows that our process has a `PID` value of `1094` and
    a `CMD` value of `/bin/bash ./test.sh`. The `CMD` field contains the full command
    invocation of our script, including the command-line parameters.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的输出显示我们的进程具有`PID`值为`1094`，`CMD`值为`/bin/bash ./test.sh`。`CMD`字段包含了我们脚本的完整命令调用，包括命令行参数。
- en: We should note that the first line of the `test.sh` script contains `#!/bin/bash`,
    which prompts the OS to invoke `bash` for the script’s execution. This line is
    also known as the `CMD` field, the command in our case is `/bin/bash` (according
    to the shebang invocation), and the related command-line parameter is the `test.sh`
    script. In other words, `bash` executes the `test.sh` script.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注意的是，`test.sh`脚本的第一行包含`#!/bin/bash`，它提示操作系统调用`bash`来执行脚本。这一行也被称为`CMD`字段，在我们的例子中，命令是`/bin/bash`（根据shebang调用），相关的命令行参数是`test.sh`脚本。换句话说，`bash`执行了`test.sh`脚本。
- en: 'The output of the preceding `ps` command also includes our `ps | grep` command’s
    invocation, which is somewhat irrelevant. A refined version of the same command
    is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`ps`命令的输出还包括了我们`ps | grep`命令的调用，这有些不相关。改进版的相同命令如下：
- en: '[PRE15]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![Figure 5.13 – Finding a process by name using the ps command (refined)](img/Figure_05_13_B19682.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – 使用ps命令通过名称查找进程（改进版）](img/Figure_05_13_B19682.jpg)'
- en: Figure 5.13 – Finding a process by name using the ps command (refined)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 使用ps命令通过名称查找进程（改进版）
- en: The `grep -v grep` pipe filters out the unwanted `grep` invocation from the
    `ps` command’s results.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep -v grep`管道用于过滤掉`ps`命令结果中不需要的`grep`调用。'
- en: 'If we want to find a process based on a process ID (`PID`), we can invoke the
    `ps` command with the `-p|--pid` option parameter. For example, the following
    command displays detailed information about our process with `PID` set to `1094`
    (running the `test.sh` script):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想根据进程ID（`PID`）查找进程，可以使用`-p|--pid`选项参数调用`ps`命令。例如，以下命令显示了有关我们的进程（`PID`为`1094`，运行`test.sh`脚本）的详细信息：
- en: '![Figure 5.14 – Finding a process by PID using the ps command](img/Figure_05_14_B19682.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14 – 使用ps命令根据PID查找进程](img/Figure_05_14_B19682.jpg)'
- en: Figure 5.14 – Finding a process by PID using the ps command
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – 使用ps命令根据PID查找进程
- en: The `-f` option displays the detailed (*long-format*) process information.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f`选项显示详细的（*长格式*）进程信息。'
- en: There are numerous other use cases for the `ps` command, and exploring them
    all is well beyond the scope of this book. The invocations we’ve enumerated here
    should provide a basic exploratory guideline for you. For more information, please
    refer to the `ps` system reference manual (`man ps`).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps`命令还有许多其他用法，探索所有用法超出了本书的范围。我们在此列出的调用应该为你提供了基本的探索指南。有关更多信息，请参阅`ps`系统参考手册（`man
    ps`）。'
- en: Using the pstree command
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用pstree命令
- en: '`pstree` shows the running processes in a hierarchical, tree-like view. In
    some respects, `pstree` acts as a visualizer of the `ps` command. The root of
    the `pstree` command’s output is either the `init` process or the process with
    the `PID` value specified in the command. The syntax of the `pstree` command is
    as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`pstree`以层次化、树状的视图显示正在运行的进程。从某种程度上来说，`pstree`充当了`ps`命令的可视化工具。`pstree`命令输出的根节点是`init`进程，或者是命令中指定的`PID`值对应的进程。`pstree`命令的语法如下：'
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following command displays the process tree of our current Terminal session:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示了当前终端会话的进程树：
- en: '[PRE17]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![Figure 5.15 – The process tree of the current Terminal session](img/Figure_05_15_B19682.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15 – 当前终端会话的进程树](img/Figure_05_15_B19682.jpg)'
- en: Figure 5.15 – The process tree of the current Terminal session
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – 当前终端会话的进程树
- en: 'In the preceding command, `echo $$` provides the `PID` value of the current
    Terminal session. `$$` is a Bash built-in variable that contains the `PID` value
    of the shell that is running. The `PID` value is wrapped as the argument for the
    `pstree` command. To show the related PIDs, we can invoke the `pstree` command
    with the `-``p|--show-pids` option:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，`echo $$` 提供了当前终端会话的 `PID` 值。`$$` 是一个 Bash 内建变量，包含了当前正在运行的 shell 的 `PID`
    值。`PID` 值作为参数传递给 `pstree` 命令。要显示相关的 PID，我们可以使用 `-``p|--show-pids` 选项来调用 `pstree`
    命令：
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![Figure 5.16 – The process tree (along with its PIDs) of the current Terminal
    session](img/Figure_05_16_B19682.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.16 – 当前终端会话的进程树（及其 PID）](img/Figure_05_16_B19682.jpg)'
- en: Figure 5.16 – The process tree (along with its PIDs) of the current Terminal
    session
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 – 当前终端会话的进程树（及其 PID）
- en: 'The following command shows the processes owned by the current user:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示当前用户拥有的进程：
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![Figure 5.17 – The process tree owned by the current user](img/Figure_05_17_B19682.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.17 – 当前用户拥有的进程树](img/Figure_05_17_B19682.jpg)'
- en: Figure 5.17 – The process tree owned by the current user
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 – 当前用户拥有的进程树
- en: For more information about the `pstree` command, please refer to the related
    system reference manual (`man pstree`).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `pstree` 命令的信息，请参考相关系统参考手册（`man pstree`）。
- en: Using the top command
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 top 命令
- en: 'When it comes to monitoring processes in real time, the `top` utility is among
    the most common tool to be used by Linux administrators. The related command-line
    syntax is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时监控进程时，`top` 工具是 Linux 管理员最常使用的工具之一。相关的命令行语法如下：
- en: '[PRE20]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following command displays all the processes currently running in the system,
    along with real-time updates (on memory, CPU usage, and so on):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示系统中当前运行的所有进程，并实时更新（包括内存、CPU 使用情况等）：
- en: '[PRE21]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Pressing *Q* will exit the `top` command. By default, the `top` command sorts
    the output by CPU usage (shown in the `%``CPU` field/column).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *Q* 会退出 `top` 命令。默认情况下，`top` 命令按 CPU 使用情况排序输出（显示在 `%``CPU` 字段/列中）。
- en: We can also choose to sort the output of the `top` command by a different field.
    While `top` is running, press *Shift* + *F* (`F`) to invoke interactive mode.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以选择按其他字段对 `top` 命令的输出进行排序。在 `top` 正在运行时，按 *Shift* + *F*（`F`）启用交互模式。
- en: Using the arrow keys, we can select the desired field to sort by (for example,
    `%MEM`), then press *S* to set the new field, followed by *Q* to exit interactive
    mode. The alternative to interactive mode sorting is invoking the `-o` option
    parameter of the `top` command, which specifies the sorting field.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方向键，我们可以选择按某一字段排序（例如，`%MEM`），然后按 *S* 设置新的字段，接着按 *Q* 退出交互模式。交互模式排序的替代方法是调用
    `top` 命令的 `-o` 选项参数，指定排序字段。
- en: 'For example, the following command lists the top 10 processes, sorted by CPU
    usage:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下命令列出了按 CPU 使用排序的前 10 个进程：
- en: '[PRE22]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similarly, the following command lists the top 10 processes, sorted by CPU
    and memory usage:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，以下命令列出了按 CPU 和内存使用排序的前 10 个进程：
- en: '[PRE23]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `-b` option parameter specifies the batch mode operation (instead of the
    default interactive mode). The `-o +%MEM` option parameter indicates the additional
    (`+`) sorting field (`%MEM`) in tandem with the default `%CPU` field. The `head
    -n 17` pipe selects the first 17 lines of the output, accounting for the seven-line
    header of the `top` command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`-b` 选项参数指定批处理模式操作（而非默认的交互模式）。`-o +%MEM` 选项参数表示与默认的 `%CPU` 字段一起，附加的（`+`）排序字段是
    `%MEM`。`head -n 17` 管道命令选择输出的前 17 行，包括 `top` 命令的七行头部：'
- en: '![Figure 5.18 – The top 10 processes sorted by CPU and memory usage](img/Figure_05_18_B19682.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.18 – 按 CPU 和内存使用排序的前 10 个进程](img/Figure_05_18_B19682.jpg)'
- en: Figure 5.18 – The top 10 processes sorted by CPU and memory usage
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18 – 按 CPU 和内存使用排序的前 10 个进程
- en: 'The following command lists the top five processes by CPU usage, owned by the
    current user (`packt`):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令列出了当前用户（`packt`）拥有的按 CPU 使用排序的前五个进程：
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `-u $(whoami)` option parameter specifies the current user for the `top`
    command.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`-u $(whoami)` 选项参数指定了 `top` 命令的当前用户。'
- en: 'With the `top` command, we can also monitor specific processes using the `-p`
    PID option parameter. For example, the following command monitors our test process
    (with PID `243436`):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `top` 命令时，我们也可以使用 `-p` PID 参数来监控特定进程。例如，以下命令监控我们的测试进程（PID 为 `243436`）：
- en: '[PRE25]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![Figure 5.19 – Monitoring a specific PID with the top command](img/Figure_05_19_B19682.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.19 – 使用 top 命令监控特定 PID](img/Figure_05_19_B19682.jpg)'
- en: Figure 5.19 – Monitoring a specific PID with the top command
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19 – 使用 top 命令监控特定 PID
- en: 'We may choose to *kill* the process by pressing *K* while using the `top` command.
    We’ll get prompted for this by the PID of the process we want to terminate:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择在使用 `top` 命令时通过按 *K* 来*杀死*进程。此时，我们会被提示输入我们希望终止的进程的 PID：
- en: '![Figure 5.20 – Killing a process with the top command](img/Figure_05_20_B19682.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.20 – 使用 top 命令杀死进程](img/Figure_05_20_B19682.jpg)'
- en: Figure 5.20 – Killing a process with the top command
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20 – 使用 top 命令杀死进程
- en: The `top` utility can be used in many creative ways. We hope that the examples
    we’ve provided in this section have inspired you to explore further use cases
    based on specific needs. For more information, please refer to the system reference
    manual for the `top` command (`man top`).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`top` 工具可以以许多创新的方式使用。我们希望本节提供的示例能够启发你根据特定需求探索更多用例。欲了解更多信息，请参考 `top` 命令的系统参考手册（`man
    top`）。'
- en: Using the kill and killall commands
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 kill 和 killall 命令
- en: 'We use the `kill` command to terminate processes. The command’s syntax is as
    follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`kill`命令来终止进程。该命令的语法如下：
- en: '[PRE26]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `kill` command sends a *signal* to a process, attempting to stop its execution.
    When no signal is specified, `SIGTERM` (`15`) is sent. A signal can either be
    specified by the signal’s name without the `SIG` prefix (for example, `KILL` for
    `SIGKILL`) or by value (for example, `9` for `SIGKILL`).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`kill` 命令向进程发送一个*信号*，尝试停止其执行。如果没有指定信号，系统会发送 `SIGTERM`（`15`）。信号可以通过其名称（不带 `SIG`
    前缀）指定（例如，`KILL` 对应 `SIGKILL`），或者通过数值指定（例如，`9` 对应 `SIGKILL`）。'
- en: 'The `kill -l` and `kill -L` commands provide a full list of signals that can
    be used in Linux:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`kill -l` 和 `kill -L` 命令提供了可以在 Linux 中使用的信号的完整列表：'
- en: '![Figure 5.21 – The Linux signals](img/Figure_05_21_B19682.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.21 – Linux 信号](img/Figure_05_21_B19682.jpg)'
- en: Figure 5.21 – The Linux signals
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21 – Linux 信号
- en: 'Each signal has a numeric value, as shown in the preceding output. For example,
    `SIGKILL` equals `9`. The following command will kill our test process (with PID
    `243436`):'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 每个信号都有一个数值，如前述输出所示。例如，`SIGKILL` 对应 `9`。以下命令将杀死我们的测试进程（PID 为 `243436`）：
- en: '[PRE27]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following command will also do the same as the preceding command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令也会与前面的命令做相同的操作：
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In some scenarios, we may want to kill multiple processes in one go. The `killall`
    command comes to the rescue here. The syntax for the `killall` command is as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能希望一次性杀死多个进程。此时，`killall` 命令将派上用场。`killall` 命令的语法如下：
- en: '[PRE29]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`killall` sends a signal to all the processes running any of the commands specified.
    When no signal is specified, `SIGTERM` (`15`) is sent. A signal can either be
    specified by the signal name without the `SIG` prefix (for example, `TERM` for
    `SIGTERM`) or by value (for example, `15` for `SIGTERM`).'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`killall` 向所有运行指定命令的进程发送信号。如果没有指定信号，则发送 `SIGTERM`（`15`）。信号可以通过信号名称（不带 `SIG`
    前缀）指定（例如，`TERM` 对应 `SIGTERM`），或者通过数值指定（例如，`15` 对应 `SIGTERM`）。'
- en: 'For example, the following command terminates all the processes running the
    `test.sh` script:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下命令终止所有运行 `test.sh` 脚本的进程：
- en: '[PRE30]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![Figure 5.22 – Terminating multiple processes with killall](img/Figure_05_22_B19682.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.22 – 使用 killall 终止多个进程](img/Figure_05_22_B19682.jpg)'
- en: Figure 5.22 – Terminating multiple processes with killall
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22 – 使用 killall 终止多个进程
- en: Killing a process will usually remove the related reference from the system
    process table. The terminated process won’t show up anymore in the output of `ps`,
    `top`, or similar commands.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 杀死一个进程通常会从系统进程表中移除相关的引用。被终止的进程将不再出现在 `ps`、`top` 或类似命令的输出中。
- en: For more information about the `kill` and `killall` commands, please refer to
    the related system reference manuals (`man kill` and `man killall`).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多关于 `kill` 和 `killall` 命令的信息，请参考相关的系统参考手册（`man kill` 和 `man killall`）。
- en: Using the pgrep and pkill commands
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pgrep 和 pkill 命令
- en: '`pgrep` and `pkill` are pattern-based lookup commands for exploring and terminating
    running processes. They have the following syntax:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`pgrep` 和 `pkill` 是基于模式查找命令，用于探索和终止正在运行的进程。它们的语法如下：'
- en: '[PRE31]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`pgrep` iterates through the current processes and lists the PIDs that match
    the selection pattern or criteria. Similarly, `pkill` terminates the processes
    that match the selection criteria.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`pgrep`遍历当前进程并列出与选择模式或标准匹配的PID。同样，`pkill`终止与选择标准匹配的进程。'
- en: 'The following command looks for our test process (`test.sh`) and displays the
    `PID` value if the related process is found. Start the process again before using
    the following command as we killed it in the previous section. This will lead
    to a different `PID` value:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令会查找我们的测试进程（`test.sh`），并在找到相关进程时显示`PID`值。在使用以下命令之前，请重新启动该进程，因为我们在上一节中已经终止了它。这将导致一个不同的`PID`值：
- en: '[PRE32]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![Figure 5.23 – Looking for a PID based on name using pgrep](img/Figure_05_23_B19682.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.23 – 使用 pgrep 根据名称查找 PID](img/Figure_05_23_B19682.jpg)'
- en: Figure 5.23 – Looking for a PID based on name using pgrep
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.23 – 使用 pgrep 根据名称查找 PID
- en: 'The `-f|--full` option enforces a full name match of the process we’re looking
    for. We may use `pgrep` in tandem with the `ps` command to get more detailed information
    about the process, like so:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f|--full`选项强制执行我们查找进程的完整名称匹配。我们可以将`pgrep`与`ps`命令结合使用，以获得关于进程的更多详细信息，像这样：'
- en: '[PRE33]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![Figure 5.24 – Chaining pgrep and ps for more information](img/Figure_05_24_B19682.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.24 – 链接 pgrep 和 ps 获取更多信息](img/Figure_05_24_B19682.jpg)'
- en: Figure 5.24 – Chaining pgrep and ps for more information
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.24 – 链接 pgrep 和 ps 获取更多信息
- en: In the preceding one-liner, we piped the output of the `pgrep` command (with
    PID `243436`) to the `ps` command, which has been invoked with the `-f` (long-format)
    and `-p|--pid` options. The `-p` option parameter gets the piped PID value.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的单行命令中，我们将`pgrep`命令的输出（PID为`243436`）通过管道传递给了`ps`命令，该命令使用了`-f`（长格式）和`-p|--pid`选项。`-p`选项的参数获取了管道传递的PID值。
- en: The `xargs` command takes the input from the `pgrep` command and converts it
    into an argument for the `ps` command. Thus, when piping from `pgrep` to `ps`,
    the output of the first command was automatically converted as the argument for
    the second command. By default, `xargs` reads the standard input.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`命令将来自`pgrep`命令的输入转换为`ps`命令的参数。因此，当从`pgrep`传递到`ps`时，第一个命令的输出会自动转换为第二个命令的参数。默认情况下，`xargs`读取标准输入。'
- en: 'To terminate our `test.sh` process, we simply invoke the `pkill` command, as
    follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要终止我们的`test.sh`进程，我们只需调用`pkill`命令，如下所示：
- en: '[PRE34]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding command will *silently* kill the related process, based on the
    full name lookup enforced by the -`f|--full` option. To get some feedback from
    the action of the `pkill` command, we need to invoke the `-e|--echo` option, like
    so:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将*静默*地终止相关进程，这是基于`-f|--full`选项强制执行的完整名称查找。如果希望从`pkill`命令的操作中获得一些反馈，我们需要调用`-e|--echo`选项，像这样：
- en: '[PRE35]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出可以在以下截图中看到：
- en: '![Figure 5.25 – Killing a process by name using pkill](img/Figure_05_25_B19682.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.25 – 使用 pkill 按名称终止进程](img/Figure_05_25_B19682.jpg)'
- en: Figure 5.25 – Killing a process by name using pkill
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.25 – 使用 pkill 按名称终止进程
- en: For more information, please refer to the `pgrep` and `pkill` system reference
    manuals (`man pgrep` and `man pkill`).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参考`pgrep`和`pkill`的系统参考手册（`man pgrep`和`man pkill`）。
- en: This section covered some command-line utilities that are frequently used in
    everyday Linux administration tasks involving processes. Keep in mind that in
    Linux, most of the time, there are many ways to accomplish a specific task. We
    hope that the examples in this section will help you come up with creative methods
    and techniques for working with processes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了一些在日常 Linux 管理任务中经常使用的命令行工具，涉及到进程管理。请记住，在 Linux 中，大多数时候，有很多方法可以完成特定任务。我们希望本节中的示例能帮助你想出创意方法和技巧来处理进程。
- en: Next, we’ll look at some common ways of interacting with daemons.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍一些与守护进程交互的常见方法。
- en: Working with daemons
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与守护进程协作
- en: As noted in the introductory sections, daemons are a special breed of background
    process. Consequently, the vast majority of methods and techniques for working
    with processes also apply to daemons. However, there are specific commands that
    strictly operate on daemons when it comes to managing (or controlling) the lifetime
    of the related processes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在引言部分提到的，守护进程是背景进程中的一种特殊类型。因此，大多数用于操作进程的方法和技术同样适用于守护进程。然而，当涉及到管理（或控制）相关进程的生命周期时，有一些特定的命令是专门用于守护进程的。
- en: As noted in the *Introducing daemons* section, daemon processes are controlled
    by shell scripts, usually stored in the `/etc/init.d/` or `/lib/systemd/` system
    directories, depending on the Linux platform. On legacy Linux systems (for example,
    RHEL 6) and Ubuntu (even in the latest distros), the daemon script files are stored
    in `/etc/init.d/`. On RHEL 7/Ubuntu 18.04 and newer platforms, they are typically
    stored in `/lib/systemd/`. Feel free to do a listing of those two directories
    to see the contents.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在 *Introducing daemons* 部分提到的，守护进程由 shell 脚本控制，这些脚本通常存储在 `/etc/init.d/` 或
    `/lib/systemd/` 系统目录中，具体取决于 Linux 平台。在老旧的 Linux 系统（例如 RHEL 6）和 Ubuntu（即使是在最新的发行版中），守护进程脚本文件存储在
    `/etc/init.d/` 中。而在 RHEL 7 / Ubuntu 18.04 及更新的平台中，这些文件通常存储在 `/lib/systemd/` 中。你可以随意列出这两个目录的内容来查看其中的文件。
- en: The location of the daemon files and the daemon command-line utilities largely
    depends on the `init` initialization system and service manager. In *The init
    process* section, we briefly mentioned a variety of `init` systems across Linux
    distributions. To illustrate the use of daemon control commands, we will explore
    the `init` system called `systemd`, which is extensively used across various Linux
    platforms.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程文件和守护进程命令行工具的位置在很大程度上取决于 `init` 初始化系统和服务管理器。在 *The init process* 部分，我们简要提到了在
    Linux 发行版中存在的多种 `init` 系统。为了说明守护进程控制命令的使用，我们将探讨一种广泛应用于各种 Linux 平台的 `init` 系统——`systemd`。
- en: Working with systemd daemons
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 systemd 守护进程
- en: The `init` system’s essential requirement is to initialize and orchestrate the
    launch and startup dependencies of various processes when the Linux kernel is
    booted. These processes are also known as `init` engine also controls the services
    and daemons while the system is running.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 系统的基本要求是在 Linux 内核启动时初始化并协调各种进程的启动和依赖关系。这些进程也被称为 `init` 引擎，它还在系统运行时控制服务和守护进程。'
- en: Over the last few years, most Linux platforms have transitioned to `systemd`
    as their default `init` engine. Due to its extensive adoption, being familiar
    with `systemd` and its related command-line tools is of paramount importance.
    With that in mind, this section’s primary focus is on `systemctl` – the central
    command-line utility for managing `systemd` daemons.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，大多数 Linux 平台已经将 `systemd` 作为默认的 `init` 引擎。由于其广泛的应用，熟悉 `systemd` 及其相关命令行工具至关重要。考虑到这一点，本节的主要重点是
    `systemctl`——管理 `systemd` 守护进程的核心命令行工具。
- en: 'The syntax of the `systemctl` command is as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemctl` 命令的语法如下：'
- en: '[PRE36]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The actions that are invoked by the `systemctl` command are directed at units,
    which are system resources that are managed by `systemd`. Several unit types are
    defined in `systemd` (for example, service, mount, socket, and so on). Each of
    these units has a corresponding file. These file types are inferred from the suffix
    of the related filename; for example, `httpd.service` is the service unit file
    of the Apache web service (daemon). For a comprehensive list of `systemd` units
    and detailed descriptions of them, please refer to the `systemd.unit` system reference
    manual (`man systemd.unit`).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemctl` 命令触发的操作是针对单位（unit）的，这些单位是由 `systemd` 管理的系统资源。`systemd` 中定义了几种单位类型（例如，服务、挂载、套接字等）。每个单位都有一个对应的文件。这些文件类型可以通过相关文件名的后缀推断出来；例如，`httpd.service`
    是 Apache 网络服务（守护进程）的服务单位文件。有关 `systemd` 单位的完整列表及详细说明，请参考 `systemd.unit` 系统参考手册（`man
    systemd.unit`）。'
- en: 'The following command enables a daemon (for example, `httpd`, the web server)
    to start at boot:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令使守护进程（例如 `httpd`，Web 服务器）在启动时自启：
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Typically, invoking `systemctl` commands requires superuser privileges. We
    should note that `systemctl` does not require the `.service` suffix when we’re
    targeting service units. The following invocation is also acceptable:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，调用 `systemctl` 命令需要超级用户权限。我们应该注意到，在我们指定服务单位时，`systemctl` 并不需要 `.service`
    后缀。以下的调用也是可以接受的：
- en: '[PRE38]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The command to disable the `httpd` service from starting at boot is as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用 `httpd` 服务在启动时自启的命令如下：
- en: '[PRE39]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To query the status of the `httpd` service, we can run the following command:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询 `httpd` 服务的状态，我们可以运行以下命令：
- en: '[PRE40]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Alternatively, we can check the status of the `httpd` service with the following
    command:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以使用以下命令检查 `httpd` 服务的状态：
- en: '[PRE41]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following commands stop or start the `httpd` service:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令停止或启动 `httpd` 服务：
- en: '[PRE42]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For more information on `systemctl`, please refer to the related system reference
    manual (`man systemctl`). For more information about `systemd` internals, please
    refer to the corresponding reference manual (`man systemd`).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `systemctl` 的更多信息，请参考相关的系统参考手册（`man systemctl`）。有关 `systemd` 内部结构的更多信息，请参考相应的参考手册（`man
    systemd`）。
- en: Working with processes and daemons is a constant theme of everyday Linux administration
    tasks. Mastering the related command-line utilities is an essential skill for
    any seasoned user. Yet, a running process or daemon should also be considered
    in relationships with other processes or daemons running either locally or on
    remote systems. The way processes communicate with each other could be a slight
    mystery to some. We will address this in the next section, in which we will explain
    how inter-process communication works.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 处理进程和守护进程是日常 Linux 管理任务中的常见主题。掌握相关的命令行工具是任何有经验的用户的基本技能。然而，运行中的进程或守护进程也应当与其他进程或守护进程之间的关系一同考虑，后者可能是在本地或远程系统上运行的。进程之间如何相互通信对某些人来说可能是一个小谜题。我们将在下一部分中讨论这一点，解释进程间通信是如何工作的。
- en: Explaining inter-process communication
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释进程间通信
- en: '**Inter-process communication** (**IPC**) is a way of interacting between processes
    using a shared mechanism or interface. In this section, we will take a short theoretical
    approach to exploring various communication mechanisms between processes. For
    more details on this matter and some of the mechanisms used, head to [*Chapter
    8*](B19682_08.xhtml#_idTextAnchor164), *Linux* *Shell Scripting*.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程间通信**（**IPC**）是通过共享机制或接口在进程之间进行交互的一种方式。在本节中，我们将以简要的理论方式探讨进程之间的各种通信机制。有关此问题的更多细节以及使用的一些机制，请参阅
    [*第8章*](B19682_08.xhtml#_idTextAnchor164)，*Linux* *Shell 脚本*。'
- en: 'Linux processes can typically share data and synchronize their actions via
    the following interfaces:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 进程通常可以通过以下接口共享数据并同步它们的操作：
- en: '**Shared storage** (**files**): In its simplest form, the shared storage of
    an IPC mechanism can be a simple file that’s been saved to disk. The producer
    then writes to a file while the consumer reads from the same file. In this simple
    use case, the obvious challenge is the integrity of the read/write operations
    due to possible race conditions between the underlying operations. To avoid race
    conditions, the file must be locked during write operations to prevent overlapping
    I/O with another read or write action. To keep things simple, we’re not going
    to resolve this problem in our naive examples, but we thought it’s worth calling
    it out.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享存储**（**文件**）：在最简单的形式下，IPC 机制的共享存储可以是已保存到磁盘的简单文件。生产者写入文件，而消费者从同一文件中读取。在这个简单的用例中，显而易见的挑战是由于底层操作之间可能存在竞争条件，导致读/写操作的完整性问题。为了避免竞争条件，文件必须在写操作期间被锁定，以防止与其他读/写操作发生重叠。为了简化起见，我们不会在简单的示例中解决这个问题，但我们认为有必要指出这一点。'
- en: '`/dev/shm` temporary file storage system, which uses the system’s RAM as its
    backing store (that is, RAM disk).'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev/shm` 临时文件存储系统，使用系统的 RAM 作为其后备存储（即，RAM 磁盘）。'
- en: With `/dev/shm` being used as shared memory, we can reuse our producer-consumer
    model from the example in the previous point on *Shared storage*, where we simply
    point the storage file to `/dev/shm/storage`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `/dev/shm` 作为共享内存，我们可以重新使用前面提到的关于 *共享存储* 的生产者-消费者模型，在该模型中，我们只需将存储文件指向 `/dev/shm/storage`。
- en: The shared memory and shared storage IPC models may not perform well with large
    amounts of data, especially massive data streams. The alternative would be to
    use IPC channels, which can be enabled through the pipe, message queue, or socket
    communication layers.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存和共享存储 IPC 模型在处理大量数据时可能表现不佳，特别是海量数据流的情况下。替代方法是使用 IPC 通道，这可以通过管道、消息队列或套接字通信层来启用。
- en: '**Named and unnamed pipes**: **Unnamed** or **anonymous pipes**, also known
    as **regular pipes**, feed the output of a process to the input of another one.
    Using our producer-consumer model, the simplest way to illustrate an unnamed pipe
    as an IPC mechanism between the two processes would be to do the following:'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名与未命名管道**：**未命名**或**匿名管道**，也叫**常规管道**，将一个进程的输出传递到另一个进程的输入。使用我们的生产者-消费者模型，最简单的方式来说明未命名管道作为两个进程之间的IPC机制如下：'
- en: '[PRE43]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The key element of the preceding code is the pipe (`|`) symbol. The left-hand
    side of the pipe produces an output that’s fed directly to the right-hand side
    of the pipe for consumption.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的关键元素是管道（`|`）符号。管道的左侧生成输出，并直接传送到管道右侧供消费。
- en: '**Named pipes**, also known as **First-In, First-Outs** (**FIFOs**), are similar
    to traditional (unnamed) pipes but substantially different in terms of their semantics.
    An unnamed pipe only persists for as long as the related process is running. However,
    a named pipe has backing storage and will last as long as the system is up, regardless
    of the running status of the processes attached to the related IPC channel. Typically,
    a named pipe acts as a file, and it can be deleted when it’s no longer being used.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名管道**，也叫**先进先出（FIFO）**，与传统的（未命名）管道类似，但在语义上有显著不同。未命名管道仅在相关进程运行时存在。然而，命名管道有后备存储，并且只要系统运行，它就会持续存在，而不管相关进程是否在运行。通常，命名管道表现得像一个文件，并且在不再使用时可以删除。'
- en: '**Message queues**: A message queue is an asynchronous communication mechanism
    that’s typically used in a distributed system architecture. Messages are written
    and stored in a queue until they are processed and eventually deleted. A message
    is written (published) by a producer and is processed only once, typically by
    a single consumer. At a very high level, a message has a sequence, a payload,
    and a type. Message queues can regulate the retrieval (order) of messages (for
    example, based on priority or type):'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息队列**：消息队列是一种异步通信机制，通常用于分布式系统架构中。消息被写入并存储在队列中，直到被处理并最终删除。消息由生产者写入（发布），并且只会被处理一次，通常由单个消费者处理。从高层次来看，消息包含序列、有效载荷和类型。消息队列可以调节消息的获取（顺序）（例如，根据优先级或类型）：'
- en: '![](img/Figure_05_26_B19682.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_05_26_B19682.jpg)'
- en: Figure 5.26 – Message queue (simplified view)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.26 – 消息队列（简化视图）
- en: A detailed analysis of message queues or a mock implementation thereof is far
    from trivial, and it’s beyond this chapter’s scope. There are numerous open source
    message queue implementations available for most Linux platforms (RabbitMQ, ActiveMQ,
    ZeroMQ, MQTT, and so on).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列的详细分析或其模拟实现并非简单之事，超出了本章的范围。大多数Linux平台上都有许多开源的消息队列实现（如RabbitMQ、ActiveMQ、ZeroMQ、MQTT等）。
- en: IPC mechanisms based on message queues and pipes are unidirectional. One process
    writes the data; another one reads it. There are bidirectional implementations
    of named pipes, but the complexities involved would negatively impact the underlying
    communication layer. For bidirectional communication, you can think of using socket-based
    IPC channels (detailed in [*Chapter 8*](B19682_08.xhtml#_idTextAnchor164), *Linux*
    *Shell Scripting*).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 基于消息队列和管道的IPC机制是单向的。一种进程写入数据，另一种进程读取数据。虽然有命名管道的双向实现，但其中的复杂性会对底层通信层产生负面影响。对于双向通信，你可以考虑使用基于套接字的IPC通道（在[*第8章*](B19682_08.xhtml#_idTextAnchor164)中有详细介绍，*Linux*
    *Shell脚本*）。
- en: '**Sockets**: There are two types of IPC socket-based facilities:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套接字**：有两种基于IPC套接字的设施：'
- en: '**IPC sockets**: Also known as Unix domain sockets, IPC sockets use a local
    file as a socket address and enable bidirectional communication between processes
    on the same host.'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IPC套接字**：也叫做Unix域套接字，IPC套接字使用本地文件作为套接字地址，允许在同一主机上的进程之间进行双向通信。'
- en: '**Network sockets**: **Transport Control Protocol** (**TCP**) and **User Datagram
    Protocol** (**UDP**) sockets. They extend the IPC data connectivity layer beyond
    the local machine via TCP/UDP networking.'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络套接字**：**传输控制协议**（**TCP**）和**用户数据报协议**（**UDP**）套接字。它们通过TCP/UDP网络扩展了IPC数据连接层，跨越本地机器。'
- en: Apart from the obvious implementation differences, the IPC socket’s and network
    socket’s data communication channels behave the same.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显而易见的实现差异，IPC套接字和网络套接字的数据通信通道行为相同。
- en: Both sockets are configured as streams, support bidirectional communication,
    and emulate a client/server pattern. The socket’s communication channel is active
    until it’s closed on either end, thereby breaking the IPC connection.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 两个套接字都配置为流式通信，支持双向通信，并模拟客户端/服务器模式。套接字的通信通道在任一端关闭之前保持活动，从而断开了 IPC 连接。
- en: '**Signals**: In Linux, a signal is a one-way asynchronous notification mechanism
    that’s used in response to a specific condition. A signal can act in any of the
    following directions:'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号**：在 Linux 中，信号是一种单向异步通知机制，用于响应特定的条件。信号可以朝以下任何一个方向传递：'
- en: From the Linux kernel to an arbitrary process
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Linux 内核到任意进程
- en: From process to process
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从进程到进程
- en: From a process to itself
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从进程到它自己
- en: We mentioned at the beginning of this section that signals are yet another IPC
    mechanism. Indeed, they are a somewhat limited form of IPC in the sense that through
    signals, processes can coordinate synchronization with each other. But signals
    don’t carry any data payloads. They simply notify processes about events, and
    processes may choose to take specific actions in response to these events.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节开始时提到过，信号是另一种 IPC 机制。实际上，它们是一种有限的 IPC 形式，因为通过信号，进程可以相互协调同步。但信号不会携带任何数据负载。它们只是通知进程某些事件，进程可以选择针对这些事件采取特定的行动。
- en: In the next section, we will detail working with signals in Linux.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将详细讲解如何在 Linux 中处理信号。
- en: Working with signals
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理信号
- en: Signals typically alert a Linux process about a specific event, such as a segmentation
    fault (`SIGSEGV`) that’s raised by the kernel or execution being interrupted (`SIGINT`)
    by the user pressing *Ctrl* + *C*. In Linux, processes are controlled via signals.
    The Linux kernel defines a few dozen signals. Each signal has a corresponding
    non-zero positive integer value.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 信号通常会提醒 Linux 进程某个特定事件的发生，例如，由内核触发的段错误（`SIGSEGV`），或者用户按下 *Ctrl* + *C* 中断执行（`SIGINT`）。在
    Linux 中，进程通过信号进行控制。Linux 内核定义了几十种信号。每个信号都有一个对应的非零正整数值。
- en: 'The following command lists all the signals that have been registered in a
    Linux system:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令列出了在 Linux 系统中注册的所有信号：
- en: '[PRE44]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The output of the preceding command can be seen back in *Figure 5**.21*. From
    the output, `SIGHUP`, for example, has a signal value of `1`, and it’s invoked
    by a Terminal session to all its child processes when it exits. `SIGKILL` has
    a signal value of `9` and is most commonly used for terminating processes. Processes
    can typically control how signals are handled, except for `SIGKILL` (`9`) and
    `SIGSTOP` (`19`), which always end or stop a process, respectively.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的输出可以在*图 5.21*中看到。从输出中可以看出，`SIGHUP` 例如，信号值为 `1`，并且在终端会话退出时，它会传递给所有子进程。`SIGKILL`
    的信号值为 `9`，并且最常用于终止进程。进程通常可以控制信号的处理方式，除了 `SIGKILL`（`9`）和 `SIGSTOP`（`19`），这两个信号总是分别终止或停止进程。
- en: 'Processes handle signals in either of the following fashions:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 进程以以下两种方式之一处理信号：
- en: Perform the default action implied by the signal; for example, stop, terminate,
    core-dump a process, or do nothing.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行信号所暗示的默认操作；例如，停止、终止、核心转储一个进程，或什么也不做。
- en: Perform a custom action (except for `SIGKILL` and `SIGSTOP`). In this case,
    the process catches the signal and handles it in a specific way.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个自定义的操作（除了 `SIGKILL` 和 `SIGSTOP`）。在这种情况下，进程捕获信号并以特定方式处理它。
- en: 'When a program implements a custom handler for a signal, it usually defines
    a signal handler function that alters the execution of the process, as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个程序实现一个自定义的信号处理程序时，通常会定义一个信号处理函数，来改变进程的执行，如下所示：
- en: When the signal is received, the process’ execution is interrupted at the current
    instruction
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当信号被接收时，进程的执行会在当前指令处被中断
- en: The process’ execution immediately jumps to the signal-handler function
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程的执行会立即跳转到信号处理函数
- en: The signal handler function runs
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号处理函数运行
- en: When the signal handler function exits, the process resumes execution, starting
    from the previously interrupted instruction
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当信号处理函数退出时，进程将恢复执行，从之前中断的指令开始
- en: 'Here’s some brief terminology related to signals:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与信号相关的一些简要术语：
- en: A signal is raised by the process that generates it
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号由产生它的进程触发
- en: A signal is caught by the process that handles it
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号由处理它的进程捕获
- en: A signal is ignored if the process has a corresponding **no-operation** or **no-op**
    (**NOOP**) handler
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果进程有一个相应的**空操作**（**no-op**，**NOOP**）处理程序，信号将被忽略
- en: A signal is handled if the process implements a specific action when the signal
    is caught
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果进程在捕获到信号时执行特定操作，那么该信号就被处理了。
- en: Out of all the signals, `SIGKILL` and `SIGSTOP` are the only ones that cannot
    be caught or ignored.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有信号中，`SIGKILL`和`SIGSTOP`是唯一无法被捕获或忽略的信号。
- en: 'Let’s explore a few use cases for handling signals:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索几个信号处理的使用案例：
- en: When the kernel raises a `SIGKILL`, `SIGFPE` (floating-point exception), `SIGSEGV`
    (segmentation fault), `SIGTERM`, or similar signals, typically, the process that
    receives the signal immediately terminates execution and may generate a core dump
    – the image of the process that’s used for debugging purposes.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当内核发送`SIGKILL`、`SIGFPE`（浮点异常）、`SIGSEGV`（段错误）、`SIGTERM`或类似的信号时，通常接收信号的进程会立即终止执行，并可能生成一个核心转储——用于调试目的的进程镜像。
- en: When a user types *Ctrl* + *C* – otherwise known as an `SIGINT` signal is sent
    to the process. The process will terminate unless the underlying program implements
    a special handler for `SIGINT`.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户按下*Ctrl* + *C*时——这时会发送一个`SIGINT`信号到进程。除非底层程序为`SIGINT`实现了特殊的处理程序，否则进程将终止。
- en: 'Using the `kill` command, we can send a signal to any process based on its
    PID. The following command sends a `SIGHUP` signal to a Terminal session with
    a PID of `3741`:'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`kill`命令，我们可以根据进程的PID向任何进程发送信号。以下命令向PID为`3741`的终端会话发送`SIGHUP`信号：
- en: '[PRE45]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding command, we can either specify the signal value (for example,
    `1` for `SIGHUP`) or just the signal name without the `SIG` prefix (for example,
    `HUP` for `SIGHUP`).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们可以指定信号值（例如，`1`表示`SIGHUP`）或直接使用信号名称，而不带`SIG`前缀（例如，`HUP`表示`SIGHUP`）。
- en: 'With `killall`, we can signal that multiple processes are running a specific
    command (for example, `test.sh`). The following command terminates all processes
    running the `test.sh` script and outputs the result to the console (via the `-``e`
    option):'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`killall`，我们可以向多个正在运行特定命令的进程发送信号（例如，`test.sh`）。以下命令终止所有运行`test.sh`脚本的进程，并将结果输出到控制台（通过`-e`选项）：
- en: '[PRE46]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The output of this command can be seen in *Figure 5**.22*.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出可以在*图 5.22*中看到。
- en: Linux processes and signals are a vast domain. The information we’ve provided
    here is far from a comprehensive guide on the topic. We hope that this short spin
    and hands-on approach to presenting some common use cases has inspired you to
    take on and possibly master more challenging issues.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Linux进程和信号是一个庞大的领域。我们在这里提供的信息远非该主题的全面指南。我们希望这种简短的实践方法，展示了一些常见的使用案例，能激发你去解决并可能掌握更具挑战性的问题。
- en: Summary
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: A detailed study of Linux processes and daemons could be a major undertaking.
    Where worthy volumes on the topic have admirably succeeded, a relatively brief
    chapter may pale in comparison. Yet in this chapter, we tried to put on a real-world,
    down-to-earth, practical coat on everything we’ve considered to make up for our
    possible shortcomings in the abstract or scholarly realm.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 对Linux进程和守护进程的详细研究可能是一个重大的工作。尽管有一些在这一主题上极为成功的著作，但相对简短的一章可能会相形见绌。然而，在本章中，我们尝试为我们考虑的每个内容披上一件现实、实用的外衣，以弥补我们在抽象或学术领域可能的不足。
- en: At this point, we hope you are comfortable working with processes and daemons.
    The skills you’ve gathered so far should include a relatively good grasp of process
    types and internals, with a reasonable understanding of process attributes and
    states. Special attention has been paid to inter-process communication mechanisms,
    and signals in particular. For each of these topics, we will take a more detailed
    approach in [*Chapter 8*](B19682_08.xhtml#_idTextAnchor164). For now, we consider
    the information we’ve provided to be sufficient for understanding how inter-process
    communication works.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们希望你已经能够熟练地处理进程和守护进程。你目前所掌握的技能应包括对进程类型和内部机制的较好理解，以及对进程属性和状态的合理理解。我们特别关注了进程间通信机制，特别是信号。关于这些主题，我们将在[*第8章*](B19682_08.xhtml#_idTextAnchor164)中进行更详细的探讨。现在，我们认为我们提供的信息足以帮助理解进程间通信的工作原理。
- en: The next chapter will take our journey further into working with Linux disks
    and filesystems. We’ll explore the Linux storage, disk partitioning, and **Logical
    Volume Management** (**LVM**) concepts. Rest assured that everything we’ve learned
    so far will be immediately put to good use in the chapters that follow.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将进一步探讨如何操作Linux磁盘和文件系统。我们将探讨Linux存储、磁盘分区和**逻辑卷管理**（**LVM**）概念。放心，到目前为止我们学到的一切将在接下来的章节中立即派上用场。
- en: Questions
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'If you managed to skim through some parts of this chapter, you might want to
    recap a few essential details about Linux processes and daemons:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经快速浏览了本章的某些部分，可能需要回顾一些关于 Linux 进程和守护进程的基本细节：
- en: Think of a few process types. How would they compare to each other?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想一想几种进程类型。它们之间有什么不同？
- en: Think of the anatomy of a process. Can you come up with a few essential process
    attributes (or fields in the `ps` command-line output) that you may look for when
    inspecting processes?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想一想进程的构成。你能列出一些在检查进程时可能关注的基本进程属性（或者是 `ps` 命令行输出中的字段）吗？
- en: '**Hint**: What would be relevant for you, except CPU, RAM, or disk usage, for
    example?'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：除了 CPU、RAM 或磁盘使用情况之外，还有哪些对你来说是相关的？'
- en: Can you think of a few process states and some of the dynamics or possible transitions
    between them?
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能想到几种进程状态以及它们之间的一些动态变化或可能的转换吗？
- en: If you are looking for a process that takes up most of the CPU on your system,
    how would you proceed?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个占用系统大部分 CPU 的进程，你会怎么做？
- en: Can you write a simple script and make it a long-lived background process?
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能编写一个简单的脚本并将其作为一个长时间运行的后台进程吗？
- en: '**Hint**: Take a peek at [*Chapter 8*](B19682_08.xhtml#_idTextAnchor164), where
    we will teach you how to create and use shell scripts.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：查看 [*第 8 章*](B19682_08.xhtml#_idTextAnchor164)，我们将在那里教你如何创建和使用 shell
    脚本。'
- en: Enumerate at least four process signals that you can think of. When or how would
    those signals be invoked?
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举至少四个你能想到的进程信号。你会在什么情况下触发这些信号？
- en: '`kill -l` command. For more information, read the manual.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`kill -l` 命令。欲了解更多信息，请阅读手册。'
- en: Think of a couple of IPC mechanisms. Try to come up with some pros and cons
    for them.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想一想几种进程间通信（IPC）机制。试着列出它们的优缺点。
- en: '**Hint**: The information in [*Chapter 8*](B19682_08.xhtml#_idTextAnchor164)
    could help you.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：在 [*第 8 章*](B19682_08.xhtml#_idTextAnchor164) 中的内容可能对你有所帮助。'
- en: Further reading
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information about what was covered in this chapter, you can refer
    to the following Packt titles:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解本章所涉及的更多信息，您可以参考以下 Packt 出版社的书籍：
- en: '*Linux Administration Best Practices*, by Scott Alan Miller'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux 管理最佳实践*，作者：Scott Alan Miller'
- en: '*Linux Service Management Made Easy with systemd*, by Donald A. Tevault'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 systemd 简化 Linux 服务管理*，作者：Donald A. Tevault'
- en: Part 2:Advanced Linux Administration
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：高级 Linux 管理
- en: In this second part, you will learn about advanced Linux system administration
    tasks, including working with disks and configuring networking, hardening Linux
    security, and system-specific troubleshooting and diagnostics.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分中，您将学习高级的 Linux 系统管理任务，包括磁盘操作、网络配置、强化 Linux 安全性，以及系统特定的故障排除和诊断。
- en: 'This part has the following chapters:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 6*](B19682_06.xhtml#_idTextAnchor124), *Working with Disks and Filesystems*'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 6 章*](B19682_06.xhtml#_idTextAnchor124)，*磁盘和文件系统管理*'
- en: '[*Chapter 7*](B19682_07.xhtml#_idTextAnchor139), *Networking with Linux*'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 7 章*](B19682_07.xhtml#_idTextAnchor139)，*与 Linux 的网络连接*'
- en: '[*Chapter 8*](B19682_08.xhtml#_idTextAnchor164), *Linux Shell Scripting*'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 8 章*](B19682_08.xhtml#_idTextAnchor164)，*Linux Shell 脚本编写*'
- en: '[*Chapter 9*](B19682_09.xhtml#_idTextAnchor194), *Securing Linux*'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 9 章*](B19682_09.xhtml#_idTextAnchor194)，*Linux 安全性*'
- en: '[*Chapter 10*](B19682_10.xhtml#_idTextAnchor212), *Disaster Recovery, Diagnostics,
    and Troubleshooting*'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 10 章*](B19682_10.xhtml#_idTextAnchor212)，*灾难恢复、诊断与故障排除*'
